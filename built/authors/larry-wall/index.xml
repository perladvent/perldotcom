<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Larry Wall on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/larry-wall/</link>
    <description>Recent content in Larry Wall on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Thu, 06 Dec 2007 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/larry-wall/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Programming is Hard, Let&#39;s Go Scripting...</title>
      <link>http://localhost:1313/pub/2007/12/06/soto-11.html/</link>
      <pubDate>Thu, 06 Dec 2007 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2007/12/06/soto-11.html/</guid>
      <description>

&lt;p&gt;I think, to most people, scripting is a lot like obscenity. I can&amp;rsquo;t define it, but I&amp;rsquo;ll know it when I see it. Here are some common memes floating around:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Simple language
    &amp;quot;Everything is a string&amp;quot;
    Rapid prototyping
    Glue language
    Process control
    Compact/concise
    Worse-is-better
    Domain specific
    &amp;quot;Batteries included&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;I don&amp;rsquo;t see any real center here, at least in terms of technology. If I had to pick one metaphor, it&amp;rsquo;d be easy onramps. And a slow lane. Maybe even with some optional fast lanes.&lt;/p&gt;

&lt;h3 id=&#34;easy-onramps&#34;&gt;Easy Onramps&lt;/h3&gt;

&lt;p&gt;But basically, scripting is not a technical term. When we call something a scripting language, we&amp;rsquo;re primarily making a linguistic and cultural judgment, not a technical judgment.&lt;/p&gt;

&lt;p&gt;I see scripting as one of the humanities. It&amp;rsquo;s our linguistic roots showing through. So speaking of roots&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;the-past&#34;&gt;The Past&lt;/h3&gt;

&lt;p&gt;Suppose you went back to Ada Lovelace and asked her the difference between a script and a program. She&amp;rsquo;d probably look at you funny, then say something like: Well, a script is what you give the actors, but a program is what you give the audience. That Ada was one sharp lady&amp;hellip;&lt;/p&gt;

&lt;p&gt;Since her time, we seem to have gotten a bit more confused about what we mean when we say scripting. It confuses even me, and I&amp;rsquo;m supposed to be one of the experts.&lt;/p&gt;

&lt;p&gt;So I&amp;rsquo;m afraid all I can do is give you my own worm&amp;rsquo;s eye view of the past, the present, and the future. Let me warn you that I am not without a few prejudices here and there.&lt;/p&gt;

&lt;h3 id=&#34;basic&#34;&gt;BASIC&lt;/h3&gt;

&lt;p&gt;Now, however it was initially intended, I think BASIC turned out to be one of the first major scripting languages, especially the extended version that DEC put onto its minicomputers called BASIC/PLUS, which happily included recursive functions with arguments. I started out as a BASIC programmer. Some people would say that I&amp;rsquo;m permanently damaged. Some people are undoubtedly right.&lt;/p&gt;

&lt;p&gt;But I&amp;rsquo;m not going to apologize for that. All language designers have their occasional idiosyncracies. I&amp;rsquo;m just better at it than most. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;rsts-basic-plus&#34;&gt;RSTS BASIC/PLUS&lt;/h3&gt;

&lt;p&gt;Anyway, when I was a RSTS programmer on a PDP-11, I certainly treated BASIC as a scripting language, at least in terms of rapid prototyping and process control. I&amp;rsquo;m sure it warped my brain forever. Perl&amp;rsquo;s statement modifiers are straight out of BASIC/PLUS. It even had some cute sigils on the ends of its variables to distinguish string and integer from floating point.&lt;/p&gt;

&lt;p&gt;But you could do extreme programming. In fact, I had a college buddy I did pair programming with. We took a compiler writing class together and studied all that fancy stuff from the dragon book. Then of course the professor announced we would be implementing our own language, called PL/0. After thinking about it a while, we announced that we were going to do our project in BASIC. The professor looked at us like were insane. Nobody else in the class was using BASIC. And you know what? Nobody else in the class finished their compiler either. We not only finished but added I/O extensions, and called it PL 0.5. That&amp;rsquo;s rapid prototyping.&lt;/p&gt;

&lt;h3 id=&#34;unix&#34;&gt;Unix?&lt;/h3&gt;

&lt;p&gt;I remember one day our computer center got a letter from Bell Labs telling us that we could get a tape of Unix V6 for cheap, only $100 because they were coming out shortly with V7. We all looked at each other and said, Why would we ever want to use this thing called Unix? We have RSTS.&lt;/p&gt;

&lt;h3 id=&#34;jam-no-not-that-one&#34;&gt;JAM (no not that one)&lt;/h3&gt;

&lt;p&gt;My first scripting language was written in BASIC. For my job in the computer center I wrote a language that I called JAM, short for Jury-rigged All-purpose Meta-language. Story of my life&amp;hellip;&lt;/p&gt;

&lt;p&gt;JAM was an inside-out text-processing language much like PHP, except that HTML hadn&amp;rsquo;t been invented yet. We mostly used it as a fancy macro processor for BASIC. Unlike PHP, it did not have 3,000 functions in one namespace. We wouldn&amp;rsquo;t have had the memory, for one thing.&lt;/p&gt;

&lt;h3 id=&#34;lisp&#34;&gt;LISP&lt;/h3&gt;

&lt;p&gt;For good or ill, when I went off to grad school, I studied linguistics, so the only computer language I used there was LISP. It was my own personal McCarthy era.&lt;/p&gt;

&lt;p&gt;Is LISP a candidate for a scripting language? While you can certainly write things rapidly in it, I cannot in good conscience call LISP a scripting language. By policy, LISP has never really catered to mere mortals.&lt;/p&gt;

&lt;p&gt;And, of course, mere mortals have never really forgiven LISP for not catering to them.&lt;/p&gt;

&lt;h3 id=&#34;pascal-ada&#34;&gt;Pascal, Ada&lt;/h3&gt;

&lt;p&gt;Once I got into industry, I wrote a compiler in Pascal for a discrete event simulator, and slavered over the forthcoming Ada specs. As a linguist, I don&amp;rsquo;t think of Ada as a big language. Now, English and Japanese, those are big languages. Ada is just a medium-sized language.&lt;/p&gt;

&lt;h3 id=&#34;unix-shell&#34;&gt;Unix, shell&lt;/h3&gt;

&lt;p&gt;After several years I finally became acquainted with Unix and its various scripting languages. OK, to be more precise, BSD, and csh.&lt;/p&gt;

&lt;h3 id=&#34;bsd-csh&#34;&gt;BSD, csh&lt;/h3&gt;

&lt;p&gt;Yeah, yeah, I know. More brain damage&amp;hellip;&lt;/p&gt;

&lt;p&gt;I also learned a little C.&lt;/p&gt;

&lt;h3 id=&#34;c&#34;&gt;C&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s because a little C is all there is. I&amp;rsquo;m still learning those libraries though.&lt;/p&gt;

&lt;h3 id=&#34;shell-awk-sed-find-expr&#34;&gt;shell + awk + sed + find + expr&amp;hellip;&lt;/h3&gt;

&lt;p&gt;But the frustrations of Unix shell programming led directly to the creation of Perl, which I don&amp;rsquo;t really have time to tell. But essentially, I found that shell scripting was intrinsically limited by the fact that most of its verbs are not under its control and hence largely inconsistent with each other. And the nouns are impoverished, restricted to strings and files, with who-knows-what typology.&lt;/p&gt;

&lt;h3 id=&#34;c-xor-shell&#34;&gt;C xor shell&lt;/h3&gt;

&lt;p&gt;More destructive was the mindset that it was a one-dimensional universe: you either programmed in C or you programmed in shell, because they&amp;rsquo;re obviously at opposite ends of the One True Continuum. Perl came about when I realized that scripting did not always have to viewed as the opposite of programming, but that a single language could be pretty good for both. That opened up a huge ecological niche. Many of you have seen my old clamshell diagram, with the two dimensions of manipulexity and whipuptitude.&lt;/p&gt;

&lt;h3 id=&#34;tcl&#34;&gt;Tcl&lt;/h3&gt;

&lt;p&gt;After Perl came Tcl, which in a sense is a purer scripting language than Perl. Perl just pretends that everything is a string when it&amp;rsquo;s convenient, but Tcl really believes that as a controlling metaphor. The string metaphor tends to have bad performance ramifications, but that&amp;rsquo;s not why Tcl languished, I think. There were two reasons for that.&lt;/p&gt;

&lt;p&gt;First, Tcl stayed in the Unix mindset that controlling tools was the opposite of creating tools, so they didn&amp;rsquo;t optimize much. The fast parts can always be written in C, after all.&lt;/p&gt;

&lt;p&gt;The second reason was the lack of a decent extension mechanism, so you ended up with separate executables for expect, incr-tcl, etc.&lt;/p&gt;

&lt;p&gt;I must say, though, that I&amp;rsquo;ve always admired Tcl&amp;rsquo;s delegational model of semantics. But it fell into the same trap as LISP by expecting everyone to use the One True Syntax. Speaking of the One True Syntax:&lt;/p&gt;

&lt;h3 id=&#34;python&#34;&gt;Python&lt;/h3&gt;

&lt;p&gt;After Tcl came Python, which in Guido&amp;rsquo;s mind was inspired positively by ABC, but in the Python community&amp;rsquo;s mind was inspired negatively by Perl. I&amp;rsquo;m not terribly qualified to talk about Python however. I don&amp;rsquo;t really know much about Python. I only stole its object system for Perl 5. I have since repented.&lt;/p&gt;

&lt;h3 id=&#34;ruby&#34;&gt;Ruby&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m much more qualified to talk about Ruby&amp;ndash;that&amp;rsquo;s because a great deal of Ruby&amp;rsquo;s syntax is borrowed from Perl, layered over Smalltalk semantics. I&amp;rsquo;ve always viewed Ruby as a much closer competitor for Perls ecological niche, not just because of the borrowed ideas, but because both Perl and Ruby take their functional programming support rather more seriously that Python does. On the other hand, I think Ruby kind of screwed up on its declaration syntax, among other things.&lt;/p&gt;

&lt;h3 id=&#34;sh&#34;&gt;*sh&lt;/h3&gt;

&lt;p&gt;Meanwhile, the Bourne shell was extended into the Korn shell and bash. I didn&amp;rsquo;t have much to do with those either. Thankfully. I will say that the continued evolution of the shell shows just how crufty a language can get when you just keep adding on ad hoc syntactic features.&lt;/p&gt;

&lt;h3 id=&#34;php&#34;&gt;PHP&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve also seen the rise of PHP, which takes the worse-is-better approach to dazzling new depths, as it were. By and large PHP seems to be making the same progression of mistakes as early Perl did, only slower. The one thing it does better is packaging. And when I say packaging, I don&amp;rsquo;t mean namespaces.&lt;/p&gt;

&lt;h3 id=&#34;javascript&#34;&gt;JavaScript&lt;/h3&gt;

&lt;p&gt;Then there&amp;rsquo;s JavaScript, a nice clean design. It has some issues, but in the long run JavaScript might actually turn out to be a decent platform for running Perl 6 on. Pugs already has part of a backend for JavaScript, though sadly that has suffered some bitrot in the last year. I think when the new JavaScript engines come out we&amp;rsquo;ll probably see renewed interest in a JavaScript backend.&lt;/p&gt;

&lt;h3 id=&#34;monad-powershell&#34;&gt;Monad/PowerShell&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve looked a bit at Microsoft&amp;rsquo;s Monad, and I&amp;rsquo;m pleased to note that it has object pipes like Perl 6. I just hope they don&amp;rsquo;t patent it.&lt;/p&gt;

&lt;h3 id=&#34;lua-applescript&#34;&gt;Lua, AppleScript&lt;/h3&gt;

&lt;p&gt;There are other scripting languages in wide use. Sadly, I must confess I never looked closely at Lua or AppleScript, probably because I&amp;rsquo;m not a game designer with a Mac.&lt;/p&gt;

&lt;p&gt;Actually, I suspect it runs deeper than that, which brings us up to the present time.&lt;/p&gt;

&lt;h3 id=&#34;the-present&#34;&gt;The Present&lt;/h3&gt;

&lt;p&gt;When I look at the present situation, what I see is the various scripting communities behaving a lot like neighboring tribes in the jungle, sometimes trading, sometimes warring, but by and large just keeping out of each other&amp;rsquo;s way in complacent isolation.&lt;/p&gt;

&lt;p&gt;I tend to take an anthropological view of these things. Many of you here are Perl programmers, but some of you come from other programming tribes. And depending on your tribal history, you might think of a string as a pointer to a byte array if you&amp;rsquo;re a C programmer, or as a list if you&amp;rsquo;re a functional programmer, or as an object if you&amp;rsquo;re a Java programmer. I view a string as a Text, with a capital T.&lt;/p&gt;

&lt;h3 id=&#34;text&#34;&gt;Text&lt;/h3&gt;

&lt;p&gt;I read that word from a postmodern perspective. Of course, the term Postmodern is itself context-sensitive. Some folks think Postmodernism means little more than the Empowerment of the Vulgar. Some folks think the same about Perl.&lt;/p&gt;

&lt;p&gt;But I take Postmodernism to mean that a Text, whether spoken or written, is an act of communication requiring intelligence on both ends, and sometimes in the middle too. I don&amp;rsquo;t want to talk to a stupid computer language. I want my computer language to understand the strings I type.&lt;/p&gt;

&lt;p&gt;Perl is a postmodern language, and a lot of conservative folks feel like Postmodernism is a rather liberal notion. So it&amp;rsquo;s rather ironic that my views on Postmodernism were primarily informed by studying linguistics and translation as taught by missionaries, specifically, the Wycliffe Bible Translators. One of the things they hammered home is that there&amp;rsquo;s really no such thing as a primitive human language. By which they mean essentially that all human languages are Turing complete.&lt;/p&gt;

&lt;p&gt;When you go out to so-called primitive tribes and analyze their languages, you find that structurally they&amp;rsquo;re just about as complex as any other human language. Basically, you can say pretty much anything in any human language, if you work at it long enough. Human languages are Turing complete, as it were.&lt;/p&gt;

&lt;p&gt;Human languages therefore differ not so much in what you &lt;em&gt;can&lt;/em&gt; say but in what you &lt;em&gt;must&lt;/em&gt; say. In English, you are forced to differentiate singular from plural. In Japanese, you don&amp;rsquo;t have to distinguish singular from plural, but you do have to pick a specific level of politeness, taking into account not only your degree of respect for the person you&amp;rsquo;re talking to, but also your degree of respect for the person or thing you&amp;rsquo;re talking about.&lt;/p&gt;

&lt;p&gt;So languages differ in what you&amp;rsquo;re forced to say. Obviously, if your language forces you to say something, you can&amp;rsquo;t be concise in that particular dimension using your language. Which brings us back to scripting.&lt;/p&gt;

&lt;p&gt;How many ways are there for different scripting languages to be concise?&lt;/p&gt;

&lt;p&gt;How many recipes for borscht are there in Russia?&lt;/p&gt;

&lt;p&gt;Language designers have many degrees of freedom. I&amp;rsquo;d like to point out just a few of them.&lt;/p&gt;

&lt;h3 id=&#34;early-binding-late-binding&#34;&gt;early binding / late binding&lt;/h3&gt;

&lt;p&gt;Binding in this context is about exactly when you decide which routine you&amp;rsquo;re going to call for a given routine name. In the early days of computing, most binding was done fairly early for efficiency reasons, either at compile time, or at the latest, at link time. You still tend to see this approach in statically typed languages. With languages like Smalltalk, however, we began to see a different trend, and these days most scripting languages are trending towards later binding. That&amp;rsquo;s because scripting languages are trying to be dwimmy (Do What I Mean), and the dwimmiest decision is usually a late decision because you then have more available semantic and even pragmatic context to work with. Otherwise you have to predict the future, which is hard.&lt;/p&gt;

&lt;p&gt;So scripting languages naturally tend to move toward an object-oriented point of view, where the binding doesn&amp;rsquo;t happen &amp;lsquo;til method dispatch time. You can still see the scars of conflict in languages like C++ and Java though. C++ makes the default method type non-virtual, so you have to say virtual explicitly to get late binding. Java has the notion of final classes, which force calls to the class to be bound at compile time, essentially. I think both of those approaches are big mistakes. Perl 6 will make different mistakes. In Perl 6 all methods are virtual by default, and only the application as a whole can tell the optimizer to finalize classes, presumably only after you know how all the classes are going to be used by all the other modules in the program.&lt;/p&gt;

&lt;h3 id=&#34;single-dispatch-multiple-dispatch&#34;&gt;single dispatch / multiple dispatch&lt;/h3&gt;

&lt;p&gt;In a sense, multiple dispatch is a way to delay binding even longer. You not only have to delay binding &amp;lsquo;til you know the type of the object, but you also have to know the types of all rest of the arguments before you can pick a routine to call. Python and Ruby always do single dispatch, while Dylan does multiple dispatch. Here is one dimension in which Perl 6 &lt;em&gt;forces&lt;/em&gt; the caller to be explicit for clarity. I think it&amp;rsquo;s an important distinction for the programmer to bear in mind, because single dispatch and multiple dispatch are philosophically very different ideas, based on different metaphors.&lt;/p&gt;

&lt;p&gt;With single-dispatch languages, you are basically sending a message to an object, and the object decides what to do with that message. With multiple dispatch languages, however, there is no privileged object. All the objects involved in the call have equal weight. So one way to look at multiple dispatch is that the objects are completely passive. But if the objects aren&amp;rsquo;t deciding how to bind, who is?&lt;/p&gt;

&lt;p&gt;Well, it&amp;rsquo;s sort of a democratic thing. All the routines of a given name get together and hold a political conference. (Well, not really, but this is how the metaphor works.) Each of the routines is a delegate to the convention. All the potential candidates put their names in the hat. Then all the routines vote on who the best candidate is, and the next best, and the next best after that. And eventually the routines themselves decide what the best routine to call is.&lt;/p&gt;

&lt;p&gt;So basically, multiple dispatch is like democracy. It&amp;rsquo;s the worst way to do late binding, except for all the others.&lt;/p&gt;

&lt;p&gt;But I really do think that&amp;rsquo;s true, and likely to become truer as time goes on. I&amp;rsquo;m spending a lot of time on this multiple dispatch issue because I think programming in the large is mutating away from the command-and-control model implicit in single dispatch. I think the field of computation as a whole is moving more toward the kinds of decisions that are better made by swarms of insects or schools of fish, where no single individual is in control, but the swarm as a whole has emergent behaviors that are somehow much smarter than any of the individual components.&lt;/p&gt;

&lt;h3 id=&#34;eager-evaluation-lazy-evaluation&#34;&gt;eager evaluation / lazy evaluation&lt;/h3&gt;

&lt;p&gt;Most languages evaluate eagerly, including Perl 5. Some languages evaluate all expressions as lazily as possible. Haskell is a good example of that. It doesn&amp;rsquo;t compute anything until it is forced to. This has the advantage that you can do lots of cool things with infinite lists without running out of memory. Well, at least until someone asks the program to calculate the whole list. Then you&amp;rsquo;re pretty much hosed in any language, unless you have a real Turing machine.&lt;/p&gt;

&lt;p&gt;So anyway, in Perl 6 we&amp;rsquo;re experimenting with a mixture of eager and lazy. Interestingly, the distinction maps very nicely onto Perl 5&amp;rsquo;s concept of scalar context vs. list context. So in Perl 6, scalar context is eager and list context is lazy. By default, of course. You can always force a scalar to be lazy or a list to be eager if you like. But you can say things like &lt;code&gt;for 1..Inf&lt;/code&gt; as long as your loop exits some other way a little bit before you run into infinity.&lt;/p&gt;

&lt;h3 id=&#34;eager-typology-lazy-typology&#34;&gt;eager typology / lazy typology&lt;/h3&gt;

&lt;p&gt;Usually known as static vs. dynamic, but again there are various positions for the adjustment knob. I rather like the gradual typing approach for a number of reasons. Efficiency is one reason. People usually think of strong typing as a reason, but the main reason to put types into Perl 6 turns out not to be strong typing, but rather multiple dispatch. Remember our political convention metaphor? When the various candidates put their names in the hat, what distinguishes them? Well, each candidate has a political platform. The planks in those political platforms are the types of arguments they want to respond to. We all know politicians are only good at responding to the types of arguments they want to have&amp;hellip;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s another way in which Perl 6 is slightly more lazy than Perl 5. We still have the notion of contexts, but exactly when the contexts are decided has changed. In Perl 5, the compiler usually knows at compile time which arguments will be in scalar context, and which arguments will be in list context. But Perl 6 delays that decision until method binding time, which is conceptually at run time, not at compile time. This might seem like an odd thing to you, but it actually fixes a great number of things that are suboptimal in the design of Perl 5. Prototypes, for instance. And the need for explicit references. And other annoying little things like that, many of which end up as frequently asked questions.&lt;/p&gt;

&lt;h3 id=&#34;limited-structures-rich-structures&#34;&gt;limited structures / rich structures&lt;/h3&gt;

&lt;p&gt;Awk, Lua, and PHP all limit their composite structures to associative arrays. That has both pluses and minuses, but the fact that awk did it that way is one of the reasons that Perl does it differently, and differentiates ordered arrays from unordered hashes. I just think about them differently, and I think a lot of other people do too.&lt;/p&gt;

&lt;h3 id=&#34;symbolic-wordy&#34;&gt;symbolic / wordy&lt;/h3&gt;

&lt;p&gt;Arguably APL is also a kind of scripting language, largely symbolic. At the other extreme we have languages that eschew punctuation in favor of words, such as AppleScript and COBOL, and to a lesser extent all the Algolish languages that use words to indicate blocks where the C-derived languages use curlies. I prefer a balanced approach here, where symbols and identifiers are each doing what theyre best at. I like it when most of the actual words are those chosen by the programmer to represent the problem at hand. I don&amp;rsquo;t like to see words used for mere syntax. Such syntactic functors merely obscure the real words. That&amp;rsquo;s one thing I learned when I switched from Pascal to C. Braces for blocks. It&amp;rsquo;s just right visually.&lt;/p&gt;

&lt;p&gt;Actually, there are languages that do it even worse than COBOL. I remember one Pascal variant that required your keywords to be capitalized so that they would stand out. No, no, no, no, no! You don&amp;rsquo;t want your functors to stand out. It&amp;rsquo;s shouting the wrong words: IF! foo THEN! bar ELSE! baz END! END! END! END!&lt;/p&gt;

&lt;p&gt;Anyway, in Perl 6 we&amp;rsquo;re raising the standard for where we use punctuation, and where we don&amp;rsquo;t. We&amp;rsquo;re getting rid of some of our punctuation that isn&amp;rsquo;t really pulling its weight, such as parentheses around conditional expressions, and most of the punctuational variables. And we&amp;rsquo;re making all the remaining punctuation work harder. Each symbol has to justify its existence according to Huffman coding.&lt;/p&gt;

&lt;p&gt;Oddly, there&amp;rsquo;s one spot where we&amp;rsquo;re introducing new punctuation. After your sigil you can add a twigil, or secondary sigil. Just as a sigil tells you the basic structure of an object, a twigil tells you that a particular variable has a weird scope. This is basically an idea stolen from Ruby, which uses sigils to indicate weird scoping. But by hiding our twigils after our sigils, we get the best of both worlds, plus an extensible twigil system for weird scopes we haven&amp;rsquo;t thought of yet.&lt;/p&gt;

&lt;p&gt;We think about extensibility a lot. We think about languages we don&amp;rsquo;t know how to think about yet. But leaving spaces in the grammar for new languages is kind of like reserving some of our land for national parks and national forests. Or like an archaeologist not digging up half the archaeological site because we know our descendants will have even better analytical tools than we have.&lt;/p&gt;

&lt;p&gt;Really designing a language for the future involves a great deal of humility. As with science, you have to assume that, over the long term, a great deal of what you think is true will turn out not to be quite the case. On the other hand, if you don&amp;rsquo;t make your best guess now, you&amp;rsquo;re not really doing science either. In retrospect, we know APL had too many strange symbols. But we wouldn&amp;rsquo;t be as sure about that if APL hadn&amp;rsquo;t tried it first.&lt;/p&gt;

&lt;h3 id=&#34;compile-time-run-time&#34;&gt;compile time / run time&lt;/h3&gt;

&lt;p&gt;Many dynamic languages can eval code at run time. Perl also takes it the other direction and runs a lot of code at compile time. This can get messy with operational definitions. You don&amp;rsquo;t want to be doing much file I/O in your &lt;code&gt;BEGIN&lt;/code&gt; blocks, for instance. But that leads us to another distinction:&lt;/p&gt;

&lt;h3 id=&#34;declarational-operational&#34;&gt;declarational / operational&lt;/h3&gt;

&lt;p&gt;Most scripting languages are way over there on the operational side. I thought Perl 5 had an oversimplified object system till I saw Lua. In Lua, an object is just a hash, and there&amp;rsquo;s a bit of syntactic sugar to call a hash element if it happens to contain code. Thats all there is. They don&amp;rsquo;t even have classes. Anything resembling inheritance has to be handled by explicit delegation. That&amp;rsquo;s a choice the designers of Lua made to keep the language very small and embeddable. For them, maybe it&amp;rsquo;s the right choice.&lt;/p&gt;

&lt;p&gt;Perl 5 has always been a bit more declarational than either Python or Ruby. I&amp;rsquo;ve always felt strongly that implicit scoping was just asking for trouble, and that scoped variable declarations should be very easy to recognize visually. Thats why we have &lt;code&gt;my&lt;/code&gt;. It&amp;rsquo;s short because I knew we&amp;rsquo;d use it frequently. Huffman coding. Keep common things short, but not too short. In this case, 0 is too short.&lt;/p&gt;

&lt;p&gt;Perl 6 has more different kinds of scopes, so we&amp;rsquo;ll have more declarators like &lt;code&gt;my&lt;/code&gt; and &lt;code&gt;our&lt;/code&gt;. But appearances can be deceiving. While the language looks more declarative on the surface, we make most of the declarations operationally hookable underneath to retain flexibility. When you declare the type of a variable, for instance, you&amp;rsquo;re really just doing a kind of tie, in Perl 5 terms. The main difference is that you&amp;rsquo;re tying the implementation to the variable at compile time rather than run time, which makes things more efficient, or at least potentially optimizable.&lt;/p&gt;

&lt;h3 id=&#34;immutable-classes-mutable-classes&#34;&gt;immutable classes / mutable classes&lt;/h3&gt;

&lt;p&gt;Classes in Java are closed, which is one of the reasons Java can run pretty fast. In contrast, Ruby&amp;rsquo;s classes are open, which means you can add new things to them at any time. Keeping that option open is perhaps one of the reasons Ruby runs so slow. But that flexibility is also why Ruby has Rails.&lt;/p&gt;

&lt;p&gt;Perl 6 will have an interesting mix of immutable generics and mutable classes here, and interesting policies on who is allowed to close classes when. Classes are never allowed to close or finalize themselves, for instance. Sorry, for some reason I keep talking about Perl 6. It could have something to do with the fact that we&amp;rsquo;ve had to think about all of these dimensions in designing Perl 6.&lt;/p&gt;

&lt;h3 id=&#34;class-based-prototype-based&#34;&gt;class-based / prototype-based&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s another dimension that can open up to allow both approaches. Some of you may be familiar with classless languages like Self or JavaScript. Instead of classes, objects just clone from their ancestors or delegate to other objects. For many kinds of modeling, it&amp;rsquo;s actually closer to the way the real world works. Real organisms just copy their DNA when they reproduce. They don&amp;rsquo;t have some DNA of their own, and an &lt;code&gt;@ISA&lt;/code&gt; array telling you which parent objects contain the rest of their DNA.&lt;/p&gt;

&lt;p&gt;The meta-object protocol for Perl 6 defaults to class-based, but is flexible enough to set up prototype-based objects as well. Some of you have played around with &lt;a href=&#34;https://metacpan.org/pod/Moose&#34;&gt;Moose&lt;/a&gt; in Perl 5. Moose is essentially a prototype of Perl 6&amp;rsquo;s object model. On a semantic level, anyway. The syntax is a little different. Hopefully a little more natural in Perl 6.&lt;/p&gt;

&lt;h3 id=&#34;passive-data-global-consistency-active-data-local-consistency&#34;&gt;passive data, global consistency / active data, local consistency&lt;/h3&gt;

&lt;p&gt;Your view of data and control will vary with how functional or object-oriented your brain is. People just think differently. Some people think mathematically, in terms of provable universal truths. Functional programmers don&amp;rsquo;t much care if they strew implicit computation state throughout the stack and heap, as long as everything &lt;em&gt;looks&lt;/em&gt; pure and free from side-effects.&lt;/p&gt;

&lt;p&gt;Other people think socially, in terms of cooperating entities that each have their own free will. And it&amp;rsquo;s pretty important to them that the state of the computation be stored with each individual object, not off in some heap of continuations somewhere.&lt;/p&gt;

&lt;p&gt;Of course, some of us can&amp;rsquo;t make up our minds whether we&amp;rsquo;d rather emulate the logical Sherlock Holmes or sociable Dr. Watson. Fortunately, scripting is not incompatible with either of these approaches, because both approaches can be made more approachable to normal folk.&lt;/p&gt;

&lt;h3 id=&#34;info-hiding-scoping-attachment&#34;&gt;info hiding / scoping / attachment&lt;/h3&gt;

&lt;p&gt;And finally, if you&amp;rsquo;re designing a computer language, there are a couple bazillion ways to encapsulate data. You have to decide which ones are important. What&amp;rsquo;s the best way to let the programmer achieve separation of concerns?&lt;/p&gt;

&lt;h3 id=&#34;object-class-aspect-closure-module-template-trait&#34;&gt;object / class / aspect / closure / module / template / trait&lt;/h3&gt;

&lt;p&gt;You can use any of these various traditional encapsulation mechanisms.&lt;/p&gt;

&lt;h3 id=&#34;transaction-reaction-dynamic-scope&#34;&gt;transaction / reaction / dynamic scope&lt;/h3&gt;

&lt;p&gt;Or you can isolate information to various time-based domains.&lt;/p&gt;

&lt;h3 id=&#34;process-thread-device-environment&#34;&gt;process / thread / device / environment&lt;/h3&gt;

&lt;p&gt;You can attach info to various OS concepts.&lt;/p&gt;

&lt;h3 id=&#34;screen-window-panel-menu-icon&#34;&gt;screen / window / panel / menu / icon&lt;/h3&gt;

&lt;p&gt;You can hide info various places in your GUI. Yeah, yeah, I know, everything is an object. But some objects are more equal than others.&lt;/p&gt;

&lt;h3 id=&#34;syntactic-scope-semantic-scope-pragmatic-scope&#34;&gt;syntactic scope / semantic scope / pragmatic scope&lt;/h3&gt;

&lt;p&gt;Information can attach to various abstractions of your program, including, bizarrely, lexical scopes. Though if you think about it hard enough, you realize lexical scopes are also a funny kind of dynamic scope, or recursion wouldn&amp;rsquo;t work right. A &lt;code&gt;state&lt;/code&gt; variable is actually more purely lexical than a &lt;code&gt;my&lt;/code&gt; variable, because it&amp;rsquo;s shared by all calls to that lexical scope. But even state variables get cloned with closures. Only global variables can be truly lexical, as long as you refer to them only in a given lexical scope. Go figure.&lt;/p&gt;

&lt;p&gt;So really, most of our scopes are semantic scopes that happen to be attached to a particular syntactic scope.&lt;/p&gt;

&lt;p&gt;You may be wondering what I mean by a &lt;em&gt;pragmatic&lt;/em&gt; scope. That&amp;rsquo;s the scope of what the user of the program is storing in their brain, or in some surrogate for their brain, such as a game cartridge. In a sense, most of the web pages out there on the Internet are part of the pragmatic scope. As is most of the data in databases. The hallmark of the pragmatic scope is that you really don&amp;rsquo;t know the lifetime of the container. It&amp;rsquo;s just out there somewhere, and will eventually be collected by that Great Garbage Collector that collects all information that anyone forgets to remember. The Google cache can only last so long. Eventually we will forget the meaning of every URL. But we must not forget the &lt;em&gt;principle&lt;/em&gt; of the URL. That leads us to our next degree of freedom.&lt;/p&gt;

&lt;h3 id=&#34;use-lingua-perligata&#34;&gt;use Lingua::Perligata;&lt;/h3&gt;

&lt;p&gt;If you allow a language to mutate its own grammar within a lexical scope, how do you keep track of that cleanly? Perl 5 discovered one really bad way to do it, namely source filters, but even so we ended up with Perl dialects such as Perligata and Klingon. What would it be like if we actually did it right?&lt;/p&gt;

&lt;p&gt;Doing it right involves treating the evolution of the language as a pragmatic scope, or as a set of pragmatic scopes. You have to be able to name your dialect, kind of like a URL, so there needs to be a universal root language, and ways of warping that universal root language into whatever dialect you like. This is actually near the heart of the vision for Perl 6. We don&amp;rsquo;t see Perl 6 as a single language, but as the root for a family of related languages. As a family, there are shared cultural values that can be passed back and forth among sibling languages as well as to the descendants.&lt;/p&gt;

&lt;p&gt;I hope you&amp;rsquo;re all scared stiff by all these degrees of freedom. I&amp;rsquo;m sure there are other dimensions that are even scarier.&lt;/p&gt;

&lt;p&gt;But&amp;hellip; I think its a manageable problem. I think its possible to still think of Perl 6 as a scripting language, with easy onramps.&lt;/p&gt;

&lt;p&gt;And the reason I think its manageable is because, for each of these dimensions, it&amp;rsquo;s not just a binary decision, but a knob that can be positioned at design time, compile time, or even run time. For a given dimension X, different scripting languages make different choices, set the knob at different locations.&lt;/p&gt;

&lt;h3 id=&#34;you-can-t-even-think-about-x&#34;&gt;You can&amp;rsquo;t even think about X!&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s only one way to do X!
There&amp;rsquo;s more than one way to do X!
There are too many ways to do X!&lt;/p&gt;

&lt;p&gt;You may recognize some slogans in here.&lt;/p&gt;

&lt;h3 id=&#34;curling-up&#34;&gt;Curling Up&lt;/h3&gt;

&lt;p&gt;So I&amp;rsquo;m not suggesting that all scripting languages have to take all these dimensions into account, even if Perl 6 tries to. The scripting paradigm is not any one of these dimensions. According to various theories the universe may be laid out in ten or twenty dimensions, but generally we get by with only about three and a half of those dimensions. The rest are said to be curled up. Maybe we live in a scripting universe.&lt;/p&gt;

&lt;p&gt;Most of the scripting languages we call Perl 6 will have most of these dimensions curled up most of the time. But unlike the real universe, where it takes huge machines to uncurl these dimensions, we&amp;rsquo;ll make the dimensions uncurl just by keeping our declarations straight. Well, we&amp;rsquo;ll try. And where that fails, we&amp;rsquo;ll rely on the culture to keep things straight.&lt;/p&gt;

&lt;p&gt;For example, that&amp;rsquo;s exactly what happened already with Perl 5. We have the declarations, &lt;code&gt;use strict; use warnings;&lt;/code&gt;. But it&amp;rsquo;s the culture that decided to enforce the use of them. So much so that we&amp;rsquo;ve decided that they should be the default for most of Perl 6. It was one of those decisions by the hive. In this case the swarm turned out to be smarter than the language designer. And that&amp;rsquo;s as it should be.&lt;/p&gt;

&lt;h3 id=&#34;the-future&#34;&gt;The Future&lt;/h3&gt;

&lt;p&gt;Well, so what&amp;rsquo;s the future of scripting?&lt;/p&gt;

&lt;p&gt;In my completely unbiased opinion, that would be Perl 6. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Seriously though, it&amp;rsquo;s always safe to predict that the ecological landscape will end up with many small languages and a few dominant ones. Some languages like AppleScript have particular ecological niches and are unlikely to grow out of them. Other languages get used outside their original niche. There will always be the generalists, like crows and mockingbirds, and the specialists, like penguins and dodos. (Well, maybe not always the dodos&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Among the generalists, the conventional wisdom is that the worse-is-better approach is more adaptive. Personally, I get a little tired of the argument: My worse-is-better is better than your worse-is-better because I&amp;rsquo;m better at being worser! Is it really true that the worse-is-better approach always wins? With Perl 6 we&amp;rsquo;re trying to sneak one better-is-better cycle in there and hope to come out ahead before reverting to the tried and true worse-is-better approach. Whether that works, only time will tell.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The State of the Onion 10</title>
      <link>http://localhost:1313/pub/2006/09/21/onion.html/</link>
      <pubDate>Thu, 21 Sep 2006 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2006/09/21/onion.html/</guid>
      <description>&lt;p&gt;Welcome to the tenth State of the Perl Onion. For those of you who are unfamiliar with my methods, this is the annual speech wherein I ramble on about various things that are only marginally related to the state of Perl. I&amp;rsquo;ve gotten pretty good at rambling in my old age.&lt;/p&gt;

&lt;p&gt;In the &lt;em&gt;Scientific American&lt;/em&gt; that just came out, there&amp;rsquo;s an article on chess experts, written by an expert, on what makes experts so expert. This expert claims that you can become an expert in just about anything if you study it persistently for ten years or so. So, since this is my tenth State of the Onion, maybe I&amp;rsquo;m about to become an expert in giving strange talks. One can only hope (not).&lt;/p&gt;

&lt;p&gt;Speaking of chess, how many of you recognize this?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x00.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Does this help?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x01.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is, of course, the mnemonic for the old Linnean taxonomy of biological classification.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x02.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Those of you who understand computers better than critters can think of these as nested namespaces.&lt;/p&gt;

&lt;p&gt;This is all about describing nature, so naturally, different languages care about different levels.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x03.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For instance, PHP isn&amp;rsquo;t much into taxonomy, so everything in PHP is just its own species in a flat namespace. Congratulations, this is your new species name:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x04.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Ruby, of course, is interested primarily in Classes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x05.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Python, as the &amp;ldquo;anti-Perl,&amp;rdquo; is heavily invested in maintaining Order.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x06.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now, you &lt;em&gt;might&lt;/em&gt; be smart enough to program in Haskell if you&amp;rsquo;ve received a MacArthur Genus award.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x07.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;hellip; used to be I couldn&amp;rsquo;t spell &amp;ldquo;genus,&amp;rdquo; and now I are one &amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x08.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Moving right along toward the other end of the spectrum, we have JavaScript that kind of believes in Phyla without believing in Classes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x09.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And at the top of the heap, playing king of the mountain, we have languages like C# and Java. The kingdom of Java only has one species.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x10.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The kingdom of C# has many species, but they all look like C#.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x11.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Well, that leaves us with families.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x12.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I expect I have a pretty good excuse for thinking a lot about families lately, and here is my excuse:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x13.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is Julian, my grandson. Julian, meet the open source hackers. Open source hackers, meet Julian.&lt;/p&gt;

&lt;p&gt;Many of you will remember my daughter Heidi from previous OSCONs. A couple years ago she married Andy, and Julian is the result. I think he&amp;rsquo;s a keeper. Julian, I mean.&lt;/p&gt;

&lt;p&gt;Well, and Andy too.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x14.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Andy obviously has his priorities straight. I would certainly recommend him as a son-in-law to anyone. (Wait, that doesn&amp;rsquo;t quite work &amp;hellip;)&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x15.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;There are many definitions of family, of course. Here&amp;rsquo;s a mommy and a daddy truck. They live on a truck farm, and raise little trucks.&lt;/p&gt;

&lt;p&gt;Out in California, the word &amp;ldquo;family&amp;rdquo; keeps leaping out at me from various signs. People use the word &amp;ldquo;family&amp;rdquo; in some really weird ways.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x16.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;There was a Family Fun Center, with a miniature golf course. I believe that sign. At least for the golf. As a parent, I&amp;rsquo;m not sure the game arcade is for the whole family. I&amp;rsquo;m an expert in staying out of loud places.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x17.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But the sign that said &amp;ldquo;Farmers Feed America&amp;ndash;Family Water Alliance&amp;rdquo; &amp;hellip; I suspect the word &amp;ldquo;family&amp;rdquo; is in there more for its PR value than anything else.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x18.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And, of course, &amp;ldquo;family planning&amp;rdquo; is for when you plan &lt;em&gt;not&lt;/em&gt; to have a family. Go figure.&lt;/p&gt;

&lt;p&gt;All of my kids were unplanned, but that doesn&amp;rsquo;t mean they were unwanted.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x19.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Many of you know that I have four kids, but in a strange way, I really have five, if you count Perl.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x20.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Geneva thinks of Perl as more or less her twin sister, since they were both born in 1987. But then, Geneva is strange.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x21.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Some people think Perl is strange too. That&amp;rsquo;s okay&amp;ndash;all my kids are a little strange. They come by it naturally.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x22.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x23.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a self-portrait of the other end of Geneva.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x24.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what you usually see of Lewis.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x25.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s some of Aron, pulling the door that says &amp;ldquo;push.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x26.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And here&amp;rsquo;s Heidi.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x27.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;She always was a pale child.&lt;/p&gt;

&lt;p&gt;Actually, here&amp;rsquo;s the real picture.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x28.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You can see she&amp;rsquo;s actually quite sane. Compared to the rest of us.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x29.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a picture of my wife Gloria.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x30.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s another picture of my wife. Well, her arms. The feet are my mom&amp;rsquo;s. Actually, this is &lt;em&gt;really&lt;/em&gt; a picture of my granddog, Milo. He&amp;rsquo;s the one on the right.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve talked before about how the stages in Perl&amp;rsquo;s life are very much like that of a kid. To review:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x31.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This extended metaphor can be extended even further as necessary and prudent. Actually, it&amp;rsquo;s probably unnecessary and imprudent, but I&amp;rsquo;ll extend it anyway, because I find the metaphor useful. Perl, my fifth child, is showing various signs that she is about to grow up, and as a pseudo-parent, that makes me pseudo-proud of her. But there are other ways the metaphor makes me happy. For instance, it gives me another argument about the name of Perl 6.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x32.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;From time to time, people have suggested that Perl 6 is sufficiently different from Perl 5 that she should be given a new name. But we don&amp;rsquo;t usually rename our kids when they grow up. They may choose to rename themselves, of course. For the moment I think Perl would like her name to stay Perl.&lt;/p&gt;

&lt;p&gt;Now, I know what some of you are thinking: in anthropomorphizing Perl this way, Larry has gone completely off the deep end. That&amp;rsquo;s not possible&amp;ndash;I started out by jumping off the deep end, and I haven&amp;rsquo;t noticed the water getting any shallower lately.&lt;/p&gt;

&lt;p&gt;But in justification of my metaphor, let me just say that when I say &amp;ldquo;Perl&amp;rdquo; here, I&amp;rsquo;m not just talking about the language, but the entire culture. There are a lot of people who worked hard to raise Perl up to where she is today, and a bunch more people working hard to send her off to college. It&amp;rsquo;s the collective aspirations of those people that is the real personality of Perl.&lt;/p&gt;

&lt;p&gt;When we first announced the Perl 6 effort back in 2000, we said it would be the community redesign of Perl. That continues to be the case today. It may look like I&amp;rsquo;m making all these arbitrary decisions as the language designer, but as with a teenager, you somehow end up making most of your decisions consistent with what they want. With what the Perl community wants, in this case.&lt;/p&gt;

&lt;p&gt;If a teenager doesn&amp;rsquo;t want to listen to you, you can&amp;rsquo;t make &amp;lsquo;em.&lt;/p&gt;

&lt;p&gt;The fact is, Perl would be nothing without the people around her. Here&amp;rsquo;s a new acronym:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x33.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;or if you like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x34.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It really helps to have an extended family to raise a kid well. American culture has been somewhat reductionist in this respect, but a lot of other cultures around the world understand the importance of extended family. Maybe it&amp;rsquo;s just because Americans move around so much. But it&amp;rsquo;s a healthy trend that young people these days are manufacturing their own extended families. At the church I go to, we call it &amp;ldquo;Doing Life Together.&amp;rdquo; Here in the extended Perl family, we&amp;rsquo;re doing life together too.&lt;/p&gt;

&lt;p&gt;We have people in our family like Uncle Chip and Aunt Audrey. There&amp;rsquo;s Cousin Allison, and Cousin Ingy, and Cousin Uri, and our very own Evil Brother Damian. I think Randal occasionally enjoys being the honorary black sheep of the family, as it were.&lt;/p&gt;

&lt;p&gt;It all kind of reminds me of the Addams family. Hmm.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x35.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I watched &lt;em&gt;The Addams Family&lt;/em&gt; a lot when I was young. Maybe you should call me Gomez, and call Gloria, Morticia. I must confess that I do love it when my wife speaks French. It gives me déjà vu all up and down my spine.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s okay for me to tell you that because I live in a fishbowl.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x36.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x37.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not sure who gets to be Lurch. Or Thing. Anybody wanna volunteer? We&amp;rsquo;re always looking for volunteers in the Perl community. Don&amp;rsquo;t be scared. The Addams family can be a little scary, and so can the Perl family, but you&amp;rsquo;ll notice we&amp;rsquo;re also affectionate and accepting. In a ghoulish sort of way.&lt;/p&gt;

&lt;p&gt;We could take this TV family metaphor a lot further, but fortunately for you I never watched the &lt;em&gt;Partridge Family&lt;/em&gt; or &lt;em&gt;The Brady Bunch&lt;/em&gt; or &lt;em&gt;All in the Family&lt;/em&gt; or &lt;em&gt;Father Knows Best&lt;/em&gt;. Those of you who were here before know I mostly watched &lt;em&gt;The Man From U.N.C.L.E.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I also watched &lt;em&gt;Combat&lt;/em&gt;, a World War II show. But I was kind of a gruesome little kid that way.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x38.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I like gruesome shows. Maybe that explains why I liked the Addams family. Hmm. I once sat on the lap of the Santa Claus at Sears and asked for all five toy machine guns listed in the Sears catalog that year. For some reason I didn&amp;rsquo;t get any of them. But I suppose my family loved me in spite of my faults. My role models in parenting obviously didn&amp;rsquo;t come from TV. Or maybe they did. You know, that would explain a lot about how my family turned out. In actual fact, the picture above is another self-portrait done by my daughter Geneva.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x39.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Anyway, I love my own family, even if they&amp;rsquo;re kind of peculiar at times. Last month we were staying at a Motel 6 in Medford, Oregon. Gloria kindly went off to fetch me a cup of coffee from the motel lobby, and then she came to this door and stood there for a while wondering how to pull the door open with her hands full. Then she realized that the door must have been designed by someone who thinks there should be only one obvious way to do it. Because, the fact is, you can either pull or push this door, despite what it says. I suggested we should start marking such pushmepullyu doors with a P*. We obviously need more globs in real life.&lt;/p&gt;

&lt;p&gt;Anyway, back to my weird family&amp;ndash;this summer as we were driving around, we had a great literary discussion about how Tolstoy debunks the Great Man theory of history in &lt;em&gt;War and Peace&lt;/em&gt;. After discussing the far-too-heavily overloaded namespace in Russian novels and the almost complete absence of names in the &lt;em&gt;Tale of Genji&lt;/em&gt;, we tried to decide if the &lt;em&gt;Tale of Genji&lt;/em&gt; was the first novel or not, and decided that it was really the first soap opera. Of course, then there had to be a long discussion of what really &lt;em&gt;was&lt;/em&gt; the first novel&amp;ndash;&lt;em&gt;Tale of Genji&lt;/em&gt;, &lt;em&gt;Madame Bovary&lt;/em&gt;, or &lt;em&gt;Sense and Sensibility&lt;/em&gt;. Then there&amp;rsquo;s the first romance, first mystery, first fantasy, first science fiction, first modern novel, etc. One interesting fact we noted was that the first in a genre almost always has to officially be some other genre too. For example, the &lt;em&gt;Tale of Genji&lt;/em&gt; was written in the existing form of explication of some haiku. Transitional forms are important in biological evolution as well, as one species learns to become another species. That&amp;rsquo;s why we explicitly allow people to program babytalk in Perl. The only way to become smart is to be stupid first. Puts a new spin on the Great Man theory of history.&lt;/p&gt;

&lt;p&gt;So then, as we were driving we saw a cloud formation resembling Thomas Jefferson, which led us to speculate on the Great Documents theory of history. &amp;ldquo;Liberty, Equality, Fraternity&amp;rdquo; brought up the Great Slogans theory of history.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x40.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Back to Tolstoy: &amp;ldquo;Moscow didn&amp;rsquo;t burn because Napoleon decided to burn it. Moscow burned because it was made of wood.&amp;rdquo; Those of you who attended YAPC Chicago may recognize that as the Great Cow theory of history. Or maybe the lantern was really kicked over by a camel, and there was a coverup.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x41.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Anyway, back to the family again, presuming the house hasn&amp;rsquo;t burned down. They say that &amp;ldquo;A family is where, when you have to go there, they have to take you in.&amp;rdquo; Arguably, regardless of your viewpoint, many people have been, um, taken in by Perl culture.&lt;/p&gt;

&lt;p&gt;Sorry. I have a low taste for taking people in with puns.&lt;/p&gt;

&lt;p&gt;But hey, taking people in is good. And stray kitties.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x42.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Some families just naturally accumulate strays. My wife and I were both fortunate enough to grow up in families that took in strays as a matter of course. We have a number of honorary members of our own family. I think a good family tends to Borg people who need to be taken in. It&amp;rsquo;s a lot like the way Audrey hands out commit bits to Pugs left and right. It all one big happy hivemind. Er, I mean family.&lt;/p&gt;

&lt;p&gt;Now, it&amp;rsquo;s all well and good to get people in the door, but that&amp;rsquo;s only the beginning of accessibility. Whenever you get someone new in the family, either by birth or by adoption, where do you go from there? You have to raise your kids somehow, and they&amp;rsquo;re all different. Raising different kids requires different approaches, just like computer problems do.&lt;/p&gt;

&lt;p&gt;So, then, how do we raise a family according to the various computing paradigms?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x43.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Imperative programming is the &lt;em&gt;Father Knows Best&lt;/em&gt; approach. It only works at all when Father &lt;em&gt;does&lt;/em&gt; know best, which is not all that often. Often Mother knows &amp;ldquo;bester&amp;rdquo; than Father. Hi, Gloria. And a surprising amount of the time, it&amp;rsquo;s the kids who know &amp;ldquo;bestest.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x44.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;For some reason the Von Trapp family comes to mind. I guess you have to structure your family to make the &lt;em&gt;Sound of Music&lt;/em&gt; together.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x45.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Look, if you hit your sister, she &lt;em&gt;will&lt;/em&gt; hit you back. Duh.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x46.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Obviously anyone who doesn&amp;rsquo;t program their family functionally has a dysfunctional family. But what does it mean to have a functional family? &amp;ldquo;Being hit back is a function of whether you hit your sister.&amp;rdquo; On the surface, everything appears to be free of side effects. Certainly when I tell my kids to mind their manners it often seems to have no lasting effect. Really, though, it does, but in the typical family, there&amp;rsquo;s a lot of hidden state change wound in the call stack. We first learn lazy evaluation in the family.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Don&amp;rsquo;t take the last piece of candy unless you really want it.&amp;rdquo;
&amp;ldquo;Please define whether you really care, and exactly how much you care.&amp;rdquo;
&amp;ldquo;I&amp;rsquo;m sure I care more than you do.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s almost a direct quote from Heidi when she was young: &amp;ldquo;But I want it more than you do.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x47.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Functional programming tends to merge into declarative programming in general. I married into a family where you have to declare whether you want the last piece of cheesecake, or you&amp;rsquo;re unlikely to get it.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x48.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately, I grew up in more of a culture where it was everyone&amp;rsquo;s responsibility to let someone else have the cheesecake. This algorithm did not always terminate. After several rounds of, &amp;ldquo;No, you go ahead and take it, no you take it, no you take it &amp;hellip;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;In the end, nobody was really sure who wanted the cheesecake. I guess you say it was a form of starvation. But when I married into my wife&amp;rsquo;s family I found out that I definitely wouldn&amp;rsquo;t get the cheesecake until I learned to predeclare.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x49.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s see, inheritance is obviously important, or you wouldn&amp;rsquo;t have a family in the first place. On the other hand, the family is where culture is handed down in the form of design patterns. A good model of composition is important&amp;ndash;a lot of the work of being a family consists of just trying to stay in one spot together. As a form of composition, we learn how to combine our traits constructively by playing various roles in the family. Sometimes those are fixed roles built at family composition time, and sometimes those are temporary roles that are mixed in at run time. Delegation is also important. I frequently delegate to my sons: &amp;ldquo;Lewis, take the trash out.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x50.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s Design By Contract. &amp;ldquo;Keep your promises, young man!&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x51.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Metaprogramming. &amp;ldquo;Takes one to know one!&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x52.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Aspected-oriented programming comes up when we teach our kids to evaluate their methods in the broader context of society:&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Okay kid, now that you&amp;rsquo;ve passed your driver&amp;rsquo;s test, you still have to believe the stop signs, but when the speed limit sign says 65, what it really means is that you should try to keep it under 70. Or when you&amp;rsquo;re in Los Angeles, under 80.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x53.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But I think the basic Perl paradigm is &amp;ldquo;Whatever-oriented programming.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Your kid comes to you and says, &amp;ldquo;Can I borrow the car?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;You say: &amp;ldquo;&lt;em&gt;May&lt;/em&gt; I borrow the car?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;They say: &amp;ldquo;Whatever &amp;hellip;&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x54.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Should I push the door or pull it?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x55.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x56.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x57.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x58.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Actually, &amp;ldquo;whatever&amp;rdquo; is such an important concept that we built it into Perl 6. This is read, &amp;ldquo;from one to whatever.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x59.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You might ask why we can&amp;rsquo;t just say &amp;ldquo;from one to infinity&amp;rdquo;:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x60.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The problem is that not all operators operate on numbers:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x61.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Not all operators are ranges. Here&amp;rsquo;s the sibling argument operator, which repeats the same words an arbitrary number of times:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x62.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Perl has always been about letting you care about the things you want to care about, while not caring about the things you don&amp;rsquo;t want to care about, or that maybe you&amp;rsquo;re not quite &lt;em&gt;ready&lt;/em&gt; to care about yet. That&amp;rsquo;s how Perl achieves both its accessibility and its power. We&amp;rsquo;ve just baked more of that &amp;ldquo;who cares?&amp;rdquo; philosophy into Perl 6.&lt;/p&gt;

&lt;p&gt;A couple of years ago, Tim O&amp;rsquo;Reilly asked me what great problem Perl 6 was being designed to solve. This question always just sat in my brain sideways because, apart from Perl 0, I have never thought of Perl as the solution to any one particular problem. If there&amp;rsquo;s a particular problem that Perl is trying to solve, it&amp;rsquo;s the basic fact that all programming languages suck. Sort of the concept of original sin, applied to programming languages.&lt;/p&gt;

&lt;p&gt;As parents, to the extent that we can influence the design of our kids, we design our kids to be creative, not to solve a particular problem. About as close as we get to that is to hope the kid takes over the family business, and we all know how often that sort of coercion works.&lt;/p&gt;

&lt;p&gt;No, instead, we design our kids to be ready to solve problems, by helping them learn to be creative, to be socially aware, to know how to use tools, and maybe even how to manufacture the tools for living when they&amp;rsquo;re missing. They should be prepared to do &amp;hellip; whatever.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x63.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Trouble is, it takes a long time to make an adult, on the order of 20 years. Most insects don&amp;rsquo;t take 20 years to mature.&lt;/p&gt;

&lt;p&gt;Apparently it takes you ten years to become an expert in being a kid, and then another ten years to become an expert in &lt;em&gt;not&lt;/em&gt; being a kid. Some people never manage the second part at all, or have a strange idea of adulthood. Some people think that adulthood is when you just bake all your learning into hardware and don&amp;rsquo;t learn anything new ever again, except maybe a few baseball scores. That&amp;rsquo;s an oversimplified view of reality, much like building a hardwired Lisp machine. Neoteny is good in moderation. We have to be lifelong learners to really be adults, I think.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x64.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;No, adulthood is really more about mature judgment. I think an adult is basically someone who knows when to care, and how to figure out when they should care when they don&amp;rsquo;t know offhand. A teenager is forever caring about things the parents think are unimportant, and &lt;em&gt;not&lt;/em&gt; caring about things the parents think &lt;em&gt;are&lt;/em&gt; important. Well, hopefully not forever. That&amp;rsquo;s the point. But it&amp;rsquo;s certainly a long process, with both kids and programming languages.&lt;/p&gt;

&lt;p&gt;In computer science, it is said that premature optimization is the root of all evil. The same is true in the family. In parenting terms, you pick your battlefields, and learn not to care so much about secondary objectives. If you can&amp;rsquo;t modulate what you care about, you&amp;rsquo;re not really ready to parent a teenager. Teenagers have a way of finding your hot buttons and pushing them just to distract you from the important issues. So, don&amp;rsquo;t get distracted.&lt;/p&gt;

&lt;p&gt;There are elements of the Perl community that like to push our collective hot buttons. Most of them go by the first name of Anonymous, because they don&amp;rsquo;t really want to stand up for their own opinions. The naysayers could even be right: we may certainly fail in what we&amp;rsquo;re trying to do with Perl 6, but I&amp;rsquo;d just like to point out that only those people who put their name behind their opinions are allowed to say &amp;ldquo;I told you so.&amp;rdquo; Anonymous cowards like the &amp;ldquo;told you so&amp;rdquo; part as long as it doesn&amp;rsquo;t include the &amp;ldquo;I.&amp;rdquo; Anonymous cowards don&amp;rsquo;t have an &amp;ldquo;I,&amp;rdquo; by definition.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x65.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Anyway, don&amp;rsquo;t let the teenage trolls distract you from the real issues.&lt;/p&gt;

&lt;p&gt;As parents we&amp;rsquo;re setting up some minimum expectations for civilized behavior. Perl should have good manners by default.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x66.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Perl should be wary of strangers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x67.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;But Perl should be helpful to strangers.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x68.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;While we&amp;rsquo;re working on their weaknesses, we also have to encourage our kids to develop where they have strengths, even if that makes them not like everyone else. It&amp;rsquo;s okay to be a little weird.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x69.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Every kid is different. At least, all my kids are really different. From each other, I mean. Well, and the other way too.&lt;/p&gt;

&lt;p&gt;I guess my kids are all alike in one way. None of them is biddable. They&amp;rsquo;re all arguers and will happily debate the merits of any idea presented to them whether it needs further discussion or not. They&amp;rsquo;re certainly unlikely to simply wander off to the slaughter with any stranger that suggests it.&lt;/p&gt;

&lt;p&gt;This is the natural result of letting them fight as siblings, with supervision. It&amp;rsquo;s inevitable that siblings will squabble. Your job as parent is to make sure they fight fair. It helps a lot if the parents have already learned how to fight fair. What I mean by fight fair is that you fight about what you&amp;rsquo;re fighting about&amp;ndash;you don&amp;rsquo;t fight the other person. If you find yourself dragging all sorts of old baggage into an argument, then you&amp;rsquo;re fighting the person, you&amp;rsquo;re not fighting about something anymore. Nothing makes me happier as a parent than to hear one of my kids make a logical argument at the same time as they&amp;rsquo;re completely pissed off.&lt;/p&gt;

&lt;p&gt;If you teach your kids to argue effectively, they&amp;rsquo;ll be resistant to peer pressure. You can&amp;rsquo;t be too careful here. There are a lotta computer languages out there doing drugs. As a parent, you don&amp;rsquo;t get into a barricade situation and isolate your kids from the outside world forever. Moving out and building other relationships is a natural process, but it needs some supervision.&lt;/p&gt;

&lt;p&gt;Perl is learning to care deeply about things like:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x70.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This final point is crucial, if you want to understand the state of Perl today. Perl 6 is all about reconciling the supposedly irreconcilable.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x71.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Reconciling the seemingly irreconcilable is part of why Perl 6 taking so long. We want to understand the various tensions that have surfaced as people have tried to use and extend Perl 5. In fact, just as Perl 1 was an attempt to digest Unix Culture down into something more coherent, you can view Perl 6 as an attempt to digest CPAN down into something more coherent. Here are some of the irreconcilables we run into when we do that:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x72.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OO brings us a world of choices:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x73.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Do we even have classes at all?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x74.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And if we do, how do they inherit and dispatch?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x75.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Is our type system more general than our class system?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x76.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Plus a grab bag of other issues:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x77.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;And finally, the biggie:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x78.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Reconciling these known conflicts is all well and good, but our goal as a parent must be a bit larger than that.&lt;/p&gt;

&lt;p&gt;Just as a child that leaves the house today will face unpredictable challenges tomorrow, the programming languages of the future will have to reconcile not only the conflicting ideas we know about today, but also the conflicting ideas that we haven&amp;rsquo;t even thought of yet.&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t know how to do that. Nobody knows how to do that, because nobody is smart enough. Some people pretend to be smart enough. That&amp;rsquo;s not something I care about.&lt;/p&gt;

&lt;p&gt;Nevertheless, a lot of smart people are really excited about Perl 6 because, as we go about teaching Perl how to reconcile the current crop of irreconcilables, we&amp;rsquo;re also hoping to teach Perl strategies for how to cope with future irreconcilables. It&amp;rsquo;s our vision that Perl can learn to care about what future generations will care about, and not to care about what they don&amp;rsquo;t care about.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s pretty abstruse, I&amp;rsquo;ll admit. Future-proofing your children is hard. &lt;em&gt;Some&lt;/em&gt; of us get excited by the long-term potential of our kids. But it&amp;rsquo;s also exciting when you see their day-to-day progress. And we&amp;rsquo;ve make a lot of progress recently.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x79.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In terms of Audrey&amp;rsquo;s Perl 6 timeline, we&amp;rsquo;re right at that spot where it says &amp;ldquo;hack, hack, hack.&amp;rdquo; In a year or so we&amp;rsquo;ll be up here saying, &amp;ldquo;What&amp;rsquo;s the big deal?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;This is the year that Perl 6 will finally be bootstrapped in Perl 6, one way or another. Actually, make that one way &lt;em&gt;and&lt;/em&gt; another. There are several approaches being pursued currently, in a kind of flooding algorithm. One or another of those approaches is bound to work eventually.&lt;/p&gt;

&lt;p&gt;Now, anyone who has been following along at home knows that we never, ever promise a delivery date for Perl 6. Nevertheless, I can point out that many of us hope to have most of a Perl 6 parser written in Perl 6 by &lt;em&gt;this&lt;/em&gt; Christmas. The only big question is which VM it will compile down to first. There&amp;rsquo;s a bit of a friendly race between the different implementations, but that&amp;rsquo;s healthy, since they&amp;rsquo;re all aiming to support the same language.&lt;/p&gt;

&lt;p&gt;So one of the exciting things that happened very recently is that the Pugs test suite was freed from its Haskell implementation and made available for all the other implementations to test against. There are already roughly 12,000 tests in the test suite, with more coming every day. The Haskell implementation is, of course, the furthest along in terms of passing tests, but the other approaches are already starting to pass the various basic sanity tests, and as many of you know, getting the first test to pass is already a large part of the work.&lt;/p&gt;

&lt;p&gt;So the plan is for Perl 6 to run consistently on a number of platforms. We suspect that eventually the Parrot platform is likely to be the most efficient way to run Perl 6, and may well be the best way to achieve interoperability with other dynamic languages, especially if Parrot can be embedded whole in other platforms.&lt;/p&gt;

&lt;p&gt;But the other virtual machines out there each have their own advantages. The Haskell implementation may well turn out to be the most acceptable to academia, and the best reference implementation for semantics, since Haskell is so picky. JavaScript is already ubiquitous in the browsers. There are various ideas for how to host Perl 6 on top of other VMs as well. Whatever.&lt;/p&gt;

&lt;p&gt;But the VM that works the best for Perl right now is, in fact, Perl 5. We&amp;rsquo;ve already bootstrapped much of a Perl 5 compiler for Perl 6. Here&amp;rsquo;s a picture of the approach of layering Perl 6 on Perl 5.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x80.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Here in the middle we have the Great Moose theory of history.&lt;/p&gt;

&lt;p&gt;Other stuff that&amp;rsquo;s going on:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x81.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In addition to lots of testing and documentation projects, I&amp;rsquo;m very happy that Sage La Torra is working on a P5-to-P6 translator for the Google Summer of Code. Soon we&amp;rsquo;ll be able to take Perl 5 code, translate it to Perl 6, and then translate it back to Perl 5 to see how well we did.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x82.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Another bootstrapping approach is to take our current Haskell codebase and translate to Perl 6. That could be very important long term in keeping all the various implementations in sync.&lt;/p&gt;

&lt;p&gt;There are many, many other exciting things going on all the time. Hang out on the mailing lists and on the IRC channels to find out more.&lt;/p&gt;

&lt;p&gt;If you care.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x83.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Perl is growing up, but she&amp;rsquo;s doing so in a healthy way, I think. Those of us who are parents tend to try to discourage our kids from getting married too young, because we know how much people change around their twentieth year. Around the age of 19 or 20 is when we start that last major rewiring of our brains to become adults. This year, Perl will be 19 going on 20. She&amp;rsquo;s due for a brain rewiring.&lt;/p&gt;

&lt;p&gt;In previous years, Perl was just trying to act grownup by ignoring her past. This year, I&amp;rsquo;m happy to report that instead of just trying to act grownup, Perl is going back and reintegrating her personality to include the positive aspects of childhood and adolescence. I don&amp;rsquo;t know where Perl will go in the next ten or twenty years. It&amp;rsquo;s my job to say, &amp;ldquo;I don&amp;rsquo;t care anymore,&amp;rdquo; and kick her out of the house. She&amp;rsquo;s a big girl now, and she&amp;rsquo;s becoming graceful and smart and wise, and she can just decide her future for herself.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2006_09_21_onion/x84.jpg&#34; width=&#34;500&#34; height=&#34;375&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Whatever. Thanks for listening, and for learning to care, and for learning to not care. Have a great conference! I don&amp;rsquo;t care how!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The State of the Onion 9</title>
      <link>http://localhost:1313/pub/2005/09/22/onion.html/</link>
      <pubDate>Thu, 22 Sep 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/09/22/onion.html/</guid>
      <description>&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/0title.jpg&#34; alt=&#34;figure 1&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;For the last couple of years, we&amp;rsquo;ve been homeschooling our two youngest kids. Gloria has been making sure they learn the easy subjects like history and mathematics. I&amp;rsquo;ve been making sure they also learn the hard subjects like, um, cinematography. So I&amp;rsquo;ve been making sure they view some of the great classics.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/1bond.jpg&#34; alt=&#34;figure 2&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;
&lt;em&gt;James Bond materials copyright 1962 - 2005 United Artists Corporation and Danjac, LLC&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Home schooling works best if the parents learn alongside the children, so I&amp;rsquo;ve been forced to watch the Bond corpus along with my kids.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/2bond.jpg&#34; alt=&#34;figure 3&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Or is that the Bond corpses? Seems like there are an awful lot of them.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/3bond.jpg&#34; alt=&#34;figure 4&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Anyway, it&amp;rsquo;s a large body of work.&lt;/p&gt;

&lt;p&gt;Though some of the bodies are larger than others. If you know what I mean, and I think you do.&lt;/p&gt;

&lt;p&gt;Anyway, now that I&amp;rsquo;ve been wading through the Bond corpus again, I&amp;rsquo;ve noticed something I&amp;rsquo;ve never noticed before about the show. It&amp;rsquo;s just not terribly realistic. I mean, come on, who would ever name an organization &amp;ldquo;SPECTRE?&amp;rdquo; Good names are important, especially for bad guys. A name like SPECTRE is just too obvious. SPECTRE. Boo! Whooo!! Run away.&lt;/p&gt;

&lt;p&gt;You know, if I were going to name an evil programming language, I certainly wouldn&amp;rsquo;t name it after a snake. Python! Run away, run away.&lt;/p&gt;

&lt;p&gt;When I was young I actually preferred &lt;em&gt;Man from U.N.C.L.E&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/4uncle.jpg&#34; alt=&#34;figure 5&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Now &amp;ldquo;THRUSH,&amp;rdquo; that&amp;rsquo;s is a decent name for an evil organization.&lt;/p&gt;

&lt;p&gt;Oh, and then there&amp;rsquo;s &lt;em&gt;Get Smart&lt;/em&gt;.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/5smart.jpg&#34; alt=&#34;figure 6&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Unlike James Bond, it&amp;rsquo;s highly realistic. I can believe in an evil organization with a name like &amp;ldquo;KAOS.&amp;rdquo; After we&amp;rsquo;re done with the James Bond series, I plan to show my kids &lt;em&gt;Get Smart&lt;/em&gt;. I want to make sure my kids score high on intelligence tests. Ba dump bump.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m a child of the Cold War. We didn&amp;rsquo;t go quite as far as to build a bomb shelter, but we actually thought about it before deciding our house would probably burn up anyway. Back then people thought you could win a nuclear war, or at least try real hard not to lose one. Eventually we all figured out that imperfect knowledge was a feature, and so we settled on a national policy of Fear, Uncertainty, and Doubt, though they couldn&amp;rsquo;t bring themselves to call it the FUD doctrine, so they called it MAD instead. Probably because they read too much &lt;em&gt;MAD&lt;/em&gt; magazine. Hmm, that puts a whole new twist on the &amp;ldquo;Spy vs. Spy&amp;rdquo; comics.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/6boom.jpg&#34; alt=&#34;figure 7&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Anyway, as a child of the Cold War, I know that seeing a mushroom cloud is a good thing, since it means you haven&amp;rsquo;t been vaporized just yet. Sort of the same principle that you should never be scared of thunder, since the shocking part is already over with. Or more subtly, if you live under the flight path of several airports, like me, you&amp;rsquo;re always wondering if the Blue Angels going 100 feet overhead are going to run into your house. But as soon as you hear the Doppler shift dropping in pitch, you know that they&amp;rsquo;re probably going to miss your house, because if they were on a collision course with your house, the pitch would stay the same until impact. As I said, that&amp;rsquo;s one&amp;rsquo;s subtle.&lt;/p&gt;

&lt;p&gt;Of course, you should also plan ahead. Where there&amp;rsquo;s one plane, there&amp;rsquo;s likely to be another one coming along after it. And lightning &lt;em&gt;does&lt;/em&gt; strike twice in the same place. And, if you see a mushroom cloud, I would suggest that you start replanning your short-term future. And your new future plans should probably take into account not only your future but the future plans of about a million other people who just saw the same mushroom cloud and are suddenly replanning their futures.&lt;/p&gt;

&lt;p&gt;Anyway, planning is good. Well, &lt;em&gt;some&lt;/em&gt; planning.&lt;/p&gt;

&lt;p&gt;Everyone my age and older knows that Five-Year Plans are bad for people, unless of course you&amp;rsquo;re someone like Josef Stalin, in which case they&amp;rsquo;re just bad for &lt;em&gt;other&lt;/em&gt; people. All good Americans know that good plans come in four-year increments, because they mostly involve planning to get reelected.&lt;/p&gt;

&lt;p&gt;I probably shouldn&amp;rsquo;t point this out, but we&amp;rsquo;ve been planning Perl 6 for five years now.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/7peoples.jpg&#34; alt=&#34;figure 8&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Comrades, here in the People&amp;rsquo;s Republic, the last five years have seen great progress in the science of computer programming. In the next five years, we will not starve nearly so many programmers, except for those we are starving on purpose, and those who will starve accidentally. Comrades, our new five-year mission is to boldly go where no man has gone before! Oh wait, wrong TV show.&lt;/p&gt;

&lt;p&gt;You might say that Perl grew out of the Cold War. I&amp;rsquo;ve often told the story about how Perl was invented at a secret lab that was working on a secret NSA project, so I won&amp;rsquo;t repeat that here, since it&amp;rsquo;s no secret. Some of you have heard the part about my looking for a good name for Perl, and scanning through &lt;em&gt;/usr/dict/words&lt;/em&gt; for every three- and four-letter word with positive connotations. Though offhand, I can&amp;rsquo;t explain how I missed seeing Ruby. So anyway, I ended up with &amp;ldquo;Pearl&amp;rdquo; instead.&lt;/p&gt;

&lt;p&gt;But it&amp;rsquo;s a little known fact that one of the three-letter names I considered for quite a while was the word &amp;ldquo;spy.&amp;rdquo; Now, those of you who took in Damian&amp;rsquo;s session on Presentation Aikido are now wondering whether I&amp;rsquo;m just making this up to make this speech more interesting. And in this particular case, I&amp;rsquo;m not. You can ask my brother-in-law, who was there. On the other hand, please don&amp;rsquo;t ask him to vouch for anything else in this speech.&lt;/p&gt;

&lt;p&gt;But wouldn&amp;rsquo;t &amp;ldquo;Spy&amp;rdquo; be a great name to give to a language whose purpose was pattern matching and reporting? Hmm. And spies are also called &amp;ldquo;agents of change.&amp;rdquo; &amp;ldquo;Practical extractions are one of our specialties.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Instead of a &lt;code&gt;warn&lt;/code&gt; operator, it&amp;rsquo;d have to be the &lt;code&gt;warn off&lt;/code&gt; operator. Instead of having a &lt;code&gt;die&lt;/code&gt; operator, we might have had the &lt;code&gt;let die&lt;/code&gt; operator. Then we&amp;rsquo;d get Perl poetry, I mean, Spy poetry, with phrases like &lt;code&gt;live or let die&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;How history might have been different! Those of you who are Perl programmers might instead be attending the 9th annual Spy conference. And maybe Ruby would not have been named Ruby, but instead have been named Spook, or Agent. And Python might not have been named after Monty Python, but after some other comedy troupe. It might be called Stooge, or Muppet, or something.&lt;/p&gt;

&lt;p&gt;Even if you&amp;rsquo;re not a child of the Cold War, you&amp;rsquo;ve been affected. My kids have been affected. Lately my son Aron and my daughter Geneva have been designing a game. No, not a computer game. It&amp;rsquo;s a kind of a board game involving spies and cool gadgets. It&amp;rsquo;s not done yet, so don&amp;rsquo;t pester them over when it&amp;rsquo;s going to be done. At least, don&amp;rsquo;t pester them any more than you pester me about Perl 6. Heh, heh.&lt;/p&gt;

&lt;p&gt;But as soon as I saw their cast of characters, I knew I had my theme for this year&amp;rsquo;s talk. For some reason, any time I see a really diverse set of characters, I think of the open source community in general, and the Perl community in specific.&lt;/p&gt;

&lt;p&gt;So if you&amp;rsquo;re new to the department, I&amp;rsquo;d like to introduce you to a few of the other spooks working for the organization.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/16up.jpg&#34; alt=&#34;figure 9&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;The cards for this game list various stats for each character&amp;rsquo;s strengths and weaknesses, as well as their favorite gadget. Now, as it happens, these spies all happen to be Perl programmers as well, so in this talk maybe we&amp;rsquo;ll get to see what their favorite &lt;em&gt;Perl&lt;/em&gt; gadgets are.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/ace.jpg&#34; alt=&#34;figure 10&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Ace is the quintessential spy. All the fake spies like James Bond are based on him. And like Bond, Ace is such a good spy that he doesn&amp;rsquo;t care if everyone knows he&amp;rsquo;s a spy. Ace knows he&amp;rsquo;s the hero of the story, and therefore invincible.&lt;/p&gt;

&lt;p&gt;So Ace does spying simply because it&amp;rsquo;s fun. That&amp;rsquo;s also why he does Perl programming. He knows it&amp;rsquo;s all just a big game, and it&amp;rsquo;s fun to win with the hand you are dealt. On the other hand, it&amp;rsquo;s also fun to win by changing the rules. It&amp;rsquo;s especially fun if you can win using someone else&amp;rsquo;s money.&lt;/p&gt;

&lt;p&gt;You know, when you think about it, most open source software is written using someone else&amp;rsquo;s money. Most Perl programmers are not paid directly to hack on Perl, or Pugs, or on CPAN modules. A lucky few are paid to have fun, but most of us have to make a living some other way, and our bosses kindly let us spend part of our time working on things that are mutually beneficial to the organization and to the world in general. And if we have fun doing that, they don&amp;rsquo;t seem to mind.&lt;/p&gt;

&lt;p&gt;But on the flip side, the Aces of the world all seem to know how to create fun wherever they go, or at least they know how to go places where people know how to have fun. For this reason, Ace is one of the most important people in the Perl community.&lt;/p&gt;

&lt;p&gt;This last year, we were starting to lose our sense of fun in the Perl community. Though we tried to be careful about not making promises, everyone knew in their hearts that five years is an awfully long time to wait for anything. People were getting tired and discouraged and a little bit dreary.&lt;/p&gt;

&lt;p&gt;Then Autrijus Tang showed up. Maybe we should call him &amp;ldquo;Ace&amp;rdquo; Tang. He basically said, &amp;ldquo;Look, we&amp;rsquo;ll never get this done unless we optimize for fun.&amp;rdquo; So fun is exactly what the Pugs project is optimized for. Mind you, Autrijus&amp;rsquo;s idea of fun is to learn Haskell and then write a prototype of Perl 6 in it. Now, for those of you who don&amp;rsquo;t know, Haskell is one of those pure functional languages that doesn&amp;rsquo;t allow any side effects (except, of course, when it does). Really way-out-there stuff, compared to the thinking of the average Perl programmer.&lt;/p&gt;

&lt;p&gt;Furthermore, Autrijus thinks it&amp;rsquo;s fun to persuade other functional programmers that it would fun to bootstrap Perl 6 in Haskell. These folks proudly call themselves the &amp;ldquo;lambdacamels.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;But when this happened, a few skeptical people in the Perl community thought they knew what was going to happen next. The cabal would say that this was just too crazy, and we already had Parrot, and why duplicate effort. You know, your basic turf-protection reaction.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s not what happened. Instead, the cabal said, &amp;ldquo;Yay. We can work this problem from both ends now. Let&amp;rsquo;s give Autrijus all the help we can. Parrot will work bottom-up, and Pugs will work top-down.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Did I say &amp;ldquo;work&amp;rdquo;? I meant &amp;ldquo;play.&amp;rdquo; That&amp;rsquo;s what Ace does best.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/chat.jpg&#34; alt=&#34;figure 11&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;But not everyone is an Ace. Some people are naturally sneaky. Every organization needs a second-story man, and people like The Cat prefer to have their fun in private. I strongly suspect certain Perl programmers of being retired jewel thieves. You watch the version tree, and things mysteriously disappear in one place and appear somewhere else. Like a real cat, Le Chat&amp;rsquo;s ego is not involved in any kind of public way. That&amp;rsquo;s not to say that cats don&amp;rsquo;t have egos&amp;ndash;just that they don&amp;rsquo;t care whether you notice.&lt;/p&gt;

&lt;p&gt;Cats know how to get into and out of places they&amp;rsquo;re not supposed to be able to get into and out of. Cats seem to know how to levitate, and to pass through supposedly impermeable barriers. Even the stupidest cat knows how to make you think they&amp;rsquo;re reading your mind, but it&amp;rsquo;s all a trick.&lt;/p&gt;

&lt;p&gt;In Perl culture, Cats also do sneaky things. Sneakiness is a good quality when you&amp;rsquo;re playing Perl golf, for example. Sneaky Perl programmers like to do sneaky things with overloading and with source filters. In fact, Le Chat is looking forward with glee to the day he can change the Perl 6 grammar on the fly and write yet another set of ACME modules. Oh, hi Damian&amp;ndash;didn&amp;rsquo;t see you there.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/engles.jpg&#34; alt=&#34;figure 12&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;This is Miss Engles. She&amp;rsquo;s a librarian. Like a jewel thief, she also moves things from place to place, but for very different reasons. A jewel thief moves things &lt;em&gt;from&lt;/em&gt; where they belong, while a librarian moves things &lt;em&gt;to&lt;/em&gt; where they belong. A place for everything, and everything in its place. Miss Engles likes those aspects of Perl 6 that support literate programming, and that let her index the documentation in various ways.&lt;/p&gt;

&lt;p&gt;Miss Engles has never cracked a smile because, oddly enough, not cracking a smile is what makes her happy. She is a librarian all the way to the bone. Or that&amp;rsquo;s what she&amp;rsquo;d like you to believe.&lt;/p&gt;

&lt;p&gt;But in fact, as we all know from the movies, librarians take off their glasses and let down their hair when they get off work, and become completely different people. Librarians instinctively understand paradigm shifts, having perused most of the history section in their spare time, not to mention a great deal of the psychology section. So nothing ever surprises a librarian, least of all themselves. If a librarian ever says &amp;ldquo;I&amp;rsquo;m shocked,&amp;rdquo; you know they&amp;rsquo;re being completely sarcastic.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/eric.jpg&#34; alt=&#34;figure 13&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Eric has a problem with dyslexia, so he&amp;rsquo;s never going to be a librarian. But that&amp;rsquo;s okay, since he&amp;rsquo;s not terribly interested in the things librarians are interested in. Now, since Miss Engles is officially interested in almost everything, that makes it a little tough for people like Eric, since it forces him to be interested in almost nothing. But that&amp;rsquo;s okay&amp;ndash;give him a fishing pole and a tent, and he&amp;rsquo;s happy. Oh, he wouldn&amp;rsquo;t mind a suitcase nuke, either.&lt;/p&gt;

&lt;p&gt;Perl culture is full of easy-going, straightforward people. Actually, now that I look at it, this looks like Eric O&amp;rsquo;Reilly, long-lost cousin to Tim O&amp;rsquo;Reilly. Just kidding. But Tim has always been a straight dealer, and so is Eric, in his own way. I think with Tim it&amp;rsquo;s a matter of choice, but with Eric&amp;ndash;well, that&amp;rsquo;s just the way he is.&lt;/p&gt;

&lt;p&gt;Eric is the sort of agent you send skiing over the mountain to count enemy soldiers. Pick your term: he&amp;rsquo;s a trooper, or a SEAL, or a Marine. You know he&amp;rsquo;ll almost certainly come back alive, eventually, but you don&amp;rsquo;t quite know in advance whether he&amp;rsquo;ll have to kill all the enemy soldiers in order to count them. What you do know is that if he does, he certainly won&amp;rsquo;t hold it against any of them. Nothing personal. That&amp;rsquo;s just the way it is.&lt;/p&gt;

&lt;p&gt;And when he reports in, you&amp;rsquo;ll just get the facts, without much interpretation. Eric doesn&amp;rsquo;t put many comments in his code. He thinks that if you have to comment a piece of code, you haven&amp;rsquo;t written it clearly enough. He is looking forward to working in Perl 6 because a lot of the magical cruft has been cleaned out of the language, or at least moved into places where he doesn&amp;rsquo;t have to worry about it, such as function signatures.&lt;/p&gt;

&lt;p&gt;But the thing he loves most about Perl 6 is the multimethod dispatch, precisely because those crufty signatures also allow him to say what he wants without extra words.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/jezebel.jpg&#34; alt=&#34;figure 14&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Jezebel isn&amp;rsquo;t really a bad girl. She&amp;rsquo;s just drawn that way.&lt;/p&gt;

&lt;p&gt;For all we know, this might be Miss Engles on her day off.&lt;/p&gt;

&lt;p&gt;That being said, I wouldn&amp;rsquo;t mind it if there more female programmers, especially female Perl programmers. And no, I don&amp;rsquo;t mean it like that, or my wife wouldn&amp;rsquo;t let me say it. But I think we need some spies to tell us what things in our culture appeal to women, and what don&amp;rsquo;t. And it kinda goes without saying that these spies need to be women. Well, look, the guys all have a lot of great ideas, but you know, guys tend to be rather, well, idea-oriented. In theory, Perl culture is supposed to be more cooperative than competitive, but it&amp;rsquo;s kind of hard to argue for that viewpoint when the vast majority of us are standing and pounding our chests like big gorillas. I include myself in that category. Er, the gorilla category, not the Jezebel category. Just thought I&amp;rsquo;d clear that up.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/mama.jpg&#34; alt=&#34;figure 15&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think Mama represents the older generation of Perl programmers. Mama is wise to all the stupid tricks of the young&amp;rsquo;uns, and not afraid to tell &amp;lsquo;em off for it. Mama tends to be strict, but she has good reasons for it, because she takes the long view.&lt;/p&gt;

&lt;p&gt;A lot of Mamas must hang out on PerlMonks&amp;ndash;they&amp;rsquo;re the ones who are always saying &amp;ldquo;use strict; use warnings;&amp;rdquo; or you&amp;rsquo;ll grow up to be sorry you didn&amp;rsquo;t. And wipe your feet when you come in.&lt;/p&gt;

&lt;p&gt;Mama kinda likes the fact that Perl 6 is growing up to become a strict language by default, but she isn&amp;rsquo;t quite sure what she&amp;rsquo;s gonna do after the kids are all grown up. It makes her happy and sad at the same time.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/natasha.jpg&#34; alt=&#34;figure 16&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Natasha gets to represent the next wave of international programmers, particularly those from developing countries. Natasha&amp;rsquo;s mother probably worked for a large eastern-bloc TLA, and I don&amp;rsquo;t mean IBM. But Natasha is actually doing a bit of industrial work here. All in the interests of capitalism, of course. Though &lt;em&gt;whose&lt;/em&gt; capital is perhaps a bit unclear at times.&lt;/p&gt;

&lt;p&gt;A lot of people like Natasha are trying to figure out how to make a living in the new economic realities, and one of those economic realities is that the traditional western powers are trying to vacuum up all intellectual property rights on behalf of various corporate interests. And she wonders, rightfully so, if there will ever be any place in that economy for her, and for people like her.&lt;/p&gt;

&lt;p&gt;So when our friend &amp;ldquo;Mad Dog&amp;rdquo; comes to town, and preaches the gospel that free and open source software is the only path to freedom, the only way for the rest of the world to push back&amp;ndash;well, she can see the appeal of that notion.&lt;/p&gt;

&lt;p&gt;And there are a &lt;em&gt;lot&lt;/em&gt; of Natashas in the world, and potential Natashas. Over the long haul, she may well be the most important member of this list.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/oliver.jpg&#34; alt=&#34;figure 17&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Oliver represents the next generation of programmers, who don&amp;rsquo;t even know it yet. Oliver is not ready to learn computer science. He is just starting to think about programming because he&amp;rsquo;d like to be a video game designer someday. He doesn&amp;rsquo;t know that what he likes best about Perl is that it will let him learn what he needs to know one concept at a time, without forcing him to learn a bunch of abstract concepts all at once before he really needs them. When he drives on the freeway, he drives in the slow lane.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/pixie.jpg&#34; alt=&#34;figure 18&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;On the other hand, Pixie drives in the fast lane. She is what you might call an extreme programmer.&lt;/p&gt;

&lt;p&gt;As an extreme programmer, Pixie loves testing. Preferably testing to destruction. The best defense is a good offense. She&amp;rsquo;ll get the job done, but she&amp;rsquo;s determined to have a lot of fun doing it.&lt;/p&gt;

&lt;p&gt;Pixie works well in small teams, especially with pair programming. A team of two is the perfect size for her because wherever she&amp;rsquo;s aiming, her partner can always stand on the opposite side of her.&lt;/p&gt;

&lt;p&gt;As part of a rapid response unit, Pixie is very much into rapid prototyping. So Pixie&amp;rsquo;s favorite Perl 6 feature is the &lt;code&gt;yadayadayada&lt;/code&gt; operator, which lets her stub out new functions and blow up their interfaces even before the function bodies are written.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/radcliffe.jpg&#34; alt=&#34;figure 19&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;As the quintessential English banker, Mr. Radcliffe is a firm believer in reliability, with a dash of style. For our talk today, he gets to represent the business interests surrounding open source software. Mr. Radcliffe knows that businesses have different set of goals than most open source programmers, but he also knows that there is a great deal of overlap in those goals, and that the clever businessman can exploit that overlap to the betterment of both business and programmer.&lt;/p&gt;

&lt;p&gt;You see, Mr. Radcliffe understands that one thing can have multiple functions. His umbrella is almost certainly multifunctional. Mr. Radcliffe&amp;rsquo;s favorite part of Perl 6 is that nearly every feature is multifunctional, though not completely orthogonal. That doesn&amp;rsquo;t bother Mr. Radcliffe, because nobody who rides cabs around in London expects complete orthogonality. He just expects to get where he&amp;rsquo;s going.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/router.jpg&#34; alt=&#34;figure 20&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;What can I say? Perl is also used by script kiddies. We just hope Oliver doesn&amp;rsquo;t grow up to be a script kiddie like r0u73r. Or if he does, we hope it&amp;rsquo;s just a passing phase.&lt;/p&gt;

&lt;p&gt;And in fact, r0u73r &lt;em&gt;used&lt;/em&gt; to be a script kiddie, but now uses his 1337 skills for good. To some extent, most of us were cargo culters as we learned how to program. We were reusing code, which is good, but we just didn&amp;rsquo;t always understand &lt;em&gt;why&lt;/em&gt; we were reusing the code. But the Perl community has always had a soft spot for cargo culters, and seeks to educate them until they learn the real reasons for things being the way they are. Then they&amp;rsquo;re ready to join the real cult. Er, I mean, the real culture.&lt;/p&gt;

&lt;p&gt;Anyway, as a vestige of his former ways, r0u73r looks forward to using the introspection capabilities of Perl 6, particularly when he can introspect someone &lt;em&gt;else&amp;rsquo;s&lt;/em&gt; data structures.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/tina.jpg&#34; alt=&#34;figure 21&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Tina seems like a girl who just wants to have fun, but she&amp;rsquo;s really aspiring to be Mata Hari, except for the part about getting caught and executed. As a dancer, and perhaps an actress someday, Tina understands about playing roles. She knows that the role she&amp;rsquo;s currently playing is not who she really is. In Perl 6 terms, she understands the difference between an &amp;ldquo;isa&amp;rdquo; relationship and a &amp;ldquo;does&amp;rdquo; relationship. So she&amp;rsquo;s very much into the Perl 6 concepts of roles, traits, properties, and mixins.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/wheelbarrow.jpg&#34; alt=&#34;figure 22&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Wheelbarrow is a scavenger. That is to say, he&amp;rsquo;s a sysadmin.&lt;/p&gt;

&lt;p&gt;Wheelbarrow loves to sift through the trash, which in his case consists primarily of discarded HTTP logs. Wheelbarrow loves the strong pattern-matching skills of Perl, and wonders how much better he&amp;rsquo;ll be at scavenging useful information with Perl 6 rules.&lt;/p&gt;

&lt;p&gt;As a strong believer in ecology, Wheelbarrow also loves CPAN, and hopes that Perl 6&amp;rsquo;s version of CPAN will be even better at helping him reduce, reuse, and recycle.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/wraith.jpg&#34; alt=&#34;figure 23&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Wraith has trained herself to be good at hiding. She&amp;rsquo;s particularly good at information hiding and various forms of encapsulation.&lt;/p&gt;

&lt;p&gt;Wraith also loves all the crazy new Perl 6 operators, especially the ones that will allow her to express parallel operations implicitly. She is willing to train herself in their skillful use because she values efficiency of expression. Why toss a single throwing star when you can throw eight at once?&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/wuli.jpg&#34; alt=&#34;figure 24&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Wu-Li is the old guy who is interested in Unicode, and is looking forward to Perl 6&amp;rsquo;s built-in support for efficient and ubiquitous Unicode processing. Wu-Li likes to think about the various positive and negative aspects of various strange philosophies, whether Eastern, Western, Northern, Southern, or somewhere in-between.&lt;/p&gt;

&lt;p&gt;Wu-Li isn&amp;rsquo;t actually Chinese. He only thinks he&amp;rsquo;s Chinese because when he was young his parents told him that every third child born into the world was Chinese, and he was a third child.&lt;/p&gt;

&lt;p&gt;As a foreteller of the future, Wu-Li is the only person who knows when Perl 6 is coming out, and I&amp;rsquo;m not telling. Er, he&amp;rsquo;s not telling.&lt;/p&gt;

&lt;p&gt;Wu-Li is also known for giving peculiar speeches from time to time.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/x.jpg&#34; alt=&#34;figure 25&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;And finally we come to Mr. X. I don&amp;rsquo;t know much about Mr. X, because nobody knows anything about Mr. X except Mr. X himself. We can only guess.&lt;/p&gt;

&lt;p&gt;Mr. X seems to be highly placed in his organization, because all his information is of high quality, and of strategic value. Mr. X seems to believe in clean interfaces, with no extraneous information. He&amp;rsquo;s a master of the deaddrop, and other forms of message passing. He seems to understand Perl 6&amp;rsquo;s concept of delegation, so he&amp;rsquo;s probably in management. Perhaps he&amp;rsquo;s the CIO. Or maybe he&amp;rsquo;s the CFO&amp;rsquo;s assistant. Who knows?&lt;/p&gt;

&lt;p&gt;In any event, he may be someone with some decision-making power, but he can&amp;rsquo;t afford to compromise his position by being overtly in favor of open source. At least, not yet. Nevertheless, he may be the most important player in the eventual success of open source. Mr. X is future-oriented, and as enigmatic as the future itself. We sincerely hope he turns out to be a nice person.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/16up.jpg&#34; alt=&#34;figure 26&#34; width=&#34;400&#34; height=&#34;300&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That&amp;rsquo;s our organization in a nutshell. We sincerely hope you&amp;rsquo;ll join up. Unfortunately, if you don&amp;rsquo;t join, we&amp;rsquo;ll have to liquidate you.&lt;/p&gt;

&lt;p&gt;Well, enough of that. If this were an ordinary State of the Onion speech, I would now go into my standard spiel about how diverse the open source community is and how it&amp;rsquo;s such a great thing that we can pool our various strengths and produce something greater than any of us can do alone. And if this conference were still in California, I might say it again anyway, since diversity in California is not just encouraged, it&amp;rsquo;s actually required, culturally speaking. Californians have gotten to the point of being completely intolerant of non-diversity. But we&amp;rsquo;re not in California, so let&amp;rsquo;s just assume I said all that again and go on to something else.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d like to leave you with one thought, along with all these pretty pictures.&lt;/p&gt;

&lt;p&gt;As I was thinking about the intelligence community and its recent obvious failures, it kinda put a new spin onto the phrase, &amp;ldquo;Information wants to be free,&amp;rdquo; or my own version of it, which is that &amp;ldquo;Information wants to be useful.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;We often think that intelligence failures are caused by having too little information. But often, in retrospect, we find that the problem is too much information, and that in fact, we had the data available to us, if only it had been analyzed correctly.&lt;/p&gt;

&lt;p&gt;So I&amp;rsquo;m just wondering if we&amp;rsquo;re getting ourselves into a similar situation with open source software. More software is not always better software. Google notwithstanding, I think it&amp;rsquo;s actually getting harder and harder over time to find that nugget you&amp;rsquo;re looking for. This process of re-inventing the wheel makes better wheels, but we&amp;rsquo;re running the risk of getting buried under a lot of half-built wheels.&lt;/p&gt;

&lt;p&gt;And there are two take-home lessons from that. The first is that, as an open source author, you should be quick to try to make someone else&amp;rsquo;s half-built wheel better, and slow to try to make your own. We&amp;rsquo;re making progress in this realm in the Perl community, but I don&amp;rsquo;t think any open source community ever gets good enough at harmonizing the dissimilar interests that sometimes lead to project forks. We can always improve there.&lt;/p&gt;

&lt;p&gt;The second take-home lesson is this. Pity your poor intelligence analyst back at headquarters. He&amp;rsquo;s not all that intelligent, after all. The intelligence of the intelligence community is distributed, and it&amp;rsquo;s often the Tinas and the Wheelbarrows of the world that know when they&amp;rsquo;ve got a piece of hot information. But somehow that meta-information gets lost on transmission back to headquarters.&lt;/p&gt;

&lt;p&gt;So my plea to all you agents out there today is to use your own initiative in figuring out which things to bother us with, and which things to work out for yourself. You&amp;rsquo;re smart, and the worst that can happen is that we tell you that you&amp;rsquo;ve wasted some effort. Just think of it as a kind of commit and rollback mechanism. Recent studies in multithreading show that hard locks do not scale as well as Software Transactional Memory, which is just such a commit/rollback mechanism.&lt;/p&gt;

&lt;p&gt;Look around you. We are a multithreaded organization, so the same is true socially. It&amp;rsquo;s easy to get offended or discouraged when a rollback happens, but just don&amp;rsquo;t. The whole community will function more efficiently that way.&lt;/p&gt;

&lt;p&gt;But if you get rolled back on something you know is important, just keep pushing. Those of us back at headquarters try to stay flexible and open-minded, but we don&amp;rsquo;t always succeed. So keep that good intel coming in, because good analysts can change their minds occasionally, too. At least, that&amp;rsquo;s what I think this week, and this year.&lt;/p&gt;

&lt;p&gt;This talk will self-destruct in five seconds. Thank you all for listening.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_09_22_onion/Z.gif&#34; alt=&#34;figure&#34; /&gt;&lt;/p&gt;
&lt;/blockquote&gt;
</description>
    </item>
    
    <item>
      <title>The State of the Onion</title>
      <link>http://localhost:1313/pub/2004/08/18/onion.html/</link>
      <pubDate>Thu, 19 Aug 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/08/18/onion.html/</guid>
      <description>&lt;p&gt;&lt;em&gt;Note: All comments in square brackets are X screensavers that I ran for my slides. If you want to play along at home, start up xscreensaver-demo and click on the screensaver named. By the way, for any screensaver that wants random images (such as VidWhacker), I used a directory full of strange camel pictures (some of which I processed to make even stranger, just for those of you who think the phrase &amp;ldquo;strange camel&amp;rdquo; is redundant).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;VidWhacker (camels)&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Good evening. Welcome to my eighth State of the Onion speech. I only have two more speeches to go after this, and I&amp;rsquo;ll be up to 10. You see, 10 is kind of a magical number for speeches. According to Sturgeon&amp;rsquo;s Law, 9 out of 10 speeches are crap. After we get to number 10, we&amp;rsquo;ll know which one of mine &lt;em&gt;wasn&amp;rsquo;t&lt;/em&gt; &amp;hellip; Probably number 9 or number 10 &amp;hellip;&lt;/p&gt;

&lt;p&gt;So I&amp;rsquo;m giving you fair warning that this is probably going to be a lousy speech. Those of you who attended Damian Conway&amp;rsquo;s Presentation Aikido seminar yesterday will be sure of it. You&amp;rsquo;ll probably get more out of this speech than anyone else — mostly as a kind of negative example. You can just get out Damian&amp;rsquo;s notes and start ticking off all the rules I&amp;rsquo;ve violated.&lt;/p&gt;

&lt;p&gt;Now the particular reason this speech is going to be lousy is that I made up all my slides before I knew what I was going to talk about.&lt;/p&gt;

&lt;p&gt;Well, OK, that&amp;rsquo;s not quite right. I didn&amp;rsquo;t make up my slides. I was lazy. That&amp;rsquo;s a virtue, right? And I was Impatient. Plus I had the hubris to think that it didn&amp;rsquo;t really matter what my slides say — I can probably wrap a speech around them anyway. Especially since there&amp;rsquo;s only a 10% chance that it has to be a good speech.&lt;/p&gt;

&lt;p&gt;So anyway, here&amp;rsquo;s my first real slide. It&amp;rsquo;s a picture of how Damian thinks.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Maze&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;As most of you know, Damian is very clear-headed and determined. He gets where he&amp;rsquo;s going. It doesn&amp;rsquo;t matter what the problem is, he&amp;rsquo;ll find a way to solve it eventually. He may have to backtrack occasionally, but he&amp;rsquo;s very goal-oriented, and knows how to backtrack gracefully. It&amp;rsquo;s very good that we have Damian on the Perl 6 design team, because we need someone who thinks like that.&lt;/p&gt;

&lt;p&gt;Here, on the other hand, is a picture of how well I think on Damian&amp;rsquo;s level.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;AntSpotlight (camels)&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Yes, this is the famous Ant Spotlight screensaver. And yes, that is where I got all my slides from. And no, I didn&amp;rsquo;t have a goal in mind when I picked them. Do you see any goals in this picture? Do you see any efficient search strategies? Do you see anything resembling speed here?&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s how well I think on Damian&amp;rsquo;s level. On a different level, I think like this:&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Cloudlife, fast&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;On this level, my mind is in a continual ferment. Things bubble up to the surface unbidden, and evolve in unexpected directions. Everything gets compared with everything else because the entire stew pot is bubbling like crazy. Well, maybe it&amp;rsquo;s not &lt;em&gt;like&lt;/em&gt; crazy. Maybe it &lt;em&gt;is&lt;/em&gt; crazy.&lt;/p&gt;

&lt;p&gt;One of the things that bubbled up recently was that the subject of this talk had to be screensavers. I didn&amp;rsquo;t know why. Maybe I still don&amp;rsquo;t know why. But be that as it may, that&amp;rsquo;s what this talk is about. Screensavers, and why I have to talk about them today, and why I have to talk about why I have to talk about them today. It&amp;rsquo;s a kind of recursive problem, you see.&lt;/p&gt;

&lt;p&gt;Incidentally, this screensaver is a variant of Conway&amp;rsquo;s Game of Life. No, not our Conway, the other Conway. Unless our Conway is the other Conway. Whatever, we&amp;rsquo;ll keep our Conway. After all, he&amp;rsquo;s TheDamian.&lt;/p&gt;

&lt;p&gt;Anyway, the game of Life is sort of the prototypical example of a cellular automaton. A number of screensavers are based on cellular automata. I have great empathy for all of them, because that&amp;rsquo;s how I think&amp;hellip; I think&amp;hellip;&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Critical&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;On the other hand, my mind is like a screensaver that no one can ever look at, except maybe me, and God. People can&amp;rsquo;t see the ferment in my mind. What they see externally has to be filtered through my verbal apparatus, which is actually quite limited. I often think that my verbal processor is a slow interpreter. My wife&amp;rsquo;s verbal processor is a fast compiler. Actually, those of you who know Gloria will realize that she probably does her verbal processing down in the microcode. Or maybe it&amp;rsquo;s just hardwired. She can read out loud faster than I can read silently. Or maybe it&amp;rsquo;s just that she can talk faster than I can think. Or more likely, it&amp;rsquo;s just that I think slower than she talks.&lt;/p&gt;

&lt;p&gt;Anyway, where was I? Oh, yeah. This is how other people view my thinking. I spend a certain amount of time bouncing all over the cognitive map, then I&amp;rsquo;ll perseverate in a particular area for a while, and then I&amp;rsquo;ll take a flying mental leap to something that seems to the observer to be totally unrelated. They aren&amp;rsquo;t unrelated, but they &lt;em&gt;are&lt;/em&gt; long-range links. You know — all that six degrees of separation stuff. You need the long links as well as the short ones to make your graph work that way. There, my mentioning that is another example of just that sort of mental leap. This screensaver tends to look like a random walk generated by a person with attention deficit disorder. I don&amp;rsquo;t have ADHD. I tend to perseverate and not get distracted when I &lt;em&gt;should&lt;/em&gt; get distracted. If anything, I have Asperger&amp;rsquo;s syndrome, or some kind of mild autism. My good friend Tom Christiansen, who does have ADHD, once said jokingly that I have &amp;ldquo;task-switching deficit&amp;rdquo; disorder. He&amp;rsquo;s probably right on that. Certainly I seem to be stuck on this Perl thing. I&amp;rsquo;ve been stuck there for more than 15 years now. People think I make these long mental leaps all the time, but they&amp;rsquo;re all in the scope of this one picture. In my mind, everything relates to Perl, one way or another. You&amp;rsquo;ll notice this screensaver never jumps off the screen.&lt;/p&gt;

&lt;p&gt;Another way to view this screensaver is that the long jumps are indicative of the ability to stay on task a long time. In that view, if you have attention deficit disorder, your thinking looks more like this, because you&amp;rsquo;re changing directions faster than you want to.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Wander&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;People with ADHD have many endearing qualities, spontaneity not the least of them. But it &lt;em&gt;is&lt;/em&gt; a disability, and the ADHD approach only gets you so far. More to the point, it tends to get you back where you were. Here we see a screensaver based on a random walk. It&amp;rsquo;s actually rather stultifying if you watch it long enough. It&amp;rsquo;s been shown mathematically that a random walk will eventually return to the place it started if you wait long enough.&lt;/p&gt;

&lt;p&gt;Now, just because I say a random walk is stultifying to watch, please don&amp;rsquo;t take that to mean that ADHD people are stultifying to watch. Quite the opposite, in fact. I&amp;rsquo;m just using these screensavers as talking points, as metaphors of life, but some of my metaphors limp. As we get older we realize that everyone has disabilities. That seems to be true of metaphors as well. They all limp. Except for the ones that are dead. Anyway, please don&amp;rsquo;t anyone take offense at my free associations. Even if they&amp;rsquo;re true.&lt;/p&gt;

&lt;p&gt;You know how people are sometimes rude on Usenet or on a mailing list. Sometimes they&amp;rsquo;ll write something that can only be taken as a deadly insult, and then they have the unmitigated gall to put a smiley face on it, as if that makes it all right. It doesn&amp;rsquo;t, you know. Nevertheless, if I insult you with a deadly insult in this talk, please put one of those little smileys after it. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Anyway, where was I. Oh, yes, random walks. And the fact that they&amp;rsquo;re kind of stultifying to watch.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Rorschach&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;You could throw in a little symmetry for interest. In fact, there&amp;rsquo;s already a special screensaver for that, which you can use if you want to find out if you&amp;rsquo;ve cracked&amp;hellip;&lt;/p&gt;

&lt;p&gt;Hmm&amp;hellip;&lt;/p&gt;

&lt;p&gt;Personally, Rorschach blots always look like butterflies to me. Or pelvis bones, I admit it.&lt;/p&gt;

&lt;p&gt;Or Mecha warriors. And such. You could almost swear the designers of Japanese anime must use this program to come up with new ideas for various kinds of monsters. But it&amp;rsquo;s still a random-walk program when you look at it. It&amp;rsquo;s value to psychoanalysis comes from the bilateral symmetry, which psychoanalysts think will remind us of sex, for some reason. Probably has something to do with the fact that people are bilaterally symmetrical.&lt;/p&gt;

&lt;p&gt;Pychoanalysts tend to have abstract hang-ups about sex (at least the Freudian ones do), but since we&amp;rsquo;re not psychoanalysts here, why stop at bilateral symmetry? Why stop at random walks? Why not psychoanalyze ourselves with other kinds of free associations?&lt;/p&gt;

&lt;p&gt;Which is precisely what I&amp;rsquo;m doing here. Another way of looking at this talk is that I&amp;rsquo;m psychoanalyzing myself in front of you, using all these screensavers as Rorschach blots to free associate with. Another way to look at it is that screensavers are sort of a poor man&amp;rsquo;s LSD, without the bad trips.&lt;/p&gt;

&lt;p&gt;By the way, I don&amp;rsquo;t think there are any Freudian psychologists in the audience, but if you happen to be a Freudian psychologist, and were insulted by my earlier remarks &amp;hellip; well &amp;hellip; just deal with it &amp;hellip; repress it, or something &amp;hellip;.&lt;/p&gt;

&lt;p&gt;In honor of Freudian psychology, I should in all fairness point out that I am myself the subject a classical case of repressed memory. I don&amp;rsquo;t remember anything from my fifth grade. It wasn&amp;rsquo;t anything sexual (I don&amp;rsquo;t think!), but I am told that it was one of these experimental open classrooms where you have to decide yourself what you&amp;rsquo;re going to learn. That works well for these kinds of people:&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Maze&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;One of the aspects of my Asperger personality is that I don&amp;rsquo;t initiate things like that. I have impaired executive function, in modern terminology. I almost never initiate telephone calls. I almost never initiate anything, in fact. Funny, considering Perl, but nevertheless true.&lt;/p&gt;

&lt;p&gt;The most telling example of that is when Deja first put up all the old Usenet news articles for browsing. My good friend Randal Schwartz went in and discovered that of the hundreds of articles I&amp;rsquo;d posted over the years, only one article was not a follow-up to some else&amp;rsquo;s article. I don&amp;rsquo;t initiate. I have no initiative. I guess that makes me lazy. Oh, well.&lt;/p&gt;

&lt;p&gt;Anyway, I don&amp;rsquo;t remember fifth grade at all. I did terribly that year, and completely blocked it out of my memory. I remember fourth grade and sixth grade just fine though. But then, I did well those years. It all fits. Case closed.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;DangerBall&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;But now I have this other psychological mystery I&amp;rsquo;m trying to solve. Maybe it&amp;rsquo;s just some kind of compulsion, but I &lt;em&gt;know&lt;/em&gt; deep down that I have to talk about screensavers for this speech. But why? Why, why, why, why, why? It&amp;rsquo;s irrational and illogical.&lt;/p&gt;

&lt;p&gt;So that&amp;rsquo;s what the rest of this talk is about. It all ties in with what happened to me last year, and it also all ties in with Perl.&lt;/p&gt;

&lt;p&gt;So about what happened to me last year: I had a mutation. That&amp;rsquo;s nothing new — people have mutations all the time. So do screensavers. Many screensavers, such as this one, are based simply on showing you a mutating object, moving around the screen. That&amp;rsquo;s pretty natural for screensavers. After all, the original purpose of screensavers was to save your screen, and that meant not putting the same picture up in the same place for an extended period of time. Of course, a blank screen would serve for that just as well. But, ya know, a blank screen just isn&amp;rsquo;t very interesting. So we get these various mutator objects instead.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Cubenetic&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;This one does interweaving cubes.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Engine&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a cute mutator. The little engine that could, if you will&amp;hellip;&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;FlipFlop&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;This one does flip flops. Being good at flip-flops is a prerequisite for designing computer languages. At least, I find that I have to do frequent flip-flops in the design of Perl 6. I probably shouldn&amp;rsquo;t over-generalize that to other language designers, who by and large are smarter than I am.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Gears&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a picture of Perl 5. It&amp;rsquo;s cool.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Gears (planetary)&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a picture of Perl 6. It&amp;rsquo;s just the same as Perl 5, only cooler.&lt;/p&gt;

&lt;p&gt;Planetary gears are very scalable — you can get a large increase or decrease in revolutions out of them. For that reason, planetary gears are often used in the engines of high-performance turboprop aircraft. Definitely industrial-strength stuff.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Bouboule, 3d&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;This one&amp;rsquo;s kind of ugly, but then it&amp;rsquo;s supposed to be viewed in 3D using those red/blue glasses. For some reason it reminds me of my stomach when I&amp;rsquo;m not feeling so good.&lt;/p&gt;

&lt;p&gt;Which reminds me to get back to the subject. Mutations. I had one, in my stomach. It&amp;rsquo;s a pretty well understood mutation, as these things go. It&amp;rsquo;s the sort of mutation that produces a stomach tumor.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Mirrorblob, color&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;As I stood in this exact spot a year ago, I told you that I&amp;rsquo;d been in the hospital for four days with a bleeding ulcer. What I did not know at that time was that the ulcer was on a tumor the size of my fist toward the lower end of my stomach. I did not know that I would have the lower half of my stomach removed two weeks after OSCON. I did not know that I would have complications, and complications on my complications, recursively. I did not know that I&amp;rsquo;d be spending a total of two months in the hospital.&lt;/p&gt;

&lt;p&gt;I was pretty ignorant back then.&lt;/p&gt;

&lt;p&gt;You see, when you have bleeding ulcers on your vacation in Kauai, the doctor there tells you that he saw the ulcers, but he doesn&amp;rsquo;t tell you that he saw them on a tumor. What he does tell you is to see a gastroenterologist the moment you get home. After all, he doesn&amp;rsquo;t want to ruin the rest of your vacation. Never mind that you&amp;rsquo;ve spent it in the hospital.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;SpeedMine&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;So after last year&amp;rsquo;s OSCON I go in for another gastric endoscopy. That&amp;rsquo;s where they slide a tube down your throat to look at what&amp;rsquo;s down there. This is rather unpleasant, so they use what&amp;rsquo;s called conscious sedation. They spray numbing gunk in the back of your throat, and put you partway under. You can kind of remember it afterwards, but not the bad bits.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Spotlight (camels)&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Then the doctor looks around, much like our ant spotlight we had earlier. He can&amp;rsquo;t see too much at a time, but he spots the tumor, and takes pictures of it. He can&amp;rsquo;t tell how big it is, because endoscopes are monocular, and you can&amp;rsquo;t really tell how close you are to what you&amp;rsquo;re looking at.&lt;/p&gt;

&lt;p&gt;A lot of screensavers are based on the spotlight metaphor. Here&amp;rsquo;s another:&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Bumps (camels)&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;And another.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Zoom, lenses (camels)&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;In this case, the size of the spotlight is the whole screen, like one of those useless digital zooms on your digital cameras. But it&amp;rsquo;s still just viewing one portion of the picture, whether that&amp;rsquo;s part of a camel, or part of an elephant. Or part of your stomach. My stomach, in this case.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Goop&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;At this point my gastroenterologist refers me to a surgeon. Since we don&amp;rsquo;t know how big the tumor is, I have to drink a bunch of coconut-flavored white gludge and go in for a CT scan. I don&amp;rsquo;t like coconut. I don&amp;rsquo;t like white gludge. But I do it anyway. It makes some of your body less transparent than other parts. Some screensavers are about transparency. Others are about opacity.&lt;/p&gt;

&lt;p&gt;Like the distinction between fermions and bosons, objects in screensavers have to decide whether to bounce off each other or allow overlap. And if they overlap, whether one of them hides the other or not. In this case, we see through the overlap. Many screensavers just pile things on top of each other, like this:&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Cynosure&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;I find these screensavers disturbing, because they remind me that with the passage of time, everything old gets covered over by new things. It&amp;rsquo;s a metaphor of past, present, and future.&lt;/p&gt;

&lt;p&gt;After my CT scan, the surgeon calls my wife even before I get home, and asks if I could go into surgery the very next day to have the tumor removed. She says yes. So I do. Sometimes the future is closer than you think.&lt;/p&gt;

&lt;p&gt;General anesthesia is not like sleeping. My dreams usually kind of look like this:&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Pipes&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;But general anesthesia looks like this:&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Blank&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;You have no present, just a past, and (hopefully) a future. You don&amp;rsquo;t dream — it&amp;rsquo;s just a big blank until you come out from under.&lt;/p&gt;

&lt;p&gt;Then they put you on morphine, so you won&amp;rsquo;t hurt. Instead, you itch. Did you know morphine makes you itch? Boy, does it ever. And you have really weird dreams. Dreams kind of like this:&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Bubbles, fastest, no hide&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Or this:&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Lament&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;I had really weird dreams on morphine. Didn&amp;rsquo;t like those screensavers. But a wonderful poem came to me — it started out &amp;ldquo;In Xanadu did Kubla Khan a stately pleasure dome decree.&amp;rdquo; But I can&amp;rsquo;t remember the rest of it.&lt;/p&gt;

&lt;p&gt;Just kidding. But the place I did visit in my dreams was Xanadu, and it wasn&amp;rsquo;t a very nice place to be. I prefer normal dreams.&lt;/p&gt;

&lt;p&gt;When I was awake, I thought I was choking to death because of the tube down my nose to my stomach. I wasn&amp;rsquo;t, but I thought I was. It wasn&amp;rsquo;t until I cajoled a nurse into looking down my throat with a flashlight that I was mollified. That nurse became my favorite nurse, in a Florence Nightingale sort of way. I had several other favorite nurses too, for various reasons.&lt;/p&gt;

&lt;p&gt;But then I had complications. As some of you know, twenty years ago I went blind in my right eye due to a case of shingles in my cornea. Shingles is just a recurrence of chicken pox virus.&lt;/p&gt;

&lt;p&gt;So here&amp;rsquo;s a screensaver called &amp;ldquo;NerveRot&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;NerveRot&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;I love this screensaver, in a perverse sort of way. It&amp;rsquo;s so&amp;hellip;so&amp;hellip;in your face. It&amp;rsquo;s unnatural in so many ways. It looks like a fractal, but its fractal dimensionality isn&amp;rsquo;t constant.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t love real nerverot. And shingles is a form of nerve rot, one of those things that kicks you when you&amp;rsquo;re down. And I was down. I got a shingles infection on both sides of my head, which was unusual. It took me several days to figure it out. Fortunately, they have drugs to suppress it. But instead of getting out of the hospital in five days, it took ten. The good news was that my pathology analysis results came back saying that the excised tumor looked relatively benign in all respects except for its large size.&lt;/p&gt;

&lt;p&gt;The bad news was that I was home for only twenty-four hours, and had to go back to emergency. I had never been more nauseous in my life, and to compound that, I found that even if I wanted to, I couldn&amp;rsquo;t upchuck due to spasms in my esophagus. If you&amp;rsquo;ve ever had a tube down your nose, you&amp;rsquo;ll know that you never want to have one again, but I was so miserable that I asked for one. It was a great improvement.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Compass&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;This screensaver was written to be nauseating, and I think it succeeds admirably in that. In fact, it really bugs me that I don&amp;rsquo;t know why it has two needles pointing in different directions. I had far too many needles going in various directions when I was in the hospital. I hope that other needle there isn&amp;rsquo;t the altimeter.&lt;/p&gt;

&lt;p&gt;Anyway, this reminds us that an open source project needs a leader who has a good sense of direction, who doesn&amp;rsquo;t change his mind continually about things like, say, how double-quoted strings ought to process interpolations, or which bits of the parser should work top down, and which bottom up. If you can find such a leader for Perl 6, that would definitely be an improvement over me. At least in some respects. Of course, I have the advantage of rules one and two. Rule 1: Larry is always right. Rule 2: Larry will still be right even after he changes his mind. Now I&amp;rsquo;m thinking there should also be a Rule 3, just in case. Rule 3 would say that Larry does not need to continue to be right after he&amp;rsquo;s dead.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;BSOD &amp;quot;Blue Screen of Death&amp;quot;&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;I was sure I was dying. I went back into the hospital, and stayed there for weeks. The bad news was that my surgery site had scarred up, and I couldn&amp;rsquo;t eat or drink anything. I got all my nutrients and fluids through an IV line.&lt;/p&gt;

&lt;p&gt;The good news was that if I waited long enough, it might open up again of its own accord.&lt;/p&gt;

&lt;p&gt;That bad news was that after several weeks, it didn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;The good news was that they had ways of putting tubes in to bypass the obstruction. So I had more procedures.&lt;/p&gt;

&lt;p&gt;The bad news was the procedures didn&amp;rsquo;t work.&lt;/p&gt;

&lt;p&gt;The good news was that they had a way to revise the first surgery.&lt;/p&gt;

&lt;p&gt;The bad news was that fixing the first surgery meant going through surgery all over again six weeks after my first surgery. Meanwhile, I spent a lot of time idling.&lt;/p&gt;

&lt;p&gt;I think I started developing an empathy for screensavers about that time. The poor things just have to sit there and twiddle their thumbs. I was simultaneously bored and unable to concentrate. My friends sent me books that I couldn&amp;rsquo;t read. The only thing I could concentrate on long enough was crossword puzzles. With a crossword puzzle, you can quit after a clue or two, and still make overall progress, even if your brain is crashing every few minutes. As mine was at that point.&lt;/p&gt;

&lt;p&gt;This particular screensaver fools me more often than I care to admit. The problem is that the more computers you&amp;rsquo;ve used, the more different kinds of crashes you&amp;rsquo;ve seen. And mentally, you classify them all in the &amp;ldquo;Oh, shit!&amp;rdquo; category, which is a category the brain is very efficient at processing.&lt;/p&gt;

&lt;p&gt;On the other hand, the part of your brain that says, &amp;ldquo;Hey, that&amp;rsquo;s the crash screen for a different operating system, dufus!&amp;rdquo; — that part operates at a much slower pace. This is actually a profound psychological truth. Back in the heyday of Prolog, everyone was bragging about how many LIPs they were able to process. That&amp;rsquo;s logical inferences per second. But your brain applies many different LIPs ratings depending on how urgent the problem seems to be. The brain is chock full of shortcuts, and orthogonality be screwed. Optimizers cheat, and sometimes they get caught cheating. With this screensaver, you can catch your own brain&amp;rsquo;s optimizer cheating.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Pedal&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;I got to go home for a week before my second surgery. I could even walk around my neighborhood with a portable IV pack on my back. I remember admiring some of the flowers in the neighborhood. They were a welcome sight after the hospital. But, you know, it&amp;rsquo;s really scary getting all your food and water through a tube. Especially the water. I got to be home for my birthday, but I couldn&amp;rsquo;t eat anything. Well, OK, I cheated. I ate one Popsicle, and watched it drain back out of my stomach tube. At least it tasted good.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Blank&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;My second surgery was a success. Eventually. I had to go through the same morphine rigmarole again. At least this time they put in a stomach drain tube so I didn&amp;rsquo;t have to put up with a nose tube. But I had complications again, this time with some internal bleeding. I lost enough blood that they were seriously considering giving me a transfusion. But I squeaked through, and eventually came home. This time I had a feeding tube, which was in some ways an improvement over an IV, and in other ways not. In particular, I was now housebound, because the stomach feeding pump was not as portable as the IV pump. I had to make do with fake foliage on my computer screen.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Forest&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;This screensaver makes use of an ancient technique. If you&amp;rsquo;re working in an opaque medium such as oil paint, draw the background first. Then paint the foreground over that. This may seem like cheating, but we use rules of thumb like this all the time. Every time you do lexical scoping, you&amp;rsquo;re treating the outer lexical scope like a background, and the inner lexical scope like a foreground. That&amp;rsquo;s why it&amp;rsquo;s so natural to talk about an inner variable hiding an outer variable of the same name.&lt;/p&gt;

&lt;p&gt;Can you begin to see why I have a special mental relationship with these screensavers? Maybe I&amp;rsquo;m a little bit crazy, but I can&amp;rsquo;t decide if it&amp;rsquo;s psychotic or neurotic. You know the difference, don&amp;rsquo;t you? A psychotic thinks that 2 + 2 = 5. A neurotic knows that 2 + 2 = 4, but it makes him nervous.&lt;/p&gt;

&lt;p&gt;Maybe it&amp;rsquo;s just a simple, everyday obsession.&lt;/p&gt;

&lt;p&gt;Eventually, I learned to eat again, and got off my feeding tube. I&amp;rsquo;ll never take eating for granted again. I&amp;rsquo;ll never take tubes for granted again either. Now that I&amp;rsquo;m out of the hospital, here&amp;rsquo;s what my dreams look like:&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Pipes&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Only they mean something different now.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Endgame&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;I recovered pretty rapidly, physically speaking. But it took months to really get back into gear mentally. Not until this spring did I feel like I was competent to write Apocalypse 12, the one about object-oriented Perl. All in all, I&amp;rsquo;d estimate that my little medical escapade set the Perl 6 design back six months or so. But Apocalypse 12 was the last big hurdle. With that, the design of Perl 6 can be said to be largely complete.&lt;/p&gt;

&lt;p&gt;We are now in the endgame, which is the name of this screensaver. Now that the Parrot engine is in such fine shape, it&amp;rsquo;s time to concentrate on writing a fine Perl 6 compiler to target it.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Anemone&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Open source projects start out small and grow over time. They send out tendrils in directions you don&amp;rsquo;t expect. Perl started as a text-processing language. Look, now it&amp;rsquo;s a system-administration language. And look over there, now it&amp;rsquo;s a web-programming language, too. Oh, wait, now it&amp;rsquo;s for genomics research.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll note sometimes the tendrils withdraw, like a squid&amp;rsquo;s tentacles. That&amp;rsquo;s just the natural process of deciding which things belong in the core. In squid terms, what to eat. Perl has eaten a number of things in the last 15 years. Some of them caused indigestion, but hey, that&amp;rsquo;s life.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll notice it&amp;rsquo;s cyclical. All successful open-source projects go through periods of expansion followed by periods of redesign and reintegration. It&amp;rsquo;s a natural cycle. You just have to try and not starve while you&amp;rsquo;re molting. Perl has been molting for a few years now. Or maybe it&amp;rsquo;s been more of a metamorphosis in a cocoon. Anyway, Perl 6 is going to start emerging this year. It&amp;rsquo;s going to be exciting.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Atlantis&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;You might say we&amp;rsquo;re going to have a whale of a time.&lt;/p&gt;

&lt;p&gt;The latest National Geographic has an article about squid who change their colors. Often they have reasons for changing, but sometimes I think they just change for the heck of it. A couple of years ago I was snorkeling in the Bahamas, and got to watch a school of cuttlefish swimming along. They weren&amp;rsquo;t hiding or courting or anything like that, but as they swam along they would all change color to brown, then yellow, then red, then green. It&amp;rsquo;s like, &amp;ldquo;Hey guys, wouldn&amp;rsquo;t it be cool if we all ran the same screensaver at the same time?&amp;rdquo; Sort of a cultural identity thing, I suppose.&lt;/p&gt;

&lt;p&gt;The interesting thing was that while I was watching, they forked. You know, like BSD. One group of cuttlefish went off one way, and the other group went off another. Maybe they had a personality conflict. Maybe they had a fight over licensing. I dunno. But the cool thing was that the moment they forked, they desynchronized their screensavers. This group wanted to stay green, while the other group wanted to go on and try out some purple. Who knows what goes on in the mind of a cuttlefish — it&amp;rsquo;s possible that they split specifically over the color issue. Wouldn&amp;rsquo;t be the first open-source project to split over the color of the bike shed.&lt;/p&gt;

&lt;p&gt;I predict that within 10 years, we&amp;rsquo;ll have clothing that runs screensavers, and what&amp;rsquo;s more, we&amp;rsquo;ll have gangs of people running around with synchronized displays to show that they &amp;ldquo;belong.&amp;rdquo; Schools will then outlaw gang screensavers, and impose uniform screensavers on their students. Someone will hack into your clothes processor just to get you into trouble with the teachers. Norton and McAfee will sell software to make sure your clothes keep saying what you want them to say, and not what someone else wants them to say. Or show&amp;hellip;&lt;/p&gt;

&lt;p&gt;Or maybe by then your shirt will be able to authenticate all the IPv6 addresses it communicates with. The hard part is going the other way — how are you going to authenticate your shirt to someone else? Are you going to bother to set up an unspoofable identity for every shirt in your closet?&lt;/p&gt;

&lt;p&gt;Of course, if your shirt is programmable, you really only need one of them. Or maybe you need two, for when the other one is in the wash. I suppose geeks can get away with owning a single programmable shirt. For some definition of &amp;ldquo;get away with.&amp;rdquo; Maybe it&amp;rsquo;s more like &amp;ldquo;get away &lt;em&gt;from&lt;/em&gt;,&amp;rdquo; as in &amp;ldquo;get away from me.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Molecule (sucrose)&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Anyway, that&amp;rsquo;s another talk. In fact, it&amp;rsquo;s a talk I already gave five years ago. Some of you will recognize this screensaver. It wasn&amp;rsquo;t a screensaver yet when I gave my third State of the Onion talk, but now it is. That&amp;rsquo;s progress. Cool. But watch out for those pheromones. And if you&amp;rsquo;re on a low-carb diet, don&amp;rsquo;t even think about looking at this picture of sugar.&lt;/p&gt;

&lt;p&gt;Well, enough about chemistry. I already talked about that once. If I start repeating myself, you&amp;rsquo;ll think I&amp;rsquo;m getting old. (I &lt;em&gt;am&lt;/em&gt; getting old, but I don&amp;rsquo;t want you to think it.) Anyway, you want to hear something fresh. Fresher than a geek&amp;rsquo;s T-shirt, anyway.&lt;/p&gt;

&lt;p&gt;In any event, the real geeks will probably just have the screen tattooed on their chest. Or their stomachs. Teletubbies &amp;ldquo;R&amp;rdquo; us.&lt;/p&gt;

&lt;p&gt;Anyway, back to freshness.&lt;/p&gt;

&lt;p&gt;Now, there&amp;rsquo;s two ways one can go about keeping a fresh outlook on life. One way that works, or at least works for some people, is to suddenly change course in midstream. Call it the worms approach.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Shadebobs&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;The problem with worms is that they don&amp;rsquo;t learn much from history. The only history they remember is where they just were, which is where they don&amp;rsquo;t want to be now. I&amp;rsquo;ve known some people like that.&lt;/p&gt;

&lt;p&gt;The other approach to keeping fresh it to not be quite so, um, random. In other words, learn a little more from history. You can do that either by depth or by breadth. In any case you&amp;rsquo;re keeping more history state around than just a single position.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Demon, slow&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Software projects have history, and state. Here you see various software projects feeding on the disorder around them. I&amp;rsquo;d like to think some of them are open-source projects, but doubtless some of the more aggressive ones are closed source.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Demon, fast&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Over the long term, this is also a view of how dominant species tend to wipe out their smaller competitors. This is also, unfortunately, a picture of where the business world is heading these days. At the rate we&amp;rsquo;re going, we&amp;rsquo;ll end up with just a few large corporate players because right now we have the best government big business can buy. You can see just a few little holdouts that survive in tiny ecological niches only because they&amp;rsquo;re parasitic on the large beasts.&lt;/p&gt;

&lt;p&gt;Notice also that nearly all the original information has been destroyed in the name of progress. Archeologists will have to study the leftover crumbs, as they always have. Necessarily, they will over-generalize, just as historians always over-generalize. That&amp;rsquo;s all you can do when too much has been forgotten. Of course, I&amp;rsquo;m over-generalizing about history here. But screensavers that forget things make me sad.&lt;/p&gt;

&lt;p&gt;Speaking of history, I recently got to see Tom Stoppard&amp;rsquo;s play, &lt;em&gt;Arcadia&lt;/em&gt;. I should say, I got to see it &lt;em&gt;again&lt;/em&gt;. Every time around, I get something a little different from it. It&amp;rsquo;s an iterated algorithm.&lt;/p&gt;

&lt;p&gt;For another example, take Perl. Paul Graham has opined (Hi, Paul) that there are a lot of spectacularly original ideas in Perl, but I&amp;rsquo;d like to correct that impression. There are indeed a few original ideas in Perl, but most of the ideas were stolen. Perl has learned a spectacular number of things from history. Paul was right about one thing, though — some of the things Perl learned from history were spectacularly &lt;em&gt;wrong&lt;/em&gt;. That&amp;rsquo;s not to say that some of my original ideas weren&amp;rsquo;t also spectacularly wrong. But hey, that&amp;rsquo;s what iterated algorithms are for. &amp;ldquo;Release early, release often&amp;rdquo; is the old phrase. The new catchphrase seems to be &amp;ldquo;Learning in Public.&amp;rdquo; Same sort of thing.&lt;/p&gt;

&lt;p&gt;[At this point I skipped to the final section for lack of time, but you can see the rest of my padding material here.]&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Triangle&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;This makes some pretty good-looking mountains. It cheats, of course, compared to how Mother Nature does it. This sort of algorithm doesn&amp;rsquo;t simulate plate tectonics or erosion, so you&amp;rsquo;re not going to get good mountain ranges or river valleys out of it. But our computers are still far too slow to do adequate simulation of all of physics, so we live in an era where &amp;ldquo;as good as we can do&amp;rdquo; has to be &amp;ldquo;good enough.&amp;rdquo; The brute-force approach would often take too long, so our algorithms tend to cheat all over the place. In the case of a fractal landscape like this, that can actually be a psychological advantage, insofar as the artificial landscape comes out with a slightly alien feel, which people seem to like, in moderation.&lt;/p&gt;

&lt;p&gt;The problem with exploring oversimplifications, however, is that they&amp;rsquo;re not actually as interesting as real life over the long haul. At least, not individually. Maybe there are enough oversimplifications to explore that they emulate the richness of reality merely by being sufficiently different from each other. Certainly all the books ever written don&amp;rsquo;t add up to the complexity of the universe, since obviously they&amp;rsquo;re a part of it. And yet through the power of imagination, an individual book can give us the impression of worlds beyond our own.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not sure how this relates to Perl, except to say that Perl has always been about being &amp;ldquo;good enough&amp;rdquo; rather than &amp;ldquo;perfect.&amp;rdquo; Good enough is often a lot more interesting than perfect. It&amp;rsquo;s almost as if the imperfections that keep &amp;ldquo;good enough&amp;rdquo; from being &amp;ldquo;perfect&amp;rdquo; are the very features that make things interesting, because there are a lot more ways for things to go wrong than for them to go right. Even if it&amp;rsquo;s just a little wrong. A lot of these screensavers are a little bit wrong. But they&amp;rsquo;re interestingly wrong.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Circuit&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;I wasn&amp;rsquo;t gonna show this one, but last Wednesday I was suddenly in the state that it looked like I wasn&amp;rsquo;t going to be able to show any of these screensavers. Namely, my laptop completely crapped out. It was too late to send it in for repair and have any hope of getting it back again in time. I didn&amp;rsquo;t have the money to buy a new laptop, nor the time to install Fedora Core 2 on one if I had bought one. I couldn&amp;rsquo;t guarantee that I could find a laptop to borrow that would have Fedora Core 2 on it, at least, not in time to make sure I got these screensavers all lined up in a row. Fortunately, I was pretty sure I knew what was wrong with my laptop, since the power light had been flickering when I wiggled the cord.&lt;/p&gt;

&lt;p&gt;So on Thursday I spent all day dismantling my laptop to get at the motherboard. I don&amp;rsquo;t know why they make it so you have to remove everything else before you can remove the motherboard, but that&amp;rsquo;s basically what you have to do. Then I went down to Fry&amp;rsquo;s and bought the teeny-tiniest little soldering iron they sell. I went back home, and I got that motherboard out and I soldered it with the complete expectation that I was probably ruining the motherboard completely. I put it back together again, and only had two extra screws when I was done. I still don&amp;rsquo;t know what they belong to. But it doesn&amp;rsquo;t matter. &amp;lsquo;Cause I booted that sucker up, and it worked. And that&amp;rsquo;s the laptop I&amp;rsquo;m showing you these screensavers on. How many of you have ever tried to solder your motherboard? OK, keep your hands up if the motherboard still worked afterwards. You guys know how I feel right now.&lt;/p&gt;

&lt;p&gt;Of course, the joke&amp;rsquo;s kind of on me. It broke again just before I left, and I had to resolder it again last night&amp;hellip; I have a great deal of empathy for my computer, having to undergo two surgeries like that&amp;hellip;&lt;/p&gt;

&lt;p&gt;Many screensavers are based on bouncing balls.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Pong&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Pong, a classic. The first version didn&amp;rsquo;t even use a computer.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;BouncingCow&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m waiting for the version that does a bouncing camel.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Boxed&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Multiple bouncing balls in a box are a metaphor for community. Notice how the escaping balls explode. This is what happens to people who move from Perl to Ruby.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Attraction, balls&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Attraction and repulsion. Some people find Perl attractive at a distance and repulsive up-close. Others have just the opposite reaction.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Eruption&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;With small enough balls, you start getting into particle simulations, which are good for flame-like effects. But if you look closely here, you can actually see the little balls bouncing when they hit the ground.&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;Euler2d&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;Communities are defined by their centers, and often have a fractal quality about them. The people circulating further in are more involved than the people farther out. The insiders say things like, &amp;ldquo;We need to make Perl 6 the best language for most common tasks.&amp;rdquo; The people further out do not feel absolutely bound to one community or another. They say things like, &amp;ldquo;Use whatever language is appropriate for the task at hand.&amp;rdquo; The outer people are more likely to drift from one community to another. That&amp;rsquo;s OK. In fact, it&amp;rsquo;s healthy.&lt;/p&gt;

&lt;p&gt;When it gets unhealthy is when you start drawing boundaries between communities, and you start being exclusive. Or worse, mandatorily inclusive. Then you start building things like the Berlin wall to keep people inside your community. In anthropological terms, that&amp;rsquo;s tribalism. A tribal Perl programmer might say, &amp;ldquo;If you leave the Perl tribe to go and join the Python tribe, we will hunt you down, cook you, and eat you.&amp;rdquo; Or if you join the Ruby tribe, you will explode. By and large, I am not in favor of tribalism.&lt;/p&gt;

&lt;p&gt;Except for my tribe, of course.&lt;/p&gt;

&lt;p&gt;[Here&amp;rsquo;s the ending I skipped to.]&lt;/p&gt;

&lt;p&gt;[&lt;code&gt;VidWhacker (camels)&lt;/code&gt;]&lt;/p&gt;

&lt;p&gt;I could go on and on. There are over 200 screensavers that come with X windows these days. We haven&amp;rsquo;t begun to talk about some of the fancier ones that you can download that do useful work, like searching for extraterrestrial intelligence, or finding new cancer drugs. But the ones I&amp;rsquo;ve talked about today are the once I notice in my kitchen when I walk past my Linux box. I notice them, and I think about them, and I think about what they mean. So I hope you&amp;rsquo;re starting to get an appreciation for them.&lt;/p&gt;

&lt;p&gt;But I don&amp;rsquo;t think I&amp;rsquo;ve really adequately conveyed yet why I wanted to show you these screensavers. Last night, when I tried to explain all this to my family, I suddenly found myself getting rather teary-eyed about it all. It&amp;rsquo;s not so much the fact that the individual screensavers are so interesting. It&amp;rsquo;s really about how they relate to each other, and to the world.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s been a lot of talk lately about 100-year languages and the like, and while it&amp;rsquo;s fun to speculate on the nature of such long-term enterprises, the history of futurology warns us that the only sure prediction is that all predictions are sure to be inaccurate. The things that are relatively predictable are not fashionable. They&amp;rsquo;re small, but universal. Like screensavers. I predict we&amp;rsquo;ll have screensavers in a 100 years, even if we don&amp;rsquo;t have screens any more, and all our brains take their inputs via neural implants. And those future screensavers will relate to each other just the same way as our screensavers, even if they are different screensavers.&lt;/p&gt;

&lt;p&gt;Think about this little program called &lt;code&gt;xscreensaver-demo&lt;/code&gt; that I&amp;rsquo;ve been using to show you these screensavers. Within this program, all screensavers are considered equal. It&amp;rsquo;s like in a hospital where all the nurses on your floor are considered to be more or less interchangeable. And indeed, they purposefully mix things around so you get different nurses each day. But when they do that, you discover that, in fact, all the nurses are different. All the doctors are different. And they&amp;rsquo;re all wonderful in their own way. Likewise, every screensaver is different, and you can relate to them in different ways.&lt;/p&gt;

&lt;p&gt;They are so equal, yet so unequal at the same time. And last night I realized that this was what was important about Perl, and about the Perl community. Not a fancy grammar, or fast engine, or clever optimizer. Those things are all nice, but the heart of Perl the language is all those modules that fit into Perl like interchangeable screensavers, and yet are all so different from each other. And the people who write those modules, and grammars, and engines — they&amp;rsquo;re all equal in the eyes of the Perl community, and yet all so different.&lt;/p&gt;

&lt;p&gt;So it was really only last night that I figured out why I had to talk about screensavers tonight. And that reason is you. You&amp;rsquo;re my little flock of screensavers. You&amp;rsquo;re my nurses and my doctors and my patients. You&amp;rsquo;ve performed multiple surgeries on my soul, and let me perform surgeries on your souls. We&amp;rsquo;re a hospital of people helping each other, performing random acts of beauty for each other, even when no one is watching but God.&lt;/p&gt;

&lt;p&gt;These days I may be missing the bottom of my stomach, but I still have the bottom of my heart. So I would like to thank you from the bottom of my heart for being precisely who you are.&lt;/p&gt;

&lt;p&gt;Thank you. Thank you. Thank you.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apocalypse 12</title>
      <link>http://localhost:1313/pub/2004/04/16/a12.html/</link>
      <pubDate>Fri, 16 Apr 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/04/16/a12.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#some_of_the_problems_with_perl_5_oo&#34;&gt;Some of the Problems with Perl 5 OO&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#a_little_too_orthogonal&#34;&gt;A little too orthogonal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#not_quite_orthogonal_enough&#34;&gt;Not quite orthogonal enough&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#forced_nonencapsulation&#34;&gt;Forced non-encapsulation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#a_little_too_minimal&#34;&gt;A little too minimal&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#too_much_keyword_reuse&#34;&gt;Too much keyword reuse&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#too_difficult_to_capture_metadata&#34;&gt;Too difficult to capture metadata&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#insideout_interfaces&#34;&gt;Inside-out interfaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#not_enough_convention&#34;&gt;Not enough convention&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#wrong_conventions&#34;&gt;Wrong conventions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#everything_possible,_but_difficult&#34;&gt;Everything possible, but difficult&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#perl_5_nonproblems&#34;&gt;Perl 5 Non-Problems&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#generating_class_by_running_code_at_compile_time&#34;&gt;Generating class by running code at compile time&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#there_are_many_roads_to_polymorphism&#34;&gt;There are many roads to polymorphism&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#people_using_a_class_shouldn&#39;t_have_to_think_hard&#34;&gt;People using a class shouldn&amp;rsquo;t have to think hard&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#trust_in_convention,_but_keep_your_powder_dry&#34;&gt;Trust in Convention, But Keep Your Powder Dry&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=2#an_easy_example&#34;&gt;An Easy Example&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=3#classes&#34;&gt;Classes&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=3#declaration_of_classes&#34;&gt;Declaration of classes&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=3#class_traits&#34;&gt;Class traits&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=3#use_of_classes&#34;&gt;Use of classes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=3#class_name_semantics&#34;&gt;Class name semantics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=4#private_classes&#34;&gt;Private classes&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=4#methods&#34;&gt;Methods&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=4#declaration_of_methods&#34;&gt;Declaration of methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=4#use_of_methods&#34;&gt;Use of methods&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=4#the_dot_notation&#34;&gt;The dot notation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=5#the_indirect_object_notation&#34;&gt;The &amp;ldquo;indirect object&amp;rdquo; notation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=5#calling_private_methods&#34;&gt;Calling private methods&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=5#class_methods&#34;&gt;Class Methods&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=5#class_invocant&#34;&gt;Class invocant&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=5#class%7Cobject_invocant&#34;&gt;Class|object invocant&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=5#submethods&#34;&gt;Submethods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=6#attributes&#34;&gt;Attributes&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=6#declaration_of_attributes&#34;&gt;Declaration of attributes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=6#use_of_attributes&#34;&gt;Use of attributes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=6#default_values&#34;&gt;Default values&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=7#class_attributes&#34;&gt;Class Attributes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=7#object_construction&#34;&gt;Object Construction&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=7#the_default_constructor&#34;&gt;The default constructor&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=7#the_default_cloner&#34;&gt;The default cloner&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=7#create&#34;&gt;CREATE&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=7#buildall&#34;&gt;BUILDALL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=7#build&#34;&gt;BUILD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=8#eliminating_redundancy_in_constructor_calls&#34;&gt;Eliminating redundancy in constructor calls&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=8#object_deconstruction&#34;&gt;Object Deconstruction&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=8#destroyall&#34;&gt;DESTROYALL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=8#destroy&#34;&gt;DESTROY&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=8#dispatch_mechanisms&#34;&gt;Dispatch Mechanisms&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=8#single_dispatch&#34;&gt;Single dispatch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=8#calling_superclasses,_and_notsosuperclasses&#34;&gt;Calling superclasses, and not-so-superclasses&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=9#parallel_dispatch&#34;&gt;Parallel dispatch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=9#walkclass_and_walkmeth_caching&#34;&gt;WALKCLASS and WALKMETH caching&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=9#multiple_dispatch&#34;&gt;Multiple Dispatch&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=9#declaration_of_multiple_dispatch_routines&#34;&gt;Declaration of multiple dispatch routines&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=9#multi_sub&#34;&gt;multi sub&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=9#multi_sub_*_(tradition_multimethods)&#34;&gt;multi sub * (tradition multimethods)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=9#multi_method&#34;&gt;multi method&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=9#multi_submethod&#34;&gt;multi submethod&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=9#multi_rule&#34;&gt;multi rule&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=9#multi_submethod_build&#34;&gt;multi submethod BUILD&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=9#multi_method_constructors&#34;&gt;multi method constructors&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=10#calling_via_multiple_dispatch&#34;&gt;Calling via multiple dispatch&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=10#multiple_dispatch_semantics&#34;&gt;Multiple dispatch semantics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=10#single_dispatch_semantics&#34;&gt;Single dispatch semantics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=10#indirect_objects&#34;&gt;Indirect objects&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=10#meaning_of_next_method&#34;&gt;Meaning of &amp;ldquo;next METHOD&amp;rdquo;&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=10#making_fiends,_er,_friends.&#34;&gt;Making fiends, er, friends&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=11#overloading&#34;&gt;Overloading&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=11#binary_ops&#34;&gt;Binary ops&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=11#class_composition_with_roles&#34;&gt;Class Composition with Roles&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=12#declaration_of_roles&#34;&gt;Declaration of roles&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=12#parametric_types&#34;&gt;Parametric types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=12#interfaces&#34;&gt;Interfaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=12#private_interfaces&#34;&gt;Private interfaces&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=12#encapsulated_attributes&#34;&gt;Encapsulated attributes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=12#encapsulated_private_attributes&#34;&gt;Encapsulated private attributes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=12#encapsulated_delegation&#34;&gt;Encapsulated delegation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=12#encapsulated_inheritance&#34;&gt;Encapsulated inheritance&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=12#use_of_roles_at_compile_time&#34;&gt;Use of roles at compile time&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=12#conflict_resolution&#34;&gt;Conflict resolution&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=13#use_of_roles_at_run_time_(mixins)&#34;&gt;Use of roles at runtime (mixins)&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=13#traits&#34;&gt;Traits&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=14#delegation&#34;&gt;Delegation&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=14#wildcard_delegation&#34;&gt;Wildcard delegation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=14#renaming_delegated_methods&#34;&gt;Renaming delegated methods&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=14#delegation_without_an_attribute&#34;&gt;Delegation without an attribute&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=14#delegation_of_handlers&#34;&gt;Delegation of handlers&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=14#hashbased_redispatch&#34;&gt;Hash-based redispatch&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=15#relationship_to_roles&#34;&gt;Relationship to roles&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=15#anonymous_delegation_for_isa_emulation&#34;&gt;Anonymous delegation for ISA emulation&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=15#types_and_subtypes&#34;&gt;Types and Subtypes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=15#enums&#34;&gt;Enums&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=16#open_vs_closed_classes&#34;&gt;Open vs. Closed Classes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=16#interface_consistency&#34;&gt;Interface Consistency&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=17#collections_of_classes&#34;&gt;Collections of Classes&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=17#in_classes&#34;&gt;In classes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=17#in_modules&#34;&gt;In modules&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=17#versioning&#34;&gt;Versioning&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=17#version_declarations&#34;&gt;Version declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=18#use_of_version_and_author_wildcards&#34;&gt;Use of version and author wildcards&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=18#introspection&#34;&gt;Introspection&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=19#other_nonoo_decisions&#34;&gt;Other Non-OO Decisions&lt;/a&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=19#exportation&#34;&gt;Exportation&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=19#the_gather/take_construct&#34;&gt;The gather/take construct&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=19#:foo()_adverbs&#34;&gt;&lt;code&gt;:foo()&lt;/code&gt; adverbs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=19#special_quoting_of_identifiers_inside_curlies_going_away!&#34;&gt;Special quoting of identifiers inside curlies going away&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=19#vector_operators_renamed_back_to_hyper_operators&#34;&gt;Vector operators renamed back to &amp;ldquo;hyper&amp;rdquo; operators&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=19#unary_hyper_operators_now_use_one_quote_rather_than_two&#34;&gt;Unary hyper operators now use one quote rather than two&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=19#$thumb.twiddle_no_longer_requires_parens_when_interpolated&#34;&gt;&lt;code&gt;$thumb.twiddle&lt;/code&gt; no longer requires parens when interpolated&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=19#the_=:=_identity_operator&#34;&gt;The =:= identity operator&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=19#new_grammatical_categories&#34;&gt;New grammatical categories&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=20#assignment_to_state_variable_declaration_now_does_first_semantics.&#34;&gt;Assignment to &lt;code&gt;state&lt;/code&gt; variable declaration now does &amp;ldquo;first&amp;rdquo; semantics&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=20#the_length()_function_is_gone&#34;&gt;The &lt;code&gt;length()&lt;/code&gt; function is gone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=20#string_positions&#34;&gt;String positions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=20#the_new_&amp;amp;_separator_in_regexen&#34;&gt;The new &amp;ldquo;&amp;amp;&amp;rdquo; separator in Regexen&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=20#optional_mandatory_crossdisciplinary_joke_for_people_tired_of_dogs&#34;&gt;Optional Mandatory Cross-Disciplinary Joke for People Tired of Dogs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=20#future_directions&#34;&gt;Future Directions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2004/04/16/a12.html?page=20#references...er,_reference...&#34;&gt;References&amp;hellip;er, Reference&amp;hellip;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The official, unofficial slogan of Perl 6 is &amp;ldquo;Second System Syndrome Done Right!&amp;rdquo;. After you read this Apocalypse you will at least be certain that we got the &amp;ldquo;Second System&amp;rdquo; part down pat. But we&amp;rsquo;ve also put in a little bit of work on the &amp;ldquo;Done Right&amp;rdquo; part, which we hope you&amp;rsquo;ll recognize. The management of complexity is complex, but only if you think about it. The goal of Perl 6 is to discourage you from thinking about it unnecessarily.&lt;/p&gt;

&lt;p&gt;Speaking of thinking unnecessarily, please don&amp;rsquo;t think that everything we write here is absolutely true. We expect some things to change as people point out various difficulties. That&amp;rsquo;s the way all the other Apocalypses have worked, so why should this one be different?&lt;/p&gt;

&lt;p&gt;When I say &amp;ldquo;we&amp;rdquo;, I don&amp;rsquo;t just mean &amp;ldquo;me&amp;rdquo;. I mean everyone who has participated in the design, including the Perl 6 cabal, er, design team, the readers (and writers) of the perl6-language mailing list, and all the participants who wrote or commented on the original RFCs. For this Apocalypse we&amp;rsquo;ve directly considered the following RFCs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RFC  PSA  Title
    ===  ===  =====
    032  abb  A Method of Allowing Foreign Objects in Perl
    067  abb  Deep Copying, a.k.a., Cloning Around
    092  abb  Extensible Meta-Object Protocol
    095  acc  Object Classes
    101  bcc  Apache-Like Event and Dispatch Handlers
    126  aaa  Ensuring Perl&#39;s Object-Oriented Future
    137  bdd  Overview: Perl OO Should &amp;lt;Not&amp;gt; Be Fundamentally Changed
    147  rr   Split Scalars and Objects/References into Two Types
    152  bdd  Replace Invocant in @_ with self() builtin
    163  bdd  Objects: Autoaccessors for Object Data Structures
    171  rr   My Dog $spot Should Call a Constructor Implicitly
    174  bdd  Improved Parsing and Flexibility of Indirect Object Syntax
    187  abb  Objects : Mandatory and Enhanced Second Argument to C&amp;lt;bless&amp;gt;
    188  acc  Objects : Private Keys and Methods
    189  abb  Objects : Hierarchical Calls to Initializers and Destructors
    190  acc  Objects : NEXT Pseudoclass for Method Redispatch
    193  acc  Objects : Core Support for Method Delegation
    223  bdd  Objects: C&amp;lt;use invocant&amp;gt; Pragma
    224  bdd  Objects : Rationalizing C&amp;lt;ref&amp;gt;, C&amp;lt;attribute::reftype&amp;gt;, and
                C&amp;lt;builtin:blessed&amp;gt;
    244  cdr  Method Calls Should Not Suffer from the Action on a Distance
    254  abb  Class Collections: Provide the Ability to Overload Classes
    256  abb  Objects : Native Support for Multimethods
    265  abc  Interface Polymorphism Considered Lovely
    277  bbb  Method Calls Should Suffer from Ambiguity by Default
    307  rr   PRAYER: What Gets Said When You C&amp;lt;bless&amp;gt; Something
    335  acc  Class Methods Introspection: What Methods Does this Object
                Support?
    336  bbb  Use Strict &#39;objects&#39;: A New Pragma for Using Java-Like
                Objects in Perl
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These RFCs contain many interesting ideas, and many more &amp;ldquo;cries for help&amp;rdquo;. Usually in these Apocalypses, I discuss the design with respect to each of the RFCs. However, in this case I won&amp;rsquo;t, because most of these RFCs fail in exactly the same way&amp;ndash;they assume the Perl 6 object model to be a set of extensions to the Perl 5 object model. But as it turns out, that would have been a great way to end up with Second System Syndrome Done Wrong. Perl 5&amp;rsquo;s OO system is a great workbench, but it has some issues that have to be dealt with systematically rather than piecemeal.&lt;/p&gt;

&lt;h4 id=&#34;span-id-some-of-the-problems-with-perl-5-oo-some-of-the-problems-with-perl-5-oo-span&#34;&gt;&lt;span id=&#34;some_of_the_problems_with_perl_5_oo&#34;&gt;Some of the Problems with Perl 5 OO&lt;/span&gt;&lt;/h4&gt;

&lt;h5 id=&#34;span-id-a-little-too-orthogonal-a-little-too-orthogonal-span&#34;&gt;&lt;span id=&#34;a_little_too_orthogonal&#34;&gt;A little too orthogonal&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;It has often been claimed that Perl 5 OO was &amp;ldquo;bolted on&amp;rdquo;, but that&amp;rsquo;s inaccurate. It was &amp;ldquo;bolted through&amp;rdquo;, at right angles to all other reference types, such that any reference could be blessed into being an object. That&amp;rsquo;s way cool, but it&amp;rsquo;s often a little &lt;em&gt;too&lt;/em&gt; cool.&lt;/p&gt;

&lt;h5 id=&#34;span-id-not-quite-orthogonal-enough-not-quite-orthogonal-enough-span&#34;&gt;&lt;span id=&#34;not_quite_orthogonal_enough&#34;&gt;Not quite orthogonal enough&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;It&amp;rsquo;s too hard to treat built-in types as objects when you want to. Perl 5&amp;rsquo;s &lt;code&gt;tie&lt;/code&gt; interface helps, but is suboptimal in several ways, not the least of which is that it only works on variables, not values.&lt;/p&gt;

&lt;h5 id=&#34;span-id-forced-nonencapsulation-forced-non-encapsulation-span&#34;&gt;&lt;span id=&#34;forced_nonencapsulation&#34;&gt;Forced non-encapsulation&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;Because of the ability to turn (almost) anything into an object, a derived class had to be aware of the internal data type of its base class. Even after convention settled on hashes as the appropriate default data structure, one had to be careful not to stomp on the attributes of one&amp;rsquo;s base class.&lt;/p&gt;

&lt;h5 id=&#34;span-id-a-little-too-minimal-a-little-too-minimal-span&#34;&gt;&lt;span id=&#34;a_little_too_minimal&#34;&gt;A little too minimal&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;Some people will be surprised to hear it, but Perl is a minimalist language at heart. It&amp;rsquo;s just minimalistic about weird things compared to your average language. Just as the binding of parameters to &lt;code&gt;@_&lt;/code&gt; was a minimalistic approach, so too the entire Perl 5 object system was an attempt to see how far you could drive a few features. But many of the following difficulties stem from that.&lt;/p&gt;

&lt;h5 id=&#34;span-id-too-much-keyword-reuse-too-much-keyword-reuse-span&#34;&gt;&lt;span id=&#34;too_much_keyword_reuse&#34;&gt;Too much keyword reuse&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;In Perl 5, a class is just a package, a method is just a subroutine, and an object is just a blessed referent. That&amp;rsquo;s all well and good, and it is still fundamentally true in Perl 6. However, Perl 5 made the mistake of reusing the same keywords to express similar ideas. That&amp;rsquo;s not how natural languages work&amp;ndash;we often use different words to express similar ideas, the better to make subtle distinctions.&lt;/p&gt;

&lt;h5 id=&#34;span-id-too-difficult-to-capture-metadata-too-difficult-to-capture-metadata-span&#34;&gt;&lt;span id=&#34;too_difficult_to_capture_metadata&#34;&gt;Too difficult to capture metadata&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;Because Perl 5 reused keywords and treated parameter binding as something you do via a list assignment at runtime, it was next to impossible for the compiler to tell which subroutines were methods and which ones were really just subroutines. Because hashes are mutable, it was difficult to tell at compile time what the attribute names were going to be.&lt;/p&gt;

&lt;h5 id=&#34;span-id-insideout-interfaces-inside-out-interfaces-span&#34;&gt;&lt;span id=&#34;insideout_interfaces&#34;&gt;Inside-out interfaces&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;The Perl 5 solution to the previous problem was to declare more things at compile time. Unfortunately, since the main way to do things at compile time was to invoke &lt;code&gt;use&lt;/code&gt;, all the compile-time interfaces were shoehorned into &lt;code&gt;use&lt;/code&gt;&amp;rsquo;s syntax, which, powerful though it may be, is often completely inside-out from a reasonable interface. For instance, overloading is done by passing a list of pairs to &lt;code&gt;use&lt;/code&gt;, when it would be much more natural to simply declare appropriate methods with appropriate names and traits. The &lt;code&gt;base&lt;/code&gt; and &lt;code&gt;fields&lt;/code&gt; pragmas are also kludges.&lt;/p&gt;

&lt;h5 id=&#34;span-id-not-enough-convention-not-enough-convention-span&#34;&gt;&lt;span id=&#34;not_enough_convention&#34;&gt;Not enough convention&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;Because of the flexibility of the Perl 5 approach, there was never any &amp;ldquo;obvious&amp;rdquo; way to do it. So best practices had to be developed by each group, and of course, everyone came up with a slightly different solution. Now, we&amp;rsquo;re not going to be like some folks and confuse &amp;ldquo;obvious&amp;rdquo; with &amp;ldquo;the only way to do it&amp;rdquo;. This is still Perl, after all, and the flexibility will still be there if you need it. But by convention, there needs to be a standard look to objects and classes so that they can interoperate. There&amp;rsquo;s more than one way to do it, but one of those is the standard way.&lt;/p&gt;

&lt;h5 id=&#34;span-id-wrong-conventions-wrong-conventions-span&#34;&gt;&lt;span id=&#34;wrong_conventions&#34;&gt;Wrong conventions&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;The use of arrow where most of the rest of the world uses dot was confusing.&lt;/p&gt;

&lt;h5 id=&#34;span-id-everything-possible-but-difficult-everything-possible-but-difficult-span&#34;&gt;&lt;span id=&#34;everything_possible,_but_difficult&#34;&gt;Everything possible, but difficult&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;The upshot of the previous problems was that, while Perl 5 made it easy to &lt;em&gt;use&lt;/em&gt; objects and classes, it was difficult to try to define classes or derive from them.&lt;/p&gt;

&lt;h4 id=&#34;span-id-perl-5-nonproblems-perl-5-non-problems-span&#34;&gt;&lt;span id=&#34;perl_5_nonproblems&#34;&gt;Perl 5 Non-Problems&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;While there are plenty of problems with Perl 5&amp;rsquo;s OO system, there are some things it did right.&lt;/p&gt;

&lt;h5 id=&#34;span-id-generating-class-by-running-code-at-compile-time-generating-class-by-running-code-at-compile-time-span&#34;&gt;&lt;span id=&#34;generating_class_by_running_code_at_compile_time&#34;&gt;Generating class by running code at compile time&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;One of the big advances in Perl 5 was that a program could be in charge of its own compilation via &lt;code&gt;use&lt;/code&gt; statements and &lt;code&gt;BEGIN&lt;/code&gt; blocks. A Perl program isn&amp;rsquo;t a passive thing that a compiler has its way with, willy-nilly. It&amp;rsquo;s an active thing that negotiates with the compiler for a set of semantics. In Perl 6 we&amp;rsquo;re not shying away from that, but taking it further, and at the same time hiding it in a more declarative style. So you need to be aware that, although many of the things we&amp;rsquo;ll be talking about here &lt;em&gt;look&lt;/em&gt; like declarations, they trigger Perl code that runs during compilation. Of such methods are metaclasses made. (While these methods are often triggered by grammar rule reductions, remember from Apocalypse 5 that all these grammar rules are also running under the user&amp;rsquo;s control. You can tweak the language without the crude ax of source filtering.)&lt;/p&gt;

&lt;h5 id=&#34;span-id-there-are-many-roads-to-polymorphism-there-are-many-roads-to-polymorphism-span&#34;&gt;&lt;span id=&#34;there_are_many_roads_to_polymorphism&#34;&gt;There are many roads to polymorphism&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;In looking for an &amp;ldquo;obvious&amp;rdquo; way to conventionalize Perl&amp;rsquo;s object system, we shouldn&amp;rsquo;t overlook the fact that there&amp;rsquo;s more than one obvious way, and different approaches work better in different circumstances. Inheritance is one way (and typically the most overused), but we also need good support for composition, delegation, and parametric types. Cutting across those techniques are issues of interface, implementation, and mixtures of interface and implementation. There are multiple strategies for ambiguity resolution as well, and no single strategy is always right. (Unless the boss says so.)&lt;/p&gt;

&lt;h5 id=&#34;span-id-people-using-a-class-shouldn-t-have-to-think-hard-people-using-a-class-shouldn-t-have-to-think-hard-span&#34;&gt;&lt;span id=&#34;people_using_a_class_shouldn&#39;t_have_to_think_hard&#34;&gt;People using a class shouldn&amp;rsquo;t have to think hard&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;In making it easier to define and derive classes, we must be careful not to make it harder to &lt;em&gt;use&lt;/em&gt; classes.&lt;/p&gt;

&lt;h4 id=&#34;span-id-trust-in-convention-but-keep-your-powder-dry-trust-in-convention-but-keep-your-powder-dry-span&#34;&gt;&lt;span id=&#34;trust_in_convention,_but_keep_your_powder_dry&#34;&gt;Trust in Convention, But Keep Your Powder Dry&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;So to summarize this summary, what we&amp;rsquo;re proposing to develop is a set of conventions for how object orientation ought to work in Perl 6&amp;ndash;by default. But there should also be enough hooks to customize things to your heart&amp;rsquo;s content, hopefully without undue impact on the sensibilities of others.&lt;/p&gt;

&lt;p&gt;And in particular, there&amp;rsquo;s enough flexibility in the new approach that, if you want to, you can still program in a way much like the old Perl 5 approach. There&amp;rsquo;s still a &lt;code&gt;bless&lt;/code&gt; method, and you can still pretend that an object is a hash&amp;ndash;though it isn&amp;rsquo;t anymore.&lt;/p&gt;

&lt;p&gt;However, as with all the rest of the design of Perl 6, the overriding concern has been that the language scale well. That means Perl has to scale down as well as up. Perl has to work well both as a first language and as a last language. We believe our design fulfills this goal&amp;ndash;though, of course, only time will tell.&lt;/p&gt;

&lt;p&gt;One other note: if you haven&amp;rsquo;t read the previous Apocalypses and Exegeses, a lot of this is going to be complete gobbledygook to you. (Of course, even if you &lt;em&gt;have&lt;/em&gt; read them, this might still be gobbledygook. You take your chances in life&amp;hellip;)&lt;/p&gt;

&lt;h3 id=&#34;span-id-an-easy-example-an-easy-example-span&#34;&gt;&lt;span id=&#34;an_easy_example&#34;&gt;An Easy Example&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Before we start talking about all the hard things that should be possible, let&amp;rsquo;s look at an example of some of the easy things that should be easy. Suppose we define a Point object that (for some strange reason) allows you to adjust the y-axis but not the x-axis.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Point {
        has $.x;
        has $.y is rw;

        method clear () { $.x = 0; $.y = 0; }
    }

    my $point = Point.new(x =&amp;gt; 2, y =&amp;gt; 3);

    $a = $point.y;      # okay
    $point.y = 42;      # okay

    $b = $point.x;      # okay
    $point.x = -1;      # illegal, default is read-only

    $point.clear;       # reset to 0,0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you compare that to how it would have to be written in Perl 5, you&amp;rsquo;ll note a number of differences:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;It uses the keywords &lt;code&gt;class&lt;/code&gt; and &lt;code&gt;method&lt;/code&gt; rather than &lt;code&gt;package&lt;/code&gt; and &lt;code&gt;sub&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;The attributes are named in explicit declarations rather than implicit hash keys.&lt;/li&gt;
&lt;li&gt;It is impossible to confuse the attribute variables with ordinary variables because of the extra dot (which also associates the attributes visually with method calls).&lt;/li&gt;
&lt;li&gt;Perhaps most importantly, we did not have to commit to using a hash (or any other external data structure) for the object&amp;rsquo;s values.&lt;/li&gt;
&lt;li&gt;We didn&amp;rsquo;t have to write a constructor.&lt;/li&gt;
&lt;li&gt;The implicit constructor automatically knows how to map named arguments to the attribute names.&lt;/li&gt;
&lt;li&gt;We didn&amp;rsquo;t have to write the accessor methods.&lt;/li&gt;
&lt;li&gt;The accessors are by default read-only outside the class, and you can&amp;rsquo;t get at the attributes from outside the class without an accessor. (Inside the class you can use the attributes directly.)&lt;/li&gt;
&lt;li&gt;The invocant of the &lt;code&gt;clear&lt;/code&gt; method is implicit.&lt;/li&gt;
&lt;li&gt;And perhaps most obviously, Perl 6 uses &lt;code&gt;.&lt;/code&gt; instead of &lt;code&gt;-&amp;gt;&lt;/code&gt; to dereference an object.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Now suppose we want to derive from Point, and add a z-axis. That&amp;rsquo;s just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Point3d is Point {
        has $:z = 123;
        method clear () { $:z = 0; next; }
    }
    my $point3d = Point3d.new(x =&amp;gt; 2, y =&amp;gt; 3, z =&amp;gt; 4);
    $c = $point3d.z;    # illegal, $:z is invisible
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The implicit constructor automatically sorts out the named arguments to the correct initializers for you. If you omit the z value, it will default to 123. And the new &lt;code&gt;clear&lt;/code&gt; method calls the old clear method merely by invoking &lt;code&gt;next&lt;/code&gt;, without the dodgy &amp;ldquo;super&amp;rdquo; semantics that break down under MI. We also declared the &lt;code&gt;$:z&lt;/code&gt; attribute to be completely private by using a colon instead of a dot. No accessor for it is visible outside the class. (And yes, OO purists, our other attributes should probably have been private in the first place&amp;hellip;that&amp;rsquo;s why we&amp;rsquo;re making it just as easy to write a private attribute as a public one.)&lt;/p&gt;

&lt;p&gt;If any of that makes your head spin, I&amp;rsquo;m sure the following will clear it right up. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-classes-classes-span&#34;&gt;&lt;span id=&#34;classes&#34;&gt;Classes&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A class is what provides a name and a place for the abstract behavior of a set of objects said to belong to the class.&lt;/p&gt;

&lt;p&gt;As in Perl 5, a class is still &amp;ldquo;just a funny package&amp;rdquo;, structurally speaking. Syntactically, however, a class is now distinct from a package or a module. And the body of a class definition now runs in the context of a metaclass, which is just a way of saying that it has a metaclass instance as its (undeclared) invocant. (An &amp;ldquo;invocant&amp;rdquo; is what we call the object or class on behalf of which a method is being called.) Hence class definitions, though apparently declarative, are also executing code to build the class definition, and the various declarations within the class are also running bits of code. By convention classes will use a standard metaclass, but that&amp;rsquo;s just convention. (A very strong convention, we hope.)&lt;/p&gt;

&lt;p&gt;The primary role of a class is to manage instances, that is, objects. So a class must worry about object creation and destruction, and everything that happens in between. Classes have a secondary role as units of software reuse, in that they can be inherited from or delegated to. However, because this is a secondary role, and because of weaknesses in models of inheritance, composition, and delegation, Perl 6 will split out the notion of software reuse into a separate class-like entity called a &amp;ldquo;role&amp;rdquo;. Roles are an abstraction mechanism for use by classes that don&amp;rsquo;t care about the secondary aspects of software reuse, or that (looking at it the other way) care so much about it that they want to encapsulate any decisions about implementation, composition, delegation, and maybe even inheritance. Sounds fancy, but just think of them as includes of partial classes, with some safety checks. Roles don&amp;rsquo;t manage objects. They manage interfaces and other abstract behavior (like default implementations), and they help classes manage objects. As such, a role may only be composed into a class or into another role, never inherited from or delegated to. That&amp;rsquo;s what classes are for.&lt;/p&gt;

&lt;p&gt;Classes are arranged in an inheritance hierarchy by their &amp;ldquo;isa&amp;rdquo; relationships. Perl 6 supports multiple inheritance, but makes it easy to program in a single-inheritance style, insofar as roles make it easy to mix in (or delegate, or parameterize) private implementation details that don&amp;rsquo;t belong in the public inheritance tree.&lt;/p&gt;

&lt;p&gt;In those cases where MI is used, there can be ambiguities in the pecking order of classes in different branches. Perl 6 will have a canonical way to disambiguate these, but by design the dispatch policy is separable from inheritance, so that you can change the rules for a given set of classes. (Certainly the rules can change when we call into another language&amp;rsquo;s class hierarchy, for instance.)&lt;/p&gt;

&lt;p&gt;Where possible, class names are treated polymorphically, just as method names are. This powerful feature makes it possible to inherit systems of classes in parallel. (These classes might be inner classes, or they might be inner aliases to outer classes.) By making the class names &amp;ldquo;virtual&amp;rdquo;, the base classes can refer to the appropriate derived classes without knowing their full name. That sounds complicated, but it just means that if you do the normal thing, Perl will call the right class instead of the one you thought it was going to call. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;(As in C++ culture, we use the term &amp;ldquo;virtual&amp;rdquo; to denote a method that dispatched based on the actual runtime type of the object rather than the declared type of the variable. C++ classes have to declare their methods to be virtual explicitly. All of Perl&amp;rsquo;s public methods are virtual implicitly.)&lt;/p&gt;

&lt;p&gt;You may derive from any built-in class. For high-level object classes such as &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Num&lt;/code&gt; there are no restrictions on how you derive. For low-level representational classes like &lt;code&gt;int&lt;/code&gt; or &lt;code&gt;num&lt;/code&gt;, you may not change the representation of the value; you may only add behaviors. (If you want to change the representation, you should probably be using composition instead of inheritance. Or define your own low-level type.) Apart from this, you don&amp;rsquo;t need to worry about the difference between &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;Int&lt;/code&gt;, or &lt;code&gt;num&lt;/code&gt; and &lt;code&gt;Num&lt;/code&gt;, since Perl 6 will do autoboxing.&lt;/p&gt;

&lt;h4 id=&#34;span-id-declaration-of-classes-declaration-of-classes-span&#34;&gt;&lt;span id=&#34;declaration_of_classes&#34;&gt;Declaration of Classes&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Class declarations may be either file scoped or block scoped. A file-scoped declaration must be the first thing in the file, and looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog is Mammal;
    has Limb @.paws;
    method walk () { .paws».move() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That has the advantage of avoiding the use of one set of braces, letting you put everything up against left margin. It is otherwise identical to a block-scoped class, which looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog is Mammal {
        has Limb @.paws;
        method walk () { .paws».move() }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An incomplete class definition makes use of the &lt;code&gt;...&lt;/code&gt; (&amp;ldquo;yada, yada, yada&amp;rdquo;) operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog is Mammal {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The declaration of a class name introduces the name as a valid bare identifier or name. In the absence of such a declaration, the name of a class in an expression must be introduced with the &lt;code&gt;::&lt;/code&gt; class sigil, or it will be considered a bareword and rejected, since Perl 6 doesn&amp;rsquo;t allow barewords. Once the name is declared however, it may be used as an ordinary term in an expression. Unlike in Perl 5, you should not view it as a bareword string. Rather, you should view it as a parameterless subroutine that returns a class object, which conveniently stringifies to the name of the class for Perl 5 compatibility. But when you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Dog.new()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the invocant of &lt;code&gt;new&lt;/code&gt; is an object of type &lt;code&gt;Class&lt;/code&gt;, not a string as in Perl 5.&lt;/p&gt;

&lt;p&gt;Unmodified, a class declaration always declares a global name. But if you prefix it with &lt;code&gt;our&lt;/code&gt;, you&amp;rsquo;re defining an inner class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Cell {
        our class Golgi {...}
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The full name of the inner class is &lt;code&gt;Cell::Golgi&lt;/code&gt;, and that name can be used outside of &lt;code&gt;Cell&lt;/code&gt;, since &lt;code&gt;Golgi&lt;/code&gt; is declared in the &lt;code&gt;Cell&lt;/code&gt; package. (Classes may be declared private, however. More later.)&lt;/p&gt;

&lt;h5 id=&#34;span-id-class-traits-class-traits-span&#34;&gt;&lt;span id=&#34;class_traits&#34;&gt;Class traits&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;A class declaration may apply various traits to the class. (A trait is a property applied at compile time.) When you apply a trait, you&amp;rsquo;re accepting whatever it is that that trait does to your class, which could be pretty much anything. Traits do things &lt;em&gt;to&lt;/em&gt; classes. Do not confuse traits with roles, which are sworn to play a subservient role to the class. Traits can do whatever they jolly well please to your class&amp;rsquo;s metadata.&lt;/p&gt;

&lt;p&gt;Now, the usual thing to do to a class&amp;rsquo;s metadata is to insert another class into its ISA metadata. So we use trait notation to install a superclass:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog is Mammal {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To specify multiple inheritance, just add another trait:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog is Mammal is Pet {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But often you&amp;rsquo;ll want a role instead, specified with &lt;code&gt;does&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog is Mammal does Pet {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More on that later. But remember that traits are evil. You can have traits like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Moose is Mammal is stuffed is really(Hatrack) is spy(Russian) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what if you actually want to derive from &lt;code&gt;stuffed&lt;/code&gt;? That&amp;rsquo;s a good question, which we will answer later. (The short answer is, you don&amp;rsquo;t.)&lt;/p&gt;

&lt;p&gt;Now as it happens, you can also use &lt;code&gt;is&lt;/code&gt; from within the class. You can also put the &lt;code&gt;does&lt;/code&gt; inside to include various roles:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog {
        is Mammal;
        does Pet;
        does Servant;
        does Best::Friend[Man];
        does Drool;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, there&amp;rsquo;s no particular reason to put any of these outside the braces except to make them more obvious to the casual reader. If we take the view that inheritance is just one form of implementation, then a simple&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is sufficient to establish that there&amp;rsquo;s a &lt;code&gt;Dog&lt;/code&gt; class defined out there somewhere. We shouldn&amp;rsquo;t really care about the implementation of &lt;code&gt;Dog&lt;/code&gt;, only its interface&amp;ndash;which is usually pretty slobbery.&lt;/p&gt;

&lt;p&gt;That being said, you can know more about the interface at compile time once you know the inheritance, so it&amp;rsquo;s good to have pulled in a definition of the class as well as a declaration. Since this is typically done with &lt;code&gt;use&lt;/code&gt;, the inheritance tree is generally available even if you don&amp;rsquo;t mark your class declaration externally with the inheritance. (But in any event, the actual inheritance tree doesn&amp;rsquo;t have to be available till runtime, since that&amp;rsquo;s when methods are dispatched. (Though as is often the case, certain optimizations work better when you give them more data earlier&amp;hellip;))&lt;/p&gt;

&lt;h4 id=&#34;span-id-use-of-classes-use-of-classes-span&#34;&gt;&lt;span id=&#34;use_of_classes&#34;&gt;Use of Classes&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A class is used directly by calling class methods, and indirectly by calling methods of an object of that class (or of a derived class that doesn&amp;rsquo;t override the methods in question).&lt;/p&gt;

&lt;p&gt;Classes may also be used as objects in their own right, as instances of a metaclass, the class &lt;code&gt;MetaClass&lt;/code&gt; by default. When you declare class &lt;code&gt;Dog&lt;/code&gt;, you&amp;rsquo;re actually calling a metaclass class method that constructs a metaclass instance (i.e., the &lt;code&gt;Dog&lt;/code&gt; class) and then calls the associated closure (i.e., the body of the class) as a method on the instance. (With a little grammatical magic thrown in so that &lt;code&gt;Dog&lt;/code&gt; isn&amp;rsquo;t considered a bareword.)&lt;/p&gt;

&lt;p&gt;The class &lt;code&gt;Dog&lt;/code&gt; is an instance of the class &lt;code&gt;MetaClass&lt;/code&gt;, but it&amp;rsquo;s also an instance of the type &lt;code&gt;Class&lt;/code&gt; when you&amp;rsquo;re thinking of it as a dispatcher. That is, a class object is really allomorphic. If you treat one as an instance of Class, it behaves as if it were the user&amp;rsquo;s view of the class, and the user thinks the class is there only to dispatch to the user&amp;rsquo;s own class and instance methods. If, however, you treat the object as an instance of &lt;code&gt;MetaClass&lt;/code&gt;, you get access to all its metaclass methods rather than the user-defined methods. Another way to look at it is that the metaclass object is a separate object that manages the class object. In any event, you can get from the ordinary class object to its corresponding metaclass object via the &lt;code&gt;.meta&lt;/code&gt; method, which every object supports.&lt;/p&gt;

&lt;p&gt;By the way, a &lt;code&gt;Class&lt;/code&gt; is a &lt;code&gt;Module&lt;/code&gt;, which in turn is a &lt;code&gt;Package&lt;/code&gt;, which in turn is an &lt;code&gt;Object&lt;/code&gt;. Or something like that. So a class can always be used as if it were a mere module or package. But modules and packages don&amp;rsquo;t have a &lt;code&gt;.dispatch&lt;/code&gt; method&amp;hellip;&lt;/p&gt;

&lt;p&gt;By default, classes in Perl are left open. That is, you can add more methods later. (However, an application may close them.) For discussion of this, see the section on &amp;ldquo;Open vs. Closed Classes&amp;rdquo;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-class-name-semantics-class-name-semantics-span&#34;&gt;&lt;span id=&#34;class_name_semantics&#34;&gt;Class Name Semantics&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Class names (and module names) are just package names.&lt;/p&gt;

&lt;p&gt;Unlike in Perl 5, when you mention a package name in Perl 6 it doesn&amp;rsquo;t always mean a global name, since Perl 6 knows about inner classes and lexically scoped packages and such. As with other entities in Perl such as variables and methods, a scan is made for who thinks they have the best definition of the name, going out from lexical scopes to package scope to global scope in the case of static class names, and via method inheritance rules in the case of virtual class names.&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;::MyClass&lt;/code&gt; and &lt;code&gt;MyClass&lt;/code&gt; mean the same thing. In Perl 6, an initial &lt;code&gt;::&lt;/code&gt; is merely an optional sigil for when the name of the package would be misconstrued as something else. It specifically does not mean (as it does in Perl 5) that it is a top-level package. To refer to the top-level package, you would need to say something like &lt;code&gt;::*MyClass&lt;/code&gt; (or just &lt;code&gt;*MyClass&lt;/code&gt; in places where the &lt;code&gt;*&lt;/code&gt; unary operator would not be expected.) But also note that the &lt;code&gt;*&lt;/code&gt; package in Perl is not the &amp;ldquo;&lt;code&gt;main&lt;/code&gt;&amp;rdquo; package in the Perl 5 sense.&lt;/p&gt;

&lt;p&gt;Likewise, the presence of &lt;code&gt;::&lt;/code&gt; within a package name like &lt;code&gt;Fish::Carp&lt;/code&gt; does not make it a global package name necessarily. Again, it scans out through various scopes, and only if no local scopes define package &lt;code&gt;Fish::Carp&lt;/code&gt; do you get the global definition. And again, you can force it by saying &lt;code&gt;::*Fish::Carp&lt;/code&gt;. (Or just &lt;code&gt;*Fish::Carp&lt;/code&gt; in places where the &lt;code&gt;*&lt;/code&gt; unary operator is not expected.)&lt;/p&gt;

&lt;p&gt;You can interpolate a parenthesized expression within a package name after any &lt;code&gt;::&lt;/code&gt;. So, these are all legal package names (or module names, or class names):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ::($alice)
    ::($alice)::($bob)
    ::($alice::($bob))
    ::*::($alice)::Bob
    ::(&#39;*&#39;)::($alice ~ &#39;_misc&#39;)::Bob
    ::(get_my_dir())
    ::(@multilevel)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And any of those package names could be part of a variable or sub name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $::($alice)::name
    @::($alice)::($bob)::elems[1,2,3]
    %::*::($alice)::Bob::map{&#39;xyz&#39;}
    &amp;amp;::(&#39;*&#39;)::($alice ~ &#39;_misc&#39;)::Bob::doit(1,2,3)
    $::(get_my_dir())::x
    $::(@multilevel)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note in the last example that the final element of &lt;code&gt;@multilevel&lt;/code&gt; is taken to be the variable name. This may be illegal under &lt;code&gt;use      strict refs&lt;/code&gt;, since it amounts to a symbolic reference. (Not that the others aren&amp;rsquo;t symbolic, but the rules may be looser for package names than for variable names, depending on how strict our strictures get.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-private-classes-private-classes-span&#34;&gt;&lt;span id=&#34;private_classes&#34;&gt;Private Classes&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A class named with a single initial colon is a private class name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class :MyPrivateClass {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is completely ignored outside of the current class. Since the name is useful only in the current package, it makes no sense to try to qualify it with a package name. While it&amp;rsquo;s an inner class of sorts, it does not override any class name from any other class because it lives in its own namespace (a subnamespace of the current package), and there&amp;rsquo;s no way to tell if the class you&amp;rsquo;re deriving from declares its own private class of the same name (apart from digging through the reflection interfaces).&lt;/p&gt;

&lt;p&gt;The colon is orthogonal to the scoping. What&amp;rsquo;s actually going on in this example is that the name is stored in the package with the leading colon, because the colon is part of the name. But if you declared &amp;ldquo;&lt;code&gt;my      class :Golgi&lt;/code&gt;&amp;rdquo; the private name would go into the lexical namespace with the colon. The colon functions a bit like a &amp;ldquo;private&amp;rdquo; trait, but isn&amp;rsquo;t really a trait. Wherever you might use a private name, the colon in the name effectively creates a private subspace of names, just as if you&amp;rsquo;d prefixed it with &amp;ldquo;_&amp;rdquo; in the good old days.&lt;/p&gt;

&lt;p&gt;But if were only that, it would just be encapsulation by convention. We&amp;rsquo;re trying to do a little better than that. So the language needs to actively prevent people from accessing that private subspace from outside the class. You might think that that&amp;rsquo;s going to slow down all the dispatchers, but probably not. The ordinary dispatch of &lt;code&gt;Class.method&lt;/code&gt; and &lt;code&gt;$obj.method&lt;/code&gt; don&amp;rsquo;t have to worry about it, because they use bare identifiers. It&amp;rsquo;s only when people start doing &lt;code&gt;::($class)&lt;/code&gt; or &lt;code&gt;$obj.$method&lt;/code&gt; that we have to trap illegal references to colonic names.&lt;/p&gt;

&lt;p&gt;Even though the initial colon isn&amp;rsquo;t really a trait, if you interrogate the &amp;ldquo;&lt;code&gt;.private&lt;/code&gt;&amp;rdquo; property of the class, it will return true. You don&amp;rsquo;t have to parse the name to get that info.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll make more of this when we talk about private methods and attributes. Speaking of methods&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-methods-methods-span&#34;&gt;&lt;span id=&#34;methods&#34;&gt;Methods&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Methods are the actions that a class knows how to invoke on behalf of an object of that type (or on behalf of itself, as a class object). But you knew that already.&lt;/p&gt;

&lt;p&gt;As in Perl 5, a method is still &amp;ldquo;just a funny subroutine&amp;rdquo;, but in Perl 6 we use a different keyword to declare it, both because it&amp;rsquo;s better documentation, and because it captures the metadata for the class at compile time. Ordinary methods may be declared only within the scope of a class definition. (Multimethods are exempt from this restriction, however.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-declaration-of-methods-declaration-of-methods-span&#34;&gt;&lt;span id=&#34;declaration_of_methods&#34;&gt;Declaration of Methods&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;To declare a method, use the &lt;code&gt;method&lt;/code&gt; keyword just as you would use &lt;code&gt;sub&lt;/code&gt; for an ordinary subroutine. The declaration is otherwise almost identical:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method doit ($a, $b, $c) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The one other difference is that a method has an &lt;em&gt;invocant&lt;/em&gt; on behalf of which the method is called. In the declaration above, that invocant is implicit. (It is implicitly typed to be the same as the current surrounding class definition.) You may, however, explicitly declare the invocant as the first argument. The declaration knows you&amp;rsquo;re doing that because you put a colon between the invocant and the rest of the arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method doit ($self: $a, $b, $c) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, we didn&amp;rsquo;t specify the type of &lt;code&gt;$self&lt;/code&gt;, so it&amp;rsquo;s an untyped variable. To make the exact equivalent of the implicit declaration, put the current class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method doit (MyClass $self: $a, $b, $c) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or more generically using the &lt;code&gt;::_&lt;/code&gt; &amp;ldquo;current class&amp;rdquo; pronoun:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method doit (::_ $self: $a, $b, $c) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In any case, the method sets the current invocant as the topic, which is also known as the &lt;code&gt;$_&lt;/code&gt; variable. However, the topic can change depending on the code inside the method. So you might want to declare an explicit invocant when the meaning of &lt;code&gt;$_&lt;/code&gt; might change. (For further discussion of topics see Apocalypse 4. For a small writeup on sub signatures see Apocalypse 6.)&lt;/p&gt;

&lt;p&gt;A private method is declared with a colon on the front:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method :think (Brain $self: $thought)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Private methods are callable only by the class itself, and by trusted &amp;ldquo;friends&amp;rdquo;. More about that when we talk about attributes.&lt;/p&gt;

&lt;h4 id=&#34;span-id-use-of-methods-use-of-methods-span&#34;&gt;&lt;span id=&#34;use_of_methods&#34;&gt;Use of Methods&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As in Perl 5, there are two notations for calling ordinary methods. They are called the &amp;ldquo;dot&amp;rdquo; notation and the &amp;ldquo;indirect object&amp;rdquo; notation.&lt;/p&gt;

&lt;h5 id=&#34;span-id-the-dot-notation-the-dot-notation-span&#34;&gt;&lt;span id=&#34;the_dot_notation&#34;&gt;The dot notation&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;Perl 6&amp;rsquo;s &amp;ldquo;dot&amp;rdquo; notation is just the industry-standard way to call a method these days. (This used to be &lt;code&gt;-&amp;gt;&lt;/code&gt; in Perl 5.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $object.doit(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the object in question is the current topic, &lt;code&gt;$_&lt;/code&gt;, then you can use the unary form of the dot operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @objects {
        .doit(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A simple variable may be used for an indirectly named method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $dosomething = &amp;quot;doit&amp;quot;;
    $object.$dosomething(&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As in Perl 5, if you want to do anything fancier, use a temporary variable.&lt;/p&gt;

&lt;p&gt;The parentheses may also be omitted when the following code is unambiguously a term or operator, so you can write things like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @thumbs.each { .twiddle }   # same as @thumbs.each({.twiddle})
    $thumb.twiddle + 1          # same as $thumb.twiddle() + 1
    .mode 1                     # same as $_.mode(1)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Parens are always required around the argument list when a method call with arguments is interpolated into a string.)&lt;/p&gt;

&lt;p&gt;The parser &lt;em&gt;will&lt;/em&gt; make use of whitespace at this point to decide some things. For instance&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.method + 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is obviously a method with no arguments, while&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.method +1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is obviously a method with an argument. However, the dwimmery only goes as far as the typical person&amp;rsquo;s visual intuition. Any construct too ambiguous is simply rejected. So&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.method+1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;produces a parse error.&lt;/p&gt;

&lt;p&gt;In particular, curlies, brackets, or parens would be interpreted as postfix subscripts or argument lists if you leave out the space. In other words, Perl 6 distinguishes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.method ($x + $y) + $z  # means $obj.method(($x + $y) + $z)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;from&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.method($x + $y) + $z   # means ($obj.method($x + $y)) + $z
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, this is different from Perl 5. And yes, I know certain people hate it. They can write their own grammar.&lt;/p&gt;

&lt;p&gt;While it&amp;rsquo;s always possible to disambiguate with parentheses, sometimes that is just too unsightly. Many methods want to be parsed as if they were list operators. So as an alternative to parenthesizing the entire argument list, you can disambiguate by putting a colon between the method call and the argument list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @thumbs.each: { .twiddle }  # same as @thumbs.each({.twiddle})
    $thumb.twiddle: + 1         # same as $thumb.twiddle(+ 1)
    .mode: 1                    # same as $_.mode(1)
    $obj.for: 1,2,3 -&amp;gt; $i { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If a method is declared with the trait &amp;ldquo;&lt;code&gt;is rw&lt;/code&gt;&amp;rdquo;, it&amp;rsquo;s an lvalue method, and you can assign to it just as if it were an ordinary variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method mystate is rw () { return $:secretstate }

    $object.mystate = 42;
    print $object.mystate;      # prints 42
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, it&amp;rsquo;s a general rule that you can use an argumentless &amp;ldquo;&lt;code&gt;rw&lt;/code&gt;&amp;rdquo; method call anywhere you might use a variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    temp $state.pi = 3;
    $tailref = \$fido.tail;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Though occasionally you might need to supply parentheses to disambiguate, since the compiler can&amp;rsquo;t always know at compile time whether the method has any arguments.)&lt;/p&gt;

&lt;p&gt;Method calls on container objects are obviously directed to the container object itself, not to the contents of the container:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $elems = @array.elems;
    @keys  = %hash.keys;
    $sig   = &amp;amp;sub.signature;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, with scalar variables, methods are always directed to the object pointed to by the reference contained in the scalar:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $scalar = @array;           # (implied \ in scalar context)
    $elems = $scalar.elems;     # returns @array.elems
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or for value types, the appropriate class is called as if the value were a reference to a &amp;ldquo;real&amp;rdquo; object.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $scalar = &amp;quot;foo&amp;quot;;
    $chars = $scalar.chars;     # calls Str::chars or some such
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to talk to the scalar container itself, use the &lt;code&gt;tied()&lt;/code&gt; pseudo-function as you would in Perl 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if tied($scalar).constant {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(You may recall, however, that in Perl 6 it&amp;rsquo;s illegal to tie any variable without first declaring it as tie-able, or (preferably) tying it directly in the variable&amp;rsquo;s declaration. Otherwise the optimizer would have to assume that every variable has semantics that are unknowable in advance, and we would have to call it a pessimizer rather than an optimizer.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h5 id=&#34;span-id-the-indirect-object-notation-the-indirect-object-notation-span&#34;&gt;&lt;span id=&#34;the_indirect_object_notation&#34;&gt;The &amp;ldquo;indirect object&amp;rdquo; notation&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;The other form of method call is known as the &amp;ldquo;indirect object&amp;rdquo; syntax, although it differs from Perl 5&amp;rsquo;s syntax in that a colon is required between the indirect object (the invocant) and its arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    doit $object: &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The colon may be omitted if there are no arguments (besides the invocant):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    twiddle $thumb;
    $x = new X;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that indirect object calls may not be directly interpolated into a string, since they don&amp;rsquo;t start with a sigil. You can always use the &lt;code&gt;$()&lt;/code&gt; expression interpolater though:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    say &amp;quot;$(greet $lang), world!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As in Perl 5, the indirect object syntax is valid only if you haven&amp;rsquo;t declared a subroutine locally that overrides the method lookup. That was a bit of a problem in Perl 5 since, if there happened to be a &lt;code&gt;new&lt;/code&gt; constructor in your class, it would call that instead dispatching to the class you wanted it to. That&amp;rsquo;s much less of a problem in Perl 6, however, because Perl 6 cannot confuse a method declaration with a subroutine declaration. (Which is yet another reason for giving methods their own keyword.)&lt;/p&gt;

&lt;p&gt;Another factor that makes indirect objects work better in Perl 6 is that the class name in &amp;ldquo;&lt;code&gt;new X&lt;/code&gt;&amp;rdquo; is a predeclared object, not a bare identifier. (Perl 5 just had to guess when it saw two bare identifiers in a row that you were trying to call a class method.)&lt;/p&gt;

&lt;p&gt;The indirect object syntax may not be used with a variable for the methodname. You must use dot notation for that.&lt;/p&gt;

&lt;p&gt;Because of precedence, the indirect object notation may not be used as an lvalue unless you parenthesize it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (mystate $object) = 42;
    (findtail Dog: &amp;quot;fido&amp;quot;) = Wagging::on;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may parenthesize an argumentless indirect object method to make it look like a function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mystate($object) = 42;
    twiddle($thumb);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The dispatch rules for methods and global multi subs conspire to keep these unambiguous, so the user really doesn&amp;rsquo;t have to worry about whether&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    close($handle);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is implemented as a global multi sub or a method on a &lt;code&gt;$handle&lt;/code&gt; object. In essence, the multimethod dispatching rules degenerate to ordinary method dispatch when there are no extra arguments to consider (and sometimes even when there are arguments). This is particularly important because Perl uses these rules to tell the difference between&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;Howdy, world!\n&amp;quot;;    # global multi sub
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print $*OUT;                # ordinary filehandle method
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, you must still put the colon after the invocant if there are other arguments. The colon tells the parser whether to look for the arguments inside:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    doit($object: &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or outside:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    doit($object): &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you do say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    doit($object, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the first comma forces it to be interpreted as a sub call rather than a method call.&lt;/p&gt;

&lt;p&gt;(We could have decided to say that whenever Perl can&amp;rsquo;t find a &lt;code&gt;doit()&lt;/code&gt; sub definition at runtime, it should assume you meant the entire parenthesized list to be the indirect object, which, since it&amp;rsquo;s in scalar context would automatically generate a list reference and call &lt;code&gt;[$object,&amp;quot;a&amp;quot;,&amp;quot;b&amp;quot;,&amp;quot;c&amp;quot;].doit()&lt;/code&gt;, which is unlikely to be what you mean, or even work. (Unless, of course, that&amp;rsquo;s how you really meant it to work.) But I think it&amp;rsquo;s much more straightforward to simply disallow comma lists at the top level of an indirect object. The old &amp;ldquo;if it looks like a function&amp;rdquo; rule applies here. Oddly, though, function syntax is how you call multisubs in Perl 6. And as it happens, the way the multisub/multimethod dispatch rules are defined, it could still end up calling &lt;code&gt;$object.doit(&amp;quot;a&amp;quot;,      &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;)&lt;/code&gt; if that is deemed to be the best choice among all the candidates. But syntactically, it&amp;rsquo;s not an indirect object. More on dispatch rule interactions later.)&lt;/p&gt;

&lt;p&gt;The comma still doesn&amp;rsquo;t work if you go the other way and leave out the parens entirely, since&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    doit $object, &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would always (in the absence of a prior sub declaration) be parsed as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (doit $object:), &amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;, &amp;quot;c&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So a print with both an indirect object and arguments has to look like one of these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print $*OUT: &amp;quot;Howdy, world!\n&amp;quot;;
    print($*OUT: &amp;quot;Howdy, world!\n&amp;quot;);
    print($*OUT): &amp;quot;Howdy, world!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the old Perl 5 form using curlies:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print {some_hairy_expression()} &amp;quot;Howdy, world!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;should instead now be written with parentheses:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print (some_hairy_expression()): &amp;quot;Howdy, world!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;though, in fact, in this case the parens are unnecessary:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print some_hairy_expression(): &amp;quot;Howdy, world!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;d only need the parens if the invocant expression contained operators lower in precedence than comma (comma itself not being allowed). Basically, if it looks confusing to you, you can expect it to look confusing to the compiler, and to make the compiler look confused. But it&amp;rsquo;s a feature for the compiler to look confused when it actually &lt;em&gt;is&lt;/em&gt; confused. (In Perl 5 this was not always so.)&lt;/p&gt;

&lt;p&gt;Note that the disambiguating colon associates with the closest method call, whether direct or indirect. So&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print $obj.meth: &amp;quot;Howdy, world!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;passes &amp;ldquo;&lt;code&gt;Howdy, world!\n&lt;/code&gt;&amp;rdquo; to &lt;code&gt;$obj.meth&lt;/code&gt; rather than to &lt;code&gt;print&lt;/code&gt;. That&amp;rsquo;s a case where you ought to have parenthesized the indirect object for clarity anyway:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print ($obj.meth): &amp;quot;Howdy, world!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h5 id=&#34;span-id-calling-private-methods-calling-private-methods-span&#34;&gt;&lt;span id=&#34;calling_private_methods&#34;&gt;Calling private methods&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;A private method does not participate in normal method dispatch. It is not listed in the class&amp;rsquo;s public methods. The &lt;code&gt;.can&lt;/code&gt; method does not see it. Calling it via normal dispatch raises a &amp;ldquo;no such method&amp;rdquo; exception. It is, in essence, invisible to the outside world. It does not hide a base class&amp;rsquo;s method of the same name&amp;ndash;even in the current class! It&amp;rsquo;s fair to ask for warnings about name collisions, of course. But we&amp;rsquo;re not following the C++ approach of making private methods visible but uncallable, because that would violate encapsulation, and in particular, &lt;a href=&#34;http://en.wikipedia.org/wiki/Liskov_substitution_principle&#34;&gt;Liskov substitutability&lt;/a&gt;. Instead, we separate the namespaces completely by distinguishing the public dot operator from the private dot-colon operator. That is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $mouth.say(&amp;quot;Yes!&amp;quot;)          # always calls public .say method
          .say(&amp;quot;Yes!&amp;quot;)          # unary form
    $brain.:think(&amp;quot;No!&amp;quot;)        # always calls private :think method
          .:think(&amp;quot;No!&amp;quot;)        # unary form
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The inclusion of the colon prevents any kind of &amp;ldquo;virtual&amp;rdquo; behavior. Calling a private method is illegal except under two very specific conditions. You can call a private method &lt;code&gt;:think&lt;/code&gt; on an object &lt;code&gt;$brain&lt;/code&gt; only if:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The class of &lt;code&gt;$brain&lt;/code&gt; is explicitly declared, and the declared class is either the class definition that we are in or a class that has explicitly granted trust to our current class, and the declared class contains a private &lt;code&gt;:think&lt;/code&gt; method. Or&amp;hellip;&lt;/li&gt;
&lt;li&gt;The class of the &lt;code&gt;$brain&lt;/code&gt; is not declared, and the current class contains a private &lt;code&gt;:think&lt;/code&gt; method.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;The upshot of these rules is that a private method call is essentially a subroutine call with a method-like syntax. But the private method we&amp;rsquo;re going to call can be determined at compile time, just like a subroutine.&lt;/p&gt;

&lt;h3 id=&#34;span-id-class-methods-class-methods-span&#34;&gt;&lt;span id=&#34;class_methods&#34;&gt;Class Methods&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Class methods are called on the class as a whole rather than on any particular instance object of the class. They are distinguished from ordinary methods only by the declared type of the invocant. Since an implicit invocant would be typed as an object of the class and not as the class itself, the invocant declaration is &lt;em&gt;not&lt;/em&gt; optional in a class method declaration if you wish to specify the type of the invocant. (Untyped explicit invocants are allowed to &amp;ldquo;squint&amp;rdquo;, however.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-class-invocant-class-invocant-span&#34;&gt;&lt;span id=&#34;class_invocant&#34;&gt;Class Invocant&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;To declare an ordinary class method, such as a constructor, you say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method new (Class $class: *@args) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Such a method may only be called with an invocant that &amp;ldquo;isa&amp;rdquo; &lt;code&gt;Class&lt;/code&gt;, that is, an object of type &lt;code&gt;Class&lt;/code&gt;, or derived from type &lt;code&gt;Class&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-class-object-invocant-class-object-invocant-span&#34;&gt;&lt;span id=&#34;class|object_invocant&#34;&gt;Class|Object Invocant&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;It is possible to write a method that can be called with an invocant that is either a &lt;code&gt;Class&lt;/code&gt; or an object of that current class. You can declare the method with a type junction:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method new (Class|Dog $classorobj: *@args) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or to be completely non-specific, you can leave out the type entirely:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method new ($something: *@args) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s not as dangerous as it looks, since almost by definition the dispatcher only calls methods that are consistent with the inheritance tree. You just can&amp;rsquo;t say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method new (*@args) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which would be the equivalent of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method new (Dog $_: *@args) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, actually, you &lt;em&gt;could&lt;/em&gt; say that, but it would require that you have an existing &lt;code&gt;Dog&lt;/code&gt;-compatible object in order to create a new one. And that could present a little bootstrapping problem&amp;hellip;&lt;/p&gt;

&lt;p&gt;(Though it could certainly cure the boot chewing problem&amp;hellip;)&lt;/p&gt;

&lt;p&gt;But in fact, you&amp;rsquo;ll rarely need to declare &lt;code&gt;new&lt;/code&gt; method at all, because Perl supplies a default constructor to go with your class.&lt;/p&gt;

&lt;h3 id=&#34;span-id-submethods-submethods-span&#34;&gt;&lt;span id=&#34;submethods&#34;&gt;Submethods&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Some methods are intended to be inherited by derived classes. Others are intended to be reimplemented in every class, or in every class that doesn&amp;rsquo;t want the default method. We call these &amp;ldquo;submethods&amp;rdquo;, because they work a little like subs, and a little like methods. (You can also read the &amp;ldquo;sub&amp;rdquo; with the meaning it has in words like &amp;ldquo;subhuman&amp;rdquo;.)&lt;/p&gt;

&lt;p&gt;Typically these are (sub)methods related to the details of construction and destruction of the object. So when you call a constructor, for instance, it ends up calling the &lt;code&gt;BUILDALL&lt;/code&gt; initialization routine for the class, which ends up calling the &lt;code&gt;BUILD&lt;/code&gt; submethod:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    submethod BUILD ($a, $b, $c) {
        $.a = $a;
        $.b = $b;
        $.c = $c;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the submethod is doing things that make sense only in the context of the current class (such as initializing attributes), it makes no sense for &lt;code&gt;BUILD&lt;/code&gt; to be inherited. Likewise &lt;code&gt;DESTROY&lt;/code&gt; is also a submethod.&lt;/p&gt;

&lt;p&gt;Why not just make them ordinary subs, then? Ordinary subs can&amp;rsquo;t be called by method invocation, and we want to call these routines that way. Furthermore, if your base class &lt;em&gt;does&lt;/em&gt; define an ordinary method named &lt;code&gt;BUILD&lt;/code&gt; or &lt;code&gt;DESTROY&lt;/code&gt;, it can serve as the default &lt;code&gt;BUILD&lt;/code&gt; or &lt;code&gt;DESTROY&lt;/code&gt; for all derived classes that don&amp;rsquo;t declare their own submethods. (All public methods are virtual in Perl, but some are more virtual than others.)&lt;/p&gt;

&lt;p&gt;You might be saying to yourself, &amp;ldquo;Wait, private methods aren&amp;rsquo;t virtual. Why not just use a private method for this?&amp;rdquo; It&amp;rsquo;s true that private methods aren&amp;rsquo;t virtual, because they aren&amp;rsquo;t in fact methods at all. They&amp;rsquo;re just ordinary subroutines in disguise. They have nothing to do with inheritance. By contrast, submethods are all about presenting a unified inherited &lt;em&gt;interface&lt;/em&gt; with the option of either inheriting or not inheriting the &lt;em&gt;implementation&lt;/em&gt; of that interface, at the discretion of the class doing the implementing.&lt;/p&gt;

&lt;p&gt;So the bottom line is that submethods allow you to override an inherited implementation for the current class without overriding the default implementation for other classes. But in any case, it&amp;rsquo;s still using a public interface, called as an ordinary method call, from anywhere in your program that has an object of your type.&lt;/p&gt;

&lt;p&gt;Or a class of your type. The default &lt;code&gt;new&lt;/code&gt; constructor is an ordinary class method in class &lt;code&gt;Object&lt;/code&gt;, so it&amp;rsquo;s inherited by all classes that don&amp;rsquo;t define their own &lt;code&gt;new&lt;/code&gt;. But when you write your own &lt;code&gt;new&lt;/code&gt;, you need to decide whether your constructor should be inherited or not. If so, that&amp;rsquo;s good, and you should declare it as a method. But if not, you should declare it as a submethod so that derived classes don&amp;rsquo;t try to use it erroneously instead of the default &lt;code&gt;Object.new()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-attributes-attributes-span&#34;&gt;&lt;span id=&#34;attributes&#34;&gt;Attributes&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In Perl 6, &amp;ldquo;attributes&amp;rdquo; are what we call the instance variables of an object. (We used that word to mean something else in Perl 5&amp;ndash;we&amp;rsquo;re now calling those things &amp;ldquo;traits&amp;rdquo; or &amp;ldquo;properties&amp;rdquo;.)&lt;/p&gt;

&lt;p&gt;As with classes and methods, attribute declarations are apparently declarative. Underneath they actually call a method in the metaclass to install the new definition. The Perl 6 implementation of attributes is not based on a hash, but on something more like a symbol table. Attributes are stored in an opaque datatype rather like a struct in C, or an array in Perl 5&amp;ndash;but you don&amp;rsquo;t know that. The datatype is opaque in the sense that you shouldn&amp;rsquo;t care how it&amp;rsquo;s laid out in memory (unless you have to interface with an outside data structure&amp;ndash;like a C struct). Do not confuse opacity with encapsulation. Encapsulation only hides the object&amp;rsquo;s implementation from the outside world. But the object&amp;rsquo;s structure is opaque even to the class that defines it.&lt;/p&gt;

&lt;p&gt;One of the large benefits of this is that you can actually take a C or C++ data structure and wrap accessor methods around it without having to copy anything into a different data structure. This should speed up things like XML parsing.&lt;/p&gt;

&lt;h4 id=&#34;span-id-declaration-of-attributes-declaration-of-attributes-span&#34;&gt;&lt;span id=&#34;declaration_of_attributes&#34;&gt;Declaration of Attributes&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;In order to provide this opaque abstraction layer, attributes are not declared as a part of any other data structure. Instead, they are modeled on real variables, whose storage details are implicitly delegated to the scope in which they are declared. So attributes are declared as if they were normal variables, but with a strange scope and lifetime that is neither &lt;code&gt;my&lt;/code&gt; nor &lt;code&gt;our&lt;/code&gt;. (That scope is, of course, the current object, and the variable lives as long as the object lasts.) The class will implicitly store those attributes in a location distinct from any other class&amp;rsquo;s attributes of the same name, including any base or derived class. To declare an attribute variable, declare it within the class definition as you would a &lt;code&gt;my&lt;/code&gt; variable, but use the &lt;code&gt;has&lt;/code&gt; declarator instead of &lt;code&gt;my&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog is Mammal {
        has $.tail;
        has @.legs;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;has&lt;/code&gt; declarator was chosen to remind people that attributes are in a &amp;ldquo;HASA&amp;rdquo; relationship to the object rather than an &amp;ldquo;ISA&amp;rdquo; relationship.&lt;/p&gt;

&lt;p&gt;The other difference from normal variables is that attributes have a secondary sigil that indicates that they are associated with methods. When you declare an attribute like &lt;code&gt;$.tail&lt;/code&gt;, you&amp;rsquo;re also implicitly declaring an accessor method of the same name, only without the &lt;code&gt;$&lt;/code&gt; on the front. The dot is there to remind you that it&amp;rsquo;s also a method call.&lt;/p&gt;

&lt;p&gt;As with other declarations, you may add various traits to an attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $.dogtag is rw;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want all your attributes to default to &amp;ldquo;&lt;code&gt;rw&lt;/code&gt;&amp;rdquo;, you can put the attribute on the class itself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Coordinates is rw {
        has int $.x;
        has int $.y;
        has int $.z;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Essentially, it&amp;rsquo;s now a C-style struct, without having to introduce an ugly word like &amp;ldquo;struct&amp;rdquo; into the language. Take that, C++. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;You can also assign to a declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $.master = &amp;quot;TheDamian&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, actually, this looks like an assignment, but it isn&amp;rsquo;t. The effect of this is to establish a default; it is not executed at runtime. (Or more precisely, it runs when the class closure is executed by the metaclass, so it gets evaluated only once and the value is stored for later use by real instances. More below.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-use-of-attributes-use-of-attributes-span&#34;&gt;&lt;span id=&#34;use_of_attributes&#34;&gt;Use of Attributes&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The attribute behaves just like an ordinary variable within the class&amp;rsquo;s instance methods. You can read and write the attributes just like ordinary variables. (It is, however, illegal to refer to an instance attribute variable (that is, a &amp;ldquo;&lt;code&gt;has&lt;/code&gt;&amp;rdquo; variable) from within a class method. Class methods may only access class attributes, not instance attributes. See below.)&lt;/p&gt;

&lt;p&gt;Bare attributes are automatically hidden from the outside world because their sigiled names cannot be seen outside the class&amp;rsquo;s package. This is how Perl 6 enforces encapsulation. Outside the class the &lt;em&gt;only&lt;/em&gt; way to talk about an attribute is through accessor methods. Since public methods are always virtual in Perl, this makes attribute access virtual outside the class. Always. (Unless you give the optimizer enough hints to optimize the class to &amp;ldquo;final&amp;rdquo;. More on that later.)&lt;/p&gt;

&lt;p&gt;In other words, only the class itself is allowed to know whether this attribute is, in fact, implemented by this class. The class may also choose to ignore that fact, and call the abstract interface, that is, the accessor method, in which case it might actually end up calling some derived class&amp;rsquo;s overriding method, which might in turn call back to this class&amp;rsquo;s accessor as a super method. (So in general, an accessor method should always refer to its actual variable name rather than the accessor method name to avoid infinite recursion.)&lt;/p&gt;

&lt;p&gt;You may write your own accessor methods around the bare attributes, but if you don&amp;rsquo;t, Perl will generate them for you based on the declaration of the attribute variable. The traits of the generated method correspond directly to the traits on the variable.&lt;/p&gt;

&lt;p&gt;By default, a generated accessor is read-only (because by default any method is read-only). If you mark an attribute with the trait &amp;ldquo;&lt;code&gt;is      rw&lt;/code&gt;&amp;rdquo; though, the corresponding generated accessor will also be marked &amp;ldquo;&lt;code&gt;is rw&lt;/code&gt;&amp;rdquo;, meaning that it can be used as an lvalue.&lt;/p&gt;

&lt;p&gt;In any event, even without &amp;ldquo;&lt;code&gt;is rw&lt;/code&gt;&amp;rdquo; the attribute variable is always writable within the class itself (unless you apply the trait &lt;code&gt;is constant&lt;/code&gt; to it).&lt;/p&gt;

&lt;p&gt;As with private classes and methods, attributes are declared private using a colon on the front of their names. As with any private method, a private accessor is completely ignored outside its class (or, by extension, the classes trusted by this class).&lt;/p&gt;

&lt;p&gt;To carry the separate namespace idea through, we incorporate the colon as the secondary sigil in declarations of private attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $:x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then we can get rid of the verbose &lt;code&gt;is private&lt;/code&gt; altogether. Well, it&amp;rsquo;s still there as a trait, but the colon implies it, and is required anyway.) And we basically force people to document the private/public distinction every place they reference &lt;code&gt;$:x&lt;/code&gt; instead of &lt;code&gt;$.x&lt;/code&gt;, or &lt;code&gt;$obj.:meth&lt;/code&gt; instead of &lt;code&gt;$obj.meth&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve seen secondary sigils before in earlier Apocalypses. In each case they&amp;rsquo;re associated with a bizarre usage of some sort. So far we have:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $*foo       # a truly global global (in every package)
    $?foo       # a regex-scoped variable
    $^foo       # an autodeclared parameter variable
    $.foo       # a public attribute
    $:foo       # a private attribute
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As a form of the dreaded &amp;ldquo;Hungarian notation&amp;rdquo;, secondary sigils are not introduced lightly. We define secondary sigils only where we deem instant recognizability to be crucial for readability. Just as you should never have to look at a variable and guess whether it&amp;rsquo;s a true global, you should never have to look at a method and guess which variables are attributes and which ones are variables you just happen to be in the lexical scope of. Or which attributes are public and which are private. In Perl 6 it&amp;rsquo;s always obvious&amp;ndash;at the cost of a secondary sigil.&lt;/p&gt;

&lt;p&gt;We do hereby solemnly swear to never, never, ever add tertiary sigils. You have been warned.&lt;/p&gt;

&lt;h4 id=&#34;span-id-default-values-default-values-span&#34;&gt;&lt;span id=&#34;default_values&#34;&gt;Default Values&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;You can set default values on attributes by pseudo-assignment to the attribute declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has Answer $.ans = 42;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These default values are associated as &amp;ldquo;&lt;code&gt;build&lt;/code&gt;&amp;rdquo; traits of the attribute declaration object. When the &lt;code&gt;BUILD&lt;/code&gt; submethod is initializing a new object, these prototype values are used for uninitialized attributes. The expression on the right is evaluated immediately at the point of declaration, but you can defer evaluation by passing a closure, which will automatically be evaluated at the actual initialization time. (Therefore, to initialize to a closure value, you have to put a closure in a closure.)&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the difference between those three approaches. Suppose you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Hitchhiker {
        my $defaultanswer = 0;
        has $.ans1 = $defaultanswer;
        has $.ans2 = { $defaultanswer };
        has $.ans3 = { { $defaultanswer } };
        $defaultanswer = 42;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When the object is eventually constructed, &lt;code&gt;$.ans1&lt;/code&gt; will be initialized to &lt;code&gt;0&lt;/code&gt;, while &lt;code&gt;$.ans2&lt;/code&gt; will be initialized to 42. (That&amp;rsquo;s because the closure binds &lt;code&gt;$defaultanswer&lt;/code&gt; to the current variable, which still presumably has the value 42 by the time the &lt;code&gt;BUILD&lt;/code&gt; routine initializes the new object, even though the lexical variable &amp;ldquo;&lt;code&gt;$defaultanswer&lt;/code&gt;&amp;rdquo; has supposedly gone out of scope by the time the object is being constructed. That&amp;rsquo;s just how closures work.)&lt;/p&gt;

&lt;p&gt;And &lt;code&gt;$.ans3&lt;/code&gt; will be initialized not to 42, but to a closure that, if you ever call it, will also return 42. So since the accessor &lt;code&gt;$obj.ans3()&lt;/code&gt; returns that closure, &lt;code&gt;$obj.ans3().()&lt;/code&gt; will return 42.&lt;/p&gt;

&lt;p&gt;The default value is actually stored under the &amp;ldquo;&lt;code&gt;build&lt;/code&gt;&amp;rdquo; trait, so this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $.x = calc($y);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $.x is build( calc($y) );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $.x = { calc($y) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to either of these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $.x is build( { calc($y) } );
    has $.x will build { calc($y) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with all closure-valued container traits, the container being declared (the &lt;code&gt;$.x&lt;/code&gt; variable in this case) is passed as the topic to the closure (in addition to being the target that will be initialized with the result of the closure, because that&amp;rsquo;s what &lt;code&gt;build&lt;/code&gt; does). In addition to the magical topic, these build traits are also magically passed the same named arguments that are passed to the &lt;code&gt;BUILD&lt;/code&gt; routine. So you could say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $.x = { calc($^y) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to do a calculation based on the &lt;code&gt;:y(582)&lt;/code&gt; parameter originally passed to the constructor. Or rather, that will be passed to the constructor someday when the object is eventually constructed. Remember we&amp;rsquo;re really still at class construction time here.&lt;/p&gt;

&lt;p&gt;As with other initializers, you can be more specific about the time at which the default value is constructed, as long as that time is earlier than class construction time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $.x = BEGIN { calc() }
    has $.x = CHECK { calc() }
    has $.x = INIT  { calc() }
    has $.x = FIRST { calc() }
    has $.x = ENTER { calc() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which are really just short for:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $.x is build( BEGIN { calc() } )
    has $.x is build( CHECK { calc() } )
    has $.x is build( INIT  { calc() } )
    has $.x is build( FIRST { calc() } )
    has $.x is build( ENTER { calc() } )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-class-attributes-class-attributes-span&#34;&gt;&lt;span id=&#34;class_attributes&#34;&gt;Class Attributes&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In general, class attributes are just package or lexical variables. If you define a package variable with a dot or colon, it autogenerates an accessor for you just as it does for an ordinary attribute:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our $.count;        # generates a public read-only .count accessor
    our %:cache is rw;  # generates a private read-write .:cache accessor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The implicit invocant of these implicit accessors has a &amp;ldquo;squinting&amp;rdquo; type&amp;ndash;it can either be the class or an object of the class. (Declare your own accessors if you have a philosophical reason for forcing the type one way or the other.)&lt;/p&gt;

&lt;p&gt;The disadvantage of using &amp;ldquo;&lt;code&gt;our&lt;/code&gt;&amp;rdquo; above is that both of these are accessible from outside the class via their package name (though the private one is Officially Ignored, and cannot be named simply by saying &lt;code&gt;%MyClass:::cache&lt;/code&gt; because that syntax is specifically disallowed).&lt;/p&gt;

&lt;p&gt;If on the other hand you declare your class variables lexically:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $.count;         # generates a read-only .count accessor
    my %:cache is rw;   # generates a read-write .:cache accessor
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the same pair of accessors are generated, but the variables themselves are visible only within the class block. If you reopen the class in another block, you can only see the accessors, not the bare variables. This is probably a feature.&lt;/p&gt;

&lt;p&gt;Generally speaking, though, unless you want to provide public accessors for your class attributes, it&amp;rsquo;s best to just declare them as ordinary variables (either &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;state&lt;/code&gt; variables) to prevent confusion with instance attributes. It&amp;rsquo;s a good policy not to declare any public accessors until you know you need them. They are, after all, part of your contract with the outside world, and the outside world has a way of holding you to your contracts.&lt;/p&gt;

&lt;h3 id=&#34;span-id-object-construction-object-construction-span&#34;&gt;&lt;span id=&#34;object_construction&#34;&gt;Object Construction&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The basic idea here is to remove the drudgery of creating objects. In addition we want object creation and cleanup to work right by default. In Perl 5 it&amp;rsquo;s possible to make recursive construction and destruction work, but it&amp;rsquo;s not the default, and it&amp;rsquo;s not easy.&lt;/p&gt;

&lt;p&gt;Perl 5 also confused the notions of constructor and initializer. A constructor should create a new object once, then call all the appropriate initializers in the inheritance tree without recreating the object. The initializer for a base class should be called before the initializer for any class derived from it.&lt;/p&gt;

&lt;p&gt;The initializer for a class is always named &lt;code&gt;BUILD&lt;/code&gt;. It&amp;rsquo;s in uppercase because it&amp;rsquo;s usually called automatically for you at construction time.&lt;/p&gt;

&lt;p&gt;As with Perl 5, a constructor is only named &amp;ldquo;&lt;code&gt;new&lt;/code&gt;&amp;rdquo; by convention, and you can write a constructor with any name you like. However, in Perl 6, if you do not supply a &amp;ldquo;&lt;code&gt;new&lt;/code&gt;&amp;rdquo; method, a generic one will be provided (by inheritance from &lt;code&gt;Object&lt;/code&gt;, as it happens).&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-default-constructor-the-default-constructor-span&#34;&gt;&lt;span id=&#34;the_default_constructor&#34;&gt;The Default Constructor&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The default &lt;code&gt;new&lt;/code&gt; constructor looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi method new (Class $class: *%_) {
        return $class.bless(0, *%_);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The arguments for the default constructor are always named arguments, hence the &lt;code&gt;*%_&lt;/code&gt; declaration to collect all those pairs and pass them on to bless.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll note also that &lt;code&gt;bless&lt;/code&gt; is no longer a subroutine but a method call, so it&amp;rsquo;s now impossible to omit the class specification. This makes it easier to inherit constructors. You can still bless any reference you could bless in Perl 5, but where you previously used a function to do that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Perl 5 code...
    return bless( {attr =&amp;gt; &amp;quot;hi&amp;quot;}, $class );


in Perl 6 you use a method call:


    # Perl 6 code...
    return $class.bless( {attr =&amp;gt; &amp;quot;hi&amp;quot;} );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if what you pass as the first argument isn&amp;rsquo;t a reference, &lt;code&gt;bless&lt;/code&gt; is going to construct an opaque object and initialize it. In a sense, &lt;code&gt;bless&lt;/code&gt; is the only real constructor in Perl 6. It first makes sure the data structure is created. If you don&amp;rsquo;t supply a reference to bless, it calls &lt;code&gt;CREATE&lt;/code&gt; to create the object. Then it calls &lt;code&gt;BUILDALL&lt;/code&gt; to call all the initializers.&lt;/p&gt;

&lt;p&gt;The signature of &lt;code&gt;bless&lt;/code&gt; is something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method bless ($class: $candidate, *%_)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;0&lt;/code&gt; candidate indicates the built-in opaque type. If you&amp;rsquo;re really strange in the head, you can think of the &amp;ldquo;&lt;code&gt;0&lt;/code&gt;&amp;rdquo; as standing for &amp;ldquo;&lt;code&gt;0paque&lt;/code&gt;&amp;rdquo;. Or it&amp;rsquo;s the &amp;ldquo;zero&amp;rdquo; object, about which we know zip. Whatever tilts your windmill&amp;hellip;&lt;/p&gt;

&lt;p&gt;In any event, strings are reserved for other object layouts. We could conceivably have things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    return $class.bless(&amp;quot;Cstruct&amp;quot;, *%_);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So as it happens, &lt;code&gt;0&lt;/code&gt; is short for the layout &amp;ldquo;P6opaque&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Any additional arguments to &lt;code&gt;.bless&lt;/code&gt; are automatically passed on to &lt;code&gt;CREATE&lt;/code&gt; and &lt;code&gt;BUILDALL&lt;/code&gt;. But note that these &lt;em&gt;must&lt;/em&gt; be named arguments. It could be argued that the &lt;em&gt;only&lt;/em&gt; real purpose for writing a &lt;code&gt;.new&lt;/code&gt; constructor in Perl 6 is to translate different positional argument signatures into a unified set of named arguments. Any other initialization common to all constructors should be done within &lt;code&gt;BUILD&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Oh, the invocant of &lt;code&gt;.bless&lt;/code&gt; is either a class or an object of the class, but if you use an object of the class, the contents of that object are &lt;em&gt;not&lt;/em&gt; automatically used to prototype the new object. If you wish to do that, you have to do it explicitly by copying the attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.bless(0, *%$obj)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(That is just a specific application of the general principle that if you treat any object like a hash, it will behave like one, to the extent that it can. That is, &lt;code&gt;%$obj&lt;/code&gt; turns the attributes into key/value pairs, and passes those as arguments to initialize the new object. Note that &lt;code&gt;%$obj&lt;/code&gt; includes the private attributes when used inside the class, but not outside.)&lt;/p&gt;

&lt;p&gt;Just because &lt;code&gt;.bless&lt;/code&gt; allows an object to be used for a class doesn&amp;rsquo;t mean your &lt;code&gt;new&lt;/code&gt; constructor has to do the same. Some folks have philosophical issues with mixing up classes and objects, and it&amp;rsquo;s fine to disallow that on the constructor level. In fact, you&amp;rsquo;ll note that the default &lt;code&gt;.new&lt;/code&gt; above requires a &lt;code&gt;Class&lt;/code&gt; as its invocant. Unless you override it, it doesn&amp;rsquo;t allow an object for the constructor invocant. Go thou and don&amp;rsquo;t likewise.&lt;/p&gt;

&lt;h5 id=&#34;span-id-the-default-cloner-the-default-cloner-span&#34;&gt;&lt;span id=&#34;the_default_cloner&#34;&gt;The default cloner&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;Another good reason not to overload &lt;code&gt;.new&lt;/code&gt; to do cloning is that Perl will also supply a default &lt;code&gt;.clone&lt;/code&gt; routine that works something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi method clone ($proto: *%_) {
        return $proto.bless(0, *%_, *%$proto);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the order of the two hash arguments to &lt;code&gt;bless&lt;/code&gt;. This gives the supplied attribute values precedence over the copied attribute values, so that you can change some of the attributes &lt;em&gt;en passant&lt;/em&gt;, if you like. That&amp;rsquo;s because we&amp;rsquo;re passing the two flattened hashes as arguments to &lt;code&gt;.bless&lt;/code&gt; and Perl 6&amp;rsquo;s named argument binding mechanism always picks the &lt;em&gt;first&lt;/em&gt; argument that matches, not the last. This is opposite of what happens when you use the Perl 5 idiom:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %newvals = (%_, %$proto);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In that case, the &lt;em&gt;last&lt;/em&gt; value (the one in %$proto) would &amp;ldquo;win&amp;rdquo;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-create-create-span&#34;&gt;&lt;span id=&#34;create&#34;&gt;CREATE&lt;/span&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    submethod CREATE ($self: *%args) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;CREATE&lt;/code&gt; is called when you don&amp;rsquo;t want to use an existing data structure as the candidate for your object. In general you won&amp;rsquo;t define &lt;code&gt;CREATE&lt;/code&gt; because the default &lt;code&gt;CREATE&lt;/code&gt; does all the heavy magic to bring an opaque object into existence. But if you don&amp;rsquo;t want an opaque object, and you don&amp;rsquo;t care to write all your constructors to create the data structure before calling &lt;code&gt;.bless&lt;/code&gt;, you can define your own &lt;code&gt;CREATE&lt;/code&gt; submethod, and it will override the standard one for all constructors in the class.&lt;/p&gt;

&lt;h4 id=&#34;span-id-buildall-buildall-span&#34;&gt;&lt;span id=&#34;buildall&#34;&gt;BUILDALL&lt;/span&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    submethod BUILDALL ($self: *%args) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After the data structure is created, it must be populated by each of the participating classes (and roles) in the proper order. The &lt;code&gt;BUILDALL&lt;/code&gt; method is called upon to do this. The default &lt;code&gt;BUILDALL&lt;/code&gt; is usually correct, so you don&amp;rsquo;t generally have to override it. In essence, it delegates the initialization of parent classes to the &lt;code&gt;BUILDALL&lt;/code&gt; of the parent classes, and then it calls &lt;code&gt;BUILD&lt;/code&gt; on the current class. In this way the pieces of the object are assembled in the correct order, from least derived to most derived.&lt;/p&gt;

&lt;p&gt;For each class &lt;code&gt;BUILDALL&lt;/code&gt; calls on, if the arguments contain a pair whose key is that class name, it passes the value of the pair as its argument to that class&amp;rsquo;s &lt;code&gt;BUILDALL&lt;/code&gt;. Otherwise it passes the entire list. (There&amp;rsquo;s not much ambiguity there&amp;ndash;most classes and roles will start with upper case, while most attribute names start with lower case.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-build-build-span&#34;&gt;&lt;span id=&#34;build&#34;&gt;BUILD&lt;/span&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    submethod BUILD ($self: *%args) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is the generic signature of &lt;code&gt;BUILD&lt;/code&gt; from the viewpoint of the caller, but the typical &lt;code&gt;BUILD&lt;/code&gt; routine declares explicit parameters named after the attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    submethod BUILD (+$tail, +@legs, *%extraargs) {
        $.tail = $tail;
        @:legs = @legs;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That occurs so frequently that there&amp;rsquo;s a shorthand available in the signature declaration. You can put the attributes (distinguished by those secondary sigils, you&amp;rsquo;ll recall) right into the signature. The following means essentially the same thing, without repeating the names:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    submethod BUILD (+$.tail, +@:legs, *%extraargs) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s actually unnecessary to declare the &lt;code&gt;*%extraargs&lt;/code&gt; parameter. If you leave it out, it will default to &lt;code&gt;*%_&lt;/code&gt; (but only on methods and submethods&amp;ndash;see the section on Interface Consistency later).&lt;/p&gt;

&lt;p&gt;You may use this special syntax only for instance attributes, not class attributes. Class attributes should generally not be reinitialized every time you make a new object, after all.&lt;/p&gt;

&lt;p&gt;If you do not declare a &lt;code&gt;BUILD&lt;/code&gt; routine, a default routine will be supplied that initializes any attributes whose names correspond to the keys of the argument pairs passed to it, and leaves the other attributes to default to whatever the class supplied as the default, or &lt;code&gt;undef&lt;/code&gt; otherwise.&lt;/p&gt;

&lt;p&gt;In any event, the assignment of default attribute values happens automatically. For any attribute that is not otherwise initialized, the attribute declaration&amp;rsquo;s &amp;ldquo;&lt;code&gt;build&lt;/code&gt;&amp;rdquo; property is evaluated and the resulting value copied in to the newly created attribute slot. This happens logically at the end of the &lt;code&gt;BUILD&lt;/code&gt; block, so we avoid running initialization closures unnecessarily. This implicit initialization is based not on whether the attribute is undefined, but on whether it was initialized earlier in &lt;code&gt;BUILD&lt;/code&gt;. (Otherwise we could never explicitly create an attribute with an undefined value.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-eliminating-redundancy-in-constructor-calls-eliminating-redundancy-in-constructor-calls-span&#34;&gt;&lt;span id=&#34;eliminating_redundancy_in_constructor_calls&#34;&gt;Eliminating Redundancy in Constructor Calls&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog $spot = Dog.new(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you have to repeat the type. That&amp;rsquo;s not a big deal for a small typename, but sometime typenames are a lot longer. Plus you&amp;rsquo;d like to get rid of the redundancy, just because it&amp;rsquo;s, like, redundant. So there&amp;rsquo;s a variant on the dot operator that looks a lot like a dot assignment operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog $spot .= new(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It doesn&amp;rsquo;t really quite fit the assignment operator rule though. If it did, it&amp;rsquo;d have to mean:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog $spot = $spot.new(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which doesn&amp;rsquo;t quite work, because &lt;code&gt;$spot&lt;/code&gt; is undefined. What probably happens is that the &lt;code&gt;my&lt;/code&gt; cheats and puts a version of &lt;code&gt;undef&lt;/code&gt; in there that knows it should dispatch to the &lt;code&gt;Dog&lt;/code&gt; class if you call &lt;code&gt;.self:new()&lt;/code&gt; on it. Anyway, we&amp;rsquo;ll make it work one way or another, so that it becomes the equivalent of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog $spot = Dog.new(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The alternative is to go the C++ route and make &lt;code&gt;new&lt;/code&gt; a reserved word. We&amp;rsquo;re just not going to do that.&lt;/p&gt;

&lt;p&gt;Note that an attribute declaration of the form&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has Tail $wagger .= new(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;might not do what you want done when you want it done, if what you want done is to create a new &lt;code&gt;Dog&lt;/code&gt; object each time an object is built. For that you&amp;rsquo;d have to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has Tail $wagger = { .new(...) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or equivalently,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has Tail $wagger will build { .new(...) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But leaving aside such timing issues, you should generally think of the &lt;code&gt;.=&lt;/code&gt; operator more as a variant on &lt;code&gt;.&lt;/code&gt; than a variant on &lt;code&gt;+=&lt;/code&gt;. It can, for instance, turn any non-mutating method call into a mutating method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array.=sort;       # sort @array in place
    .=lc;               # lowercase $_ in place
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This presumes, of course, that the method&amp;rsquo;s invocant and return value are of compatible types. Some classes will wish to define special in-place mutators. The syntax for that is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method self:sort (Array @a is rw) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is illegal to use &lt;code&gt;return&lt;/code&gt; from such a routine, since the invocant is automatically returned. If you do not declare the invocant, the default invocant is automatically considered &amp;ldquo;&lt;code&gt;rw&lt;/code&gt;&amp;rdquo;. If you do not supply a mutating version, one is autogenerated for you based on the corresponding copy operator.&lt;/p&gt;

&lt;h3 id=&#34;span-id-object-deconstruction-object-deconstruction-span&#34;&gt;&lt;span id=&#34;object_deconstruction&#34;&gt;Object Deconstruction&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Object destruction is no longer guaranteed to be &amp;ldquo;timely&amp;rdquo; in Perl 6. It happens when the garbage collector gets around to it. (Though there will be ways to emulate Perl 5 end-of-scope cleanup.)&lt;/p&gt;

&lt;p&gt;As with object creation, object destruction is recursive. Unlike creation, it must proceed in the opposite order.&lt;/p&gt;

&lt;h4 id=&#34;span-id-destroyall-destroyall-span&#34;&gt;&lt;span id=&#34;destroyall&#34;&gt;DESTROYALL&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;DESTROYALL&lt;/code&gt; routine is the counterpart to the &lt;code&gt;BUILDALL&lt;/code&gt; routine. Similarly, the default definition is normally sufficient for the needs of most classes. &lt;code&gt;DESTROYALL&lt;/code&gt; first calls &lt;code&gt;DESTROY&lt;/code&gt; on the current class, and then delegates to the &lt;code&gt;DESTROYALL&lt;/code&gt; of any parent classes. In this way the pieces of the object are disassembled in the correct order, from most derived to least derived.&lt;/p&gt;

&lt;h4 id=&#34;span-id-destroy-destroy-span&#34;&gt;&lt;span id=&#34;destroy&#34;&gt;DESTROY&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As with Perl 5, all the memory deallocation is done for you, so you really only need to define &lt;code&gt;DESTROY&lt;/code&gt; if you have to release external resources such as files.&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;DESTROY&lt;/code&gt; is the opposite of &lt;code&gt;BUILD&lt;/code&gt;, if any attribute declaration has a &amp;ldquo;&lt;code&gt;destroy&lt;/code&gt;&amp;rdquo; property, that property (presumably a closure) is evaluated before the main block of &lt;code&gt;DESTROY&lt;/code&gt;. This happens even if you don&amp;rsquo;t declare a &lt;code&gt;DESTROY&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(The &amp;ldquo;&lt;code&gt;build&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;destroy&lt;/code&gt;&amp;rdquo; traits are the only way for roles to let their preferences be made known at &lt;code&gt;BUILD&lt;/code&gt; and &lt;code&gt;DESTROY&lt;/code&gt; time. It follows that any role that does not define an attribute cannot participate in building and destroying except by defining a method that &lt;code&gt;BUILD&lt;/code&gt; or &lt;code&gt;DESTROY&lt;/code&gt; might call. In other words, stateless roles aren&amp;rsquo;t allowed to muck around with the object&amp;rsquo;s state. This is construed as a feature.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-dispatch-mechanisms-dispatch-mechanisms-span&#34;&gt;&lt;span id=&#34;dispatch_mechanisms&#34;&gt;Dispatch Mechanisms&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl 6 supports both single dispatch (traditional OO) and multiple dispatch (also known as &amp;ldquo;multimethod dispatch&amp;rdquo;, but we try to avoid that term).&lt;/p&gt;

&lt;h4 id=&#34;span-id-single-dispatch-single-dispatch-span&#34;&gt;&lt;span id=&#34;single_dispatch&#34;&gt;Single Dispatch&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Single dispatch looks up which method to run solely on the basis of the type of the first argument, the invocant. A single-dispatch call distinguishes the invocant syntactically (unlike a multiple-dispatch call, which looks like a subroutine call, or even an operator.)&lt;/p&gt;

&lt;p&gt;Basically, anything can be an invocant as long as it fills the &lt;code&gt;Dispatch&lt;/code&gt; role, which provides a &lt;code&gt;.dispatcher&lt;/code&gt; method. This includes ordinary objects, class objects, and (in some cases) even varieties of &lt;code&gt;undef&lt;/code&gt; that happen to know what class of thing they aren&amp;rsquo;t (yet).&lt;/p&gt;

&lt;p&gt;Simple single dispatch is specified with the dot operator, or its indirect object equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $object.meth(@args)   # always calls public .meth
           .meth(@args)   # unary form
    meth $object: @args   # indirect object form
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are variants on the dot form indicated by the character after the dot. (None of these variants allows indirect object syntax.) The private dispatcher only ever dispatches to the current class or its proxies, so it&amp;rsquo;s really more like a subroutine call in disguise:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $object.:meth(@args)  # always calls private :meth
           .:meth(@args)  # unary form
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is an error to use &lt;code&gt;.:&lt;/code&gt; unless there is a correspondingly named &amp;ldquo;colon&amp;rdquo; method in the appropriate class, just as it is an error to use &lt;code&gt;.&lt;/code&gt; when no method can be found of that name. Unlike the &lt;code&gt;.:&lt;/code&gt; operator, which can have only one candidate method, the &lt;code&gt;.&lt;/code&gt; operator potentially generates a list of candidates, and allows methods in that candidate list to defer to subsequent methods in other classes until a candidate has been found that is willing to handle the dispatch.&lt;/p&gt;

&lt;p&gt;In addition to the &lt;code&gt;.:&lt;/code&gt; and &lt;code&gt;.=&lt;/code&gt; operators, there are three other dot variants that can be used if it&amp;rsquo;s not known how many methods are willing to handle the dispatch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $object.?meth(@args)  # calls method if there is one
           .?meth(@args)  # unary form
    $object.*meth(@args)  # calls all methods (0 or more)
           .*meth(@args)  # unary form
    $object.+meth(@args)  # calls all methods (1 or more)
           .+meth(@args)  # unary form
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;.*&lt;/code&gt; and &lt;code&gt;.+&lt;/code&gt; versions are generally only useful for calling submethods, or methods that are otherwise expected to work like submethods. They return a list of all the successful return values. The &lt;code&gt;.?&lt;/code&gt; operator either returns the one successful result, or undef if no appropriate method is found. Like the corresponding regex modifiers, &lt;code&gt;?&lt;/code&gt; means &amp;ldquo;0 or 1&amp;rdquo;, while &lt;code&gt;*&lt;/code&gt; means &amp;ldquo;0 or more&amp;rdquo;, and &lt;code&gt;+&lt;/code&gt; means &amp;ldquo;1 or more&amp;rdquo;. Ordinary &lt;code&gt;.&lt;/code&gt; means &amp;ldquo;exactly one&amp;rdquo;. Here are some sample implementations, though of course these are probably implemented in C for maximum efficiency:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Implements . (or .? if :maybe is set).
    sub CALLONE ($obj, $methname, +$maybe, *%opt, *@args) {
        my $startclass = $obj.dispatcher() // fail &amp;quot;No dispatcher: $obj&amp;quot;;
      METHOD:
        for WALKMETH($startclass, :method($methname), %opt) -&amp;gt; &amp;amp;meth {
            return meth($obj, @args);
        }
        fail qq(Can&#39;t locate method &amp;quot;$methname&amp;quot; via class &amp;quot;$startclass&amp;quot;)
            unless $maybe;
        return;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this dispatcher you can continue by saying &amp;ldquo;&lt;code&gt;next METHOD&lt;/code&gt;&amp;rdquo;. This allows methods to &amp;ldquo;failover&amp;rdquo; to other methods if they choose not to handle the request themselves.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Implements .+ (or .* if :maybe is set).
    #   Add :force to redispatch in every class
    sub CALLALL ($obj, $methname, +$maybe, +$force, *%opt, *@args) {
        my $startclass = $obj.dispatcher() // fail &amp;quot;No dispatcher: $obj&amp;quot;;
        my @results = gather {
            if $force {
              METHOD:
                for WALKCLASS($startclass, %opt) -&amp;gt; $class {
                    take $obj.::($class)::$methname(*@args) # redispatch
                }
            }
            else {
              METHOD:
                for WALKMETH($startclass, :method($methname), %opt) -&amp;gt; &amp;amp;meth {
                    take meth($obj,*@args);
                }
            }
        }
        return @results if @results or $maybe;
        fail qq(Can&#39;t locate method &amp;quot;$methname&amp;quot; via class &amp;quot;$startclass&amp;quot;);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This one you can quit early by saying &amp;ldquo;&lt;code&gt;last METHOD&lt;/code&gt;&amp;rdquo;. Notice that both of these dispatchers cheat by calling a method as if it were a sub. You may only do that by taking a reference to the method, and calling it as a subroutine, passing the object as the first argument. This is the only way to call a virtual method non-virtually in Perl. If you try to call a method directly as a subroutine, Perl will ignore the method, look for a subroutine of that name elsewhere, probably not find it, and complain bitterly. (Or find the wrong subroutine, and execute it, after which you will complain bitterly.)&lt;/p&gt;

&lt;p&gt;We snuck in an example the new &lt;code&gt;gather&lt;/code&gt;/&lt;code&gt;take&lt;/code&gt; construct. It is still somewhat conjectural.&lt;/p&gt;

&lt;h4 id=&#34;span-id-calling-superclasses-and-notsosuperclasses-calling-superclasses-and-not-so-superclasses-span&#34;&gt;&lt;span id=&#34;calling_superclasses,_and_notsosuperclasses&#34;&gt;Calling Superclasses, and Not-So-Superclasses&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Perl 5 supplies a pseudoclass, &lt;code&gt;SUPER::&lt;/code&gt;, that redirects dispatch to a parent class&amp;rsquo;s method. That&amp;rsquo;s often the wrong thing to do, though, in part because under MI you may have more than one parent class, and also because you might have sibling classes that also need to have the given method triggered. Even if &lt;code&gt;SUPER&lt;/code&gt; is smart enough to visit multiple parent classes, and even if all your classes cooperate and call &lt;code&gt;SUPER&lt;/code&gt; at the right time, the depth first order of visitation might be the wrong order, especially under diamond inheritance. Still, if you know that your parent classes use &lt;code&gt;SUPER&lt;/code&gt;, or you&amp;rsquo;re calling into a language with &lt;code&gt;SUPER&lt;/code&gt; semantics (such as Perl 5) then you should probably use &lt;code&gt;SUPER&lt;/code&gt; semantics too, or you&amp;rsquo;ll end up calling your parent&amp;rsquo;s parents in duplicate. However, since use of &lt;code&gt;SUPER&lt;/code&gt; is slightly discouraged, we Huffman code it a bit longer in Perl 6. Remember the &lt;code&gt;*%opt&lt;/code&gt; parameters to the dispatchers above? That comes in as a parameterized pseudoclass called &lt;code&gt;WALK&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.*WALK[:super]::method(@args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That limits the call to only those immediate super classes that define the method. Note the star in the example. If you really want the Perl 5 semantics, leave the star out, and you&amp;rsquo;ll only get the first existing parent method of that name. (Why you&amp;rsquo;d want that is beyond me.)&lt;/p&gt;

&lt;p&gt;Actually, we&amp;rsquo;ll probably still allow &lt;code&gt;SUPER::&lt;/code&gt; as a shorthand for &lt;code&gt;WALK[:super]::&lt;/code&gt;, since people will just hack it in anyway if we don&amp;rsquo;t provide it&amp;hellip;&lt;/p&gt;

&lt;p&gt;If you think about it, every ordinary dispatch has an implicit &lt;code&gt;WALK&lt;/code&gt; modifier on the front that just happens to default to &lt;code&gt;WALK[:canonical]&lt;/code&gt;. That is, the dispatcher looks for methods in the canonical order. But you could say &lt;code&gt;WALK[:depth]&lt;/code&gt; to get Perl 5&amp;rsquo;s order, or you could say &lt;code&gt;WALK[:descendant]&lt;/code&gt; to get an order approximating the order of construction, or &lt;code&gt;WALK[:ascendant]&lt;/code&gt; to get an order approximating the order of destruction. You could say &lt;code&gt;WALK[:omit(SomeClass)]&lt;/code&gt; to call all classes not equivalent to or derived from &lt;code&gt;SomeClass&lt;/code&gt;. For instance, to call all super classes, and not just your immediate parents, you could say &lt;code&gt;WALK[:omit(::_)]&lt;/code&gt; to skip the current lexical class or anything derived from it.&lt;/p&gt;

&lt;p&gt;But again, that&amp;rsquo;s not usually the right thing to do. If your base classes are all willing to cooperate, it&amp;rsquo;s much better to simply call&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.method(@args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then let each of the implementations of the method defer to the next one when they&amp;rsquo;re done with their part of it. If any method says &amp;ldquo;&lt;code&gt;next      METHOD&lt;/code&gt;&amp;rdquo;, it automatically iterates the loop of the dispatcher and finds the next method to dispatch to, even if that method comes from a sibling class rather than a parent class. The next method is called with the same arguments as originally supplied.&lt;/p&gt;

&lt;p&gt;That presupposes that the entire set of methods knows to call &amp;ldquo;next&amp;rdquo; appropriately. This is not always the case. In fact, if they don&amp;rsquo;t all call next, it&amp;rsquo;s likely that none of them does. And maybe just knowing whether or not they do is considered a violation of encapsulation. In any case, if you still want to call all the methods without their active cooperation, then use the star form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.*method(@args)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then the various methods don&amp;rsquo;t have to do anything to call the next method&amp;ndash;it happens automatically by default. In this case a method has to do something special if it wants to &lt;em&gt;stop&lt;/em&gt; the dispatch. Naturally, that something is to call &amp;ldquo;&lt;code&gt;last METHOD&lt;/code&gt;&amp;rdquo;, which terminates the dispatch loop early.&lt;/p&gt;

&lt;p&gt;Now, sometimes you want to call the next method, but you want to change the arguments so that the next method doesn&amp;rsquo;t get the original argument list. This is done with deep magic. If you use the &lt;code&gt;call&lt;/code&gt; keyword in an ordinary (nonwrapper) method, it steals the rest of the dispatch list from the outer loop and redispatches to the next method with the new arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @retvals = call(@newargs)
    return @retvals;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And unlike with &amp;ldquo;&lt;code&gt;next METHOD&lt;/code&gt;&amp;rdquo;, control returns to this method following the call. It returns the results of the subsequent method calls, which you should return so that your outer dispatcher can add them to the return values it already gathered.&lt;/p&gt;

&lt;p&gt;Note that &amp;ldquo;&lt;code&gt;next METHOD&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;last METHOD&lt;/code&gt;&amp;rdquo; can typically be spelt &amp;ldquo;&lt;code&gt;next&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;last&lt;/code&gt;&amp;rdquo; unless they are in an inner loop.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-parallel-dispatch-parallel-dispatch-span&#34;&gt;&lt;span id=&#34;parallel_dispatch&#34;&gt;Parallel Dispatch&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;By default the various dot operators call a method on a single object, even if it ends up calling multiple methods for that object. Since a method call is essentially a unary postfix operator, however, you can use it as a hyper operator on a list of objects:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @object».meth(@args)        # Call one for each or fail
    @object».?meth(@args)       # Call one for each if available
    @object».*meth(@args)       # Call all available for each
    @object».+meth(@args)       # Call one or more for each
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that with the last two, if a method uses &amp;ldquo;&lt;code&gt;last METHOD&lt;/code&gt;&amp;rdquo;, it doesn&amp;rsquo;t bomb out of the &amp;ldquo;hyper&amp;rdquo; loop, but just goes on to the next entry. One can always bomb out of the hyperloop with a real exception, of course. And maybe with &amp;ldquo;&lt;code&gt;last HYPER&lt;/code&gt;&amp;rdquo;, depending on how hyper&amp;rsquo;s implicit iteration is implemented.&lt;/p&gt;

&lt;p&gt;If you want to use an array for serial rather than parallel method calling, see Delegation, which lets you set up cascading handlers.&lt;/p&gt;

&lt;h4 id=&#34;span-id-walkclass-and-walkmeth-caching-walkclass-and-walkmeth-caching-span&#34;&gt;&lt;span id=&#34;walkclass_and_walkmeth_caching&#34;&gt;WALKCLASS and WALKMETH Caching&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;WALKCLASS&lt;/code&gt; generates a list of matching classes. &lt;code&gt;WALKMETH&lt;/code&gt; generates a list of method references from matching classes.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;WALKCLASS&lt;/code&gt; and &lt;code&gt;WALKMETH&lt;/code&gt; routines used in the sample dispatch code need to cache their results so that every dispatch doesn&amp;rsquo;t have to traverse the inheritance tree again, but just consult the preconstructed list in order. However, if there are changes to any of the classes involved, then someone needs to call the appropriate cache clear method to make sure that the inheritance is recalculated.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;WALKCLASS&lt;/code&gt;/&lt;code&gt;WALKMETH&lt;/code&gt; options include some that specify ordering:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :canonical      # canonical dispatch order
    :ascendant      # most-derived first, like destruction order
    :descendant     # least-derived first, like construction order
    :preorder       # like Perl 5 dispatch
    :breadth        # like multimethod dispatch
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and some that specify selection criteria:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :super              # only immediate parent classes
    :method(Str)        # only classes containing method declaration
    :omit(Selector)     # only classes that don&#39;t match selector
    :include(Selector)  # only classes that match selector
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;:method(Str)&lt;/code&gt; selects classes that merely have methods declared, not necessarily defined. A declaration without a definition probably implies that they intend to autoload a definition, so we should call the stub anyway. In fact, Perl 6 differentiates an &lt;code&gt;AUTOMETHDEF&lt;/code&gt; from &lt;code&gt;AUTOLOAD&lt;/code&gt;. &lt;code&gt;AUTOLOAD&lt;/code&gt; works as it does in Perl 5. &lt;code&gt;AUTOMETHDEF&lt;/code&gt; is never called unless there is already a declaration of the stub (or equivalently, &lt;code&gt;AUTOMETH&lt;/code&gt; faked a stub.)&lt;/p&gt;

&lt;p&gt;It would be possible to just define everything in terms of &lt;code&gt;WALKCLASS&lt;/code&gt;, but that would imply looking up each method name twice, once inside &lt;code&gt;WALKCLASS&lt;/code&gt; to see if the method exists in the current class, and once again outside in order to call it. Even if &lt;code&gt;WALKCLASS&lt;/code&gt; caches the cache list, it wouldn&amp;rsquo;t cache the derived method list, so it&amp;rsquo;s better to have a separate cache for that, controlled by &lt;code&gt;WALKMETH&lt;/code&gt;, since that&amp;rsquo;s the common case and has to be fast.&lt;/p&gt;

&lt;p&gt;(Again, this is all abstract, and is probably implemented in gloriously grungy C code. Nevertheless, you can probably call &lt;code&gt;WALKCLASS&lt;/code&gt; and &lt;code&gt;WALKMETH&lt;/code&gt; yourself if you feel like writing your own dispatcher.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-multiple-dispatch-multiple-dispatch-span&#34;&gt;&lt;span id=&#34;multiple_dispatch&#34;&gt;Multiple Dispatch&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Multiple dispatch is based on the notion that methods often mediate the relationships of multiple objects of diverse types, and therefore the first object in the argument list should not be privileged over other objects in the argument list when it comes to selecting which method to run. In this view, methods aren&amp;rsquo;t subservient to a particular class, but are independent agents. A set of independent-minded, identically named methods use the class hierarchy to do pattern matching on the argument list and decide among themselves which method can best handle the given set of arguments.&lt;/p&gt;

&lt;p&gt;The Perl approach is, of course, that sometimes you want to distinguish the first invocant, and sometimes you don&amp;rsquo;t. The interaction of these two approaches gets, um, interesting. But the basic notion is to let the caller specify which approach is expected, and then, where it makes sense, fall back on the other approach when the first one fails. Underlying all this is the Principle of Least Surprise. Do not confuse this with the Principle of Zero Surprise, which usually means you&amp;rsquo;ve just swept the real surprises under some else&amp;rsquo;s carpet. (There&amp;rsquo;s a certain amount of surprise you can&amp;rsquo;t go below&amp;ndash;the Heisenberg Uncertainty Principle applies to software too.)&lt;/p&gt;

&lt;p&gt;With traditional multimethods, all methods live in the same global namespace. Perl 6 takes a different approach&amp;ndash;we still keep all the traditional Perl namespaces (lexical, package, global) and we still search for names the same way (outward through the lexical scopes, then the current package, then the global &lt;code&gt;*&lt;/code&gt; namespace; or upward in the class hierarchy). Then we simply claim that, under multiple dispatch, the &amp;ldquo;long name&amp;rdquo; of any multi routine includes its signature, and that visibility is based on the long name. So an inner or derived multi only hides an outer or base multi of the same name &lt;em&gt;and&lt;/em&gt; the same signature. (Routines not declared &amp;ldquo;&lt;code&gt;multi&lt;/code&gt;&amp;rdquo; still hide everything in the traditional fashion.)&lt;/p&gt;

&lt;p&gt;To put it another way, the multiple dispatch always works when both the caller and the callee agree that that&amp;rsquo;s how it should work. (And in some cases it also works when it ought to work, even if they don&amp;rsquo;t agree&amp;ndash;sort of a &amp;ldquo;common law&amp;rdquo; multimethod, as it were&amp;hellip;)&lt;/p&gt;

&lt;h4 id=&#34;span-id-declaration-of-multiple-dispatch-routines-declaration-of-multiple-dispatch-routines-span&#34;&gt;&lt;span id=&#34;declaration_of_multiple_dispatch_routines&#34;&gt;Declaration of Multiple Dispatch Routines&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A callee agrees to the multiple dispatch &amp;ldquo;contract&amp;rdquo; by including the word &amp;ldquo;&lt;code&gt;multi&lt;/code&gt;&amp;rdquo; in the declaration of the routine in question. It essentially says, &amp;ldquo;Ordinarily this would be a unique name, but it&amp;rsquo;s okay to have duplicates of this name (the short name) that are differentiated by signatures (the long name).&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Looking at it from the other end, leaving the &amp;ldquo;&lt;code&gt;multi&lt;/code&gt;&amp;rdquo; out says &amp;ldquo;I am a perfect match for any signature&amp;ndash;don&amp;rsquo;t bother looking any further outward or upward.&amp;rdquo; In other words, the standard non-multi semantics.&lt;/p&gt;

&lt;p&gt;You may not declare a multi in the same scope as a non-multi. However, as long as they are in different scopes, you can have a single non-multi inside a set of multis, or a set of multis inside a single non-multi. You can even have a set of multis inside a non-multi inside a set of multis. Indeed, this is how you hide all the outer multis so that only the inner multi&amp;rsquo;s long names are considered. (And if no long name matches, you get the intermediate non-multi as a kind of backstop.) The same policy applies to both nested lexical scopes and derived subclasses.&lt;/p&gt;

&lt;p&gt;Actually, up till now we&amp;rsquo;ve been oversimplifying the concept of &amp;ldquo;long name&amp;rdquo; slightly. The long name includes only that part of the signature up to the first colon. If there is no colon, then the entire signature is part of the long name. (You can have more colons, in which case the additional arguments function as tie breakers if the original set of long names is insufficient to prevent a tie.)&lt;/p&gt;

&lt;p&gt;So sometimes we&amp;rsquo;ll probably slip and say &amp;ldquo;signature&amp;rdquo; when we mean &amp;ldquo;long name&amp;rdquo;. We pray your indulgence.&lt;/p&gt;

&lt;h5 id=&#34;span-id-multi-sub-multi-sub-span&#34;&gt;&lt;span id=&#34;multi_sub&#34;&gt;multi sub&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;A multi sub in any scope hides any multi sub with the same &amp;ldquo;long name&amp;rdquo; in any outer scope. It does not hide subs with the same short name but a different signature. Er, long name, I mean&amp;hellip;&lt;/p&gt;

&lt;h5 id=&#34;span-id-multi-sub-tradition-multimethods-multi-sub-tradition-multimethods-span&#34;&gt;&lt;span id=&#34;multi_sub_*_(tradition_multimethods)&#34;&gt;multi sub * (tradition multimethods)&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;If you want a multi that is visible in all namespaces (that don&amp;rsquo;t hide the long name), then declare the name in the global name space, indicated in Perl 6 with a &lt;code&gt;*&lt;/code&gt;. Most of the so-called &amp;ldquo;built-ins&amp;rdquo; are declared this way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi sub *push (Array $array, *@args) {...}
    multi sub *infix:+ (Num $x, Num $y) returns Num {...}
    multi sub *infix:.. (Int $x, Int $y: Int ?$by) returns Ranger {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the use of colon in the last example to exclude &lt;code&gt;$by&lt;/code&gt; as part of the long name. The range operator is dispatched only on the types of its two main arguments.&lt;/p&gt;

&lt;h5 id=&#34;span-id-multi-method-multi-method-span&#34;&gt;&lt;span id=&#34;multi_method&#34;&gt;multi method&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;If you declare a method with &lt;code&gt;multi&lt;/code&gt;, then that method hides any base class method with the same long name. It does not hide methods with the same short name but a different signature when called as a multimethod. (It does hide methods when called under single dispatch, in which case the first invocant is treated as the &lt;em&gt;only&lt;/em&gt; invocant regardless of where you put the colon. Just because a method is declared with &lt;code&gt;multi&lt;/code&gt; doesn&amp;rsquo;t make it invisible to single dispatch.)&lt;/p&gt;

&lt;p&gt;Unlike a regular method declaration, there is no implied invocant in the syntax of a multi method. A method declared as multi &lt;em&gt;must&lt;/em&gt; declare all its invocants so that there&amp;rsquo;s no ambiguity as to the meaning of the first colon. With a multi method, it always means the end of the long name. (With a non-multi, it always means that the optional invocant declaration is present.)&lt;/p&gt;

&lt;h5 id=&#34;span-id-multi-submethod-multi-submethod-span&#34;&gt;&lt;span id=&#34;multi_submethod&#34;&gt;multi submethod&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;Submethods may be declared with &lt;code&gt;multi&lt;/code&gt;, in which case visibility works the same as for ordinary methods. However, a submethod has the additional constraint that the first invocant must be an exact class match. Which effectively means that a submethod is first single dispatched to the class, and then the appropriate submethod within that class is selected, ignoring any other class&amp;rsquo;s submethods of the same name.&lt;/p&gt;

&lt;h5 id=&#34;span-id-multi-rule-multi-rule-span&#34;&gt;&lt;span id=&#34;multi_rule&#34;&gt;multi rule&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;Since rules are just methods in disguise, you can have multi rules as well. (Of course, that doesn&amp;rsquo;t do you a lot of good unless you have rules with different signatures, which is unusual.)&lt;/p&gt;

&lt;h5 id=&#34;span-id-multi-submethod-build-multi-submethod-build-span&#34;&gt;&lt;span id=&#34;multi_submethod_build&#34;&gt;multi submethod BUILD&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;It is not likely that Perl 6.0.0 will support multiple dispatch on named arguments, but only on positional arguments. Since all the extra arguments to a &lt;code&gt;BUILD&lt;/code&gt; routine come in as named arguments, you probably can&amp;rsquo;t usefully multi a &lt;code&gt;BUILD&lt;/code&gt; (yet). However, we should not do anything that precludes multiple &lt;code&gt;BUILD&lt;/code&gt; submethods in the future. Which means we should probably enforce the presence of a colon before the first named argument declaration in any multi signature, so that the semantics don&amp;rsquo;t suddenly change if and when we start supporting multiple dispatch that includes named arguments as part of the long name.&lt;/p&gt;

&lt;h5 id=&#34;span-id-multi-method-constructors-multi-method-constructors-span&#34;&gt;&lt;span id=&#34;multi_method_constructors&#34;&gt;multi method constructors&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;To the extent that you declare constructors (such as &lt;code&gt;.new&lt;/code&gt;) with positional arguments, you can use &lt;code&gt;multi&lt;/code&gt; on them in 6.0.0.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-calling-via-multiple-dispatch-calling-via-multiple-dispatch-span&#34;&gt;&lt;span id=&#34;calling_via_multiple_dispatch&#34;&gt;Calling Via Multiple Dispatch&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As we mentioned, multiple dispatch is enabled by agreement of both caller and callee. From the caller&amp;rsquo;s point of view, you invoke multiple dispatch simply by calling with subroutine call syntax instead of method call syntax. It&amp;rsquo;s then up to the dispatcher to figure out which of the arguments are invocants and which ones are just options. (In the case where the innermost visible subroutine is declared non-multi, this degenerates to the Perl 5 semantics of subroutine calls.) This approach lets you refactor a simple subroutine into a more nuanced set of subroutines without changing how the subroutines are called at all. That makes this sort of refactoring drop-dead simple. (Or at least as simple as refactoring ever gets&amp;hellip;)&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s a little harder to refactor between single dispatch and multiple dispatch, but a good argument could be made that it &lt;em&gt;should&lt;/em&gt; be harder to do that, because you&amp;rsquo;re going to have to think through a lot more things in that case anyway.&lt;/p&gt;

&lt;p&gt;Anyway, here&amp;rsquo;s the basic relationship between single dispatch and multiple dispatch. Single dispatch is more familiar, so we&amp;rsquo;ll discuss multiple dispatch first.&lt;/p&gt;

&lt;h5 id=&#34;span-id-multiple-dispatch-semantics-multiple-dispatch-semantics-span&#34;&gt;&lt;span id=&#34;multiple_dispatch_semantics&#34;&gt;Multiple dispatch semantics&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;Whenever you make a call using subroutine call syntax, it&amp;rsquo;s a candidate for multiple dispatch. A search is made for an appropriate subroutine declaration. As in Perl 5, this search goes outward through the lexical scopes, then through the current package and on to the global namespace (represented in Perl 6 with an initial * for the &amp;ldquo;wildcard&amp;rdquo; package name). If the name found is not a multi, then it&amp;rsquo;s a good old-fashioned sub call, and no multiple dispatch is done. End of story.&lt;/p&gt;

&lt;p&gt;However, if the first declaration we come to is a multi, then lots of interesting stuff happens. (Fortunately for our performance, most of this interesting stuff can happen at compile time, or upon first use.) The basic idea is that we will collect a complete list of candidates before we decide which one to call.&lt;/p&gt;

&lt;p&gt;So the search continues outward, collecting all sub declarations with the same short name but different long names. (We can ignore outer declarations that are hidden by an inner declaration with the same long name.) If we run into a scope with a non-multi declaration, then we&amp;rsquo;re done generating our candidate list, and we can skip the next paragraph.&lt;/p&gt;

&lt;p&gt;After going all the way out to the global scope, we then examine the type of the first argument as if we were about to do single dispatch on it. We then visit any classes that would have been single dispatched, in most-derived to least-derived order, and for each of those classes we add into our candidate list any methods declared multi, plus all the single invocant methods, whether or not they were declared multi! In other words, we just add in all the methods declared in the class as a subset of the candidates. (There are reasons for this that we&amp;rsquo;ll discuss below.) Anyway, just as with nested lexical scopes, if two methods have the same long name, the more derived one hides the less derived one. And if there&amp;rsquo;s a class in which the method of the same short name is not declared multi, it serves as a &amp;ldquo;stopper&amp;rdquo;, just as a non-multi sub does in a lexical scope. (Though that &amp;ldquo;stopper&amp;rdquo; method can of course redispatch further up the inheritance tree, just as a &amp;ldquo;stopper&amp;rdquo; lexical sub can always call further outward if it wants to.)&lt;/p&gt;

&lt;p&gt;Now we have our list of candidates, which may or may not include every sub and method with the same short name, depending on whether we hit a &amp;ldquo;stopper&amp;rdquo;. Anyway, once we know the candidate list, it is sorted into order of distance from the actual argument types. Any exact match on a parameter type is distance 0. Any miss by a single level of derivation counts as a distance of 1. Any violation of a hard constraint (such as having too many arguments for the number of parameters, or violating a subtype check on a type that does constraint checking, or missing the exact type on a submethod) is effectively an infinite distance, and disqualifies the candidate completely.&lt;/p&gt;

&lt;p&gt;Once we have our list of candidates sorted, we simply call the first one on the list, unless there&amp;rsquo;s more than one &amp;ldquo;first one&amp;rdquo; on the list, in which case we look to see if one of them is declared to be the default. If so, we call it. If not, we die.&lt;/p&gt;

&lt;p&gt;So if there&amp;rsquo;s a tie, the default routine is in charge of subsequent behavior:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Pick next best at random...
    multi sub foo (BaseA $a, BaseB $b) is default {
        next METHOD;
    }

    # Give up at first ambiguity...
    multi sub bar (BaseA $a, BaseB $b) is default {
        last METHOD;
    }

    # Invoke my least-derived ancestor
    multi sub baz (BaseA $a, BaseB $b) is default {
        my @ambiguities = WALKMETH($startclass, :method(&#39;baz&#39;))
            or last METHOD;
        pop(@ambiguities).($a, $b);
    }

    # Invoke most generic candidate (often a good fall-back)...
    multi sub baz (BaseA $a, BaseB $b) is default {
        my @ambiguities = @CALLER::methods or last METHOD;
        pop(@ambiguities).value.($a, $b);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In many cases, of course, the default routine won&amp;rsquo;t redispatch, but simply do something generically appropriate.&lt;/p&gt;

&lt;h5 id=&#34;span-id-single-dispatch-semantics-single-dispatch-semantics-span&#34;&gt;&lt;span id=&#34;single_dispatch_semantics&#34;&gt;Single dispatch semantics&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;If you use the dot notation, you are explicitly calling single dispatch. By default, if single dispatch doesn&amp;rsquo;t find a suitable method, it does a &amp;ldquo;failsoft&amp;rdquo; to multiple dispatch, pretending that you called a subroutine with the invocant passed as the first argument. (Multiple dispatch doesn&amp;rsquo;t need to failsoft to single dispatch since all single dispatch methods are included as a subset of the multiple dispatch candidates anyway.)&lt;/p&gt;

&lt;p&gt;This failsoft behavior can be modified by lexically scoped pragma. If you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use dispatch :failhard
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then single dispatch will be totally unforgiving as it is in Perl 5. Or you can tell single dispatch to go away:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use dispatch :multi
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in which case all your dot notation is treated as a sub call. That is, any&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.method(1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in the lexical scope acts like you&amp;rsquo;d said:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method($obj,1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If single dispatch locates a class that defines the method, but the method in question turns out to be a set of one or more multi methods, then, the single dispatch fails immediately and a multiple dispatch is done, with the additional constraint that only multis within that class are considered. (If you wanted the first argument to do loose matching as well, you should have called it as a multimethod in the first place.)&lt;/p&gt;

&lt;h5 id=&#34;span-id-indirect-objects-indirect-objects-span&#34;&gt;&lt;span id=&#34;indirect_objects&#34;&gt;Indirect objects&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;If you use indirect object syntax with an explicit colon, it is exactly equivalent to dot notation in its semantics.&lt;/p&gt;

&lt;p&gt;However, one-argument subs are inherently ambiguous, because Perl 6 does not require the colon on indirect objects without arguments. That is, if you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print $fh
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s not clear whether you mean&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $fh.print
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print($fh)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As it happens, we&amp;rsquo;ve defined the semantics so that it doesn&amp;rsquo;t matter. Since all single invocant methods are included automatically in multimethod dispatch, and since multiple dispatch degenerates to single dispatch when there&amp;rsquo;s only one invocant, it doesn&amp;rsquo;t matter which way your write it. The effect is the same either way. (Unless you&amp;rsquo;ve defined your own non-multi print routine in a surrounding lexical scope. But then, if you&amp;rsquo;ve done that, you probably did it on purpose &lt;em&gt;precisely&lt;/em&gt; because you wanted to disable the default dispatch semantics.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-meaning-of-next-method-meaning-of-next-method-span&#34;&gt;&lt;span id=&#34;meaning_of_next_method&#34;&gt;Meaning of &amp;ldquo;next METHOD&amp;rdquo;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Within the context of a multimethod dispatch, &amp;ldquo;&lt;code&gt;next METHOD&lt;/code&gt;&amp;rdquo; means to try the next best match, if unambiguous, or else the marked default method. From within the default method it means just pick the next in the list even if it&amp;rsquo;s ambiguous. The dispatch list is actually kept in &lt;code&gt;@CALLER::methods&lt;/code&gt;, which is a list of pairs, the key of each indicating the &amp;ldquo;distance&amp;rdquo; rating, and the value of each containing a reference to the method to call (as a sub ref).&lt;/p&gt;

&lt;h4 id=&#34;span-id-making-fiends-er-friends-making-fiends-er-friends-span&#34;&gt;&lt;span id=&#34;making_fiends,_er,_friends.&#34;&gt;Making Fiends, er, Friends.&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If you want to directly access the attributes of a class, your multi must be declared within the scope of that class. Attributes are never directly visible outside a class. This makes it difficult to write an efficient multimethod that knows about the internals of two different classes. However, it&amp;rsquo;s possible for private accessors to be visible outside your class under one condition. If your class declares that another class is trusted, that other class can see the private accessors of your class. If the other class declares that you are trusted, then you can see its private accessor methods. The trust relationship is not necessarily symmetrical. This lets you have an architecture where classes by and large don&amp;rsquo;t trust each other, but they all trust a single well-guarded &amp;ldquo;&lt;code&gt;multi&lt;/code&gt;-plexor&amp;rdquo; class that keeps everyone else in line.&lt;/p&gt;

&lt;p&gt;The syntax for trusting another class is simply:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class MyClass {
        trusts Yourclass;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s not clear whether roles should be allowed to grant trust. In the absence of evidence to the contrary, I&amp;rsquo;m inclined to say not. We can always relax that later if, after many large, longitudinal, double-blind studies, it turns out to be both safe and effective.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-overloading-overloading-span&#34;&gt;&lt;span id=&#34;overloading&#34;&gt;Overloading&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In Perl 5 overloading was this big special deal that had to have special hooks inserted all over the C code to catch various operations on overloaded types and do something special with them. In Perl 6, that just all falls out naturally from multiple dispatch. The only other part of the trick is to consider operators to be function calls in disguise. So in Perl 6 the real name of an operator is composed of a grammatical context identifier, a colon, and then the name of the operator as you usually see it. The common context identifiers are &amp;ldquo;prefix&amp;rdquo;, &amp;ldquo;infix&amp;rdquo;, &amp;ldquo;postfix&amp;rdquo;, &amp;ldquo;circumfix&amp;rdquo;, and &amp;ldquo;term&amp;rdquo;, but there are others.&lt;/p&gt;

&lt;p&gt;So when you say something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $x = &amp;lt;$a++ * -@b.[...]&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;re really saying something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $x = circumfix:&amp;lt;&amp;gt;(
        infix:*(
            postfix:++($a),
            prefix:-(
                infix:.(
                    @b,
                    circumfix:[](
                        term:...();
                    )
                )
            )
        )
    )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl 5 had special key names representing stringification and numification. In Perl 6 these naturally fall out if you define:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method prefix:+ () {...}    # what we do in numeric context
    method prefix:~ () {...}    # what we do in string context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise you can define what to return in boolean context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method prefix:? () {...}    # what we do in boolean context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Integer context is, of course, just an ordinary method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method int () {...}         # what we do in integer context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These can be defined as normal methods since single-invocant multi subs degenerate to standard methods anyway. C++ programmers will tend to feel comfy defining these as methods. But others may prefer to declare them as multi subs for consistency with binary operators. In which case they&amp;rsquo;d look more like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi sub *prefix:+ (Us $us) {...}   # what we do in numeric context
    multi sub *prefix:~ (Us $us) {...}   # what we do in string context
    multi sub *prefix:? (Us $us) {...}   # what we do in string context
    multi sub *prefix:int (Us $us) {...} # what we do in integer context
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Coercions to other classes can also be defined:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi sub *coerce:as (Us $us, Them ::to) { to.transmogrify($us) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Such coercions allow both explicit conversion:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $them = $us as Them;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;as well as implicit conversions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Them $them = $us;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-binary-ops-binary-ops-span&#34;&gt;&lt;span id=&#34;binary_ops&#34;&gt;Binary Ops&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Binary operators should generally be defined as multi subs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi sub infix:+ (Us $us, Us $ustoo) {...}
    multi sub infix:+ (Us $us, Them $them) is commutative {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;&lt;code&gt;is commutative&lt;/code&gt;&amp;rdquo; trait installs an additional autogenerated sub with the invocant arguments reversed, but with the same semantics otherwise. So the declaration above effectively autogenerates this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi sub infix:+ (Them $them, Us $us) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, there&amp;rsquo;s no need for that if the two arguments have the same type. And there might not actually be an autogenerated other subroutine in any case, if the implementation can be smart enough to simply swap the two arguments when it needs to. However it gets implemented, note that there&amp;rsquo;s no need for Perl 5&amp;rsquo;s &amp;ldquo;reversed arguments flag&amp;rdquo; kludge, since we reverse the parameter name bindings along with the types. Perl 5 couldn&amp;rsquo;t do that because it had no control of the signature from the compiler&amp;rsquo;s point of view.&lt;/p&gt;

&lt;p&gt;See Apocalypse 6 for much more on the definition of user-defined operators, their precedence, and their associativity. Some of it might even still be accurate.&lt;/p&gt;

&lt;h3 id=&#34;span-id-class-composition-with-roles-class-composition-with-roles-span&#34;&gt;&lt;span id=&#34;class_composition_with_roles&#34;&gt;Class Composition with Roles&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Objects have many kinds of relationships with other objects. One of the pitfalls of the early OO movement was to encourage people to model many relationships with inheritance that weren&amp;rsquo;t really &amp;ldquo;isa&amp;rdquo; relationships. Various languages have sought to redress this deficiency in various ways, with varying degrees of success. With Perl 6 we&amp;rsquo;d like to back off a step and allow the user to define abstract relationships between classes without committing to a particular implementation.&lt;/p&gt;

&lt;p&gt;More specifically, we buy the argument of the &lt;a href=&#34;http://www.cse.ogi.edu/~black/publications/TR_CSE_02-012.pdf&#34;&gt;Traits paper&lt;/a&gt; that classes should not be used both to manage objects and to manage code reuse. It needs to be possible to separate those concerns. Since a lot of the code that people want to reuse is that which manages non-isa object relationships, that&amp;rsquo;s what we should abstract out from classes.&lt;/p&gt;

&lt;p&gt;That abstraction we are calling a role. Roles can encompass both interface and implementation of object relationships. A role without implementation degenerates to an interface. A role without interface degenerates to privately instantiated generics. But the typical role will provide both interface and at least a default implementation.&lt;/p&gt;

&lt;p&gt;Unlike the Traits paper, we will allow state as part of our implementation. This is necessary if we are to abstract out the delegation decision. We feel that the decision to delegate rather than compose a sub-object is a matter of implementation, and therefore that decision should be encapsulated (or at least be allowed to be encapsulated) in a role. This allows you to refactor a problem by redefining one or more roles without having to doctor all the classes that make use of those roles. This is a great way to turn your huge, glorious &amp;ldquo;god object&amp;rdquo; into a cooperating set of objects that know how to delegate to each other.&lt;/p&gt;

&lt;p&gt;As in the Traits paper, roles are composed at class construction time, and the class composer does some work to make sure the composed class is not unintentionally ambiguous. If two methods of the same name are composed into the same class, the ambiguity will be caught. The author of the class has various remedies for dealing with this situation, which we&amp;rsquo;ll go into below.&lt;/p&gt;

&lt;p&gt;From the standpoint of the typical user, a role just looks like a &amp;ldquo;smart&amp;rdquo; include of a &amp;ldquo;partial class&amp;rdquo;. They&amp;rsquo;re smart in that roles have to be well behaved in certain respects, but most of the time the naive user can ignore the power of the abstraction.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-declaration-of-roles-declaration-of-roles-span&#34;&gt;&lt;span id=&#34;declaration_of_roles&#34;&gt;Declaration of Roles&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A role is declared much like a class, but with a &lt;code&gt;role&lt;/code&gt; keyword instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    role Pet {
        method feed ($food) {
            $food.open_can();
            $food.put_in_bowl();
            .call();
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A role may not inherit from a class. It may be composed of other roles, however. In essence, a role doesn&amp;rsquo;t know its own type yet, because it will be composed into another type. So if you happen to make any mention of its main type (available as &lt;code&gt;::_&lt;/code&gt;), that mention is in fact generic. Therefore the type of &lt;code&gt;$self&lt;/code&gt; is generic. Likewise if you refer to &lt;code&gt;SUPER&lt;/code&gt;, the role doesn&amp;rsquo;t know what the parent classes are yet, so that&amp;rsquo;s also generic. The actual types are instantiated from the generic types when the role is composed into the class. (You can use the role name (&amp;rdquo;&lt;code&gt;Pet&lt;/code&gt;&amp;rdquo;) directly, but only in places where a role name is allowed as a type constraint, not in places that declare the type of an actual object.)&lt;/p&gt;

&lt;p&gt;Just as the body of a class declaration is actually a method call on an instance of the &lt;code&gt;MetaClass&lt;/code&gt; class, so too the body of a role declaration is actually a method call on an instance of the &lt;code&gt;MetaRole&lt;/code&gt; class, which is like the &lt;code&gt;MetaClass&lt;/code&gt; class, with some tweaks to manage &lt;code&gt;Role&lt;/code&gt; objects instead of &lt;code&gt;Class&lt;/code&gt; objects. For instance, a &lt;code&gt;Role&lt;/code&gt; object doesn&amp;rsquo;t actually support a dispatcher like a &lt;code&gt;Class&lt;/code&gt; object.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;MetaRole&lt;/code&gt; and &lt;code&gt;MetaClass&lt;/code&gt; do not inherit from each other. More likely they both inherit from &lt;code&gt;MetaModule&lt;/code&gt; or some such.&lt;/p&gt;

&lt;h5 id=&#34;span-id-parametric-types-parametric-types-span&#34;&gt;&lt;span id=&#34;parametric_types&#34;&gt;Parametric types&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;A role&amp;rsquo;s main type is generic by default, but you can also parameterize other types explicitly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    role Pet[Type $petfood = TableScraps] {
        method feed (::($petfood) $food) {...}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike certain other languages you may be altogether too familiar with, Perl uses square brackets for parametric types rather than angles. Within those square brackets it uses standard signature notation, so you can also use the arguments to pass initial values, for instance. Just bear in mind that by default any parameters to a role or class are considered part of the name of the class when instantiated. Inasmuch as instantiated type names are reminiscent of multimethod &amp;ldquo;long names&amp;rdquo;, you may use a colon to separate those arguments that are to be considered part of the name from those that are just options.&lt;/p&gt;

&lt;p&gt;Please note that these types can be as latent (or as non-latent) as you like. Remember that what looks like compile time to you is actually runtime to the compiler, so it&amp;rsquo;s free to bind types as early or late as you tell it to, including not at all.&lt;/p&gt;

&lt;h5 id=&#34;span-id-interfaces-interfaces-span&#34;&gt;&lt;span id=&#34;interfaces&#34;&gt;Interfaces&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;If a role merely declares methods without defining them, it degenerates to an interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    role Pet {
        method feed ($food) {...}
        method groom () {...}
        method scratch (+$where) {...}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When such a role is included in a class, the methods then have to be defined by the class that uses the role. Actually, each method is on its own&amp;ndash;a role is free to define default implementations for any subset of the methods it declares.&lt;/p&gt;

&lt;h5 id=&#34;span-id-private-interfaces-private-interfaces-span&#34;&gt;&lt;span id=&#34;private_interfaces&#34;&gt;Private interfaces&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;If a role declares private accessors, those accessors are private to the class, not the role. The class must define any private implementations that are not supplied by the role, just as with public methods. But private method names are never visible outside the class (except to its trusted proxy classes).&lt;/p&gt;

&lt;h5 id=&#34;span-id-encapsulated-attributes-encapsulated-attributes-span&#34;&gt;&lt;span id=&#34;encapsulated_attributes&#34;&gt;Encapsulated attributes&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;Unlike in the Traits paper, we allow roles to have state. Which is fancy way of saying that the role can define attributes, and methods that act on those attributes, not just methods that act only on other methods.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    role Pet {
        has $.collar = { Collar.new(Tag.new) };
        method id () { return $.collar.tag }
        method lose_collar () { undef $.collar }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way, I think that when &lt;code&gt;$.collar&lt;/code&gt; is undefined, calling &lt;code&gt;.tag&lt;/code&gt; on it should merely return &lt;code&gt;undef&lt;/code&gt; rather than throwing an exception (in the same way that &lt;code&gt;@foo[$x][$y][$z]&lt;/code&gt; returns &lt;code&gt;undef&lt;/code&gt; when &lt;code&gt;@foo[$x]&lt;/code&gt; is undefined, and for the same reason). The &lt;code&gt;undef&lt;/code&gt; object returned should, of course, contain an unthrown exception documenting the problem, so that if the &lt;code&gt;undef&lt;/code&gt; is ever asked to provide a defined value, it can explain why it can&amp;rsquo;t do so. Or if the returned value is tested by &lt;code&gt;//&lt;/code&gt;, it can participate in the resulting error message.&lt;/p&gt;

&lt;p&gt;If you want to parameterize the initial value of a role attribute, be sure to put a colon if you don&amp;rsquo;t want the parameter to be considered part of the long name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    role Pet[IDholder $id: $tag] {
        has IDholder $.collar .= new($tag);
    }
    class Dog does Pet[Collar, DogLicense(&amp;quot;fido&amp;quot;)] {...}
    class Pigeon does Pet[LegBand, RacerId()] {...}
    my $dog = new Dog;
    my $pigeon = new Pigeon;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In which case the long names of the roles in question are &lt;code&gt;Pet[Collar]&lt;/code&gt; and &lt;code&gt;Pet[LegBand]&lt;/code&gt;. In which case all of these are true:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $dog.does(Dog)
    $dog.does(Pet)
    $dog.does(Pet[Collar])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but this is false:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $dog.does(Pet[LegBand])
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anyway, where were we. Ah, yes, encapsulated attributes, which leads us to&amp;hellip;&lt;/p&gt;

&lt;h5 id=&#34;span-id-encapsulated-private-attributes-encapsulated-private-attributes-span&#34;&gt;&lt;span id=&#34;encapsulated_private_attributes&#34;&gt;Encapsulated private attributes&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;We can also have private attributes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has Nose $:sniffer .= new();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And encapsulated private attributes lead us to&amp;hellip;&lt;/p&gt;

&lt;h5 id=&#34;span-id-encapsulated-delegation-encapsulated-delegation-span&#34;&gt;&lt;span id=&#34;encapsulated_delegation&#34;&gt;Encapsulated delegation&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;A role can abstract the decision to delegate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    role Pet {
        has $:groomer handles «bathe groom trim» = hire_groomer();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now when the &lt;code&gt;Dog&lt;/code&gt; or &lt;code&gt;Cat&lt;/code&gt; class incorporates the &lt;code&gt;Pet&lt;/code&gt; role, it doesn&amp;rsquo;t even have to know that the &lt;code&gt;.groom&lt;/code&gt; method is delegated to a professional groomer. (See section on Delegation below.)&lt;/p&gt;

&lt;h5 id=&#34;span-id-encapsulated-inheritance-encapsulated-inheritance-span&#34;&gt;&lt;span id=&#34;encapsulated_inheritance&#34;&gt;Encapsulated inheritance&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;It gets worse. Since you can specify inheritance with an &amp;ldquo;is&amp;rdquo; declaration within a class, you can do the same with a role:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    role Pet {
        is Friend;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note carefully that this is not claiming that a &lt;code&gt;Pet&lt;/code&gt; ISA &lt;code&gt;Friend&lt;/code&gt; (though that might be true enough). Roles never inherit. So this is only saying that whatever animal takes on the role of &lt;code&gt;Pet&lt;/code&gt; gets some methods from &lt;code&gt;Friend&lt;/code&gt; that just happen to be implemented by inheritance rather than by composition. Probably &lt;code&gt;Friend&lt;/code&gt; &lt;em&gt;should&lt;/em&gt; have been written as a role, but it wasn&amp;rsquo;t (perhaps because it was written in Some Other Language that runs on Parrot), and now you want to pretend that it &lt;em&gt;was&lt;/em&gt; written as a role to get your project out the door. You don&amp;rsquo;t want to use delegation because there&amp;rsquo;s only one animal involved, and inheritance will work good enough till you can rewrite &lt;code&gt;Friend&lt;/code&gt; in a language that supports role playing.&lt;/p&gt;

&lt;p&gt;Of course, the really funny thing is that if you go across a language barrier like that, Perl might just decide to emulate the inheritance with delegation anyway. But that should be transparent to you. And if two languages manage to unify their object models within the Parrot engine, you don&amp;rsquo;t want to suddenly have to rewrite your roles and classes.&lt;/p&gt;

&lt;p&gt;And the really, really funny thing is that Parrot implements roles internally with a funny form of multiple inheritance anyway&amp;hellip;&lt;/p&gt;

&lt;p&gt;Ain&amp;rsquo;t abstraction wonderful.&lt;/p&gt;

&lt;h4 id=&#34;span-id-use-of-roles-at-compile-time-use-of-roles-at-compile-time-span&#34;&gt;&lt;span id=&#34;use_of_roles_at_compile_time&#34;&gt;Use of Roles at Compile Time&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Roles are most useful at compile time, or more precisely, at class composition time, the moment in which the &lt;code&gt;MetaClass&lt;/code&gt; class is figuring out how to put together your &lt;code&gt;Class&lt;/code&gt; object. Essentially, that&amp;rsquo;s while the closure associated with your class is being executed, with a little extra happening before and after.&lt;/p&gt;

&lt;p&gt;A class incorporates a role with the verb &amp;ldquo;does&amp;rdquo;, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog is Mammal does Pet does Sentry {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or equivalently, within the body of the class closure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog {
        is Mammal;
        does Pet;
        does Sentry;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is no ordering dependency among the roles, so it doesn&amp;rsquo;t matter above if &lt;code&gt;Sentry&lt;/code&gt; comes before &lt;code&gt;Pet&lt;/code&gt;. That is because the class just remembers all the roles and then meshes them after the closure is done executing.&lt;/p&gt;

&lt;p&gt;Each role&amp;rsquo;s methods are incorporated into the class unless there is already a method of that name defined in the class itself. A class&amp;rsquo;s method definition hides any role definition of the same name, so role methods are second-class citizens. On the other hand, role methods are still part of the class itself, so they hide any methods inherited from other classes, which makes ordinary inherited methods third-class citizens, as it were.&lt;/p&gt;

&lt;p&gt;If there are no method name conflicts between roles (or with the class), then each role&amp;rsquo;s methods can be installed in the class, and we&amp;rsquo;re done. (Unless we wish to do further analysis of role interrelationships to make sure that each role can find the methods it depends on, in which case we can do that. But for 6.0.0 I&amp;rsquo;ll be happy if non-existent methods just fail at runtime as they do now in Perl 5.)&lt;/p&gt;

&lt;p&gt;If, however, two roles try to introduce a method of the same name (for some definition of name), then the composition of the class &lt;em&gt;fails&lt;/em&gt;, and the compilation of the program blows sky high&amp;ndash;we sincerely hope. It&amp;rsquo;s much better to catch this kind of error at compile time if you can. And in this case, you can.&lt;/p&gt;

&lt;h5 id=&#34;span-id-conflict-resolution-conflict-resolution-span&#34;&gt;&lt;span id=&#34;conflict_resolution&#34;&gt;Conflict resolution&lt;/span&gt;&lt;/h5&gt;

&lt;p&gt;There are several ways to solve conflicts. The first is simply to write a class method that overrides the conflicting role methods, perhaps figuring out which role method to call. It is allowed to use the role name to select one of the hidden role methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method shake ($self: $arg) {
        given $arg {
            when Culprit { $self.Sentry::shake($arg) }
            when Paw     { $self.Pet::shake($arg) }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So even though the methods were not officially composed into the class, they&amp;rsquo;re still there&amp;ndash;they&amp;rsquo;re not thrown away.&lt;/p&gt;

&lt;p&gt;That last example looks an awful lot like multiple dispatch, and in fact, if you declare the roles&amp;rsquo; methods with &lt;code&gt;multi&lt;/code&gt;, they would be treated as methods with different &amp;ldquo;long names&amp;rdquo;, provided their signatures were sufficiently different.&lt;/p&gt;

&lt;p&gt;An interesting question, though, is whether the class can force two role methods that weren&amp;rsquo;t declared &amp;ldquo;multi&amp;rdquo; to behave as if they were. Perhaps this can be forced if the class declares a signatureless multi stub without defining it later in the class:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi shake {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Traits paper recommends providing ways of renaming or excluding one or the other of the conflicting methods. We don&amp;rsquo;t recommend that, because it&amp;rsquo;s better if you can keep both contracts through multiple dispatch to the role methods. However, you can force renaming or exclusion by pretending the role is a delegation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    does Pet handles [ :myshake«shake», Any ];
    does Pet handles { $^name !~ &amp;quot;shake&amp;quot; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or something that. (See the section on Delegation below.) If we can&amp;rsquo;t get that to work right, you can always say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method shake { .Sentry::shake(@_) }    # exclude Pet::shake
    method handshake { .Pet::shake(@_) }   # rename Pet::shake
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In many ways that&amp;rsquo;s clearer than trying to attach a selection syntax to &amp;ldquo;does&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-use-of-roles-at-run-time-mixins-use-of-roles-at-runtime-mixins-span&#34;&gt;&lt;span id=&#34;use_of_roles_at_run_time_(mixins)&#34;&gt;Use of Roles at Runtime (mixins)&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;While roles are at their most powerful at compile time, they can also function as mixin classes at runtime. The &amp;ldquo;does&amp;rdquo; binary operator performs the feat of deriving a new class and binding the object to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $fido does Sentry
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, it only does this if &lt;code&gt;$fido&lt;/code&gt; doesn&amp;rsquo;t already do the &lt;code&gt;Sentry&lt;/code&gt; role. If it does already, this is basically a no-op. The &lt;code&gt;does&lt;/code&gt; operator works on the object in place. It would be illegal to say, for instance,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 does true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;does&lt;/code&gt; operator returns the object so you can nest mixins:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $fido does Sentry does Tricks does TailChasing does Scratch;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike the compile-time role composition, each of these layers on a new mixin with a new level of inheritance, creating a new anonymous class for dear old Fido, so that a &lt;code&gt;.chase&lt;/code&gt; method from &lt;code&gt;TailChasing&lt;/code&gt; hides a &lt;code&gt;.chase&lt;/code&gt; method from &lt;code&gt;Sentry&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;(Do not confuse the binary &lt;code&gt;does&lt;/code&gt; with the unary &lt;code&gt;does&lt;/code&gt; that you use inside a class definition to pull in a role.)&lt;/p&gt;

&lt;p&gt;In contrast to &lt;code&gt;does&lt;/code&gt;, the &lt;code&gt;but&lt;/code&gt; operator works on a copy. So you can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 but true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and you get a mixin based on a copy of 0, not the original 0, which everyone shares. One other wrinkle is that &amp;ldquo;true&amp;rdquo; isn&amp;rsquo;t, in fact, a class name. It&amp;rsquo;s an enumerated value of a bit class. So what we said was a shorthand for something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 but bit::true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In earlier Apocalypses we talked about applying properties with &lt;code&gt;but&lt;/code&gt;. This has now been unified with mixins, so any time you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $value but prop($x)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;re really doing something more like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $tmp = $value;      # make a copy
    $tmp does SomeRole; # guarantee there&#39;s a rw .prop method
    $tmp.prop = $x;     # set the prop method
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And therefore a property is defined by a role like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    role SomeRole {
        has SomeType $.prop is rw = 1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This means that when you mention &amp;ldquo;&lt;code&gt;prop&lt;/code&gt;&amp;rdquo; in your program, something has to know how to map that to the &lt;code&gt;SomeRole&lt;/code&gt; role. That would often be something like an enum declaration. It&amp;rsquo;s illegal to use an undeclared property. But sometimes you just want a random old property for which the role has the same name as the property. You can declare one with&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my property answer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and that essentially declares a role that looks something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my role answer {
        has $.answer is rw = 1;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a = 0 but answer(42)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and you have an object of an anonymous type that &amp;ldquo;does&amp;rdquo; &lt;code&gt;answer&lt;/code&gt;, and that include a &lt;code&gt;.answer&lt;/code&gt; accessor of the same name, so that if you call &lt;code&gt;$a.answer&lt;/code&gt;, you&amp;rsquo;ll get back &lt;code&gt;42&lt;/code&gt;. But &lt;code&gt;$a&lt;/code&gt; itself has the value &lt;code&gt;0&lt;/code&gt;. Since the accessor is &amp;ldquo;&lt;code&gt;rw&lt;/code&gt;&amp;rdquo;, you can also say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a.answer = 43;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a corresponding assignment operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a but= tainted;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That avoids copying &lt;code&gt;$a&lt;/code&gt; before tainting it. It basically means the same thing as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a does taint::tainted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For more on enumerated types, see Enums below.&lt;/p&gt;

&lt;h3 id=&#34;span-id-traits-traits-span&#34;&gt;&lt;span id=&#34;traits&#34;&gt;Traits&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Here we&amp;rsquo;re talking about Perl&amp;rsquo;s traits (as in compile-time properties), not Traits (as in the Traits paper).&lt;/p&gt;

&lt;p&gt;Traits can be thought of as roles gone wrong. Like roles, they can function as straightforward mixins on container objects at compile time, but they can also cheat, and frequently do. Unlike roles, traits are not constrained to play fair with each other. With traits, it&amp;rsquo;s both &amp;ldquo;first come, first served&amp;rdquo;, and &amp;ldquo;he who laughs last laughs best&amp;rdquo;. Traits are applied one at a time to their container victim, er, object, and an earlier trait can throw away information required by a later trait. Contrariwise, a later trait can overrule anything done by an earlier trait&amp;ndash;except of course that it can&amp;rsquo;t undestroy information that has been totally forgotten by the earlier trait.&lt;/p&gt;

&lt;p&gt;You might say that &amp;ldquo;role&amp;rdquo; is short for &amp;ldquo;role model&amp;rdquo;, while &amp;ldquo;trait&amp;rdquo; is short for &amp;ldquo;traitor&amp;rdquo;. In a nutshell, roles are symbiotes, while traits are parasites. Nevertheless, some parasites are symbiotic, and some symbiotes are parasitic. Go figure&amp;hellip;&lt;/p&gt;

&lt;p&gt;All that being said, well-behaved traits are really just roles applied to declared items like containers or classes. It&amp;rsquo;s the declaration of the item itself that makes traits seem more permanent than ordinary properties. The only reason we call them &amp;ldquo;traits&amp;rdquo; rather than &amp;ldquo;properties&amp;rdquo; is to continually remind people that they are, in fact, applied at compile time. (Well, and so that we can make bad puns on &amp;ldquo;traitor&amp;rdquo;.)&lt;/p&gt;

&lt;p&gt;Even ill-behaved traits should add an appropriately named role to the container, however, in case someone wants to look at the metadata properties of the container.&lt;/p&gt;

&lt;p&gt;Traits are generally inflicted upon the &amp;ldquo;traitee&amp;rdquo; with the &amp;ldquo;is&amp;rdquo; keyword, though other modalities are possible. When the compiler sees words like &amp;ldquo;is&amp;rdquo; or &amp;ldquo;will&amp;rdquo; or &amp;ldquo;returns&amp;rdquo; or &amp;ldquo;handles&amp;rdquo;, or special constructs like signatures and body closures, it calls into an associated trait handler, which applies the role to the item as a mixin, and also does any other traitorous magic that needs doing.&lt;/p&gt;

&lt;p&gt;To define a trait handler for an &amp;ldquo;is xxx&amp;rdquo; trait, define one or more multisubs into a property role like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    role xxx {
        has Int $.xxx;
        multi sub trait_auxiliary:is(xxx $trait, Class $container: ?$arg) {...}
        multi sub trait_auxiliary:is(xxx $trait, Any $container: ?$arg) {...}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then it can function as a trait. A well-behaved trait handler will say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $container does xxx($arg);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;somewhere inside to set the metadata on the container correctly. Then not only can you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class MyClass is xxx(123) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but you&amp;rsquo;ll also be able to say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if MyClass.meta.xxx == 123 {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since a class can function as a role when it comes to parameter type matching, you can also say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class MyBase {
        multi sub trait_auxiliary:is(MyBase $base, Class $class: ?$arg) {...}
        multi sub trait_auxiliary:is(MyBase $tied, Any $container: ?$arg) {...}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These capture control if &lt;code&gt;MyBase&lt;/code&gt; wants to capture control of how it gets used by any class or container. But usually you can just let it call the generic defaults:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi sub *trait_auxiliary:is(Class $base, Class $class: ?$arg) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which adds &lt;code&gt;$base&lt;/code&gt; to the &amp;ldquo;isa&amp;rdquo; list of &lt;code&gt;$class&lt;/code&gt;, or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi sub *trait_auxiliary:is(Class $tied, Any $container: ?$arg) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which sets the &amp;ldquo;tie&amp;rdquo; type of the container to the implementation type in &lt;code&gt;$tied&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In any event, if the trait supplies the optional argument, that comes in as &lt;code&gt;$arg&lt;/code&gt;. (It&amp;rsquo;s probably something unimportant, like the function body&amp;hellip;) Note that unlike &amp;ldquo;pair options&amp;rdquo; such as &amp;ldquo;&lt;code&gt;:wag&lt;/code&gt;&amp;rdquo;, traits do not necessarily default to the value 1 if you don&amp;rsquo;t supply the argument. This is consistent with the notion that traits don&amp;rsquo;t generally do something passive like setting a value somewhere, but something active like totally screwing up the structure of your container.&lt;/p&gt;

&lt;p&gt;Most traits are introduced by use of a &amp;ldquo;helping verb&amp;rdquo;, which could be something like &amp;ldquo;&lt;code&gt;is&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;will&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;can&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;might&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;should&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;does&lt;/code&gt;&amp;rdquo;. We call these helping verbs &amp;ldquo;trait auxiliaries&amp;rdquo;. Here&amp;rsquo;s &amp;ldquo;&lt;code&gt;will&lt;/code&gt;&amp;rdquo;, which (being syntactic sugar) merely delegates to back to &amp;ldquo;is&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi sub *trait_auxiliary:will($trait, $container: &amp;amp;arg) {
        trait_auxiliary:is($trait, $container, &amp;amp;arg);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the declaration of the argument as a non-optional reference to a closure. This is what allows us to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $dog will eat { anything() };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;rather than having to use parens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $dog is eat({ anything() });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other traits are applied with a single word, and we call one of those a &amp;ldquo;trait verb&amp;rdquo;. For instance, the &amp;ldquo;&lt;code&gt;returns&lt;/code&gt;&amp;rdquo; trait described in Apocalypse 6 is defined something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    role returns {
        has ReturnType $.returns;
        multi sub trait_verb:returns($container: ReturnType $arg) {
            $container does returns($arg);
        }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the argument is not optional on &amp;ldquo;&lt;code&gt;returns&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Earlier we defined the &lt;code&gt;xxx&lt;/code&gt; trait using multi sub definitions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    role xxx {
        has Int $.xxx;
        multi sub trait_auxiliary:is(xxx $trait, Class $container: ?$arg) {...}
        multi sub trait_auxiliary:is(xxx $trait, Any $container: ?$arg) {...}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is one of those situations in which you may really want single-dispatch methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    role xxx {
        has Int $.xxx;
        method trait_auxiliary:is(xxx $trait: Class $container, ?$arg) {...}
        method trait_auxiliary:is(xxx $trait: Any $container, ?$arg) {...}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some traits are control freaks, so they want to make sure that anything mentioning them comes through their control. They don&amp;rsquo;t want something dispatching to another trait&amp;rsquo;s trait_help:is method just because someone introduced a cute new container type they don&amp;rsquo;t know about. That other trait would just mess things up.&lt;/p&gt;

&lt;p&gt;Of course, if a trait is feeling magnanimous, it should just go ahead and use multi subs. Since the multi-dispatcher takes into account single-dispatch methods, and the distance of an exact match on the first argument is 0, the dispatcher will generally respect the wishes of both the paranoid and the carefree.&lt;/p&gt;

&lt;p&gt;Note that we included &amp;ldquo;does&amp;rdquo; in our list of &amp;ldquo;helping verbs&amp;rdquo;. Roles actually implement themselves using the trait interface, but the generic version of &lt;code&gt;trait_auxiliary:does&lt;/code&gt; defaults to doing proper roley things rather than proper classy things or improper traitorous things. So yes, you could define your own &lt;code&gt;trait_auxiliary:does&lt;/code&gt; and turn your nice role traitorous. That would be&amp;hellip;naughty.&lt;/p&gt;

&lt;p&gt;But apart from how you typically invoke them, traits and roles are really the same thing. Just like the roles on which they&amp;rsquo;re based, you may neither instantiate nor inherit from a trait. You may, however, use their names as type constraints on multimethod signatures and such. As with well-behaved roles, they should define attributes or methods that show up as metadata properties where that&amp;rsquo;s appropriate. Unlike compile-time roles, which all flatten out in the same class, compile-time traits are applied one at a time, like mixin roles. You can, in fact, apply a trait to a container at runtime, but if you do, it&amp;rsquo;s just an ordinary mixin role. You have to call the appropriate &lt;code&gt;trait_auxiliary:is()&lt;/code&gt; routine yourself if you want it to do any extra shenanigans. The compiler won&amp;rsquo;t call it for you at runtime like it would at compile time.&lt;/p&gt;

&lt;p&gt;When you define a helping verb such as &amp;ldquo;is&amp;rdquo; or &amp;ldquo;does&amp;rdquo;, it not only makes it a postfix operator for declarations, but a unary operator within class and role closures. Likewise, declarative closure blocks like &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;INIT&lt;/code&gt; are actually trait verbs, albeit ones that can add multiple closures to a queue rather than adding a single property. This implies that something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo {
        LEAVE {...}
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;could (except for scoping issues) equivalently be written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo LEAVE {...} {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though why you&amp;rsquo;d want to that, I don&amp;rsquo;t know. Hmm, if we really generalize trait verbs like that, then you could also write things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo {
        is signature (&#39;int $x&#39;);
        is cached;
        returns Int;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s getting a little out there. Maybe we won&amp;rsquo;t generalize it quite that far&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-delegation-delegation-span&#34;&gt;&lt;span id=&#34;delegation&#34;&gt;Delegation&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Delegation is the art of letting someone else do your work for you. The fact that you consider it &amp;ldquo;your&amp;rdquo; work implies that delegation is actually a means of taking credit in advance for what someone else is going to do. In terms of objects, it means pretending that some other object&amp;rsquo;s methods are your own. Now, as it happens, you can always do that by hand simply by writing your own methods that call out to another object&amp;rsquo;s methods of the same name. So any shorthand for doing that is pure syntactic sugar. That&amp;rsquo;s what we&amp;rsquo;re talking about here.&lt;/p&gt;

&lt;p&gt;Delegation in this sugary sense always requires there to be an attribute to keep a reference to the object we&amp;rsquo;re delegating to. So our syntactic relief will come in the form of annotations on a &amp;ldquo;&lt;code&gt;has&lt;/code&gt;&amp;rdquo; declaration. We could have decided to instead attach annotations to each method declaration associated with the attribute, but by the time you do this, you&amp;rsquo;ve repeated so much information that you almost might as well have written the non-sugary version yourself. I know that for a fact, because that&amp;rsquo;s how I originally proposed it. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Delegation is specified by a &amp;ldquo;handles&amp;rdquo; trait verb with an argument specifying one or more method names that the current object and the delegated object will have in common:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $:tail handles &#39;wag&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the method name (but nothing else) is known at class construction time, the following &lt;code&gt;.wag&lt;/code&gt; method is autogenerated for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method wag (*@args is context(Lazy)) { $:tail.wag(*@args) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(It&amp;rsquo;s necessary to specify a &lt;code&gt;Lazy&lt;/code&gt; context for the arguments to a such a delegator method because the actual signature is supplied by the tail&amp;rsquo;s &lt;code&gt;.wag&lt;/code&gt; method, not your method.) So as you can see, the delegation syntax already cuts our typing in half, not to mention the reading. The win is even greater when you specify multiple methods to delegate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $:legs handles «walk run lope shake pee»;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or equivalently:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $:legs handles [&#39;walk&#39;, &#39;run&#39;, &#39;lope&#39;, &#39;shake&#39;, &#39;pee&#39;];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also say things like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @legmethods := «walk run lope shake pee»;
    has $:legs handles (@legmethods);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;since the &amp;ldquo;&lt;code&gt;has&lt;/code&gt;&amp;rdquo; declaration is evaluated at class construction time.&lt;/p&gt;

&lt;p&gt;Of course, it&amp;rsquo;s illegal to call the outer method unless the attribute has been initialized to an object of a type supporting the method. So a declaration that makes a new delegatee at object build time might be specified like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $:tail handles &#39;wag&#39; will build { Tail.new(*%_) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or, equivalently,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $:tail handles &#39;wag&#39; = { Tail.new(*%_) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This automatically performs&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $:tail = Tail.new(*%_);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;when &lt;code&gt;BUILD&lt;/code&gt; is called on a new object of the current class (unless &lt;code&gt;BUILD&lt;/code&gt; initializes &lt;code&gt;$:tail&lt;/code&gt; to some other value). Or, since you might want to declare the type of the attribute without duplicating it in the default value, you can also say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has Tail $:tail handles &#39;wag&#39; = { .new(*%_) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has Tail $:tail handles &#39;wag&#39; will build { .new(*%_) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that putting a &lt;code&gt;Tail&lt;/code&gt; type on the attribute does not necessarily mean that the method is always delegated to the &lt;code&gt;Tail&lt;/code&gt; class. The dispatch is still based on the &lt;em&gt;runtime&lt;/em&gt; type of the object, not the declared type. So&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has Tail $:tail handles &#39;wag&#39; = { LongTail.new(*%_) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;delegates to the &lt;code&gt;LongTail&lt;/code&gt; class, not the &lt;code&gt;Tail&lt;/code&gt; class. Of course, you&amp;rsquo;ll get an exception at build time if you try to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has Tail $:tail handles &#39;wag&#39; = { Dog.new(*%_) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;since &lt;code&gt;Dog&lt;/code&gt; is not derived from &lt;code&gt;Tail&lt;/code&gt; (whether or not the tail can wag the dog).&lt;/p&gt;

&lt;p&gt;We declare &lt;code&gt;$:tail&lt;/code&gt; as a private attribute here, but &lt;code&gt;$.tail&lt;/code&gt; would have worked just as well. A &lt;code&gt;Dog&lt;/code&gt;&amp;rsquo;s tail does seem to be a public interface, after all. Kind of a read-only accessor.&lt;/p&gt;

&lt;h4 id=&#34;span-id-wildcard-delegation-wildcard-delegation-span&#34;&gt;&lt;span id=&#34;wildcard_delegation&#34;&gt;Wildcard Delegation&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;We&amp;rsquo;ve seen that the argument to &amp;ldquo;&lt;code&gt;handles&lt;/code&gt;&amp;rdquo; can be a string or a list of strings. But any argument or subargument that is not a string is considered to be a smartmatch selector for methods. So you can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $:fur handles /^get_/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then you can do the &lt;code&gt;.get_wet&lt;/code&gt; or &lt;code&gt;.get_fleas&lt;/code&gt; methods (presuming there are such), but you can&amp;rsquo;t call the &lt;code&gt;.shake&lt;/code&gt; or &lt;code&gt;.roll_in_the_dirt&lt;/code&gt; methods. (Obviously you don&amp;rsquo;t want to delegate the &lt;code&gt;.shake&lt;/code&gt; method since that means something else when applied to the &lt;code&gt;Dog&lt;/code&gt; as a whole.)&lt;/p&gt;

&lt;p&gt;If you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $:fur handles Groomable;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then you get only those methods available via the &lt;code&gt;Groomable&lt;/code&gt; role or class.&lt;/p&gt;

&lt;p&gt;Wildcard matches are evaluated only after it has been determined that there&amp;rsquo;s no exact match to the method name. They therefore function as a kind of autoloading in the overall pecking order. If the class also has an &lt;code&gt;AUTOLOAD&lt;/code&gt;, it is called only if none of the wildcard delegations match. (An &lt;code&gt;AUTOMETHDEF&lt;/code&gt; is called much earlier, since it knows from the stub declarations whether there is supposed to be a method of that name. So you can think of explicit delegation as a kind of autodefine, and wildcard delegation as a kind of autoload.)&lt;/p&gt;

&lt;p&gt;When you have multiple wildcard delegations to different objects, it&amp;rsquo;s possible to have a conflict of method names. Wildcard method matches are evaluated in order, so the earliest one wins. (Non-wildcard method conflicts can be caught at class composition time.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-renaming-delegated-methods-renaming-delegated-methods-span&#34;&gt;&lt;span id=&#34;renaming_delegated_methods&#34;&gt;Renaming Delegated Methods&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If, where you would ordinarily specify a string, you put a pair, then the pair maps the method name in this class to the method name in the other class. If you put a hash, each key/value pair is treated as such a mapping. Such mappings are not considered wildcards.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $:fur handles { :shakefur«shake» :scratch«get_fleas» };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perhaps that reads better with the old pair notation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $:fur handles { shakefur =&amp;gt; &#39;shake&#39;, scratch =&amp;gt; &#39;get_fleas&#39; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You &lt;em&gt;can&lt;/em&gt; do a wildcard renaming, but not with pairs. Instead do smartmatch with a substitution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has $:fur handles (s/^furget_/get_/);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As always, the left-to-right mapping is from this class to the other one. The pattern matching is working on the method name passed to us, and the substituted method name is used on the class we delegate to.&lt;/p&gt;

&lt;h4 id=&#34;span-id-delegation-without-an-attribute-delegation-without-an-attribute-span&#34;&gt;&lt;span id=&#34;delegation_without_an_attribute&#34;&gt;Delegation Without an Attribute&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Ordinarily delegation is based on an attribute holding an object reference, but there&amp;rsquo;s no reason in principle why you have to use an attribute. Suppose you had a &lt;code&gt;Dog&lt;/code&gt; with two tails. You can delegate based on a method call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method select_tail handles «wag hang» {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The arguments are sent to both the delegator and delegatee method. So when you call&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $dog.wag(:fast)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;re actually calling&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $dog.select_tail(:fast).wag(:fast)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you use a wildcard delegation based on a method, you should be aware that it has to call the method before it can even decide whether there&amp;rsquo;s a valid method call to the delegatee or not. So it behooves you not to get too fancy with &lt;code&gt;select_tail()&lt;/code&gt;, since it might just have to throw all that work away and go on to the next wildcard specification.&lt;/p&gt;

&lt;h4 id=&#34;span-id-delegation-of-handlers-delegation-of-handlers-span&#34;&gt;&lt;span id=&#34;delegation_of_handlers&#34;&gt;Delegation of Handlers&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If your delegation object happens to be an array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has @:handlers handles &#39;foo&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then something cool happens. &amp;lt;cool rays&amp;gt; In this case Perl 6 assumes that your array contains a list of potential handlers, and you just want to call the &lt;em&gt;first&lt;/em&gt; one that succeeds. This is not considered a wildcard match unless the &amp;ldquo;handles&amp;rdquo; argument forces it to be.&lt;/p&gt;

&lt;p&gt;Note that this is different from the semantics of a hyper method such as &lt;code&gt;@objects».foo()&lt;/code&gt;, which will try to call the method on &lt;em&gt;every&lt;/em&gt; object in &lt;code&gt;@objects&lt;/code&gt;. If you want to do that, you&amp;rsquo;ll just have to write your own method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has @:ears;
    method twitchears () { @:ears».twitch() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Life is hard.&lt;/p&gt;

&lt;h4 id=&#34;span-id-hashbased-redispatch-hash-based-redispatch-span&#34;&gt;&lt;span id=&#34;hashbased_redispatch&#34;&gt;Hash-Based Redispatch&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If your delegation object happens to be a hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has %:objects handles &#39;foo&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the hash provides a mapping from the string value of &amp;ldquo;self&amp;rdquo; to the object that should be delegated to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    has %:barkers handles &amp;quot;bark&amp;quot; =
                (Chihauhau =&amp;gt; $yip,
                    Beagle =&amp;gt; $yap,
                   Terrier =&amp;gt; $arf,
                 StBernard =&amp;gt; $woof,
                );
    method prefix:~( return &amp;quot;$.breed&amp;quot; )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the string is not found in the hash, a &amp;ldquo;&lt;code&gt;next METHOD&lt;/code&gt;&amp;rdquo; is automatically performed.&lt;/p&gt;

&lt;p&gt;Again, this construct is not necessarily considered a wildcard. In the example above we know for a fact that there&amp;rsquo;s supposed to be a &lt;code&gt;.bark&lt;/code&gt; method somewhere, therefore a specific method can be autogenerated in the current class.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-relationship-to-roles-relationship-to-roles-span&#34;&gt;&lt;span id=&#34;relationship_to_roles&#34;&gt;Relationship to Roles&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Delegation is a means of including a set of methods into your class. Roles can also include a set of methods in your class, but the difference is that what a role includes happens at class composition time, while delegation is much more dynamic, depending on the current state of the delegating attribute (or method).&lt;/p&gt;

&lt;p&gt;But there&amp;rsquo;s no reason you can&amp;rsquo;t have your cake and eat it too, because roles are specifically designed to allow you to pull in delegations without the class even being aware of the fact that it&amp;rsquo;s delegating. When you include a role, you&amp;rsquo;re just signing up for a set of methods, with maybe a little state thrown in. You don&amp;rsquo;t care whether those methods are defined directly, or indirectly. The role manages that.&lt;/p&gt;

&lt;p&gt;In fact, this is one of the primary motivators for including roles in the design of Perl 6. As a named abstraction, a role lets you refactor all the classes using that role without changing any of the classes involved. You can turn your single &amp;ldquo;god&amp;rdquo; object into a set of nicely cooperating objects transparently. Well, you have to do the composition using roles first, and that&amp;rsquo;s not transparent.&lt;/p&gt;

&lt;p&gt;Note that all statically named methods are dispatched before any wildcard methods, regardless of whether the methods came from a role or the class itself. (Inherited methods also come before wildcard methods because we order all the cachable method dispatches before all the non-cachable ones. But see below.) So the lookup order is:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;This class&amp;rsquo;s declared methods (including autodefs and delegations)&lt;/li&gt;
&lt;li&gt;An included role&amp;rsquo;s declared methods (including autodefs and delegations)&lt;/li&gt;
&lt;li&gt;Normal inherited methods (including autodefs and delegations of the parent class)&lt;/li&gt;
&lt;li&gt;Wildcard delegated methods in this class (or failing that, from any inherited class that does wildcard delegations)&lt;/li&gt;
&lt;li&gt;Methods autoloaded by an autoloader defined in this class (or failing that, an autoloader from any inherited class)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Note that any method that is stubbed (declared but not yet defined) in steps 1 or 2 skips straight to step 4, because it means this class thinks it &amp;ldquo;owns&amp;rdquo; a method of that name. (At this point Perl 5 would skip straight to step 5, but Perl 6 still wants to do wildcard delegation before falling back on inherited autoloading.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-anonymous-delegation-for-isa-emulation-anonymous-delegation-for-isa-emulation-span&#34;&gt;&lt;span id=&#34;anonymous_delegation_for_isa_emulation&#34;&gt;Anonymous Delegation for ISA Emulation&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;When you inherit from a class with a different layout policy, Perl has to emulate inheritance via anonymous delegation. In this case it installs a wildcard delegation for you. According to the list above, this gives precedence to all methods with the same layout policy over all methods with a different layout policy. This might be a feature, especially when calling cross-language. Then again, maybe it isn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;There is no &amp;ldquo;&lt;code&gt;has&lt;/code&gt;&amp;rdquo; variable for such an anonymous delegation. Its delegated object is stored as a property on the class&amp;rsquo;s entry in the ISA list, probably. (Or we could autogenerate an attribute whose name is related to the class name, I suppose.)&lt;/p&gt;

&lt;p&gt;Since one of the primary motivations for allowing this is to make it possible to call back and forth between Perl 5 and Perl 6 objects, we need to make that as transparent as possible. When a Perl 6 object inherits from a Perl 5 object, it is emulated with delegation. The invocant passed into the Perl 5 (Ponie) object looks like a Perl 5 object to Perl 5. However, if the Perl 5 object passes that as an invocant back into Perl 6, it has to go back to looking like a Perl 6 object to Perl 6, or our emulation of inheritance is suboptimal. When a Ponie object accesses its attributes through what it &lt;em&gt;thinks&lt;/em&gt; is a hash reference, it really has to call the appropriate Perl 6 accessor function if the object comes from Perl 6. Likewise, when Perl 6 calls an accessor on a Perl 5 object, it has to translate that method call into a hash lookup&amp;ndash;presuming that the Perl 5 object is implemented as a blessed hash.&lt;/p&gt;

&lt;p&gt;Other language boundaries may or may not do similar tricks. Python&amp;rsquo;s attributes suffer from the same misdesign as Perl 5&amp;rsquo;s attributes. (My fault for copying Python&amp;rsquo;s object model. &lt;code&gt;:-)&lt;/code&gt; So that&amp;rsquo;d be a good place for a similar policy.&lt;/p&gt;

&lt;p&gt;So we can almost certainly emulate inheritance with delegation, albeit with some possible misordering of classes if there are duplicate method names. However, the hard part is constructing objects. Perl 5 doesn&amp;rsquo;t enforce a policy of named arguments for its constructors, so it is difficult for a Perl 6 &lt;code&gt;BUILDALL&lt;/code&gt; routine to have any automatic way to call a Perl 5 constructor. It&amp;rsquo;s tempting to install glue code into the Perl 6 class that will do the translation, but that&amp;rsquo;s really not a good idea, because someday the Perl 5 class may eventually get translated to a Perl 6 class, and your glue code will be useless, or worse.&lt;/p&gt;

&lt;p&gt;So the right place to put the glue is actually back into the Perl 5 class. If a Perl 5 class defines a &lt;code&gt;BUILD&lt;/code&gt; subroutine, it will be assumed that it properly handles named pairs in Perl 5&amp;rsquo;s even/odd list format. That will be used in lieu of any predefined constructor named &amp;ldquo;&lt;code&gt;new&lt;/code&gt;&amp;rdquo; or anything else.&lt;/p&gt;

&lt;p&gt;If there is no &lt;code&gt;BUILD&lt;/code&gt; routine in the Perl 5 package, but there is a &amp;ldquo;&lt;code&gt;use fields&lt;/code&gt;&amp;rdquo; declaration, then we can autogenerate a rudimentary &lt;code&gt;BUILD&lt;/code&gt; routine that should suffice for most scalar attributes.&lt;/p&gt;

&lt;h3 id=&#34;span-id-types-and-subtypes-types-and-subtypes-span&#34;&gt;&lt;span id=&#34;types_and_subtypes&#34;&gt;Types and Subtypes&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve always really liked the Ada distinction between types and subtypes. A type is something that adds capabilities, while a subtype is something that takes away capabilities. Classes and roles generally function as types in Perl 6. In general you don&amp;rsquo;t want to make a subclass that, say, restricts your integers to only even numbers, because then you&amp;rsquo;ve violated Liskov substitutability. In the same way that we force role composition to be &amp;ldquo;before&amp;rdquo; classes, we will force subtyping constraints to be &amp;ldquo;after&amp;rdquo; classes. In both cases we force it by a declarator change so that you are unlikely to confuse a role with a class, or a class with a subtype. And just as you aren&amp;rsquo;t allowed to derive a role from a class, you aren&amp;rsquo;t allowed to derive a class from a constrained type.&lt;/p&gt;

&lt;p&gt;On the other hand, a bit confusingly, it looks like subtyping will be done with the &amp;ldquo;type&amp;rdquo; keyword, since we aren&amp;rsquo;t using that word yet.&lt;/p&gt;

&lt;p&gt;To remind people that a subtype of a class is just a constrained alias for the class, we avoid the &amp;ldquo;is&amp;rdquo; word and declare a type using a &lt;code&gt;::=&lt;/code&gt; compile-time alias, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    type Str_not2b ::= Str where /^[isnt|arent|amnot|aint]$/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;::=&lt;/code&gt; doesn&amp;rsquo;t create the type, nor in fact does the &lt;code&gt;type&lt;/code&gt; keyword. It&amp;rsquo;s actually the &lt;code&gt;where&lt;/code&gt; that creates the type. The &lt;code&gt;type&lt;/code&gt; keyword just marks the name as &amp;ldquo;not really a classname&amp;rdquo; so that you don&amp;rsquo;t accidentally try to derive from it.&lt;/p&gt;

&lt;p&gt;Since a type is &amp;ldquo;post-class-ical&amp;rdquo;, there&amp;rsquo;s really no such thing as an object blessed into a type. If you try it, you&amp;rsquo;ll just end up with an object blessed into whatever the underlying unconstrained class is, as far as inheritance is concerned. A type is not a subclass. A type is primarily a handy way of sneaking smartmatching into multiple dispatch. Just as a role allows you to specify something more general than a class, a type allows you to specify something more specific than a class.&lt;/p&gt;

&lt;p&gt;While types are primarily intended for restricting parameter types for multiple dispatch, they also let you impose preconditions on assignment. Basically, if you declare any container with a subtype, Perl will check the constraint against any value you might try to bind or assign to the container.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    type Str_not2b ::= Str where /^[isnt|arent|amnot|aint]$/;
    type EvenNum   ::= Num where { $^n % 2 == 0 }

    my Str_not2b $hamlet;
    $hamlet = &#39;isnt&#39;;   # Okay because &#39;isnt&#39; ~~ /^[isnt|arent|amnot|aint]$/
    $hamlet = &#39;amnt&#39;;   # Bzzzzzzzt!   &#39;amnt&#39; !~ /^[isnt|arent|amnot|aint]$/

    my EvenNum $n;
    $n = 2;             # Okay
    $n = -2;            # Okay
    $n = 0;             # Okay
    $n = 3;             # Bzzzzzzzt
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s perfectly legal to base one subtype on another. It merely adds an additional constraint.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s possible to use an anonymous subtype in a signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Rules::Common :profanity;

    multi sub mesg (Str where /&amp;lt;profanity&amp;gt;/ $mesg is copy) {
        $mesg ~~ s:g/&amp;lt;profanity&amp;gt;/[expletive deleted]/;
        print $MESG_LOG: $mesg;
    }

    multi sub mesg (Str $mesg) {
        print $MESG_LOG: $mesg;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Given a set of multimethods that would &amp;ldquo;tie&amp;rdquo; on the actual classes of the arguments, a multimethod with a matching constraint will be preferred over an equivalent one with no constraint. So the first &lt;code&gt;mesg&lt;/code&gt; above is preferred if the constraint matches, and otherwise the second is preferred. However, if two multis with constraints match (and are otherwise equivalent), it&amp;rsquo;s just as if you&amp;rsquo;d called any other set of ambiguous multimethods, and one of them had better be marked as the default, or you die.&lt;/p&gt;

&lt;p&gt;We say that types are &amp;ldquo;post-class-ical&amp;rdquo;, but since you can base them off of any class including &lt;code&gt;Any&lt;/code&gt;, they are actually rather orthogonal to the class system.&lt;/p&gt;

&lt;h3 id=&#34;span-id-enums-enums-span&#34;&gt;&lt;span id=&#34;enums&#34;&gt;Enums&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;An enum functions as a subtype that is constrained to a single value. (When a subtype is constrained to a single value, it can be used for that value.) But rather than declaring it as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    type DayOfWeek ::= Int where 0..6;
    type DayOfWeek::Sunday    ::= DayOfWeek where 0;
    type DayOfWeek::Monday    ::= DayOfWeek where 1;
    type DayOfWeek::Tuesday   ::= DayOfWeek where 2;
    type DayOfWeek::Wednesday ::= DayOfWeek where 3;
    type DayOfWeek::Thursday  ::= DayOfWeek where 4;
    type DayOfWeek::Friday    ::= DayOfWeek where 5;
    type DayOfWeek::Saturday  ::= DayOfWeek where 6;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we allow a shorthand:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    type DayOfWeek ::= int enum
        «Sunday Monday Tuesday Wednesday Thursday Friday Saturday»;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Type int is the default enum type, so that can be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    type DayOfWeek ::= enum
        «Sunday Monday Tuesday Wednesday Thursday Friday Saturday»;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The enum installer inspects the strings you give it for things that look like pairs, so to number your days from 1 to 7, you can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    type DayOfWeek ::= enum
        «:Sunday(1) Monday Tuesday Wednesday Thursday Friday Saturday»;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can import individual enums into your scope where they will function like argumentless constant subs. However, if there is a name collision with a sub or other enum, you&amp;rsquo;ll have to disambiguate. Unambiguous enums may be used as a property on the right side of a &amp;ldquo;but&amp;rdquo;, and the enum type can be intuited from it to make sure the object in question has the right semantics mixed in. Two builtin enums are:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    type bool ::= bit enum «false true»;
    type taint ::= bit enum «untainted tainted»;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-open-vs-closed-classes-open-vs-closed-classes-span&#34;&gt;&lt;span id=&#34;open_vs_closed_classes&#34;&gt;Open vs. Closed Classes&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;By default, classes in Perl are left open. That is, you can add more methods to them, though you have to be explicit that that is what you&amp;rsquo;re doing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Object is extended {
        method wow () { say &amp;quot;Wow, I&#39;m an object.&amp;quot; }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Otherwise you&amp;rsquo;ll get a class redefinition error.&lt;/p&gt;

&lt;p&gt;Likewise, a &amp;ldquo;final&amp;rdquo; class (to use the Java term) is one that you know will never be derived from, let alone mucked with internally.&lt;/p&gt;

&lt;p&gt;Now, it so happens that leaving all your classes open is not terribly conducive to certain kinds of optimization (let alone encapsulation). From the standpoint of the compiler, you&amp;rsquo;d like to be able to say, &amp;ldquo;I know this class will never be derived from or modified, so I can do things like access my attributes directly without going through virtual accessors.&amp;rdquo; We were, in fact, tempted to make closed classes the default. But this breaks in frameworks like mod_perl where you cannot predict in advance which classes will want to be extended or derived from.&lt;/p&gt;

&lt;p&gt;Some languages solve this (or think they solve it) by letting classes declare themselves to be closed and/or final. But that&amp;rsquo;s actually a bad violation of OO principles. It should be the &lt;em&gt;users&lt;/em&gt; of a class that decide such things&amp;ndash;and decide it for themselves, not for others. As such, there has to be a consensus among all users of a class to close or finalize it. And as we all know, consensus is difficult to achieve.&lt;/p&gt;

&lt;p&gt;Nevertheless, the Perl 6 approach is to give the top-level application the right to close (and finalize) classes. But we don&amp;rsquo;t do this by simply listing the classes we want to close. Instead, we use the sneaky strategy of switching the default to closed and then list the classes we want to stay open.&lt;/p&gt;

&lt;p&gt;The benefit of this is that modules other than the top level can simply list all the classes that they know should stay open. In an open framework, these are, at worst, no-ops, and they don&amp;rsquo;t cause classes to close that other modules might want to remain open. If &lt;em&gt;any&lt;/em&gt; module requests a class to stay open, it stays open. If &lt;em&gt;any&lt;/em&gt; module requests that a class remain available as a base class, it remains available.&lt;/p&gt;

&lt;p&gt;It has been speculated that optimizer technology in Parrot will develop such that a class can conjecturally be compiled as closed, and then recompiled as open should the need arise. (This is just a specific case of the more general problem of what you do whenever the assumptions of the optimizer are violated.) If we get such an on-the-fly optimizer/pessimizer, then our open class declarations are still not wasted&amp;ndash;they will tell the optimizer which classes not to bother trying to close or finalize in the first place. Setting the default the other way wouldn&amp;rsquo;t have the same benefit.&lt;/p&gt;

&lt;p&gt;Syntax? You want syntax? Hmm.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use classes :closed :open«Mammal Insect»;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or some such. Maybe certain kinds of class reference automatically request the class to be open without a special pragma. A module could request open classes without attempting to close everything with just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use classes :open«Mammal Insect»;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, maybe that&amp;rsquo;s another one of those inside-out interfaces, and it should just be options on the classes whose declarations you have to include anyway:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use classes :closed;
    class Mammal is open {...}
    class Insect is open {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, we can finalize classes by default and then &amp;ldquo;take it back&amp;rdquo; for certain classes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use classes :final;
    class Mammal is base {...}
    class Insect is base {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In any event, even though the default is expressed at the top of the main application, the final decision on each class is not made by the compiler until &lt;code&gt;CHECK&lt;/code&gt; time, when all the compiled code has had a chance to stake its claims. (A JIT compiler might well wait even longer, in case runtime evaluated code wishes to express an opinion.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-interface-consistency-interface-consistency-span&#34;&gt;&lt;span id=&#34;interface_consistency&#34;&gt;Interface Consistency&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In theory, a subclass should always act as a more specialized version of a superclass. In terms of the design-by-contract theory, a subclass should OR in its preconditions and AND in its postconditions. In terms of Liskov substitutability, you should always be able to substitute a derived class object in where a base class object is expected, and not have it blow up. In terms of Internet policy, a derived class (compared to its base class) should be at least as lenient in what it accepts, and at least as strict in what it emits.&lt;/p&gt;

&lt;p&gt;So, while it would be lovely in a way to require that derived methods of the same name as a base method must use the same signature, in practice that doesn&amp;rsquo;t work out. A derived class often has to be able to add arguments to the signature of a method so that it can &amp;ldquo;be more lenient&amp;rdquo; in what it accepts as input.&lt;/p&gt;

&lt;p&gt;But this poses a problem, insofar as the user of the derived object does not know whether all the methods of a given name support the same interface. Under &lt;code&gt;SUPER&lt;/code&gt; semantics, one can at least assume that the derived class will &amp;ldquo;weed out&amp;rdquo; any arguments that would be detrimental to its superclass. But as we have already pointed out, there isn&amp;rsquo;t a single superclass under MI, and each superclass might need to have different &amp;ldquo;detrimental arguments&amp;rdquo; weeded out. One could say that in that case, you don&amp;rsquo;t call &lt;code&gt;SUPER&lt;/code&gt; but rather call out to each superclass explicitly. But then you&amp;rsquo;re back to the problem that &lt;code&gt;SUPER&lt;/code&gt; was designed to solve. And you haven&amp;rsquo;t solved &lt;code&gt;SUPER&lt;/code&gt;&amp;rsquo;s problem either.&lt;/p&gt;

&lt;p&gt;Under &lt;code&gt;NEXT&lt;/code&gt; semantics, we assume that we are dispatching to a set of methods with the same name, but potentially different signatures. (Perl 6&amp;rsquo;s &lt;code&gt;SUPER&lt;/code&gt; implementation is really a limited form of &lt;code&gt;NEXT&lt;/code&gt;, insofar as &lt;code&gt;SUPER&lt;/code&gt; indicates a set of parent methods, unlike in Perl 5 where it picks one.) We need a way of satisfying different signatures with the same set of arguments.&lt;/p&gt;

&lt;p&gt;There are, in fact, two ways to approach this. One way is to say, okay everything is a multimethod, and we just won&amp;rsquo;t call anything whose signature is irreconcilably inconsistent with the arguments presented. Plus there are varying degrees of consistency within the set of &amp;ldquo;consistent&amp;rdquo; interfaces, so we try them in decreasing order of consistency. A more consistent multi is allowed to fall back to a less consistent multi with &amp;ldquo;&lt;code&gt;next      METHOD&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;But as a variant of the &amp;ldquo;pick one&amp;rdquo; mentality, that still doesn&amp;rsquo;t help the situation where you want to send a message to all your ancestor classes (like &amp;ldquo;Please Mr. Base Class, help me initialize this object.&amp;rdquo;), but you want to be more specific with some classes than others (&amp;ldquo;Please Miss Derived Class, set your &lt;code&gt;$.prim&lt;/code&gt; attribute to 1.&amp;ldquo;). So the other approach is to use named arguments that can be ignored by any classes that don&amp;rsquo;t grok the argument.&lt;/p&gt;

&lt;p&gt;So what this essentially comes down to is the fact that all methods and submethods of classes that might be derived from (which is essentially all classes, but see the previous section) must have a &lt;code&gt;*%&lt;/code&gt; parameter, either explicitly or implicitly, to collect up and render harmless any unrecognized option pairs in the argument list. So the ruling is that all methods and submethods that do not declare an explicit &lt;code&gt;*%&lt;/code&gt; parameter will get an implicit &lt;code&gt;*%_&lt;/code&gt; parameter declared for them whether they like it or not. (Subroutines are not granted this &amp;ldquo;favor&amp;rdquo;.)&lt;/p&gt;

&lt;p&gt;It might be objected that this will slow down the parameter binding algorithm for all methods favored with an implicit &lt;code&gt;*%_&lt;/code&gt;, but I would argue that the binding code doesn&amp;rsquo;t have to do anything till it sees a named parameter it doesn&amp;rsquo;t recognize, and then it can figure out whether the method even references &lt;code&gt;%_&lt;/code&gt;, and if not, simply throw the unrecognized argument away instead of constructing a &lt;code&gt;%_&lt;/code&gt; that won&amp;rsquo;t be used. And most of this &amp;ldquo;figuring out&amp;rdquo; can be done at compile time.&lt;/p&gt;

&lt;p&gt;Another counterargument is that this prevents a class from recognizing typos in argument names. That&amp;rsquo;s true. It might be possible to ask for a warning that checks globally (at class-finalization time in the optimizer?) to see if there is any method of that name anywhere that is interested in a parameter of that name. But any class that gets its parameters out of a &lt;code&gt;*%&lt;/code&gt; hash at runtime would cause false positives, unless we assume that any &lt;code&gt;*%&lt;/code&gt; hash makes any argument name legal, in which case we&amp;rsquo;re pretty much back to where we started, unless we do analysis of the usage of all &lt;code&gt;*%&lt;/code&gt; hash in those methods, and count things like &lt;code&gt;%_«prim»&lt;/code&gt; as proper parameter declarations. And that can still be spoofed in any number of ways. Plus it&amp;rsquo;s not a trivial warning to calculate, so it probably wouldn&amp;rsquo;t be the default in a load-and-go interpreter.&lt;/p&gt;

&lt;p&gt;So I think we basically have to live with possible typos to get proper polymorphic dispatch. If something is frequently misspelled, then you could always put in an explicit test against &lt;code&gt;%_&lt;/code&gt; for that argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    warn &amp;quot;Didn&#39;t you mean :the(%_«teh»)?&amp;quot; if %_«teh»;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And perhaps we could have a pragma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use signatures :exact;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it&amp;rsquo;s possible that the correct solution is to differentiate two kinds of &amp;ldquo;isa&amp;rdquo;, one that derives from &amp;ldquo;nextish&amp;rdquo; classes, and one that derives from &amp;ldquo;superish&amp;rdquo; classes. A &amp;ldquo;&lt;code&gt;next METHOD&lt;/code&gt;&amp;rdquo; traversal would assume that any delegation to a super class would be handled explicitly by the current class&amp;rsquo;s methods. That is, a &amp;ldquo;superish&amp;rdquo; inheritance hides the base class from &lt;code&gt;.*&lt;/code&gt; and &lt;code&gt;.+&lt;/code&gt;, as well as &amp;ldquo;&lt;code&gt;next METHOD&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;On the other hand, if we marked the super class itself, we could refrain from generating &lt;code&gt;*%&lt;/code&gt; parameters for its methods. Any &amp;ldquo;next&amp;rdquo; dispatcher would then have to &amp;ldquo;look ahead&amp;rdquo; to see if the next class was a &amp;ldquo;superish&amp;rdquo; class, and bypass it. I haven&amp;rsquo;t a clue what the syntax should be though. We could mark the class with a &amp;ldquo;superish&amp;rdquo; trait, which wouldn&amp;rsquo;t be inheritable. Or we could mark it with a Superish role, which would be inheritable, and a base class would have to override it to impose a Nextish role instead. (But then what if one parent class is Superish and one is Nextish?) Or we could even have two different metaclasses, if we decide the two kinds of classes are fundamentally different beasts. In that case we&amp;rsquo;d declare them differently using &amp;ldquo;class&amp;rdquo; and some other keyword. Of course, people will want to use &amp;ldquo;class&amp;rdquo; for the type they prefer, and the other keyword for the type they don&amp;rsquo;t prefer. :-)&lt;/p&gt;

&lt;p&gt;But since we&amp;rsquo;re attempting to bias things in favor of nextish semantics, that would be a &amp;ldquo;class&amp;rdquo;, and the superish semantics might be a &amp;ldquo;guthlophikralique&amp;rdquo; or some such. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Seriously, if we mark the class, &amp;ldquo;&lt;code&gt;is hidden&lt;/code&gt;&amp;rdquo; can hide the current class from &amp;ldquo;&lt;code&gt;next METHOD&lt;/code&gt;&amp;rdquo; semantics. The problem with that is, how do you apply the trait to a class in a different language? That argues for marking the &amp;ldquo;isa&amp;rdquo; instead. So as usual when we can&amp;rsquo;t make up our minds, we&amp;rsquo;ll just have it both ways. To mark the class itself, use &amp;ldquo;&lt;code&gt;is hidden&lt;/code&gt;&amp;rdquo;. To mark the &amp;ldquo;isa&amp;rdquo;, use &amp;ldquo;&lt;code&gt;hides Base&lt;/code&gt;&amp;rdquo; instead of &amp;ldquo;&lt;code&gt;is Base&lt;/code&gt;&amp;rdquo;. In neither case will &amp;ldquo;&lt;code&gt;next      METHOD&lt;/code&gt;&amp;rdquo; traverse to such a class. (And no &lt;code&gt;*%_&lt;/code&gt; will be autogenerated.)&lt;/p&gt;

&lt;p&gt;For example, here are two base classes that know about &amp;ldquo;&lt;code&gt;next METHOD&lt;/code&gt;&amp;ldquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Nextish1 { method dostuff() {...; next;}
    class Nextish2 { method dostuff() {...; next;}

    class MyClass is Nextish1 is Nextish2 {
        method dostuff () {...; next;}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since all the base classes are &amp;ldquo;next-aware&amp;rdquo;, &lt;code&gt;MyClass&lt;/code&gt; knows it can just defer to &amp;ldquo;next&amp;rdquo; and both parent classes&amp;rsquo; &lt;code&gt;dostuff&lt;/code&gt; methods will be called. However, suppose one of our base classes is old-fashioned and thinks it should call things with &lt;code&gt;SUPER::&lt;/code&gt; instead. (Or it&amp;rsquo;s a class off in Python or Ruby.) Then we have to write our classes more like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Superish { method dostuff(...; .*SUPER::dostuff(); }
    class Nextish { method dostuff() {...; next;}

    class MyClass hides Superish is Nextish {
        method dostuff () {
            .Superish::dostuff();       # do Superish::dostuff()
            next;                       # do Nextish::dostuff()
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here, &lt;code&gt;MyClass&lt;/code&gt; knows that it has two very different base classes. &lt;code&gt;Nextish&lt;/code&gt; knows about &amp;ldquo;&lt;code&gt;next&lt;/code&gt;&amp;rdquo;, and &lt;code&gt;Superish&lt;/code&gt; doesn&amp;rsquo;t. So it delegates to &lt;code&gt;Superish::dostuff()&lt;/code&gt; differently than it delegates to &lt;code&gt;Nextish::dostuff()&lt;/code&gt;. The fact that it declared &amp;ldquo;&lt;code&gt;hides Superish&lt;/code&gt;&amp;rdquo; prevents &lt;code&gt;next&lt;/code&gt; from visiting the Superish class.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-collections-of-classes-collections-of-classes-span&#34;&gt;&lt;span id=&#34;collections_of_classes&#34;&gt;Collections of Classes&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-in-classes-in-classes-span&#34;&gt;&lt;span id=&#34;in_classes&#34;&gt;In Classes&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;We&amp;rsquo;d like to be able to support virtual inner classes. You can&amp;rsquo;t have virtual inner classes unless you have a way to dispatch to the actual class of the invocant. That says to me that the solution is bound up intimately with the method dispatcher, and the syntax of naming an inner class has to know about the invocant in whose context we have to start searching for the inner class. So we could have an explicit syntax like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Base {
        our class Inner { ... }
        has Inner $inner;
        submethod BUILD { .makeinner; }
        method makeinner ($self:){
            my Inner $thing .= $self.Inner.new();
            return $thing;
        }
    }

    class Middle is Base {
        our class Inner is Base::Inner { ... }
    }

    class Derived is Middle {
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you say &lt;code&gt;Derived.new()&lt;/code&gt;, it creates a &lt;code&gt;Derived&lt;/code&gt; object, calls &lt;code&gt;Derived::BUILDALL&lt;/code&gt;, which eventually calls &lt;code&gt;Base::BUILD&lt;/code&gt;, which makes a &lt;code&gt;Middle::Inner&lt;/code&gt; object (because that&amp;rsquo;s what the virtual method &lt;code&gt;$self.Inner&lt;/code&gt; returns) and puts it in a variable that of the &lt;code&gt;Base::Inner&lt;/code&gt; type (which is fine, since &lt;code&gt;Middle::Inner&lt;/code&gt; ISA &lt;code&gt;Base::Inner&lt;/code&gt;. Whew!&lt;/p&gt;

&lt;p&gt;The only extra magic here is that an inner class would have to autogenerate an accessor method (of the same name) that returns the class. A class could then choose to access an inner class name directly, in which case it would get its own inner class of that name, much like &lt;code&gt;$.foo&lt;/code&gt; always gets you your own attribute. But if you called the inner class name as a method, it would automatically virtualize the name, and you&amp;rsquo;d get the most derived existing version of the class.&lt;/p&gt;

&lt;p&gt;This would give us most of what RFC 254 is asking for, at the expense of one more autogenerated method. Use of such inner classes would take the connivance of a base class that doesn&amp;rsquo;t mind if derived classes redefine its inner class. Unfortunately, it would have to express that approval by calling &lt;code&gt;$self.Inner&lt;/code&gt; explicitly. So this solution does not go as far as letting you change classes that didn&amp;rsquo;t expect to be changed.&lt;/p&gt;

&lt;p&gt;It would be possible to take it further, and I think we should. If we say that whenever you use any global class, it makes an inner class on your behalf that is merely an alias to the global class, creating the accessor method as if it were an inner class, then it&amp;rsquo;s possible to virtualize the name of &lt;em&gt;any&lt;/em&gt; class, as long as you&amp;rsquo;re in a context that has an appropriate invocant. Then we&amp;rsquo;d make any class name lookup assume &lt;code&gt;$self.&lt;/code&gt; on the front, basically.&lt;/p&gt;

&lt;p&gt;This may seem like a wild idea, but interestingly, we&amp;rsquo;re already proposing to do a similar aliasing in order to have multiple versions of a module running simultaneously. In the case of classes, it seems perfectly natural that a new version might derive from an older version rather than redefining everything.&lt;/p&gt;

&lt;p&gt;The one fly in the ointment that I can see is that we might not always have an appropriate invocant&amp;ndash;for instance, outside any method body, when we&amp;rsquo;re declaring attributes. I guess when there&amp;rsquo;s no dynamic context indicating what an &amp;ldquo;inner&amp;rdquo; classname should mean, it should default to the ordinary meaning in the current lexical and/or package context. Within a class definition, for instance, the invocant is the metaclass, which is unhelpful. So generally that means that a declared attribute type will turn out to be a superclass of the actual attribute type at runtime. But that&amp;rsquo;s fine, ain&amp;rsquo;t it? You can always store a &lt;code&gt;Beagle&lt;/code&gt; in a &lt;code&gt;Dog&lt;/code&gt; attribute.&lt;/p&gt;

&lt;p&gt;So in essence, it boils down to this. Within a method, the invocant is allowed to have opinions about the meanings of any class names, and when there are multiple possible meanings, pick the most appropriate one, where that amounts to the name you&amp;rsquo;d find if the class name were a virtual method name.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the example from RFC 254, translated to Perl 6 (with &lt;code&gt;Frog&lt;/code&gt; made into an explicit inner class for clarity (though it should work with any class by the aliasing rule above)):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Forest {
        our class Frog {
            method speak () { say &amp;quot;ribbit ribbit&amp;quot;; }
            method jump  () {...}
            method croak () {...} # ;-)
        }

        has Frog $.frog;

        method new ($class) {
            my Frog $frog .= new;       # MAGIC
            return $class.bless( frog =&amp;gt; $frog );
        }

        sub make_noise {
            .frog.speak;        # prints &amp;quot;ribbit ribbit&amp;quot;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we derive from &lt;code&gt;Forest&lt;/code&gt;, producing &lt;code&gt;Forest::Japanese&lt;/code&gt;, with its own kind of frogs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Forest::Japanese is Forest {
        our class Frog is Forest::Frog {
            method speak () { say &amp;quot;kerokero&amp;quot;; }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally, we make a forest of that type, and tell it to make a noise:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $forest = new Forest::Japanese;
    $forest.make_noise();               # prints &amp;quot;kerokero&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the Perl 5 equivalent, that would have printed &amp;ldquo;ribbit ribbit&amp;rdquo; instead. How did it do the right thing in Perl 6?&lt;/p&gt;

&lt;p&gt;The difference is on the line marked &amp;ldquo;&lt;code&gt;MAGIC&lt;/code&gt;&amp;rdquo;. Because &lt;code&gt;Frog&lt;/code&gt; was mentioned in a method, and the invocant was of type &lt;code&gt;Forest::Japanese&lt;/code&gt; rather than of type &lt;code&gt;Forest&lt;/code&gt;, the word &amp;ldquo;&lt;code&gt;Frog&lt;/code&gt;&amp;rdquo; figured out that it was supposed to mean a &lt;code&gt;Forest::Japanese::Frog&lt;/code&gt; rather than a &lt;code&gt;Forest::Frog&lt;/code&gt;. The name was &amp;ldquo;virtual&amp;rdquo;. So we ended up creating a forest with a frog of the appropriate type, even though it might not have occurred to the writer of &lt;code&gt;Forest&lt;/code&gt; that a subclass would override the meaning of &lt;code&gt;Frog&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;So one object can think that its &lt;code&gt;Frog&lt;/code&gt; is Japanese, while another thinks it&amp;rsquo;s Russian, or Mexican, or even Antarctican (if you can find any forests there). Base methods that talk about &lt;code&gt;Frog&lt;/code&gt; will automatically find the &lt;code&gt;Frog&lt;/code&gt; appropriate to the current invocant. This works even if &lt;code&gt;Frog&lt;/code&gt; is an outer class rather than an inner class, because any outer class referenced by a base class is automatically aliased into the class as a fake inner class. And the derived class doesn&amp;rsquo;t have to redefine its &lt;code&gt;Frog&lt;/code&gt; by declaring an inner class either. It can just alias (or use) a different outer &lt;code&gt;Frog&lt;/code&gt; class in as its fake inner class. Or even a different version of the same &lt;code&gt;Frog&lt;/code&gt; class, if there are multiple versions of it in the library.&lt;/p&gt;

&lt;p&gt;And it just works.&lt;/p&gt;

&lt;h4 id=&#34;span-id-in-modules-in-modules-span&#34;&gt;&lt;span id=&#34;in_modules&#34;&gt;In Modules&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s also possible to put a collection of classes into a module, but that doesn&amp;rsquo;t buy you much except the ability to pull them all in with one &lt;code&gt;use&lt;/code&gt;, and manage them all with one version number. Which has a lot to be said for it&amp;ndash;in the next section.&lt;/p&gt;

&lt;h3 id=&#34;span-id-versioning-versioning-span&#34;&gt;&lt;span id=&#34;versioning&#34;&gt;Versioning&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Way back at the beginning, we claimed that a file-scoped class declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog;
    ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to the corresponding block-scoped declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;While that&amp;rsquo;s true, it isn&amp;rsquo;t the whole truth. A file-scoped class (or module, or package) is the carrier of more metadata than a block-scoped declaration. Perl 6 supports a notion of versions that is file based. But even a class name plus a version is not sufficient to name a module&amp;ndash;there also has to be a naming authority, which could be a URI or a CPAN id. This will be discussed more fully in Apocalypse 11, but for now we can make some predictions.&lt;/p&gt;

&lt;p&gt;The extra metadata has to be associated with the file somehow. It may be implicit in the filename, or in the directory path leading to the file. If so, then Perl 6 has to collect up this information as modules are loaded and associate it with the top level class or module as a set of properties.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also possible that a module could declare properties explicitly to define these and other bits of metadata:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    author        http://www.some.com/~jrandom
    version       1.2.1
    creator       Joe Random
    description   This class implements camera obscura.
    subject       optics, boxes
    language      ja_JP
    licensed      Artistic|GPL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modules posted to CPAN or entered into any standard Perl 6 library are required to declare some set of these properties so that installations can know where to keep them, such that multiple versions by different authors can coexist, all of them available to any installed version of Perl. (This is a requirement for any Perl 6 installation. We&amp;rsquo;re tired of having to reinstall half of CPAN every time we patch Perl. We also want to be able to run different versions of the &lt;code&gt;Frog&lt;/code&gt; module simultaneously when the &lt;code&gt;Frog&lt;/code&gt; requirements of the modules we use are contradictory.)&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s possible that the metadata is supplied by both the declarations and by the file&amp;rsquo;s name or location in the library, but if so, it&amp;rsquo;s a fatal error to use a module for which those two sources contradict each other as to author or version. (In theory, it could also be a fatal error to use modules with incompatible licensing, but a kind warning might be more appreciated.) Likely there will also be some kind of automatic checksumming going on as well to prevent fraudulent distributions of code.&lt;/p&gt;

&lt;p&gt;It might simplify things if we make an &lt;code&gt;identifier&lt;/code&gt; metadatum that incorporates all of naming authority, package name, and version. But the individual parts still have to be accessible, if only as components of &lt;code&gt;identifier&lt;/code&gt;. However we structure it, we should make the &lt;code&gt;identifier&lt;/code&gt; the actual declared full name of the class, yet another one of those &amp;ldquo;long names&amp;rdquo; that include extra parameters.&lt;/p&gt;

&lt;h4 id=&#34;span-id-version-declarations-version-declarations-span&#34;&gt;&lt;span id=&#34;version_declarations&#34;&gt;Version Declarations&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The syntax of a versioned class declaration looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog-1.2.1-cpan:JRANDOM;
    class Dog-1.2.1-http://www.some.com/~jrandom
    class Dog-1.2.1-mailto:jrandom@some.com
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perhaps those could also have short forms, presuming we can distinguish CPAN ids, web pages, and email addresses by their internal forms.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class Dog-1.2.1-JRANDOM;
    class Dog-1.2.1-www.some.com/~jrandom;
    class Dog-1.2.1-jrandom@some.com;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or maybe using email addresses is a bad idea now in the modern Spam Age. Or maybe Spam Ages should be plural, like the Dark Ages&amp;hellip;&lt;/p&gt;

&lt;p&gt;In any event, such a declaration automatically aliases the full name of the class (or module) to the short name. So for the rest of the scope, &lt;code&gt;Dog&lt;/code&gt; refers to the longer name.&lt;/p&gt;

&lt;p&gt;(Though if you refer to &lt;code&gt;Dog&lt;/code&gt; within a method, it&amp;rsquo;s considered a virtual class name, so Perl will search any derived classes for a redefined inner &lt;code&gt;Dog&lt;/code&gt; class (or alias) before it settles on the least-derived aliased &lt;code&gt;Dog&lt;/code&gt; class.)&lt;/p&gt;

&lt;p&gt;We lied slightly when we said earlier that only the file-scoped class carries extra metadata. In fact, all of the classes (or modules, or packages) defined within your file carry metadata, but it so happens that the version and author of all your extra classes (or modules, or packages) are forced to be the same as the file&amp;rsquo;s version and author. This happens automatically, and you may not override the generation of these long names, because if you did, different file versions could and would have version collisions of their interior components, and that would be catastrophic. In general you can ignore this, however, since the long names of your extra classes are always automatically aliased back down to the short names you thought you gave them in the first place. The extra bookkeeping is in there only so that Perl can keep your classes straight when multiple versions are running at the same time. Just don&amp;rsquo;t be surprised when you ask for the name of the class and it tells you more than you expected.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-use-of-version-and-author-wildcards-use-of-version-and-author-wildcards-span&#34;&gt;&lt;span id=&#34;use_of_version_and_author_wildcards&#34;&gt;Use of Version and Author Wildcards&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Since these long names are the actual names of the classes, when you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Dog;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;re really asking for something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Dog-(Any)-(Any);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And when you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Dog-1.2.1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;re really asking for:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Dog-1.2.1-(Any);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;1.2.1&lt;/code&gt; specifies an &lt;em&gt;exact&lt;/em&gt; match on the version number. You might think that it should specify a minimum version. However, people who want stable software will specify an exact version and stick with it. They don&amp;rsquo;t want &lt;code&gt;1.2.1&lt;/code&gt; to mean a minimum version. They know &lt;code&gt;1.2.1&lt;/code&gt; works, so they want that version nailed down forever&amp;ndash;at least for now.&lt;/p&gt;

&lt;p&gt;To match more than one version, put a range operator in parens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Dog-(1.2.1..1.2.3);
    use Dog-(1.2.1..^1.3);
    use Dog-(1.2.1...);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What goes inside the parens is in fact any valid smartmatch selector:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Dog-(1.2.1 | 1.3.4)-(/:i jrandom/);
    use Dog-(Any)-(/^cpan\:/)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in fact they could be closures too. These means the same thing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Dog-{$^ver ~~ 1.2.1 | 1.3.4}-{$^auth ~~ /:i jrandom/};
    use Dog-{$^ver ~~ Any}-{$^auth ~~ /^cpan\:/}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In any event, however you select the module, its full name is automatically aliased to the short name for the rest of your lexical scope. So you can just say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog $spot .= new(&amp;quot;woof&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and it knows (even if you don&amp;rsquo;t) that you mean&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog-1.3.4-cpan:JRANDOM $spot .= new(&amp;quot;woof&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Again, if you refer to &lt;code&gt;Dog&lt;/code&gt; within a method, it&amp;rsquo;s a virtual class name, so Perl will search any derived classes for a redefined &lt;code&gt;Dog&lt;/code&gt; class before it settles on the outermost aliased &lt;code&gt;Dog&lt;/code&gt; class.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-introspection-introspection-span&#34;&gt;&lt;span id=&#34;introspection&#34;&gt;Introspection&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s easy to specify what Perl 6 will provide for introspection: the union of what Perl 6 needs and whatever Parrot provides for other languages. &lt;code&gt;;-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In the particular case of class metadata, the interface should generally be via the class&amp;rsquo;s metaclass instance&amp;ndash;the object of type &lt;code&gt;MetaClass&lt;/code&gt; that was in charge of building the class in the first place. The metamethods are in the metaobject, not in the class object. (Well, actually, those are the same object, but a class object ignores the fact that it&amp;rsquo;s also a metaobject, and dispatches by default to its own methods, not the ones defined by the metaclass.) To get to the metamethods of an ordinary class object you have to use the &lt;code&gt;.meta&lt;/code&gt; method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    MyClass.getmethods()        # call MyClass&#39;s .getmethods method
    MyClass.meta.getmethods()   # get the method list of MyClass
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unless &lt;code&gt;MyClass&lt;/code&gt; has defined or inherited a &lt;code&gt;.getmethods&lt;/code&gt; method, the first call is an error. The second is guaranteed to work for Perl 6&amp;rsquo;s standard &lt;code&gt;MetaClass&lt;/code&gt; objects. You can also call &lt;code&gt;.meta&lt;/code&gt; on any ordinary object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.meta.getmethods();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.dispatcher.meta.getmethods();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As for which parts of a class are considered metadata&amp;ndash;they all are, if you scratch hard enough. Everything that is not stored directly as a trait or property really ought to have some kind of trait-like method to access it. Even the method body closures have to be accessible as traits, since the &lt;code&gt;.wrap&lt;/code&gt; method needs to have something to put its wrapper around.&lt;/p&gt;

&lt;p&gt;Minimally, we&amp;rsquo;ll have user-specified class traits that look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    identifier    Dog-1.2.1-http://www.some.com/~jrandom
        name      Dog
        version   1.2.1
        authority http://www.some.com/~jrandom
    author        Joe Random
    description   This class implements camera obscura.
    subject       optics, boxes
    language      ja_JP
    licensed      Artistic|GPL
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there may be internal traits like these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    isa           list of parent classes
    roles         list of roles
    disambig      how to deal with ambiguous method names from roles
    layout        P6opaque, P6hash, P5hash, P5array, PyDict, Cstruct, etc.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;layout&lt;/code&gt; determines whether one class can actually derive from another or has to fake it. Any P6opaque class can compatibly inherit from any other P6opaque class, but if it inherits from any P5 class, it must use some form of delegation to another invocant. (Hopefully with a smart enough invocant reference that, if the delegated object unknowingly calls back into our layout system, we can recover the original object reference and maintain some kind of compositional integrity.)&lt;/p&gt;

&lt;p&gt;The metaclass&amp;rsquo;s &lt;code&gt;.getmethods&lt;/code&gt; method returns method-descriptor objects with at least the following properties:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    name                the name of the method
    signature           the parameters of the method
    returns             the return type of the method
    multi               whether duplicate names are allowed
    do                  the method body
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;.getmethods&lt;/code&gt; method has a selector parameter that lets you specify whether you want to see a flattened or hierarchical view, whether you&amp;rsquo;re interested in private methods, and so forth. If you want a hierarchical view, you only get the methods actually defined in the class proper. To get at the others, you follow the &amp;ldquo;isa&amp;rdquo; trait to find your parent classes&amp;rsquo; methods, and you follow the &amp;ldquo;roles&amp;rdquo; trait to get to role methods, and from parents or roles you may also find links to further parents or roles.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;.getattributes&lt;/code&gt; method returns a list of attribute descriptors that have traits like these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    name
    type
    scope
    rw
    private
    accessor
    build
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Additionally they can have any other variable traits that can reasonably be applied to object attributes, such as &lt;code&gt;constant&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Strictly speaking, metamethods like &lt;code&gt;.isa()&lt;/code&gt;, &lt;code&gt;.does()&lt;/code&gt;, and &lt;code&gt;.can()&lt;/code&gt; should be called through the meta object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.meta.can(&amp;quot;bark&amp;quot;)
    $obj.meta.does(Dog)
    $obj.meta.isa(Mammal)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And they can always be called that way. For convenience you can often omit the &lt;code&gt;.meta&lt;/code&gt; call because the base &lt;code&gt;Object&lt;/code&gt; type translates any unrecognized &lt;code&gt;.foo()&lt;/code&gt; into &lt;code&gt;.meta.foo()&lt;/code&gt; if the meta class has a method of that name. But if a derived class overrides such a metamethod, you have to go through the &lt;code&gt;.meta&lt;/code&gt; call explicitly to get the original call.&lt;/p&gt;

&lt;p&gt;In previous Apocalypses we said that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj ~~ Dog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;calls:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.isa(Dog)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is not longer the case&amp;ndash;you&amp;rsquo;re actually calling:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.meta.does(Dog)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is true if &lt;code&gt;$obj&lt;/code&gt; either &amp;ldquo;does&amp;rdquo; or &amp;ldquo;isa&amp;rdquo; &lt;code&gt;Dog&lt;/code&gt; (or &amp;ldquo;isa&amp;rdquo; something that &amp;ldquo;does&amp;rdquo; &lt;code&gt;Dog&lt;/code&gt;). That is, it asks if &lt;code&gt;$obj&lt;/code&gt; is likely to satisfy the interface that comes from the &lt;code&gt;Dog&lt;/code&gt; role or class. The &lt;code&gt;.isa&lt;/code&gt; method, by contrast, is strictly asking if &lt;code&gt;$obj&lt;/code&gt; inherits from the &lt;code&gt;Dog&lt;/code&gt; class. It&amp;rsquo;s erroneous to call it on a role. Well, okay, it&amp;rsquo;s not strictly erroneous. It will just never return true. The optimizer will love you, and remove half your code.&lt;/p&gt;

&lt;p&gt;Note that either of &lt;code&gt;.does&lt;/code&gt; or &lt;code&gt;.isa&lt;/code&gt; can lie, insofar as you might include an interface that you later override parts of. When in doubt, rely on &lt;code&gt;.can&lt;/code&gt; instead. Better yet, rely on your dispatcher to pick the right method without trying to second guess it. (And then be prepared to catch the exception if the dispatcher throws up its hands in disgust&amp;hellip;)&lt;/p&gt;

&lt;p&gt;By the way, unlike in Perl 5 where &lt;code&gt;.can&lt;/code&gt; returns a single routine reference, Perl 6&amp;rsquo;s version of &lt;code&gt;.meta.can&lt;/code&gt; returns a &amp;ldquo;WALK&amp;rdquo; iterator for a set of routines that match the name. When dereferenced, the iterator gets fed to a dispatcher as if the method had been called in the first place. Note that any wildcard methods (via delegation or &lt;code&gt;AUTOLOAD&lt;/code&gt;) are included by default in this list of potential handlers, so there is no reason for subclasses to have to redefine &lt;code&gt;.can&lt;/code&gt; to reflect the new names. This does potentially weaken the meaning of &lt;code&gt;.can&lt;/code&gt; from &amp;ldquo;definitely has a method of this name&amp;rdquo; to &amp;ldquo;definitely has one or more methods in one or more classes that will try to handle this.&amp;rdquo; But that&amp;rsquo;s probably closer to what you want, and the best we can do when people start fooling around with wildcard methods under MI.&lt;/p&gt;

&lt;p&gt;However, that being said, many classes may wish to dynamically specify at the last moment which methods they can or cannot handle. That is, they want a hook to allow a class to declare names even while the &lt;code&gt;.can&lt;/code&gt; candidate list is being built. By default &lt;code&gt;.meta.can&lt;/code&gt; includes all wildcard delegations and autoloads at the end of the list. However, it will exclude from the list of candidates any class that defines its own &lt;code&gt;AUTOMETH&lt;/code&gt; method, on the assumption that each such &lt;code&gt;AUTOMETH&lt;/code&gt; method has already had its chance to add any callable names to the list. If the class&amp;rsquo;s &lt;code&gt;AUTOMETH&lt;/code&gt; wishes to supply a method, it should return a reference to that method.&lt;/p&gt;

&lt;p&gt;Do not confuse &lt;code&gt;AUTOMETH&lt;/code&gt; with &lt;code&gt;AUTOMETHDEF&lt;/code&gt;. The former is equivalent to declaring a stub declaration. The latter is equivalent to supplying a body for an existing stub. Whether &lt;code&gt;AUTOMETH&lt;/code&gt; actually creates a stub, or &lt;code&gt;AUTOMETHDEF&lt;/code&gt; actually creates a body, is entirely up to those routines. If they wish to cache their results, of course, then they should create the stub or body.&lt;/p&gt;

&lt;p&gt;There are corresponding &lt;code&gt;AUTOSUB&lt;/code&gt; and &lt;code&gt;AUTOSUBDEF&lt;/code&gt; hooks. And &lt;code&gt;AUTOVAR&lt;/code&gt; and &lt;code&gt;AUTOVARDEF&lt;/code&gt; hooks. These all pretty much make &lt;code&gt;AUTOLOAD&lt;/code&gt; obsolete. But &lt;code&gt;AUTOLOAD&lt;/code&gt; is still there for old times&amp;rsquo;s sake.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-other-nonoo-decisions-other-non-oo-decisions-span&#34;&gt;&lt;span id=&#34;other_nonoo_decisions&#34;&gt;Other Non-OO Decisions&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A lot of time went by while I was in the hospital last year, so we ended up polishing up the design of Perl 6 in a number of areas not directly related to OO. Since I&amp;rsquo;ve already got your attention (and we&amp;rsquo;re already 90% of the way through this Apocalypse), I might as well list these decisions here.&lt;/p&gt;

&lt;h4 id=&#34;span-id-exportation-exportation-span&#34;&gt;&lt;span id=&#34;exportation&#34;&gt;Exportation&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The trait we&amp;rsquo;ll use for exportation (typically from modules but also from classes pretending to be modules) is &lt;code&gt;export&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                               # Tagset...
    sub foo is export(:DEFAULT)         {...}  #  :DEFAULT, :ALL
    sub bar is export(:DEFAULT :others) {...}  #  :DEFAULT, :ALL, :others
    sub baz is export(:MANDATORY)       {...}  #  (always exported)
    sub bop is export                   {...}  #  :ALL
    sub qux is export(:others)          {...}  #  :ALL, :others
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Compared to Perl 5, we&amp;rsquo;ve basically made it easier to mark something as exportable, but more difficult to export something by default. You no longer have to declare your tagsets separately, since &lt;code&gt;:foo&lt;/code&gt; parameters are self-declaring, and the module will automatically build the tagsets for you from the export trait arguments.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-gather-take-construct-the-gather-take-construct-span&#34;&gt;&lt;span id=&#34;the_gather/take_construct&#34;&gt;The Gather/Take Construct&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;We used one example of the conjectural gather/take construct. A gather executes a closure, returning a list of all the values returned by &lt;code&gt;take&lt;/code&gt; within its lexical scope. In a lazy context it might run as a coroutine. There probably ought to be a dynamically scoped variant. Unless it should be dynamic by default, in which case there probably ought to be a lexically scoped variant&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;span-id-foo-adverbs-foo-adverbs-span&#34;&gt;&lt;span id=&#34;:foo()_adverbs&#34;&gt;:foo() Adverbs&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;There&amp;rsquo;s a new pair syntax that is more conducive to use as option arguments. This syntax is reminiscent of both the Unix command line syntax and the I/O layers syntax of Perl 5. But unlike Unix command-line options, we use colon to introduce the option rather than the overly negative minus sign. And unlike Perl 5&amp;rsquo;s layers options, you can use these outside of a string.&lt;/p&gt;

&lt;p&gt;We haven&amp;rsquo;t discarded the old pair syntax. It&amp;rsquo;s still more readable for certain uses, and it allows the key to be a non-identifier. Plus we can define the new syntax in terms of it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                         New
    ---                         ---
    foo =&amp;gt; $bar                 :foo($bar)
    foo =&amp;gt; [1,2,3,@many]        :foo[1,2,3,@many]
    foo =&amp;gt; «alice bob charles»  :foo«alice bob charles»
    foo =&amp;gt; &#39;alice&#39;              :foo«alice»
    foo =&amp;gt; { a =&amp;gt; 1, b =&amp;gt; 2 }   :foo{ a =&amp;gt; 1, b =&amp;gt; 2 }
    foo =&amp;gt; { dostuff() }        :foo{ dostuff() }
    foo =&amp;gt; 0                    :foo(0)
    foo =&amp;gt; 1                    :foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s that last one that&amp;rsquo;s the real winner for passing boolean options. One other nice thing is that if you have several options in a row you don&amp;rsquo;t have to put commas between:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $handle = open $file, :chomp :encoding«guess» :ungzip or die &amp;quot;Oops&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It might be argued that this conflicts the :foo notation for private methods. I don&amp;rsquo;t think it&amp;rsquo;s a problem because method names never occur in isolation.&lt;/p&gt;

&lt;p&gt;Oh, one other feature of option pairs is that certain operations can use them as adverbs. For instance, you often want to tell the range operator how much to skip on each iteration. That looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1..100 :by(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that this only works where an operator is expected rather than a term. So there&amp;rsquo;s no confusion between:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    randomlistop 1..100 :by(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    randomlistop 1..100, :by(3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the latter case, the option is being passed to &lt;code&gt;randomlistop()&lt;/code&gt; rather than the &lt;code&gt;infix:..&lt;/code&gt; operator.&lt;/p&gt;

&lt;h4 id=&#34;span-id-special-quoting-of-identifiers-inside-curlies-going-away-special-quoting-of-identifiers-inside-curlies-going-away-span&#34;&gt;&lt;span id=&#34;special_quoting_of_identifiers_inside_curlies_going_away!&#34;&gt;Special Quoting of Identifiers Inside Curlies Going Away!&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Novice Perl 5 programmers are continually getting trapped by subscripts that autoquote unexpectedly. So in Perl 6, we&amp;rsquo;ll remove that special case. %hash{shift} now always calls the shift function, because the inside of curlies is always an expression. Instead, if you want to subscript a hash with a constant string, or a slice of constant strings, use the new French qw//-ish brackets like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash«alice»                # same as %hash{&#39;alice&#39;}
    %hash«alice bob charlie»    # same as %hash{&#39;alice&#39;,&#39;bob&#39;,&#39;charlie&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note in particular that, since slices in Perl 6 are determined by the subscript only, not the sigil, this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash«alice» = @x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;evaluates the right side in scalar context, while&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash«alice bob charlie» = @x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;evaluates the right side in list context. As with all other uses of the French quotes in Perl 6, you can always use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash&amp;lt;&amp;lt;alice&amp;gt;&amp;gt; = @x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if you can&amp;rsquo;t figure out how to type &lt;code&gt;^K&amp;lt;&amp;lt; or ^K&amp;gt;&amp;gt;&lt;/code&gt; in vim.&lt;/p&gt;

&lt;p&gt;On the other hand, if you&amp;rsquo;ve got a fully Unicode aware editor, you could probably write some macros to use the big double angles from Asian languages:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash《alice》 = @x;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But by default we only provide the Latin-1 compatible versions. It would be easy to overuse Unicode in Perl 6, so we&amp;rsquo;re trying to underuse Unicode for small values of 6. (Not to be confused with ⁶, or ⅵ.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-vector-operators-renamed-back-to-hyper-operators-vector-operators-renamed-back-to-hyper-operators-span&#34;&gt;&lt;span id=&#34;vector_operators_renamed_back_to_hyper_operators&#34;&gt;Vector Operators Renamed Back to &amp;ldquo;hyper&amp;rdquo; Operators&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The mathematicians got confused when we started talking about &amp;ldquo;vector&amp;rdquo; operators, so these dimensionally dwimming versions of scalar operators are now called hyper operators (again). Some folks see operations like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a »*« @b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;as totally useless, and maybe they are&amp;ndash;to a mathematician. But to someone simply trying to calculate a bunch of things in parallel (think cellular automata, or aerodynamic simulations, for instance), they make a lot of sense. And don&amp;rsquo;t restrict your thinking to math operators. How about appending a newline to every string before printing it out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print @strings »~« &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @strings {say}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is a shorter way to do the same thing. (&amp;rdquo;&lt;code&gt;say&lt;/code&gt;&amp;rdquo; is just Perl 6&amp;rsquo;s version of a printline function.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-unary-hyper-operators-now-use-one-quote-rather-than-two-unary-hyper-operators-now-use-one-quote-rather-than-two-span&#34;&gt;&lt;span id=&#34;unary_hyper_operators_now_use_one_quote_rather_than_two&#34;&gt;Unary Hyper Operators Now Use One Quote Rather Than Two&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Unary operators read better if they only &amp;ldquo;hyper&amp;rdquo; on the side where there&amp;rsquo;s an actual argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @neg = -« @pos;
    @indexes = @x »++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And in particular, I consider a method spec like &lt;code&gt;.bletch(1,2,3)&lt;/code&gt; to be a unary postfix operator, and it would be really ugly to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @objects».bletch(1,2,3)«
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So that&amp;rsquo;s just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @objects».bletch(1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In general, binary operators still take &amp;ldquo;hypers&amp;rdquo; on both sides, indicating that both sides participate in the dwimmery.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a »+« @a
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To indicate that one side or the other should be evaluated as a scalar before participating in the hyperoperator, you can always put in a context specifier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a »+« +@a
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-thumb-twiddle-no-longer-requires-parens-when-interpolated-thumb-twiddle-no-longer-requires-parens-when-interpolated-span&#34;&gt;&lt;span id=&#34;$thumb.twiddle_no_longer_requires_parens_when_interpolated&#34;&gt;&lt;code&gt;$thumb.twiddle&lt;/code&gt; No Longer Requires Parens When Interpolated&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;In Apocalypse 2 we said that any method interpolated into a double-quoted string has to have parentheses. We&amp;rsquo;re throwing out that special rule in the interests of consistency. Now if you want to interpolate a variable followed by an &amp;ldquo;accidental&amp;rdquo; dot, use one of these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $($var).twiddle
    $var\.twiddle
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, that will make it a little harder to translate Perl 5 to Perl 6.&lt;/p&gt;

&lt;p&gt;(Parentheses are still required if there are any arguments, however.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-identity-operator-the-identity-operator-span&#34;&gt;&lt;span id=&#34;the_=:=_identity_operator&#34;&gt;The =:= Identity Operator&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;There is a new &lt;code&gt;=:=&lt;/code&gt; identity operator, which tests to see if two objects are the same object. The association with the &lt;code&gt;:=&lt;/code&gt; binding operator should be obvious. (Some classes such as integers may consider all objects of the same value to be a single object, in a Platonic sense.)&lt;/p&gt;

&lt;p&gt;Hmm? No, there is no associated assignment operator. And if there were, I wouldn&amp;rsquo;t tell you about it. Sheesh, some people&amp;hellip;&lt;/p&gt;

&lt;p&gt;But there is, of course, a hyper version:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a »=:=« @b
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-new-grammatical-categories-new-grammatical-categories-span&#34;&gt;&lt;span id=&#34;new_grammatical_categories&#34;&gt;New Grammatical Categories&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The current set of grammatical categories for operator names is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Category                            Example of use
    --------                            --------------
    coerce:as                           123 as BigInt, BigInt(123)
    self:sort                           @array.=sort
    term:...                            $x = {...}
    prefix:+                            +$x
    infix:+                             $x + $y
    postfix:++                          $x++
    circumfix:[]                        [ @x ]
    postcircumfix:[]                    $x[$y] or $x .[$y]
    rule_modifier:p5                    m:p5//
    trait_verb:handles                  has $.tail handles «wag»
    trait_auxiliary:shall               my $x shall conform«TR123»
    scope_declarator:has                has $.x;
    statement_control:if                if $condition {...} else {...}
    infix_postfix_meta_operator:=       $x += 2;
    postfix_prefix_meta_operator:»      @array »++
    prefix_postfix_meta_operator:«      -« @magnitudes
    infix_circumfix_meta_operator:»«    @a »+« @b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, you may be thinking that some of these have long, unwieldy names. You&amp;rsquo;d be right. The longer the name, the longer you should think before adding a new operator of that category. (And the length of time you should think probably scales exponentially with the length of the name.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S12.html&#34;&gt;Synopsis 12&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-assignment-to-state-variable-declaration-now-does-first-semantics-assignment-to-state-variable-declaration-now-does-first-semantics-span&#34;&gt;&lt;span id=&#34;assignment_to_state_variable_declaration_now_does_first_semantics.&#34;&gt;Assignment to &lt;code&gt;state&lt;/code&gt; Variable Declaration Now Does &amp;ldquo;First&amp;rdquo; Semantics&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As we talked about earlier, assignment to a &amp;ldquo;&lt;code&gt;has&lt;/code&gt;&amp;rdquo; variable is really pseudo-assignment representing a call to the &amp;ldquo;&lt;code&gt;build&lt;/code&gt;&amp;rdquo; trait. In the same way, assignment to &lt;code&gt;state&lt;/code&gt; variables (Perl&amp;rsquo;s version of lexically scoped &amp;ldquo;static&amp;rdquo; variables), is taken as pseudo-assignment representing a call to the &amp;ldquo;&lt;code&gt;first&lt;/code&gt;&amp;rdquo; trait. The first time through a piece of code is when state variables typically like to be initialized. So saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    state $pc = $startpc;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    state $pc is first( $startpc );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which means that it will pay attention to the &lt;code&gt;$startpc&lt;/code&gt; variable only the first time this block is ever executed. Note that any side effects within the expression will only happen the first time through. If you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    state $x = $y++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then that statement will only ever increment &lt;code&gt;$y&lt;/code&gt; once. If that&amp;rsquo;s not what you want, then use a real assignment as a separate statement:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    state $x;
    $x = $y++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;:=&lt;/code&gt; and &lt;code&gt;.=&lt;/code&gt; operators also attempt to do what you mean, which in the case of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    state $x := $y++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;still probably doesn&amp;rsquo;t do what you want. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In general, any &amp;ldquo;preset&amp;rdquo; trait is smart about when to apply its value to the container it&amp;rsquo;s being applied to, such that the value is set statically if that&amp;rsquo;s possible, and if that&amp;rsquo;s not possible, it is set dynamically at the &amp;ldquo;correct&amp;rdquo; moment.&lt;/p&gt;

&lt;p&gt;For ordinary assignment to a &amp;ldquo;&lt;code&gt;my&lt;/code&gt;&amp;rdquo; variable, that correct moment just happens to be every time it is executed, so &lt;code&gt;=&lt;/code&gt; represents ordinary assignment. If you want to force an initial value at execution time that was calculated earlier, however, then just use ordinary assignment to assign the results of a precalculated block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @canines = INIT { split slurp &amp;quot;%ENV«HOME»/.canines&amp;quot; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s only the &lt;code&gt;has&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; declarators that redefine assignment to set defaults with traits. (For &lt;code&gt;has&lt;/code&gt;, that&amp;rsquo;s because the actual attribute variable won&amp;rsquo;t exist until the object is created. For &lt;code&gt;state&lt;/code&gt;, that&amp;rsquo;s because we want the default to be &amp;ldquo;first time through&amp;rdquo;.) But you can use any of the traits on any variable for which it makes sense. For instance, just because we invented the &amp;ldquo;&lt;code&gt;first&lt;/code&gt;&amp;rdquo; initializer for state variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    state $lexstate is first(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;doesn&amp;rsquo;t mean you can&amp;rsquo;t use it to initialize any variable only the first time through a block of code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $foo is first(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, it probably doesn&amp;rsquo;t make a lot of sense on a &amp;ldquo;&lt;code&gt;my&lt;/code&gt;&amp;rdquo; variable, unless you really want it to be undefined the second time through. It does make a little more sense on an &amp;ldquo;&lt;code&gt;our&lt;/code&gt;&amp;rdquo; variable that will hang onto its value like a state variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our $counter is first(0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An assignment would often be wrong in this case. But generally, the naive user can simply use assignment, and it will usually do what they want (if occasionally more often than they want). But it does exactly what they want on &lt;code&gt;has&lt;/code&gt; and &lt;code&gt;state&lt;/code&gt; variables&amp;ndash;presuming they are savvy enough to want what it actually does&amp;hellip; &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;So as with &lt;code&gt;has&lt;/code&gt; variables, &lt;code&gt;state&lt;/code&gt; variables can be initialized with precomputed values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    state $x = BEGIN { calc() }
    state $x = CHECK { calc() }
    state $x = INIT  { calc() }
    state $x = FIRST { calc() }
    state $x = ENTER { calc() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which mean something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    state $x is first( BEGIN { calc() } )
    state $x is first( CHECK { calc() } )
    state $x is first( INIT  { calc() } )
    state $x is first( FIRST { calc() } )
    state $x is first( ENTER { calc() } )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note, however, that the last one doesn&amp;rsquo;t in fact make much sense, since &lt;code&gt;ENTER&lt;/code&gt; happens more frequently than &lt;code&gt;FIRST&lt;/code&gt;. Come to think of it, doing &lt;code&gt;FIRST&lt;/code&gt; inside a &lt;code&gt;first&lt;/code&gt; doesn&amp;rsquo;t buy you much either&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-length-function-is-gone-the-length-function-is-gone-span&#34;&gt;&lt;span id=&#34;the_length()_function_is_gone&#34;&gt;The &lt;code&gt;length()&lt;/code&gt; Function Is Gone&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;In Perl 6 you&amp;rsquo;re not going to see&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $sizeofstring = length($string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s because &amp;ldquo;length&amp;rdquo; has been deemed to be an insufficiently specified concept, because it doesn&amp;rsquo;t specify the units. Instead, if you want the length of something in characters you use&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $sizeinchars = chars($string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and if you want the size in elements, you use&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $sizeinelems = elems(@array);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is more orthogonal in some ways, insofar as you can now ask for the size in chars of an array, and it will add up all the lengths of the strings in it for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $sizeinchars = chars(@array);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if you ask for the number of elems of a scalar, it knows to dereference it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $ref = [1,2,3];
    my $sizeinelems = elems($ref);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These are, in fact, just generic object methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array.elems
    $string.chars
    @array.chars
    $ref.elems
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the functional forms are just multimethod calls. (Unless they&amp;rsquo;re indirect object calls&amp;hellip;who knows?)&lt;/p&gt;

&lt;p&gt;You can also use &lt;code&gt;%hash.elems&lt;/code&gt;, which returns the number of pairs in the hash. I don&amp;rsquo;t think &lt;code&gt;%hash.chars&lt;/code&gt; is terribly useful, but it will tell you how many characters total there are in the values. (The key lengths are ignored, just like the integer &amp;ldquo;keys&amp;rdquo; of an ordinary array.)&lt;/p&gt;

&lt;p&gt;Actually, the meaning of &lt;code&gt;.chars&lt;/code&gt; varies depending on your current level of Unicode support. To be more specific, there&amp;rsquo;s also:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $string.bytes
    $string.codepoints
    $string.graphemes
    $string.letters
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;none of which should be confused with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $string.columns
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or its evil twin:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $string.pixels
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those last two require knowledge of the current font and rendering engine, in fact. Though &lt;code&gt;.columns&lt;/code&gt; is likely to be pretty much the same for most Unicode fonts that restrict themselves to single and double-wide characters.&lt;/p&gt;

&lt;h4 id=&#34;span-id-string-positions-string-positions-span&#34;&gt;&lt;span id=&#34;string_positions&#34;&gt;String Positions&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A corollary to the preceding is that string positions are not numbers. If you say either&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $pos = index($string, &amp;quot;foo&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $string ~~ /foo/; $pos = $string.pos;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then &lt;code&gt;$pos&lt;/code&gt; points to that location in that string. If you ask for the numeric value of &lt;code&gt;$pos&lt;/code&gt;, you&amp;rsquo;ll get a number, but which number you get can vary depending on whether you&amp;rsquo;re currently treating characters as bytes, codepoints, graphemes, or letters. When you pass a &lt;code&gt;$pos&lt;/code&gt; to &lt;code&gt;substr($string, $pos, 3)&lt;/code&gt;, you&amp;rsquo;ll get back &amp;ldquo;&lt;code&gt;foo&lt;/code&gt;&amp;rdquo;, but not because it counted over some number of characters. If you use &lt;code&gt;$pos&lt;/code&gt; on some other string, then it has to interpret the value numerically in the current view of what &amp;ldquo;character&amp;rdquo; means. In a boolean context, a position is true if the position is defined, even if that position would evaluate to 0 numerically. (&lt;code&gt;index&lt;/code&gt; and &lt;code&gt;rindex&lt;/code&gt; return undef when they &amp;ldquo;run out&amp;rdquo;.)&lt;/p&gt;

&lt;p&gt;And, in fact, when you say &lt;code&gt;$len = .chars&lt;/code&gt;, you&amp;rsquo;re really getting back the position of the end of the string, which just happens to numerify to the number of characters in the string in the current view. A consequence of the preceding rules is that &lt;code&gt;&amp;quot;&amp;quot;.chars&lt;/code&gt; is true, but &lt;code&gt;+&amp;quot;&amp;quot;.chars&lt;/code&gt; is false. So Perl 5 code that says &lt;code&gt;length($string)&lt;/code&gt; needs to be translated to &lt;code&gt;+chars($string)&lt;/code&gt; if used in a boolean context.&lt;/p&gt;

&lt;p&gt;Routines like &lt;code&gt;substr&lt;/code&gt; and &lt;code&gt;index&lt;/code&gt; take either positions or integers for arguments. Integers will automatically be turned into positions in the current view. This may involve traversing the string for variable-width representations, especially when working with combining characters as parts of graphemes. Once you&amp;rsquo;re working with abstract positions, however, they are efficient. So&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while $pos = index($string, &amp;quot;fido&amp;quot;, $pos + 1) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;never has to rescan the string.&lt;/p&gt;

&lt;p&gt;The other point of all this is that you can pass &lt;code&gt;$pos&lt;/code&gt; or &lt;code&gt;$len&lt;/code&gt; to another module, and &lt;em&gt;it doesn&amp;rsquo;t matter&lt;/em&gt; if you&amp;rsquo;re doing offsets in graphemes and they are doing offsets in codepoints. They get the correct position by their lights, even though the number of characters looks different. The main constraint on this is that if you pass a position from a lower Unicode support level to a higher Unicode support level, you can end up with a position that is inside what you think of as a unitary character, whether that&amp;rsquo;s a byte within a codepoint, or a codepoint within a grapheme or letter. If you deref such a position, an exception is thrown. But generally high-level routines call into low-level routines, so the issue shouldn&amp;rsquo;t arise all that often in practice. However, low-level routines that want to be called from high-level routines should strive not to return positions inside high-level characters&amp;ndash;the fly in the ointment being that the low-level routine doesn&amp;rsquo;t necessarily know the Unicode level expected by the calling routine. But we have a solution for that&amp;hellip;&lt;/p&gt;

&lt;p&gt;High-level routines that suspect they may have a &amp;ldquo;partial position&amp;rdquo; can call &lt;code&gt;$pos.snap&lt;/code&gt; (or &lt;code&gt;$pos.=snap&lt;/code&gt;) to round up to the next integral position in the current view, or (much less commonly) &lt;code&gt;$pos.snapback&lt;/code&gt; (or &lt;code&gt;$pos.=snapback&lt;/code&gt;) to round down to the next integral position in the current view. This only biases the position rightward or leftward. It doesn&amp;rsquo;t actually do any repositioning unless we&amp;rsquo;re about to throw an exception. So this allows the low-level routine to return &lt;code&gt;$pos.snap&lt;/code&gt; without knowing at the time how far forward to snap. The actual snapping is done later when the high-level routine tries to use the position, and at that point we know which semantics to snap forward under.&lt;/p&gt;

&lt;p&gt;By the way, if you bind to a position rather than assign, it tracks the string in question:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $string = &amp;quot;xyz&amp;quot;;
    my $endpos := $string.chars;        # $endpos == 3
    substr($string,0,0,&amp;quot;abc&amp;quot;);          # $endpos == 6, $string = &amp;quot;abcxyz&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Deletions of string around a position cause the position to be reduced to the beginning of the deletion. Insertions at a position are assumed to be after that position. That is, the position stays pointing to the beginning of the newly inserted string, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $string = &amp;quot;xyz&amp;quot;;
    my $endpos := $string.chars;        # $endpos == 3
    substr($string,2,1,&amp;quot;abc&amp;quot;);          # $endpos == 2, $string = &amp;quot;xyabc&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hence concatenation never updates any positions. Which means that sometimes you just have to call &lt;code&gt;.chars&lt;/code&gt; again&amp;hellip; (Perhaps we&amp;rsquo;ll provide a way to optionally insert before any matching position.)&lt;/p&gt;

&lt;p&gt;Note that positions try very hard not to get demoted to integers. In particular, position objects overload addition and substraction such that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $string.chars - 1
    index($string, &amp;quot;foo&amp;quot;) + 2
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;are still position objects with an implicit reference into the string. (Subtracting one position object from another results in an integer, however.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-new-separator-in-regexen-the-new-separator-in-regexen-span&#34;&gt;&lt;span id=&#34;the_new_&amp;_separator_in_regexen&#34;&gt;The New &amp;ldquo;&amp;amp;&amp;rdquo; Separator in Regexen&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Analogous to the disjunctional &lt;code&gt;|&lt;/code&gt; separator, we&amp;rsquo;re also putting in a conjunctional &lt;code&gt;&amp;amp;&lt;/code&gt; separator into our regex syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;DOG&amp;quot; ~~ /D [ &amp;lt;vowel&amp;gt;+ &amp;amp; &amp;lt;upper&amp;gt;+ ] G/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The semantics of it are pretty straightforward, as long as you realize that all of the AND&amp;rsquo;ed assertions have to match &lt;em&gt;with the same length&lt;/em&gt;. More precisely, they have to start and stop matching at the same location. So the following is always going to be false:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / . &amp;amp; .. /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It would be possible to have the other semantics where, as long as the trailing assertion matches either way, it doesn&amp;rsquo;t have to match the trailing assertion the &lt;em&gt;same&lt;/em&gt; way. But then tell me whether &lt;code&gt;$1&lt;/code&gt; should return &amp;ldquo;&lt;code&gt;O&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;G&lt;/code&gt;&amp;rdquo; after this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;DOG&amp;quot; ~~ /^[. &amp;amp; ..] (.)/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Besides, it&amp;rsquo;s easy enough to get the other semantics with lookahead assertions. Autoanchoring all the legs of a conjunction to the same spot adds much more value to it by differentiating it from lookahead. You have to work pretty hard to make separate lookaheads match the same length. Plus doing that turns what should be a symmetric operator into a non-symmetrical one, where the final lookahead can&amp;rsquo;t be a lookahead because someone has to &amp;ldquo;eat&amp;rdquo; the characters that all the assertions have agreed on are the right number to eat. So for all these reasons it&amp;rsquo;s better to have a conjunction operator with complicated enough start/stop semantics to be useful.&lt;/p&gt;

&lt;p&gt;Actually, this operator was originally suggested to me by a biologist. Which leads us to our&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-optional-mandatory-crossdisciplinary-joke-for-people-tired-of-dogs-optional-mandatory-cross-disciplinary-joke-for-people-tired-of-dogs-span&#34;&gt;&lt;span id=&#34;optional_mandatory_crossdisciplinary_joke_for_people_tired_of_dogs&#34;&gt;Optional Mandatory Cross-Disciplinary Joke for People Tired of Dogs&lt;/span&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;    Biologist: What&#39;s worse than being chased by a Velociraptor?
    Physicist: Obviously, being chased by an Acceloraptor.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-future-directions-future-directions-span&#34;&gt;&lt;span id=&#34;future_directions&#34;&gt;Future Directions&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Away from Acceloraptors, obviously.&lt;/p&gt;

&lt;h3 id=&#34;span-id-references-er-reference-references-er-reference-span&#34;&gt;&lt;span id=&#34;references...er,_reference...&#34;&gt;References&amp;hellip;er, Reference&amp;hellip;&lt;/span&gt;&lt;/h3&gt;

&lt;pre&gt;&lt;code&gt;Nathanael Schärli, Stéphane Ducasse, Oscar Nierstrasz and Andrew Black. 
    Traits: Composable Units of Behavior. European Conference on Object-Oriented 
    Programming (ECOOP), July 2003. Springer LNCS 2743, Ed. Luca Cardelli. 
&lt;/code&gt;&lt;/pre&gt;
</description>
    </item>
    
    <item>
      <title>State of the Onion 2003</title>
      <link>http://localhost:1313/pub/2003/07/16/soto2003.html/</link>
      <pubDate>Wed, 16 Jul 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/07/16/soto2003.html/</guid>
      <description>&lt;p&gt;This is the 7th annual State of the Perl Onion speech, wherein I tell you how Perl is doing. Perl is doing fine, thank you. Now that that&amp;rsquo;s out of the way, I&amp;rsquo;d like to spend the rest of the time telling jokes.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide1.jpg&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
In fact, the conference organizers have noticed that I spend most of the time telling jokes. So each year they give me a little less time, so I have to chop out more of the serious subject matter so as to leave time for the jokes.&lt;/p&gt;

&lt;p&gt;Extrapolating several years into the future, they&amp;rsquo;ll eventually chop my time down to ten seconds. I&amp;rsquo;ll have just enough time to say: &amp;ldquo;I&amp;rsquo;m really, really excited about what is happening with Perl this year. And I&amp;rsquo;d like to announce that, after lengthy negotiations, Guido and I have finally decided&amp;hellip; &amp;lt;gong&amp;gt; [&amp;ldquo;Time&amp;rsquo;s up. Next speaker please&amp;rdquo;]&lt;/p&gt;

&lt;p&gt;Well, you didn&amp;rsquo;t really want to know that anyway&amp;hellip;&lt;/p&gt;

&lt;p&gt;Since this is a State of the Union speech, or State of the Onion, in the particular case of Perl, I&amp;rsquo;m supposed to tell you what Perl&amp;rsquo;s current state is. But I already told you that the current state of Perl is just fine. Or at least as fine as it ever was. Maybe a little better.&lt;/p&gt;

&lt;p&gt;But what you really want to know about is the future state of Perl. That&amp;rsquo;s nice. I don&amp;rsquo;t know much about the future of Perl. Nobody does. That&amp;rsquo;s part of the design of Perl 6. Since we&amp;rsquo;re designing it to be a mutable language, it will probably mutate. If I did know the future of Perl, and if I told you, you&amp;rsquo;d probably run away screaming.&lt;/p&gt;

&lt;p&gt;As I was meditating on this subject, thinking about how I don&amp;rsquo;t know the future of Perl, and how you probably don&amp;rsquo;t &lt;em&gt;want&lt;/em&gt; to know it anyway, I was reminded of a saying that I first saw posted in the 1960&amp;rsquo;s. You may feel like this on some days.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We the unwilling,
led by the unknowing,
are doing the impossible
for the ungrateful.
We have done so much for so long with so little
We are now qualified to do anything with nothing&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide2.jpg&#34; alt=&#34;blue collar&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
I think of it as the Blue-Collar Worker&amp;rsquo;s Creed.&lt;/p&gt;

&lt;p&gt;This has been attributed to various people, none of whom are Ben Franklin, Abraham Lincoln, or Mark Twain. My favorite attribution is to Mother Teresa. She may well have quoted it, but I don&amp;rsquo;t think she coined it, because I don&amp;rsquo;t think Mother Teresa thought of herself as &amp;ldquo;unwilling&amp;rdquo;. After all, Mother Teresa got a Nobel prize for being one of the most willing people on the face of the earth.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also been attributed to the Marines in Vietnam, and it certainly fits a little better. But since I grew up in a Navy town, I&amp;rsquo;d like to think it was invented by a civilian shipyard worker working for the Navy. In any event, I first saw it posted in a work area at Puget Sound Naval Shipyard back in the 1960&amp;rsquo;s. Now, you may well wondering what I was doing in a Naval Shipyard in the 1960&amp;rsquo;s. That&amp;rsquo;s a secret.&lt;/p&gt;

&lt;p&gt;Anyway, you may also be wondering why I brought it up at all. Well, last year I used the table of contents from an issue of Scientific American as my outline. This year I&amp;rsquo;d like to use this as my outline.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d like to, but I won&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;But if I did, here&amp;rsquo;s what I&amp;rsquo;d say.&lt;/p&gt;

&lt;p&gt;From the postmodern point of view, this is a text that needs to be deconstructed. It was obviously written by someone in a position of power pretending not to be. And by making light of the plight of blue collar workers, and allowing the oppressed workers to post this copy-machine meme in the workplace, this white-collar wolf in blue-collar sheep&amp;rsquo;s clothing has managed to persuade the oppressed workers that being powerless is something to be proud of.&lt;/p&gt;

&lt;p&gt;Now, some of you young folks are too steeped in postmodernism to know anything about postmodernism, so let&amp;rsquo;s review. Postmodernism in its most vicious form started out with the notion that there exist various cultural constructs, or texts, or memes, that allow some human beings to oppress other human beings. Of course, in Soviet Russia it&amp;rsquo;s the other way around. Which is why they managed to deconstruct themselves, I guess.&lt;/p&gt;

&lt;p&gt;Anyway, deconstructionism is all about throwing out the bad cultural memes, where &amp;ldquo;bad&amp;rdquo; is defined as anything an oppressed person doesn&amp;rsquo;t like. Which is fine as far as it goes, but the spanner in the works is that you can only be an oppressed person if the deconstructionists say you are. Dead white males need not apply. Fortunately, I&amp;rsquo;m not dead yet. Though I&amp;rsquo;m trying. As some of you know, several weeks ago I was in the hospital with a bleeding ulcer. I guess I&amp;rsquo;m a little like Soviet Russia. I oppress myself, so I deconstruct myself.&lt;/p&gt;

&lt;p&gt;Oh, by the way, I got better. In case you hadn&amp;rsquo;t noticed.&lt;/p&gt;

&lt;p&gt;Though I&amp;rsquo;m not allowed to drink anything brown anymore. Sigh. That&amp;rsquo;s why this speech is so boring — I wrote it under the non-influence.&lt;/p&gt;

&lt;p&gt;But back to postmodernism. Postmodern critics have invented a notation for using a word and denying its customary meaning at the same time, since most customary meanings are oppressive to someone or other, and if not, they ought to be. Or something like that.&lt;/p&gt;

&lt;p&gt;Anyway, I&amp;rsquo;m going to borrow that notation for my own oppressive purposes, and strike out a few of these words that don&amp;rsquo;t mean exactly what I want them to mean. I hope that doesn&amp;rsquo;t make me a postmodern critic. Or maybe it does. As Humpty Dumpty said, the question is who&amp;rsquo;s to be master, that&amp;rsquo;s all.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s start by striking out &amp;ldquo;unwilling&amp;rdquo;, because there are quite a few willing people around here. Or at least willful.&lt;/p&gt;

&lt;p&gt;And let&amp;rsquo;s strike out &amp;ldquo;unknowing&amp;rdquo; too, because you wouldn&amp;rsquo;t be sitting here listening to us leaders here tonight if you thought we didn&amp;rsquo;t know anything. On the other hand, maybe you just came for the jokes&amp;hellip;&lt;/p&gt;

&lt;p&gt;Now let&amp;rsquo;s strike out the &amp;ldquo;impossible&amp;rdquo;. Actually, I hesitate to strike that one out, because what we&amp;rsquo;re trying to do with Perl is to be all things to all people, and in the long run that is completely impossible, technically, socially, and theologically speaking.&lt;/p&gt;

&lt;p&gt;But that doesn&amp;rsquo;t stop us from trying. And who knows, maybe more of it is possible than we imagine.&lt;/p&gt;

&lt;p&gt;We definitely have to strike out ungrateful, because we know many people are grateful. Nevertheless, a number of people find it impossible to be grateful, and we should be working to please them as well. Love your enemies, and all that. Another impossible task. Or&amp;hellip; perhaps the same one.&lt;/p&gt;

&lt;p&gt;I like to please people who did not expect to be pleased. One day when I was a lot younger than I am now, I performed a piece on my violin. A lady came up to me afterward and said, &amp;ldquo;You know, I don&amp;rsquo;t like the violin. But I liked that.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;I treasure that sort of compliment, just as I treasure the email messages that say, &amp;ldquo;I had given up on computer programming because it wasn&amp;rsquo;t any fun, and then I discovered Perl.&amp;rdquo; That&amp;rsquo;s what I mean when I say we should work to please the people who don&amp;rsquo;t expect to be grateful.&lt;/p&gt;

&lt;p&gt;Anyway, back to our Creed here. I can&amp;rsquo;t see anything wrong with the last two lines. In fact, they&amp;rsquo;re directly applicable.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We have done so much for so long with so little&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That&amp;rsquo;s Perl 5.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;We are now qualified to anything with nothing.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;That&amp;rsquo;s Perl 6. I suppose I need to strike that out too, since it doesn&amp;rsquo;t really exist yet, except in our heads.&lt;/p&gt;

&lt;p&gt;Well, maybe that&amp;rsquo;s not such a bad outline after all. Let&amp;rsquo;s talk a little more about those things.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide10.jpg&#34; alt=&#34;the unwilling&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
&amp;gt; We the unwilling&lt;/p&gt;

&lt;p&gt;Here in the open source community, we&amp;rsquo;re willing to help out, but that&amp;rsquo;s because we&amp;rsquo;re &lt;em&gt;not&lt;/em&gt; willing to put up with the status quo. And that&amp;rsquo;s generally due to our inflated sense of Laziness, Impatience, and Hubris. But then a really funny thing happens. A number of us will get together and agree about something that needs doing because of our Laziness, Impatience, and Hubris, and then we&amp;rsquo;ll start working on that project with a great deal of industriousness, patience, and humility, which seem to be the very opposite qualities to those that motivated us in the first place.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve tried to figure out a rationale for that, but I&amp;rsquo;ve pretty much come to the conclusion that it&amp;rsquo;s not rational or reasonable. It&amp;rsquo;s just who we are. Here&amp;rsquo;s a favorite quotation of mine.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&amp;ldquo;The reasonable man adapts himself to the world; the unreasonable one persists in trying to adapt the world to himself. Therefore all progress depends on the unreasonable man.&amp;rdquo;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think that all of us agree that this is true. We just can&amp;rsquo;t always agree on what to be unreasonable about. Of course, this was written by George Bernard Shaw, who had his own ideas of the most reasonable ways to be unreasonable. This is, after all, the guy who wrote Pygmalion, upon which the musical My Fair Lady was based, with dear old &amp;lsquo;Enry &amp;lsquo;Iggins and Eliza Dolit&amp;rsquo;le going at each other&amp;rsquo;s throats. And over linguistics of all things. Fancy that.&lt;/p&gt;

&lt;p&gt;The only problem with this quote is that it&amp;rsquo;s false. A lot of progress comes from unreasonable women.&lt;/p&gt;

&lt;p&gt;Well, okay, maybe Shaw meant &amp;ldquo;he or she&amp;rdquo; when he only said &amp;ldquo;he&amp;rdquo;. Still, if we&amp;rsquo;re going to please unreasonable people in the twenty-first century, maybe we need to rewrite it like this:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide11.jpg&#34; alt=&#34;strike out man and him&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
On the other hand, some people are impossible to please. We should probably just strike out &amp;ldquo;George Bernard Shaw&amp;rdquo; since he&amp;rsquo;s a dead white male.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide13.jpg&#34; alt=&#34;unknowing&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
&amp;gt; We the unwilling, led by the unknowing&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s me all over. Which is what the bug said after he hit the windshield.&lt;/p&gt;

&lt;p&gt;Or as the bug&amp;rsquo;s friend said, &amp;ldquo;Bet you don&amp;rsquo;t have the guts to do that again.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Whether I have the guts to do Perl again is another question. My guts are still in sad shape at the moment, according to the doctor&amp;hellip;&lt;/p&gt;

&lt;p&gt;Anyway, back to &amp;ldquo;me the unknowing&amp;rdquo;. I admit that there&amp;rsquo;s an awful lot that I don&amp;rsquo;t know. I&amp;rsquo;d love to tell you how much I don&amp;rsquo;t know, but I don&amp;rsquo;t know that either.&lt;/p&gt;

&lt;p&gt;So I&amp;rsquo;ll have to talk about what I know instead. If you are so inclined, you may infer that I am totally oblivious to anything I don&amp;rsquo;t talk about today.&lt;/p&gt;

&lt;p&gt;One thing I do know about is the universal architectural diagram. It looks like this.&lt;/p&gt;

&lt;p&gt;It doesn&amp;rsquo;t have to be chartreuse. How about pink, to match the fireworks up in the corner. I put the fireworks up in the corner there in case you missed the fireworks on the 4th of July.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide14.jpg&#34; alt=&#34;pink&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Anyway, this is the universal architectural diagram because you can represent almost any architecture with it, if you try hard enough. Here&amp;rsquo;s a common enough one:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide15.jpg&#34; alt=&#34;CPU&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Here we have a bus that&amp;rsquo;s common across the other three components of our computer, the memory, the CPU, and the I/O system. Within the computer we have other entities such as strings, which you can view either as a whole or as a sequence of characters.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide16.jpg&#34; alt=&#34;string&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
An integer is just like a string, only it&amp;rsquo;s a sequence of bits.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide17.jpg&#34; alt=&#34;integer&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
We can go from very small ideas like integers to very large ideas like government:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide18.jpg&#34; alt=&#34;government&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Or even alternate forms of government.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide19.jpg&#34; alt=&#34;Borg&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
The diagram is even more versatile because you can rotate it on its side.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide20.jpg&#34; alt=&#34;plain&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt; &lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide21.jpg&#34; alt=&#34;right&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Now, for some reason, this particular orientation seems to engender the most patriotism. It might just be accidental, but if you color it like this&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide22.jpg&#34; alt=&#34;flag&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
people start thinking about saluting it. Kinda goes with the fireworks, I guess.&lt;/p&gt;

&lt;p&gt;A little more dangerous is this diagram.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide23.jpg&#34; alt=&#34;object&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
It&amp;rsquo;s amazing how many people will salute that one. And people will even go to war for this one:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide24.jpg&#34; alt=&#34;class&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
But you know, the whole notion of objects like this is that there are ways in which you treat them as a single thing, and ways in which you treat them as multiple things. Every structured object is wrapped up in its own identity. That&amp;rsquo;s really what this little diagram is getting at.&lt;/p&gt;

&lt;p&gt;Well, let&amp;rsquo;s keep rotating it and see what we get.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide26.jpg&#34; alt=&#34;rotate&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt; &lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide27.jpg&#34; alt=&#34;God&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Okay, if you happen to be a Christian of the trinitarian persuasion like me, then you believe that God is a structured object that is simultaneously singular and plural depending on how you look at it. Of course, nobody ever fights about that sort of thing, right?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide28.jpg&#34; alt=&#34;plain&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt; &lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide29.jpg&#34; alt=&#34;left&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
It&amp;rsquo;s kind of unusual to see the diagram in this orientation, probably due to linguistic considerations.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide30.jpg&#34; alt=&#34;one out of many&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
But whether you say &amp;ldquo;one out of many&amp;rdquo; or &amp;ldquo;e pluribus unum&amp;rdquo;,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide31.jpg&#34; alt=&#34;pluribus&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
it means much the same thing. In a language that reads left to right, perhaps it&amp;rsquo;s more naturally suited to processes that lose information, such as certain kinds of logic.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide32.jpg&#34; alt=&#34;or&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Again, we can go from the very small to the very large.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide33.jpg&#34; alt=&#34;black hole&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
If you feed three random planets to a black hole, you also lose information. Or at least you hide it very well, depending on your theory of how black holes work.&lt;/p&gt;

&lt;p&gt;If you feed one of these diagrams to a black hole, it turns into a piece of spaghetti.&lt;/p&gt;

&lt;p&gt;But let&amp;rsquo;s not, and say we did.&lt;/p&gt;

&lt;p&gt;Oddly enough, what I&amp;rsquo;d really like to talk about today is Perl. If we look at our goal for the Parrot project, it looks something like this.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide37.jpg&#34; alt=&#34;Borg Parrot&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Oops, wrong slide.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide38.jpg&#34; alt=&#34;Parrot&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
That is, Parrot is designed to be a single engine upon which we can run both Perl 5 and Perl 6. And&amp;hellip; stuff. Admittedly, this is a rather Perl-centric view of reality, to the extent you can call this reality.&lt;/p&gt;

&lt;p&gt;Well, okay, I&amp;rsquo;ll cheat and show you the other stuff we&amp;rsquo;d like to do.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide39.jpg&#34; alt=&#34;detail&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
We&amp;rsquo;d also like to support, for example, PHP, Ruby, Python, BASIC, Scheme, COBOL, Java, Befunge, TECO, Rebol, REXX, and&amp;hellip; I can&amp;rsquo;t quite make out that one on the bottom there. And if I could, I wouldn&amp;rsquo;t say it anyway, because there are children present, and I wouldn&amp;rsquo;t want to fuck up their brains.&lt;/p&gt;

&lt;p&gt;Okay, I admit this is not quite reality yet. I just put in all those languages because I&amp;rsquo;m a white male who is trying to oppress you before I&amp;rsquo;m quite dead. So I&amp;rsquo;d better strike out a few things that aren&amp;rsquo;t really there yet.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide40.jpg&#34; alt=&#34;strikes&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Could I interest you in a really fast BASIC interpreter?&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide41.jpg&#34; alt=&#34;Parrot + BASIC&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Well, it&amp;rsquo;s time to move on to our next point.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide42.jpg&#34; alt=&#34;impossible&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
&amp;gt; We the unwilling, led by the unknowing, are doing the impossible.&lt;/p&gt;

&lt;p&gt;Is what we&amp;rsquo;re doing really impossible? It&amp;rsquo;s possible. But we won&amp;rsquo;t know till we try. More precisely, till we finish trying. Sometimes things seem impossible to us, but maybe that&amp;rsquo;s just because we&amp;rsquo;re all slackers.&lt;/p&gt;

&lt;p&gt;And because we oversimplify.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s take another look at the pink tennis court. I mean, the universal architectural diagram. It really isn&amp;rsquo;t quite as universal as I&amp;rsquo;ve made it out to be. First, let&amp;rsquo;s get rid of the pink.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide43.jpg&#34; alt=&#34;black&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Maybe I should give equal time to blue.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide44.jpg&#34; alt=&#34;blue&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Nah.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide43.jpg&#34; alt=&#34;black&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Anyway, as I was saying, this isn&amp;rsquo;t universal enough. Here&amp;rsquo;s the real universal diagram.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide46.jpg&#34; alt=&#34;line widget&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
This is what&amp;rsquo;s known as an impossible object. I like it. I&amp;rsquo;m impossible object oriented. This particular impossible object is often called a widget. But you knew that already.&lt;/p&gt;

&lt;p&gt;What you might not have known is that, up till now, it&amp;rsquo;s been thought impossible to color such an object accurately. But as you can see,&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide47.jpg&#34; alt=&#34;colorized&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
that is false. There are still some perceptual difficulties with it, but I&amp;rsquo;m sure &lt;em&gt;that&lt;/em&gt; problem is just a relic of our reptile brain. Or was it our bird brain. I forget. In any event, if you have trouble perceiving this object correctly, just use the universal clarification tool.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide48.jpg&#34; alt=&#34;cloud&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
I&amp;rsquo;ll assume you can supply your own cloud from now on.&lt;/p&gt;

&lt;p&gt;Should be easy here in Portland&amp;hellip; I&amp;rsquo;m allowed to make jokes about Portland because I grew up in the Pacific Northwet.&lt;/p&gt;

&lt;p&gt;As you can see, this more accurate universal architectural diagram can actually be rotated in 3-d with properly simulated lighting.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide49.jpg&#34; alt=&#34;rotate&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt; &lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide50.jpg&#34; alt=&#34;rotate&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt; &lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide51.jpg&#34; alt=&#34;rotate&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt; &lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide52.jpg&#34; alt=&#34;rotate&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
It&amp;rsquo;s extensible.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide53.jpg&#34; alt=&#34;6comb&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt; &lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide54.jpg&#34; alt=&#34;12comb&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Comb structures are important in a programming language. That&amp;rsquo;s why we&amp;rsquo;re adding a switch statement to Perl 6.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also a more accurate representation of Parrot.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide55.jpg&#34; alt=&#34;parrot&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
It&amp;rsquo;s also more sophisticated linguistically.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide56.jpg&#34; alt=&#34;widget&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Not only can it represent singular and plural concepts, but also the old Indo-European notion of dual objects.&lt;/p&gt;

&lt;p&gt;We still have vestiges of that in English.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide57.jpg&#34; alt=&#34;oxen&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
One ox, many oxes, two oxen yoked together pulling your plow.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide58.jpg&#34; alt=&#34;regexen&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Or one regex, many regexes, but two regexen working together.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide59.jpg&#34; alt=&#34;Vaxen&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
You always wanted to know the proper name for a two-headed Vax?&lt;/p&gt;

&lt;p&gt;Everything is possible. You should be grateful.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide60.jpg&#34; alt=&#34;ungrateful&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
On to the ungrateful undead.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s been a lot of carping lately about how slow Perl 6 development is going. Some of it comes from well intentioned folks, but some of it comes from our poison pen pals who live in the troll house. Still, I think a lot of the criticism shows a lack of understanding of the basic laws of development. These laws can be illustrated with this diagram:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide61.jpg&#34; alt=&#34;widget&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Basically, perfect development is impossible. Development can be fast, good, and cheap. Pick two.&lt;/p&gt;

&lt;p&gt;Actually, that&amp;rsquo;s unrealistic.&lt;/p&gt;

&lt;p&gt;Pick one.&lt;/p&gt;

&lt;p&gt;Which one would you pick? You want fast? You want cheap? No, I think you want this one.&lt;/p&gt;

&lt;p&gt;Good.&lt;/p&gt;

&lt;p&gt;Good design is neither fast nor cheap. Every time we crank out a new chunk of the design of Perl 6 or of Parrot, it&amp;rsquo;s a bit like writing a master&amp;rsquo;s thesis. It&amp;rsquo;s a lot of reading, and a lot of writing, and a lot of thinking, and a lot of email, and a lot of phone conferences. It&amp;rsquo;s really complicated and multidimensional.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide62.jpg&#34; alt=&#34;escher&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
There&amp;rsquo;s a lot going on behind the scenes that you don&amp;rsquo;t hear about every day. Many people have sacrificed to give us time to work on these things. People have donated their own time and money to it. O&amp;rsquo;Reilly and Associates have donated phone conferences and other infrastructure. The Perl 6 design team in particular has borne a direct financial cost but also a tremendous opportunity cost in pursuing this at the expense of career and income. I&amp;rsquo;m not looking for sympathy, but I want you to know that I almost certainly could have landed a full-time job 20 months ago if I&amp;rsquo;d been willing to forget about Perl 6. I&amp;rsquo;m extremely grateful for the grants the Perl Foundation has been able to give toward the Perl 6 effort. But I just want you to know that it&amp;rsquo;s costing us more than that.&lt;/p&gt;

&lt;p&gt;But Perl 6 is all about freedom, and that&amp;rsquo;s why we&amp;rsquo;re willing to pledge our lives, our fortunes, and our sacred honor.&lt;/p&gt;

&lt;p&gt;Times are tough, and I&amp;rsquo;m not begging for more sacrifice from you good folks. I just want to give a little perspective, and fair warning that at some point soon I&amp;rsquo;m going to have to get a real job with real health insurance because I can&amp;rsquo;t live off my mortgage much longer. It&amp;rsquo;s bad for my ulcer, and it&amp;rsquo;s bad for my family.&lt;/p&gt;

&lt;p&gt;Fortunately, the basic design of Perl 6 is largely done, appearances to the contrary notwithstanding. Damian and I will be talking about that in the Perl 6 session later in the week.&lt;/p&gt;

&lt;p&gt;Well, enough ranting. I don&amp;rsquo;t want to sound ungrateful myself, because I&amp;rsquo;m not. In any event, the last three years have been extremely exciting, and I think the coming years will be just as interesting.&lt;/p&gt;

&lt;p&gt;In particular, I have a great announcement to make at the end of my talk about what&amp;rsquo;s going to be happening next. But let me explain a bit first what&amp;rsquo;s happened, again using our poor, abused widget.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide63.jpg&#34; alt=&#34;implementations&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
In this case, time is flowing in the upward direction.&lt;/p&gt;

&lt;p&gt;Originally we just had one implementation of Perl, and the general perception as we started developing Perl 6 was that we were going to have two implementations of Perl.&lt;/p&gt;

&lt;p&gt;But in actual fact, we&amp;rsquo;re going to have at least three implementations of Perl.&lt;/p&gt;

&lt;p&gt;First, the good old Perl 5 that&amp;rsquo;s based on C, And on the right, the Perl 6 that&amp;rsquo;s based on Parrot. But there in the middle is a Perl5 that is also based on Parrot.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide64.jpg&#34; alt=&#34;ellipses&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Note that the left two are the same language, while the right two share the same platform.&lt;/p&gt;

&lt;p&gt;So what&amp;rsquo;s that Perl 5 doing there in the middle? If you&amp;rsquo;ve been following Perl 6 development, you&amp;rsquo;ll know that from the very beginning we&amp;rsquo;ve said that there has to be a migration strategy, and that that strategy has two parts. First, we have to be able to translate Perl 5 to Perl 6. If that were all of it, we wouldn&amp;rsquo;t need the middle Perl there. But not only do people need to be able to translate from Perl 5 to Perl 6, it is absolutely crucial that they be allowed to do it piecemeal. You can&amp;rsquo;t translate a complicated set of modules all at once and expect them to work. Instead, we want people to be able to run some of their modules in Perl 5, and others in Perl 6, all under the same interpreter.&lt;/p&gt;

&lt;p&gt;So that&amp;rsquo;s one good reason to have a Perl 5 compiler for Parrot. Another good reason is that we expect Perl 5 to run faster on Parrot, by and large.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide65.jpg&#34; alt=&#34;hands&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Yet another reason is that we have a little bootstrapping issue with the Perl 6 grammar. The Perl 6 grammar is defined in Perl 6 regexes. But those regexes are parsed with the Perl 6 grammar. Catch 22. The solution to this involves two things. First, a magical module of Damian&amp;rsquo;s that translates Perl 6 regexes back into Perl 5 regexes. Second, a Perl 5 regex interpreter to run those regexes. Now, it&amp;rsquo;d be possible to do it with old Perl 5, but it&amp;rsquo;ll be cleaner to run it with the new Perl 5 running on Parrot.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide66.jpg&#34; alt=&#34;widget&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Now, it&amp;rsquo;s awfully cumbersome to keep saying &amp;ldquo;Perl 5 over Parrot&amp;rdquo; and such, so we need to do some namespace cleanup here. We can drop the &amp;ldquo;over Parrot&amp;rdquo; for Perl 6, because that&amp;rsquo;s redundant.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide67.jpg&#34; alt=&#34;drop parrot&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Likewise, people always think of the original when we say &amp;ldquo;Perl 5&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide68.jpg&#34; alt=&#34;drop C&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
That means we need a code name for this thing in the middle. We&amp;rsquo;ve decided to call it &amp;ldquo;Ponie&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide69.jpg&#34; alt=&#34;Ponie&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
We have lots of reasons to call it that. To be sure, none of them are &lt;em&gt;good&lt;/em&gt; reasons, but I&amp;rsquo;m told it will make the London.pm&amp;rsquo;ers deliriously happy if I say, &amp;ldquo;I want a Ponie&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;And I do want a Ponie. &amp;ldquo;I want the Ponie, I want the whole Ponie. I want it now.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide71.jpg&#34; alt=&#34;versions&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
The plan is to for Ponie version 5.10 to be a drop-in replacement for Perl 5.10. Eventually there will be a Ponie 5.12, and if Ponie is good enough, there may not be an old-fashioned 5.12. We&amp;rsquo;ll just stop with 5.10.&lt;/p&gt;

&lt;p&gt;So we&amp;rsquo;re gonna start on Ponie right now. Since I&amp;rsquo;ve been carping about lack of resources, you might wonder how we&amp;rsquo;re gonna do this.&lt;/p&gt;

&lt;p&gt;Well, as it happens, a nice company called Fotango has a lot of Perl 5 code they want to run on Parrot, and they are clued enough to have authorized one of their employees, our very own Arthur Bergman, to spend company time porting Perl 5 to Parrot.&lt;/p&gt;

&lt;p&gt;Is that cool or what? I&amp;rsquo;m out of time, so read the press release. But I&amp;rsquo;m really excited by our vision for the future, and if you&amp;rsquo;re not excited, maybe you need to have your vision checked.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2003_07_16_soto2003/slide72.jpg&#34; alt=&#34;vision&#34; width=&#34;499&#34; height=&#34;375&#34; /&gt;
Thanks for listening, and I hope that from now on you&amp;rsquo;ll all be completely unreasonable.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apocalypse 6</title>
      <link>http://localhost:1313/pub/2003/03/07/apocalypse6.html/</link>
      <pubDate>Fri, 07 Mar 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/03/07/apocalypse6.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is the Apocalypse on Subroutines. In Perl culture the term &amp;ldquo;subroutine&amp;rdquo; conveys the general notion of calling something that returns control automatically when it&amp;rsquo;s done. This &amp;ldquo;something&amp;rdquo; that you&amp;rsquo;re calling may go by a more specialized name such as &amp;ldquo;procedure&amp;rdquo;, &amp;ldquo;function&amp;rdquo;, &amp;ldquo;closure&amp;rdquo;, or &amp;ldquo;method&amp;rdquo;. In Perl 5, all such subroutines were declared using the keyword &lt;code&gt;sub&lt;/code&gt; regardless of their specialty. For readability, Perl 6 will use alternate keywords to declare special subroutines, but they&amp;rsquo;re still essentially the same thing underneath. Insofar as they all behave similarly, this Apocalypse will have something to say about them. (And if we also leak a few secrets about how method calls work, that will make Apocalypse 12 all the easier&amp;ndash;presuming we don&amp;rsquo;t have to un-invent anything between now and then&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Here are the RFCs covered in this Apocalypse. PSA stands for &amp;ldquo;problem, solution, acceptance&amp;rdquo;, my private rating of how this RFC will fit into Perl 6. I note that none of the RFCs achieved unreserved acceptance this time around. Maybe I&amp;rsquo;m getting picky in my old age. Or maybe I just can&amp;rsquo;t incorporate anything into Perl without &amp;ldquo;marking&amp;rdquo; it&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RFC   PSA   Title
    ---   ---   -----
     21   abc   Subroutines: Replace C&amp;lt;wantarray&amp;gt; with a generic C&amp;lt;want&amp;gt;
                   function
     23   bcc   Higher order functions
     57   abb   Subroutine prototypes and parameters
     59   bcr   Proposal to utilize C&amp;lt;*&amp;gt; as the prefix to magic subroutines
     75   dcr   structures and interface definitions
    107   adr   lvalue subs should receive the rvalue as an argument
    118   rrr   lvalue subs: parameters, explicit assignment, and wantarray()
                   changes
    128   acc   Subroutines: Extend subroutine contexts to include name
                   parameters and lazy arguments
    132   acr   Subroutines should be able to return an lvalue
    149   adr   Lvalue subroutines: implicit and explicit assignment
    154   bdr   Simple assignment lvalue subs should be on by default
    160   acc   Function-call named parameters (with compiler optimizations)
    168   abb   Built-in functions should be functions
    176   bbb   subroutine / generic entity documentation
    194   acc   Standardise Function Pre- and Post-Handling
    271   abc   Subroutines : Pre- and post- handlers for subroutines
    298   cbc   Make subroutines&#39; prototypes accessible from Perl
    334   abb   Perl should allow specially attributed subs to be called as C
                   functions
    344   acb   Elements of @_ should be read-only by default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Apocalypses 1 through 4, I used the RFCs as a springboard for discussion. In Apocalypse 5 I was forced by the complexity of the redesign to switch strategies and present the RFCs after a discussion of all the issues involved. That was so well received that I&amp;rsquo;ll try to follow the same approach with this and subsequent Apocalypses.&lt;/p&gt;

&lt;p&gt;But this Apocalypse is not trying to be as radical as the one on regexes. Well, okay, it is, and it isn&amp;rsquo;t. Alright, it &lt;em&gt;is&lt;/em&gt; radical, but you&amp;rsquo;ll like it anyway (we hope). At least the old way of calling subroutines still works. Unlike regexes, Perl subroutines don&amp;rsquo;t have a lot of historical cruft to get rid of. In fact, the basic problem with Perl 5&amp;rsquo;s subroutines is that they&amp;rsquo;re not crufty enough, so the cruft leaks out into user-defined code instead, by the Conservation of Cruft Principle. Perl 6 will let you migrate the cruft out of the user-defined code and back into the declarations where it belongs. Then you will think it to be very beautiful cruft indeed (we hope).&lt;/p&gt;

&lt;p&gt;Perl 5&amp;rsquo;s subroutines have a number of issues that need to be dealt with. First of all, they&amp;rsquo;re just awfully slow, for various reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Construction of the &lt;code&gt;@_&lt;/code&gt; array&lt;/li&gt;
&lt;li&gt;Needless prepping of potential lvalues&lt;/li&gt;
&lt;li&gt;General model that forces lots of run-time processing&lt;/li&gt;
&lt;li&gt;Difficulty of optimization&lt;/li&gt;
&lt;li&gt;Storage of unneeded context&lt;/li&gt;
&lt;li&gt;Lack of tail recursion optimization&lt;/li&gt;
&lt;li&gt;Named params that aren&amp;rsquo;t really&lt;/li&gt;
&lt;li&gt;Object model that forces double dispatch in some cases&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quite apart from performance, however, there are a number of problems with usability:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Not easy to detect type errors at compile time&lt;/li&gt;
&lt;li&gt;Not possible to specify the signatures of certain built-in functions&lt;/li&gt;
&lt;li&gt;Not possible to define control structures as subroutines&lt;/li&gt;
&lt;li&gt;Not possible to type-check any variadic args other than as a list&lt;/li&gt;
&lt;li&gt;Not possible to have a variadic list providing scalar context to its elements&lt;/li&gt;
&lt;li&gt;Not possible to have lazy parameters&lt;/li&gt;
&lt;li&gt;Not possible to define immediate subroutines (macros)&lt;/li&gt;
&lt;li&gt;Not possible to define subroutines with special syntax&lt;/li&gt;
&lt;li&gt;Not enough contextual information available at run time.&lt;/li&gt;
&lt;li&gt;Not enough contextual information available at compile time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In general, the consensus is that Perl 5&amp;rsquo;s simple subroutine syntax is just a little &lt;em&gt;too&lt;/em&gt; simple. Well, okay, it&amp;rsquo;s a &lt;em&gt;lot&lt;/em&gt; too simple. While it&amp;rsquo;s extremely orthogonal to always pass all arguments as a single variadic array, that mechanism does not always map well onto the problem space. So in Perl 6, subroutine syntax has blossomed in several directions.&lt;/p&gt;

&lt;p&gt;But the most important thing to note is that we haven&amp;rsquo;t actually added a lot of syntax. We&amp;rsquo;ve added some, but most of new capabilities come in through the generalized trait/property system, and the new type system. But in those cases where specialized syntax buys us clarity, we have not hesitated to add it. (Er, actually, we hesitated quite a lot. Months, in fact.)&lt;/p&gt;

&lt;p&gt;One obvious difference is that the &lt;code&gt;sub&lt;/code&gt; on closures is now optional, since every brace-delimited block is now essentially a closure. You can still put the &lt;code&gt;sub&lt;/code&gt; if you like. But it is only required if the block would otherwise be construed as a hash value; that is, if it appears to contain a list of pairs. You can force any block to be considered a subroutine with the &lt;code&gt;sub&lt;/code&gt; keyword; likewise you can force any block to be considered a hash value with the &lt;code&gt;hash&lt;/code&gt; keyword. But in general Perl just dwims based on whether the top-level is a list that happens to have a first argument that is a pair or hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Block               Meaning
    -----               -------
    { 1 =&amp;gt; 2 }          hash { 1 =&amp;gt; 2 }
    { 1 =&amp;gt; 2, 3 =&amp;gt; 4 }  hash { 1 =&amp;gt; 2, 3 =&amp;gt; 4 }
    { 1 =&amp;gt; 2, 3, 4 }    hash { 1 =&amp;gt; 2, 3 =&amp;gt; 4 }
    { %foo, 1 =&amp;gt; 2 }    hash { %foo.pairs, 1 =&amp;gt; 2 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anything else that is not a list, or does not start with a pair or hash, indicates a subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { 1 }               sub { return 1 }
    { 1, 2 }            sub { return 1, 2 }
    { 1, 2, 3 }         sub { return 1, 2, 3 }
    { 1, 2, 3 =&amp;gt; 4 }    sub { return 1, 2, 3 =&amp;gt; 4 }
    { pair 1,2,3,4 }    sub { return 1 =&amp;gt; 2, 3 =&amp;gt; 4 }
    { gethash() }       sub { return gethash() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a syntactic distinction, not a semantic one. That last two examples are taken to be subs despite containing functions returning pairs or hashes. Note that it would save no typing to recognize the &lt;code&gt;pair&lt;/code&gt; method specially, since &lt;code&gt;hash&lt;/code&gt; automatically does pairing of non-pairs. So we distinguish these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { pair 1,2,3,4 }    sub { return 1 =&amp;gt; 2, 3 =&amp;gt; 4 }
    hash { 1,2,3,4 }    hash { 1 =&amp;gt; 2, 3 =&amp;gt; 4 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re worried about the compiler making bad choices before deciding whether it&amp;rsquo;s a subroutine or hash, you shouldn&amp;rsquo;t. The two constructs really aren&amp;rsquo;t all that far apart. The &lt;code&gt;hash&lt;/code&gt; keyword could in fact be considered a function that takes as its first argument a closure returning a hash value list. So the compiler might just compile the block as a closure in either case, then do the obvious optimization.&lt;/p&gt;

&lt;p&gt;Although we say the &lt;code&gt;sub&lt;/code&gt; keyword is now optional on a closure, the &lt;code&gt;return&lt;/code&gt; keyword only works with an explicit &lt;code&gt;sub&lt;/code&gt;. (There are other ways to return values from a block.)&lt;/p&gt;

&lt;h2 id=&#34;span-id-subroutine-declarations-subroutine-declarations-span&#34;&gt;&lt;span id=&#34;subroutine_declarations&#34;&gt;Subroutine Declarations&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;You may still declare a sub just as you did in Perl 5, in which case it behaves much like it did in Perl 5. To wit, the arguments still come in via the &lt;code&gt;@_&lt;/code&gt; array. When you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo { print @_ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;that is just syntactic sugar for this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo (*@_) { print @_ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, Perl 6 will supply a default parameter signature (the precise meaning of which will be explained below) that makes the subroutine behave much as a Perl 5 programmer would expect, with all the arguments in &lt;code&gt;@_&lt;/code&gt;. It is not exactly the same, however. You may not modify the arguments via &lt;code&gt;@_&lt;/code&gt; without declaring explicitly that you want to do so. So in the rare cases that you want to do that, you&amp;rsquo;ll have to supply the &lt;code&gt;rw&lt;/code&gt; trait (meaning the arguments should be considered &amp;ldquo;read-write&amp;rdquo;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub swap (*@_ is rw) { @_[0,1] = @_[1,0] };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Perl5-to-Perl6 translator will try to catch those cases and add the parameter signature for you when you want to modify the arguments. (Note: we will try to be consistent about using &amp;ldquo;arguments&amp;rdquo; to mean the actual values you pass to the function when you call it, and &amp;ldquo;parameters&amp;rdquo; to mean the list of lexical variables declared as part of the subroutine signature, through which you access the values that were passed to the subroutine.)&lt;/p&gt;

&lt;p&gt;Perl 5 has rudimentary prototypes, but Perl 6 type signatures can be much more expressive if you want them to be. The entire declaration is much more flexible. Not only can you declare types and names of individual parameters, you can add various traits to the parameters, such as &lt;code&gt;rw&lt;/code&gt; above. You can add traits to the subroutine itself, and declare the return type. In fact, at some level or other, the subroutine&amp;rsquo;s signature and return type are also just traits. You might even consider the body of the subroutine to be a trait.&lt;/p&gt;

&lt;p&gt;For those of you who have been following Perl 6 development, you&amp;rsquo;ll wonder why we&amp;rsquo;re now calling these &amp;ldquo;traits&amp;rdquo; rather than &amp;ldquo;properties&amp;rdquo;. They&amp;rsquo;re all really still properties under the hood, but we&amp;rsquo;re trying to distinguish those properties that are expected to be set on containers at compile time from those that are expected to be set on values at run time. So compile-time properties are now called &amp;ldquo;traits&amp;rdquo;. Basically, if you declare it with &lt;code&gt;is&lt;/code&gt;, it&amp;rsquo;s a trait, and if you add it onto a value with &lt;code&gt;but&lt;/code&gt;, it&amp;rsquo;s a property. The main reason for making the distinction is to keep the concepts straight in people&amp;rsquo;s minds, but it also has the nice benefit of telling the optimizer which properties are subject to change, and which ones aren&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;A given trait may or may not be implemented as a method on the underlying container object. You&amp;rsquo;re not supposed to care.&lt;/p&gt;

&lt;p&gt;There are actually several syntactic forms of trait:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule trait :w {
          is &amp;lt;ident&amp;gt;[\( &amp;lt;traitparam&amp;gt; \)]?
        | will &amp;lt;ident&amp;gt; &amp;lt;closure&amp;gt;
        | of &amp;lt;type&amp;gt;
        | returns &amp;lt;type&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(We&amp;rsquo;re specifying the syntax here using Perl 6 regexes. If you don&amp;rsquo;t know about those, go back and read Apocalypse 5.)&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is actually allowed to be a junction of types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo returns Int|Str {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;will&lt;/code&gt; syntax specifically introduces a closure trait without requiring the extra parens that &lt;code&gt;is&lt;/code&gt; would. Saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    will flapdoodle { flap() and doodle() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is exactly equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    is flapdoodle({ flap() and doodle() })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but reads a little better. More typically you&amp;rsquo;ll see traits like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    will first { setup() }
    will last { teardown() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final block of a subroutine declaration is the &amp;ldquo;do&amp;rdquo; trait. Saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is like saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo will do { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note however that the closure eventually stored under the &lt;code&gt;do&lt;/code&gt; trait may in fact be modified in various ways to reflect argument processing, exception handling, and such.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll discuss the &lt;code&gt;of&lt;/code&gt; and &lt;code&gt;returns&lt;/code&gt; traits later when we discuss types. Back to syntax.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-sub-form-the-sub-form-span&#34;&gt;&lt;span id=&#34;the_sub_form&#34;&gt;The &lt;code&gt;sub&lt;/code&gt; form&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A subroutine can be declared as lexically scoped, package scoped, or unscoped:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule lexicalsub :w {
        &amp;lt;lexscope&amp;gt; &amp;lt;type&amp;gt;?
        &amp;lt;subintro&amp;gt; &amp;lt;subname&amp;gt; &amp;lt;psignature&amp;gt;?
        &amp;lt;trait&amp;gt;*
        &amp;lt;block&amp;gt;
    }

    rule packagesub :w {
        &amp;lt;subintro&amp;gt; &amp;lt;subname&amp;gt; &amp;lt;psignature&amp;gt;?
        &amp;lt;trait&amp;gt;*
        &amp;lt;block&amp;gt;
    }

    rule anonsub :w {
        &amp;lt;subintro&amp;gt; &amp;lt;psignature&amp;gt;?
        &amp;lt;trait&amp;gt;*
        &amp;lt;block&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The non-lexically scoped declaration cannot specify a return type in front. The return type can only be specified as a trait in that case.&lt;/p&gt;

&lt;p&gt;As in Perl 5, the difference between a package sub and an anonymous sub depends on whether you specify the &lt;code&gt;&amp;lt;subname&amp;gt;&lt;/code&gt;. If omitted, the declaration (which is not really a declaration in that case) generates and returns a closure. (Which may not &lt;em&gt;really&lt;/em&gt; be a closure if it doesn&amp;rsquo;t access any external lexicals, but we call them all closures anyway just in case&amp;hellip;)&lt;/p&gt;

&lt;p&gt;A lexical subroutine is declared using either &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;our&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule lexscope { my | our }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This list doesn&amp;rsquo;t include &lt;code&gt;temp&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; because those are not declarators of lexical scope but rather operators that initiate dynamic scoping. See the section below on Lvalue subroutines for more about &lt;code&gt;temp&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In both lexical and package declarations, the name of the subroutine is introduced by the keyword &lt;code&gt;sub&lt;/code&gt;, or one of its variants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule subintro { sub | method | submethod | multi | rule | macro }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;method&lt;/code&gt; participates in inheritance and always has an invocant (object or class). A &lt;code&gt;submethod&lt;/code&gt; has an invocant but does not participate in inheritance. It&amp;rsquo;s a sub pretending to be a method for the current class only. A &lt;code&gt;multi&lt;/code&gt; is a multimethod, that is, a method that called like a subroutine or operator, but is dispatched based on the types of one or more of its arguments.&lt;/p&gt;

&lt;p&gt;Another variant is the regex &lt;code&gt;rule&lt;/code&gt;, which is really a special kind of method; but in actuality rules probably get their own set of parse rules, since the body of a rule is a regex. I just put &amp;ldquo;rule&amp;rdquo; into &amp;lt;subintro&amp;gt; as a placeholder of sorts, because I&amp;rsquo;m lazy.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;macro&lt;/code&gt; is a subroutine that is called immediately upon completion of parsing. It has a default means of parsing arguments, or it may be bound to an alternate grammar rule to parse its arguments however you like.&lt;/p&gt;

&lt;p&gt;These syntactic forms correspond the various &lt;code&gt;Routine&lt;/code&gt; types in the &lt;code&gt;Code&lt;/code&gt; type hierarchy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                   Code
                        ____________|________________
                       |                             |
                    Routine                        Block
       ________________|_______________            __|___
      |     |       |       |    |     |          |      |
     Sub Method Submethod Multi Rule Macro      Bare Parametric
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Routine&lt;/code&gt;/&lt;code&gt;Block&lt;/code&gt; distinction is fairly important, since you always &lt;code&gt;return&lt;/code&gt; out of the current &lt;code&gt;Routine&lt;/code&gt;, that is, the current &lt;code&gt;Sub&lt;/code&gt;, &lt;code&gt;Method&lt;/code&gt;, &lt;code&gt;Submethod&lt;/code&gt;, &lt;code&gt;Multi&lt;/code&gt;, &lt;code&gt;Rule&lt;/code&gt;, or &lt;code&gt;Macro&lt;/code&gt;. Also, the &lt;code&gt;&amp;amp;_&lt;/code&gt; variable refers to your current &lt;code&gt;Routine&lt;/code&gt;. A &lt;code&gt;Block&lt;/code&gt;, whether &lt;code&gt;Bare&lt;/code&gt; or &lt;code&gt;Parametric&lt;/code&gt;, is invisible to both of those notions.&lt;/p&gt;

&lt;p&gt;(It&amp;rsquo;s not yet clear whether the &lt;code&gt;Bare&lt;/code&gt; vs &lt;code&gt;Parametric&lt;/code&gt; distinction is useful. Some apparently &lt;code&gt;Bare&lt;/code&gt; blocks are actually &lt;code&gt;Parametric&lt;/code&gt; if they refer to &lt;code&gt;$_&lt;/code&gt; internally, even implicitly. And a &lt;code&gt;Bare&lt;/code&gt; block is just a &lt;code&gt;Parametric&lt;/code&gt; block with a signature of &lt;code&gt;()&lt;/code&gt;. More later.)&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;&amp;lt;psignature&amp;gt;&lt;/code&gt; is a parenthesized signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule psignature :w { \( &amp;lt;signature&amp;gt; \) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there is a variant that doesn&amp;rsquo;t declare names:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule psiglet :w { \( &amp;lt;siglet&amp;gt; \) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(We&amp;rsquo;ll discuss &amp;ldquo;siglets&amp;rdquo; later in their own section.)&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s possible to declare a subroutine in an lvalue or a signature as if it were an ordinary variable, in anticipation of binding the symbol to an actual subroutine later. Note this only works with an explicit name, since the whole point of declaring it in the first place is to have a name for it. On the other hand, the formal subroutine&amp;rsquo;s parameters &lt;em&gt;aren&amp;rsquo;t&lt;/em&gt; named, hence they are specified by a &lt;code&gt;&amp;lt;psiglet&amp;gt;&lt;/code&gt; rather than a &lt;code&gt;&amp;lt;psignature&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule scopedsubvar :w {
        &amp;lt;lexscope&amp;gt; &amp;lt;type&amp;gt;? &amp;amp;&amp;lt;subname&amp;gt; &amp;lt;psiglet&amp;gt;? &amp;lt;trait&amp;gt;*
    }

    rule unscopedsubvar :w {
        &amp;amp;&amp;lt;subname&amp;gt; &amp;lt;psiglet&amp;gt;? &amp;lt;trait&amp;gt;*
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If no &lt;code&gt;&amp;lt;psiglet&amp;gt;&lt;/code&gt; is supplied for such a declaration, it just uses whatever the signature of the bound routine is. So instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub foo (*@_) { print @_ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you could equivalently say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;foo ::= sub (*@_) { print @_ };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(You may recall that &lt;code&gt;::=&lt;/code&gt; does binding at compile time. Then again, you may not.)&lt;/p&gt;

&lt;p&gt;If there is a &lt;code&gt;&amp;lt;psiglet&amp;gt;&lt;/code&gt;, however, it must be compatible with the signature of the routine that is bound to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;moo(Cow) ::= sub (Horse $x) { $x.neigh };     # ERROR
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-pointy-subs-pointy-subs-span&#34;&gt;&lt;span id=&#34;pointy_subs&#34;&gt;&amp;ldquo;Pointy subs&amp;rdquo;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Pointy subs&amp;rdquo; declare a closure with an unparenthesized signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule pointysub :w {
        -\&amp;gt; &amp;lt;signature&amp;gt; &amp;lt;block&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They may not take traits.&lt;/p&gt;

&lt;h3 id=&#34;span-id-bare-subs-bare-subs-span&#34;&gt;&lt;span id=&#34;bare_subs&#34;&gt;Bare subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A bare block generates a closure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule baresub :w {
        &amp;lt;block&amp;gt; { .find_placeholders() }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A bare block declaration does not take traits (externally, anyway), and if there are any parameters, they must be specified with placeholder variables. If no placeholders are used, &lt;code&gt;$_&lt;/code&gt; may be treated as a placeholder variable, provided the surrounding control structure passes an argument to the the closure. Otherwise, &lt;code&gt;$_&lt;/code&gt; is bound as an ordinary lexical variable to the outer &lt;code&gt;$_&lt;/code&gt;. (&lt;code&gt;$_&lt;/code&gt; is also an ordinary lexical variable when explicit placeholders are used.)&lt;/p&gt;

&lt;p&gt;More on parameters below. But before we talk about parameters, we need to talk about types.&lt;/p&gt;

&lt;h2 id=&#34;span-id-digression-on-types-digression-on-types-span&#34;&gt;&lt;span id=&#34;digression_on_types&#34;&gt;Digression on types&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Well, what are types, anyway? Though known as a &amp;ldquo;typeless&amp;rdquo; language, Perl actually supports several built-in container types such as scalar, array, and hash, as well as user-defined, dynamically typed objects via &lt;code&gt;bless&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Perl 6 will certainly support more types. These include some low-level storage types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bit int str num ref bool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;as well as some high-level object types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Bit Int Str Num Ref Bool
    Array Hash Code IO
    Routine Sub Method Submethod Macro Rule
    Block Bare Parametric
    Package Module Class Object Grammar
    List Lazy Eager
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(These lists should not be construed as exhaustive.) We&amp;rsquo;ll also need some way of at least hinting at representations to the compiler, so we may also end up with types like these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    int8 int16 int32 int64
    uint8 uint16 uint32 uint64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or maybe those are just extra &lt;code&gt;size&lt;/code&gt; traits on a declaration somewhere. That&amp;rsquo;s not important at this point.&lt;/p&gt;

&lt;p&gt;The important thing is that we&amp;rsquo;re adding a generalized type system to Perl. Let us begin by admitting that it is the height of madness to add a type system to a language that is well-loved for being typeless.&lt;/p&gt;

&lt;p&gt;But mad or not, there are some good reasons to do just that. First, it makes it possible to write interfaces to other languages in Perl. Second, it gives the optimizer more information to think about. Third, it allows the S&amp;amp;M folks to inflict strongly typed compile-time semantics on each other. (Which is fine, as long as they don&amp;rsquo;t inflict those semantics on the rest of us.) Fourth, a type system can be viewed as a pattern matching system for multi-method dispatch.&lt;/p&gt;

&lt;p&gt;Which basically boils down to the notion that it&amp;rsquo;s fine for Perl to have a type system as long as it&amp;rsquo;s optional. It&amp;rsquo;s just another area where Perl 6 will try to have its cake and eat it too.&lt;/p&gt;

&lt;p&gt;This should not actually come as a surprise to anyone who has been following the development of Perl 5, since the grammatical slot for declaring a variable&amp;rsquo;s effective type has been defined for some time now. In Perl 5 you can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat $felix;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to declare a variable intended to hold a &lt;code&gt;Cat&lt;/code&gt; object. That&amp;rsquo;s nice, as far as it goes. Perl 6 will support the same syntax, but we&amp;rsquo;ll have to push it much further than that if we&amp;rsquo;re to have a type system that is good enough to specify interfaces to languages like C++ or Java. In particular, we have to be able to specify the types of composite objects such as arrays and hashes without resorting to class definitions, which are rather heavyweight&amp;ndash;not to mention opaque. We need to be able to specify the types of individual function and method parameters and return values. Taken collectively, these parameter types can form the signature of a subroutine, which is one of the traits of the subroutine.&lt;/p&gt;

&lt;p&gt;And of course, all this has to be intuitively obvious to the naive user.&lt;/p&gt;

&lt;p&gt;Yeah, sure, you say.&lt;/p&gt;

&lt;p&gt;Well, let&amp;rsquo;s see how far we can get with it. If the type system is too klunky for some particular use, people will simply avoid using it. Which is fine&amp;ndash;that&amp;rsquo;s why it&amp;rsquo;s optional.&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s clarify one thing that seems to confuse people frequently. Unlike some languages, Perl makes a distinction between the type of the variable, and the type of the value. In Perl 5, this shows up as the difference between overloading and tying. You overload the value, but you tie the variable. When you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat $felix;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you are specifying the type of the &lt;em&gt;value&lt;/em&gt; being stored, not the type of the &lt;em&gt;variable&lt;/em&gt; doing the storing. That is, &lt;code&gt;$felix&lt;/code&gt; must contain a reference to a &lt;code&gt;Cat&lt;/code&gt; value, or something that &amp;ldquo;isa&amp;rdquo; &lt;code&gt;Cat&lt;/code&gt;. The variable type in this case is just a simple scalar, though that can be changed by tying the variable to some class implementing the scalar variable operations.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In Perl 6, the type of the variable is just one of the traits of the variable, so if you want to do the equivalent of a &lt;code&gt;tie&lt;/code&gt; to the &lt;code&gt;Box&lt;/code&gt; class, you say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat $felix is Box;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That declares your intent to store a &lt;code&gt;Cat&lt;/code&gt; value into a &lt;code&gt;Box&lt;/code&gt; variable. (Whether the cat will then dead or alive (or dead|alive) depends on the definition of the &lt;code&gt;Box&lt;/code&gt; class, and whether the &lt;code&gt;Box&lt;/code&gt; object&amp;rsquo;s side effects extend to the &lt;code&gt;Cat&lt;/code&gt; value stored in it.)&lt;/p&gt;

&lt;p&gt;But by default:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat $felix;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;just means something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat $felix is Scalar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, if you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat @litter;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s like saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat @litter is Array;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, &lt;code&gt;@litter&lt;/code&gt; is an ordinary array of scalar values that happen to be references to &lt;code&gt;Cat&lt;/code&gt;s. In the abstract, &lt;code&gt;@litter&lt;/code&gt; is a function that maps integers to cats.&lt;/p&gt;

&lt;p&gt;Likewise,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat %pet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat %pet is Hash;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can think of the &lt;code&gt;%pet&lt;/code&gt; hash as a function that maps cat names (strings) to cats. Of course, that&amp;rsquo;s an oversimplification&amp;ndash;for both arrays and hashes, subscripting is not the only operation. But it&amp;rsquo;s the fundamental operation, so the declared type of the returned value reflects the return value of such a subscripted call.&lt;/p&gt;

&lt;p&gt;Actually, it&amp;rsquo;s not necessarily the return type. It&amp;rsquo;s merely a type that is &lt;em&gt;consistent&lt;/em&gt; with the returned type. It would be better to declare:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Animal %pet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then you could return a &lt;code&gt;Cat&lt;/code&gt; or a &lt;code&gt;Dog&lt;/code&gt; or a &lt;code&gt;Sponge&lt;/code&gt;, presuming all those are derived from &lt;code&gt;Animal&lt;/code&gt;. You&amp;rsquo;d have to generalize it a bit further if you want to store your pet &lt;code&gt;Rock&lt;/code&gt;. In the limit, you can just leave the type out. When you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %pet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;re really just saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Object %pet is Hash;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;except that you&amp;rsquo;re not. We have to push it further than that, because we have to handle more complicated structures as well. When you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat @litter is Array;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s really shorthand for:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @litter is Array of Cat;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, &amp;ldquo;&lt;code&gt;Cat&lt;/code&gt;&amp;rdquo; is really a funny parameter that says what kind of &lt;code&gt;Array&lt;/code&gt; you have. If you like, you could even write it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @litter is Array(returns =&amp;gt; Cat)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise you might write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %pet is Hash(keytype =&amp;gt; Str, returns =&amp;gt; Cat)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and specify the key type of the hash. The &amp;ldquo;&lt;code&gt;of&lt;/code&gt;&amp;rdquo; keyword is just syntactic sugar for specifying the return type of the previous storage class. So we could have&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %pet is Hash of Array of Array of Hash of Array of Cat;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which might really mean:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %pet is Hash(keytype =&amp;gt; Str,
                    returns =&amp;gt; Array(
                        returns =&amp;gt; Array(
                            returns =&amp;gt; Hash(
                                keytype =&amp;gt; Str,
                                returns =&amp;gt; Array(
                                    returns =&amp;gt; Cat)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or some such.&lt;/p&gt;

&lt;p&gt;I suppose you could also write that as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Array of Array of Hash of Array of Cat %pet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but for linguistic reasons it&amp;rsquo;s probably better to keep the variable name near the left and put the long, heavy phrases to the right. (People tend to prefer to say the short parts of their sentences before the long parts&amp;ndash;linguists call this the &amp;ldquo;end-weight&amp;rdquo; problem.) The &lt;code&gt;Hash&lt;/code&gt; is implied by the &lt;code&gt;%pet&lt;/code&gt;, so you could leave out the &amp;ldquo;&lt;code&gt;is&lt;/code&gt;&amp;rdquo; part and just say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %pet of Array of Array of Hash of Array of Cat;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another possibility is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat %pet is Hash of Array of Array of Hash of Array;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That one reads kinda funny if you leave out the &amp;ldquo;&lt;code&gt;is Hash&lt;/code&gt;&amp;rdquo;, though. Nevertheless, it says that we have this funny data structure that has multiple parameters that you can view as a funny function returning &lt;code&gt;Cat&lt;/code&gt;. In fact, &amp;ldquo;&lt;code&gt;returns&lt;/code&gt;&amp;rdquo; is a synonym for &amp;ldquo;&lt;code&gt;of&lt;/code&gt;&amp;rdquo;. This is also legal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @litter returns Cat;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But the &amp;ldquo;&lt;code&gt;returns&lt;/code&gt;&amp;rdquo; keyword is mostly for use by functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat sub find_cat($name) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is the same as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub find_cat($name) returns Cat {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is more important for things like closures that have no &amp;ldquo;&lt;code&gt;my&lt;/code&gt;&amp;rdquo; on the front:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $closure = sub ($name) returns Cat {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though for the closure case, it&amp;rsquo;s possible we could define some kind of non-&lt;code&gt;my&lt;/code&gt; article to introduce a type unambiguously:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $closure = a Camel sub ($name) {...}
    $closure = an Aardvark sub () {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Presumably &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;an&lt;/code&gt;&amp;rdquo; is short for &amp;ldquo;anonymous&amp;rdquo;. Which is more or less what the indefinite article means in English.&lt;/p&gt;

&lt;p&gt;However, we need &lt;code&gt;returns&lt;/code&gt; anyway in cases where the return value is complicated, so that you&amp;rsquo;d rather list it later (for end-weight reasons):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub next_prisoner() returns (Nationality, Name, Rank, SerialNo) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the return type is a signature much like the parameter types, though of course there are no formal parameter names on a return value. (Though there could be, I suppose.) We&amp;rsquo;re calling such nameless signatures &amp;ldquo;siglets&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;span-id-stub-declarations-stub-declarations-span&#34;&gt;&lt;span id=&#34;stub_declarations&#34;&gt;Stub declarations&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;When you declare a subroutine, it can change how the rest of the current file (or string) is compiled. So there is some pressure to put subroutine declarations early. On the other hand, there are good reasons for putting subroutine definitions later in the file too, particularly when you have mutually recursive subroutines. Beyond that, the definition might not even be supplied until run time if you use some kind of autoloading mechanism. (We&amp;rsquo;ll discuss autoloading in Apocalypse 10, Packages.) Perl 5 has long supported the notion of &amp;ldquo;forward&amp;rdquo; declarations or &amp;ldquo;stubs&amp;rdquo; via a syntax that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub optimal;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl 6 also supports stubbing, but instead you write it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub optimal {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, the stub is distinguished not by leaving the body of the function out, but by supplying a body that explicitly calls the &amp;ldquo;&lt;code&gt;...&lt;/code&gt;&amp;rdquo; operator (known affectionately as the &amp;ldquo;yada, yada, yada&amp;rdquo; operator). This operator emits a warning if you actually try to execute it. (It can also be made to pitch an exception.) There is no warning for redefining a &lt;code&gt;{...}&lt;/code&gt; body.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re moving away from the semicolon syntax in order to be consistent with the distinction made by other declarations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Fee;        # scope extends to end of file
    package Fee { ... } # scope extends over block

    module Fie;         # scope extends to end of file
    module Fie { ... }  # scope extends over block

    class Foe;          # scope extends to end of file
    class Foe { ... }   # scope extends over block
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To be consistent, a declaration like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would therefore extend to the end of the file. But that would be confusing for historical reasons, so we disallow it instead, and you have to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;span-id-scope-of-subroutine-names-scope-of-subroutine-names-span&#34;&gt;&lt;span id=&#34;scope_of_subroutine_names&#34;&gt;Scope of subroutine names&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Perl 5 gives subroutine names two scopes. Perl 6 gives them four.&lt;/p&gt;

&lt;h3 id=&#34;span-id-package-scoped-subs-package-scoped-subs-span&#34;&gt;&lt;span id=&#34;package_scoped_subs&#34;&gt;Package scoped subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;All named subs in Perl 5 have package scope. (The body provides a lexical scope, but we&amp;rsquo;re not talking about that. We&amp;rsquo;re talking about where the name of the subroutine is visible from.) Perl 6 provides by default a package-scoped name for &amp;ldquo;unscoped&amp;rdquo; declarations such as these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          sub fee {...}
       method fie {...}
    submethod foe {...}
        multi foo {...}
        macro sic {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Methods and submethods are ordinarily package scoped, because (just as in Perl 5) a class&amp;rsquo;s namespace is kept in a package.&lt;/p&gt;

&lt;h3 id=&#34;span-id-anonymous-subs-anonymous-subs-span&#34;&gt;&lt;span id=&#34;anonymous_subs&#34;&gt;Anonymous subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s sort of cheating to call this a subroutine scope, because it&amp;rsquo;s really more of a non-scope. Scope is a property of the &lt;em&gt;name&lt;/em&gt; of a subroutine. Since closures and anonymous subs have no name, they naturally have no intrinsic scope of their own. Instead, they rely on the scope of whatever variable contains a reference to them. The only way to get a lexically scoped subroutine name in Perl 5 was by indirection:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $subref = sub { dostuff(@_) }
    &amp;amp;$subref(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that doesn&amp;rsquo;t actually give you a lexically scoped name that is equivalent to an ordinary subroutine&amp;rsquo;s name. Hence, Perl 6 also provides&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-lexically-scoped-subs-lexically-scoped-subs-span&#34;&gt;&lt;span id=&#34;lexically_scoped_subs&#34;&gt;Lexically scoped subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You can declare &amp;ldquo;scoped&amp;rdquo; subroutines by explicitly putting a &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;our&lt;/code&gt; on the front of the declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub privatestuff { ... }
    our sub semiprivatestuff { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both of these introduce a name into the current lexical scope, though in the case of &lt;code&gt;our&lt;/code&gt; this is just an alias for a package subroutine of the same name. (As with other uses of &lt;code&gt;our&lt;/code&gt;, you might want to introduce a lexical alias if your strictness level prohibits unqualified access to package subroutines.)&lt;/p&gt;

&lt;p&gt;You can also declare lexically scoped macros:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my macro sic { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-global-scoped-subs-global-scoped-subs-span&#34;&gt;&lt;span id=&#34;global_scoped_subs&#34;&gt;Global scoped subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl 6 also introduces the notion of completely global variables that are visible from everywhere they aren&amp;rsquo;t overridden by the current package or lexical scope. Such variables are named with a leading &lt;code&gt;*&lt;/code&gt; on the identifier, indicating that the package prefix is a wildcard, if you will. Since subroutines are just a funny kind of variable, you can also have global subs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub *print (*@list) { $*DEFOUT.print(@list) } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, that&amp;rsquo;s more-or-less how some built-in functions like &lt;code&gt;print&lt;/code&gt; could be implemented in Perl 6. (Methods like &lt;code&gt;$*DEFOUT.print()&lt;/code&gt; are a different story, of course. They&amp;rsquo;re defined off in a class somewhere. (Unless they&amp;rsquo;re multimethods, in which case they could be defined almost anywhere, because multimethods are always globally scoped. (In fact, most built-ins including &lt;code&gt;print&lt;/code&gt; will be multimethods, not subs. (But we&amp;rsquo;re getting ahead of ourselves&amp;hellip;))))&lt;/p&gt;

&lt;h2 id=&#34;span-id-signatures-signatures-span&#34;&gt;&lt;span id=&#34;signatures&#34;&gt;Signatures&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;One of Perl&amp;rsquo;s strong points has always been the blending of positional parameters with variadic parameters.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Variadic&amp;rdquo; parameters are the ones that &lt;em&gt;vary&lt;/em&gt;. They&amp;rsquo;re the &amp;ldquo;&amp;hellip;And The Rest&amp;rdquo; list of values that many functions&amp;ndash;like &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, and &lt;code&gt;chomp&lt;/code&gt;&amp;ndash;have at the end of their call. Whereas positional parameters generally tell a function &lt;em&gt;how&lt;/em&gt; to do its job, variadic parameters are most often used to pass the arbitrary sequences of data the function is supposed to do its job on/with/to.&lt;/p&gt;

&lt;p&gt;In Perl 5, when you unpack the arguments to a &lt;code&gt;sub&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($a, $b, $c, @rest) = @_;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you are defining three positional parameters, followed by a variadic list. And if you give the sub a prototype of &lt;code&gt;($$$@)&lt;/code&gt; it will force the first three parameters to be evaluated in scalar context, while the remaining arguments are evaluated in list context.&lt;/p&gt;

&lt;p&gt;The big problem with the Perl 5 solution is that the parameter binding is done at run time, which has run-time costs. It also means the metadata is not readily available outside the function body. We could just as easily have written it in some other form like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $a = shift;
    my $b = shift;
    my $c = shift;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and left the rest of the arguments in &lt;code&gt;@_&lt;/code&gt;. Not only is this difficult for a compiler to analyze, but it&amp;rsquo;s impossible to get the metadata from a stub declaration; you have to have the body defined already.&lt;/p&gt;

&lt;p&gt;The old approach is very flexible, but the cost to the user is rather high.&lt;/p&gt;

&lt;p&gt;Perl 6 still allows you to access the arguments via &lt;code&gt;@_&lt;/code&gt; if you like, but in general you&amp;rsquo;ll want to hoist the metadata up into the declaration. Perl 6 still fully supports the distinction between positional and variadic data&amp;ndash;you just have to declare them differently. In general, variadic items must follow positional items both in declaration and in invocation.&lt;/p&gt;

&lt;p&gt;In turn, there are at least three kinds of positional parameters, and three kinds of variadic parameters. A declaration for all six kinds of parameter won&amp;rsquo;t win a beauty contest, but might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method x ($me: $req, ?$opt, +$namedopt, *%named, *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, you&amp;rsquo;d rarely write all of those in one declaration. Most declarations only use one or two of them. Or three or four&amp;hellip; Or five or six&amp;hellip;&lt;/p&gt;

&lt;p&gt;There is some flexibility in how you pass some of these parameters, but the ordering of both formal parameters and actual arguments is constrained in several ways. For instance, positional parameters must precede non-positional, and required parameters must precede optional. Variadic lists must be attached either to the end of the positional list or the end of the named parameter list. These constraints serve a number of purposes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They avoid user confusion.&lt;/li&gt;
&lt;li&gt;They enable the system to implement calls efficiently.&lt;/li&gt;
&lt;li&gt;Perhaps most importantly, they allow interfaces to evolve without breaking old code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since there are constraints on the ordering of parameters, similar parameters tend to clump together into &amp;ldquo;zones&amp;rdquo;. So we&amp;rsquo;ll call the &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;*&lt;/code&gt; symbols you see above &amp;ldquo;zone markers&amp;rdquo;. The underlying metaphor really is very much like zoning regulations&amp;ndash;you know, the ones where your city tells you what you may or may not do on a chunk of land you think you own. Each zone has a set of possible uses, and similar zones often have overlapping uses. But you&amp;rsquo;re still in trouble if you put a factory in the middle of a housing division, just as you&amp;rsquo;re in trouble if you pass a positional argument to a formal parameter that has no position.&lt;/p&gt;

&lt;p&gt;I was originally going to go with a semicolon to separate required from optional parameters (as Perl 5 uses in its prototypes), but I realized that it would get lost in the traffic, visually speaking. It&amp;rsquo;s better to have the zone markers line up, especially if you decide to repeat them in the vertical style:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method action ($self:
                int  $x,
                int ?$y,
                int ?$z,
             Adverb +$how,
        Beneficiary +$for,
           Location +$at is copy,
           Location +$toward is copy,
           Location +$from is copy,
             Reason +$why,
                    *%named,
                    *@list
                ) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So optional parameters are all marked with zone markers.&lt;/p&gt;

&lt;p&gt;In this section we&amp;rsquo;ll be concentrating on the declaration&amp;rsquo;s syntax rather than the call&amp;rsquo;s syntax, though the two cannot be completely disintertwingled. The declaration syntax is actually the more complicated of the two for various good reasons, so don&amp;rsquo;t get too discouraged just yet.&lt;/p&gt;

&lt;h3 id=&#34;span-id-positional-parameters-positional-parameters-span&#34;&gt;&lt;span id=&#34;positional_parameters&#34;&gt;Positional parameters&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The three positional parameter types are the invocant, the required parameters, and the optional positional parameters. (Note that in general, positional parameters may also be called using named parameter notation, but they must be declared as positional parameters if you wish to have the &lt;em&gt;option&lt;/em&gt; of calling them as positional parameters.) All positional parameters regardless of their type are considered scalars, and imply scalar context for the actual arguments. If you pass an array or hash to such a parameter, it will actually pass a reference to the array or hash, just as if you&amp;rsquo;d backslashed the actual argument.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-invocant-the-invocant-span&#34;&gt;&lt;span id=&#34;the_invocant&#34;&gt;The invocant&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The first argument to any method (or submethod) is its invocant, that is, the object or class upon which the method is acting. The invocant parameter, if present, is always declared with a colon following it. The invocant is optional in the sense that, if there&amp;rsquo;s no colon, there&amp;rsquo;s no explicit invocant declared. It&amp;rsquo;s still there, and it must be passed by the caller, but it has no name, and merely sets the outer topic of the method. That is, the invocant&amp;rsquo;s name is &lt;code&gt;$_&lt;/code&gt;, at least until something overrides the current topic. (You can always get at the invocant with the &lt;code&gt;self&lt;/code&gt; built-in, however. If you don&amp;rsquo;t like &amp;ldquo;self&amp;rdquo;, you can change it with a macro. See below.)&lt;/p&gt;

&lt;p&gt;Ordinary subs never have an invocant. If you want to declare a non-method subroutine that behaves as a method, you should declare a submethod instead.&lt;/p&gt;

&lt;p&gt;Multimethods can have multiple invocants. A colon terminates the list of invocants, so if there is no colon, all parameters are considered invocants. Only invocants participate in multimethod dispatch. Only the first invocant is bound to &lt;code&gt;$_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Macros are considered methods on the current parse state object, so they have an invocant.&lt;/p&gt;

&lt;h4 id=&#34;span-id-required-parameters-required-parameters-span&#34;&gt;&lt;span id=&#34;required_parameters&#34;&gt;Required parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Next (or first in the case of subs) come the required positional parameters. If, for instance, the routine declares three of these, you have to pass at least three arguments in the same order. The list of required parameters is terminated at the first optional parameter, that is the first parameter having any kind of zone marker. If none of those are found, all the parameters are required, and if you pass either too many or too few arguments, Perl will throw an exception as soon as it notices. (That might be at either compile time or run time.) If there are optional or variadic parameters, the required list merely serves as the minimum number of arguments you&amp;rsquo;re allowed to pass.&lt;/p&gt;

&lt;h4 id=&#34;span-id-optional-parameters-optional-parameters-span&#34;&gt;&lt;span id=&#34;optional_parameters&#34;&gt;Optional parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Next come the optional positional parameters. (They have to come next because they&amp;rsquo;re positional.) In the declaration, optional positional parameters are distinguished from required parameters by marking the optional parameters with a question mark. (The parameters are not distinguished in the call&amp;ndash;you just use commas. We&amp;rsquo;ll discuss call syntax later.) All optional positional parameters are marked with &lt;code&gt;?&lt;/code&gt;, not just the first one. Once you&amp;rsquo;ve made the transition to the optional parameter zone, all parameters are considered optional from there to the end of the signature, even after you switch zones to &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;. But once you leave the positional zone (at the end of the &lt;code&gt;?&lt;/code&gt; zone), you can&amp;rsquo;t switch back to the positional zone, because positionals may not follow variadics.&lt;/p&gt;

&lt;p&gt;If there are no variadic parameters following the optional parameters, the declaration establishes both a minimum and a maximum number of allowed arguments. And again, Perl will complain when it notices you violating either constraint. So the declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub *substr ($string, ?$offset, ?$length, ?$repl) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;says that &lt;code&gt;substr&lt;/code&gt; can be called with anywhere from 1 to 4 scalar parameters.&lt;/p&gt;

&lt;h3 id=&#34;span-id-variadic-parameters-variadic-parameters-span&#34;&gt;&lt;span id=&#34;variadic_parameters&#34;&gt;Variadic parameters&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Following the positional parameters, three kinds of variadic parameters may be declared. Variadic arguments may be slurped into a hash or an array depending on whether they look like named arguments or not. &amp;ldquo;Slurpy&amp;rdquo; parameters are denoted by a unary &lt;code&gt;*&lt;/code&gt; before the variable name, which indicates that an arbitrary number of values is expected for that variable.&lt;/p&gt;

&lt;p&gt;Additional named parameters may be placed at the end of the declaration, or marked with a unary &lt;code&gt;+&lt;/code&gt; (because they&amp;rsquo;re &amp;ldquo;extra&amp;rdquo; parameters). Since they are&amp;ndash;by definition&amp;ndash;in the variadic region, they may only be passed as named arguments, never positionally. It is illegal to mark a parameter with &lt;code&gt;?&lt;/code&gt; after the first &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;, because you can&amp;rsquo;t reenter a positional zone from a variadic zone.&lt;/p&gt;

&lt;p&gt;Unlike the positional parameters, the variadic parameters are not necessarily declared in the same order as they will be passed in the call. They may be declared in any order (though the exact behavior of a slurpy array depends slightly on whether you declare it first or last).&lt;/p&gt;

&lt;h4 id=&#34;span-id-namedonly-parameters-named-only-parameters-span&#34;&gt;&lt;span id=&#34;namedonly_parameters&#34;&gt;Named-only parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Parameters marked with a &lt;code&gt;+&lt;/code&gt; zone marker are named-only parameters. Such a parameter may never be passed positionally, but only by name.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-slurpy-hash-the-slurpy-hash-span&#34;&gt;&lt;span id=&#34;the_slurpy_hash&#34;&gt;The slurpy hash&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A hash declaration like &lt;code&gt;*%named&lt;/code&gt; indicates that the &lt;code&gt;%named&lt;/code&gt; hash should slurp up all the remaining named arguments (that is, those that aren&amp;rsquo;t bound explicitly to a specific formal parameter).&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-slurpy-array-the-slurpy-array-span&#34;&gt;&lt;span id=&#34;the_slurpy_array&#34;&gt;The slurpy array&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;An array declaration like &lt;code&gt;*@rest&lt;/code&gt; indicates that the &lt;code&gt;@rest&lt;/code&gt; array should slurp up all the remaining items after the named parameters. (Later we&amp;rsquo;ll discuss how to disambiguate the situation when the beginning of your list looks like named parameters.) If you &lt;code&gt;shift&lt;/code&gt; or &lt;code&gt;pop&lt;/code&gt; without an argument, it shifts or pops whatever slurpy array is in scope. (So in a sense, your main program has an implicit slurpy array of &lt;code&gt;*@*ARGS&lt;/code&gt; because that&amp;rsquo;s what &lt;code&gt;shift&lt;/code&gt; shifts there.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-formal-parameter-syntax-formal-parameter-syntax-span&#34;&gt;&lt;span id=&#34;formal_parameter_syntax&#34;&gt;Formal parameter syntax&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Formal parameters have lexical scope, as if they were declared with a &lt;code&gt;my&lt;/code&gt;. (That is reflected in the pseudocode in Appendix B.) Their scope extends only to the end of the associated block. Formal parameters are the only lexically scoped variables that are allowed to be declared outside their blocks. (Ordinary &lt;code&gt;my&lt;/code&gt; and &lt;code&gt;our&lt;/code&gt; declarations are always scoped to their surrounding block.)&lt;/p&gt;

&lt;p&gt;Any subroutine can have a method signature syntactically, but subsequent semantic analysis will reject mistakes like invocants on subroutines. This is not just motivated by laziness. I think that &amp;ldquo;&lt;code&gt;You can&#39;t have an invocant on a subroutine&lt;/code&gt;&amp;rdquo; is a better error message than &amp;ldquo;&lt;code&gt;Syntax error&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule signature :w {
        [&amp;lt;parameter&amp;gt; [&amp;lt;[,:]&amp;gt; &amp;lt;parameter&amp;gt; ]* ]?
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, we just treat colon as a funny comma here, so any use of extra colons is detected in semantic analysis. Similarly, zone markers are semantically restricted, not syntactically. Again, &amp;ldquo;&lt;code&gt;Syntax error&lt;/code&gt;&amp;rdquo; doesn&amp;rsquo;t tell you much. It&amp;rsquo;s much more informative to see &amp;ldquo;&lt;code&gt;You can&#39;t declare an optional positional parameter like ?$flag after a slurpy parameter like *@list&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;You can&#39;t use a zone marker on an invocant&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what an individual parameter looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule parameter :w {
        [ &amp;lt;type&amp;gt;? &amp;lt;zone&amp;gt;? &amp;lt;variable&amp;gt; &amp;lt;trait&amp;gt;* &amp;lt;defval&amp;gt;?
        | \[ &amp;lt;signature&amp;gt; \]     # treat single array ref as an arg list
        ]
    }

    rule zone {
        [ \?            # optional positional
        | \*            # slurpy array or hash
        | \+            # optional named-only
        ]
    }

    rule variable { &amp;lt;sigil&amp;gt; &amp;lt;name&amp;gt; [ \( &amp;lt;siglet&amp;gt; \) ]? }
    rule sigil { &amp;lt;[$@%&amp;amp;]&amp;gt; &amp;lt;[*.?^]&amp;gt;? }   # &amp;quot;What is that, swearing?&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, we parse any sigil here, but semantically reject things like &lt;code&gt;$*x&lt;/code&gt; or &lt;code&gt;$?x&lt;/code&gt;. We also reject package-qualified names and indirect names. We could have a &lt;code&gt;&amp;lt;simplevar&amp;gt;&lt;/code&gt; rule that only admits &lt;code&gt;&amp;lt;ident&amp;gt;&lt;/code&gt;, but again, &amp;ldquo;&lt;code&gt;Syntax error&lt;/code&gt;&amp;rdquo; is a lot less user-friendly than &amp;ldquo;&lt;code&gt;You can&#39;t use a package variable as a parameter, dimwit!&lt;/code&gt;&amp;ldquo;&lt;/p&gt;

&lt;p&gt;Similarly, the optional &lt;code&gt;&amp;lt;siglet&amp;gt;&lt;/code&gt; in &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; is allowed only on &lt;code&gt;&amp;amp;&lt;/code&gt; parameters, to say what you expect the signature of the referenced subroutine to look like. We should talk about siglets.&lt;/p&gt;

&lt;h4 id=&#34;span-id-siglets-siglets-span&#34;&gt;&lt;span id=&#34;siglets&#34;&gt;Siglets&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;siglet&amp;gt;&lt;/code&gt; in the &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; rule is an example of a nameless signature, that is, a &amp;ldquo;small signature&amp;rdquo;, or &amp;ldquo;siglet&amp;rdquo;. Signatures without names are also used for return types and context traits (explained later). A siglet is sequential list of paramlets. The paramlets do not refer to actual variable names, nor do they take defaults:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule siglet :w {
        [&amp;lt;paramlet&amp;gt; [&amp;lt;[,:]&amp;gt; &amp;lt;paramlet&amp;gt; ]* ]?
    }

    rule paramlet :w {
        [ &amp;lt;type&amp;gt; &amp;lt;zone&amp;gt;? &amp;lt;varlet&amp;gt;? &amp;lt;trait&amp;gt;*     # require type
        | &amp;lt;zone&amp;gt; &amp;lt;varlet&amp;gt;? &amp;lt;trait&amp;gt;*             # or zone
        | &amp;lt;varlet&amp;gt; &amp;lt;trait&amp;gt;*                     # or varlet
        | \[ &amp;lt;siglet&amp;gt; \]        # treat single array ref as an arg list
        ]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In place of a &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt;, there&amp;rsquo;s a kind of stub we&amp;rsquo;ll call a &amp;ldquo;varlet&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule varlet :w {
        &amp;lt;sigil&amp;gt; [ \( &amp;lt;siglet \) ]?
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with the &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; rule, a &lt;code&gt;&amp;lt;varlet&amp;gt;&lt;/code&gt;&amp;rsquo;s optional siglet is allowed only on &lt;code&gt;&amp;amp;&lt;/code&gt; parameters.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a fancy example with one signature and several siglets.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub (int *@) imap ((int *@) &amp;amp;block(int $),
                        int *@vector is context(int) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;re not expected to understand all of that yet. What you should notice, however, is that a paramlet is allowed to be reduced to a type (such as &lt;code&gt;int&lt;/code&gt;), or a zone (such as &lt;code&gt;?&lt;/code&gt;), or a varlet (such as &lt;code&gt;$&lt;/code&gt;), or some sequence of those (such as &lt;code&gt;int *@&lt;/code&gt;). But it&amp;rsquo;s not allowed to be reduced to a null string. A signature of &lt;code&gt;()&lt;/code&gt; indicates zero arguments, not one argument that could be anything. Use &lt;code&gt;($)&lt;/code&gt; for that. Nor can you specify four arguments by saying &lt;code&gt;(,,,)&lt;/code&gt;. You have to put something there.&lt;/p&gt;

&lt;p&gt;Perl 6 siglets can boil down to something very much like Perl 5&amp;rsquo;s &amp;ldquo;prototype pills&amp;rdquo;. However, you can&amp;rsquo;t leave out the comma between parameters in Perl 6. So you have to say &lt;code&gt;($,$)&lt;/code&gt; rather than &lt;code&gt;($$)&lt;/code&gt;, when you want to indicate a list of two scalars.&lt;/p&gt;

&lt;p&gt;If you use a &lt;code&gt;&amp;lt;siglet&amp;gt;&lt;/code&gt; instead of a &lt;code&gt;&amp;lt;signature&amp;gt;&lt;/code&gt; in declaring a subroutine, it will be taken as a Perl 5 style prototype, and all args still come in via &lt;code&gt;@_&lt;/code&gt;. This is a sop to the Perl5-to-Perl6 translator, which may not be able to figure out how to translate a prototype to a signature if you&amp;rsquo;ve done something strange with &lt;code&gt;@_&lt;/code&gt;. You should not use this feature in new code. If you use a siglet on a stub declaration, you must use the same siglet on the corresponding definition as well, and vice versa. You can&amp;rsquo;t mix siglets and signatures that way. (This is not a special rule, but a natural consequence of the signature matching rules.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-siglets-and-multimethods-siglets-and-multimethods-span&#34;&gt;&lt;span id=&#34;siglets_and_multimethods&#34;&gt;Siglets and multimethods&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;For closure parameters like &lt;code&gt;&amp;amp;block(int $)&lt;/code&gt;, the associated siglet is considered part of its name. This is true not just for parameters, but anywhere you use the &lt;code&gt;&amp;amp;&lt;/code&gt; form in your program, because with multimethods there may be several routines sharing the same identifier, distinguishable only by their type signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi factorial(int $a) { $a&amp;lt;=1 ?? 1 :: $a*factorial($a-1) }
    multi factorial(num $a) { gamma(1+$a) }

    $ref = &amp;amp;factorial;          # illegal--too ambiguous
    $ref = &amp;amp;factorial($);       # illegal--too ambiguous
    $ref = &amp;amp;factorial(int);     # good, means first one.
    $ref = &amp;amp;factorial(num);     # good, means second one.
    $ref = &amp;amp;factorial(complex); # bad, no such multimethod.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that when following a name like &amp;ldquo;&lt;code&gt;&amp;amp;factorial&lt;/code&gt;&amp;rdquo;, parentheses do not automatically mean to make a call to the subroutine. (This Apocalypse contradicts earlier Apocalypses. Guess which one is right&amp;hellip;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $val = &amp;amp;factorial($x);      # illegal, must use either
    $val = factorial($x);       #   this or
    $val = &amp;amp;factorial.($x);     #   maybe this.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In general, don&amp;rsquo;t use the &lt;code&gt;&amp;amp;&lt;/code&gt; form when you really want to call something.&lt;/p&gt;

&lt;h3 id=&#34;span-id-formal-parameter-traits-formal-parameter-traits-span&#34;&gt;&lt;span id=&#34;formal_parameter_traits&#34;&gt;Formal parameter traits&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Other than type, zone, and variable name, all other information about parameters is specified by the standard trait syntax, generally introduced by &lt;code&gt;is&lt;/code&gt;. Internally even the type and zone are just traits, but syntactically they&amp;rsquo;re out in front for psychological reasons. &lt;em&gt;Whose&lt;/em&gt; psychological reasons we won&amp;rsquo;t discuss.&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-constant-default-is-constant-default-span&#34;&gt;&lt;span id=&#34;is_constant_(default)&#34;&gt;&lt;code&gt;is constant&lt;/code&gt; (default)&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Every formal parameter is constant by default, meaning primarily that the compiler won&amp;rsquo;t feel obligated to construct an lvalue out the actual argument unless you specifically tell it to. It also means that you may not modify the parameter variable in any way. If the parameter is a reference, you may use it to modify the referenced object (if the object lets you), but you can&amp;rsquo;t assign to it and change the original variable passed to the routine.&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-rw-is-rw-span&#34;&gt;&lt;span id=&#34;is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;rw&lt;/code&gt; trait is how you tell the compiler to ask for an lvalue when evaluating the actual argument for this parameter. Do not confuse this with the &lt;code&gt;rw&lt;/code&gt; trait on the subroutine as a whole, which says that the entire subroutine knows how to function as an lvalue. If you set this trait, then you may modify the variable that was passed as the actual argument. A &lt;code&gt;swap&lt;/code&gt; routine would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub swap ($a is rw, $b is rw) { ($a,$b) = ($b,$a) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If applied to a slurpy parameter, the &lt;code&gt;rw&lt;/code&gt; trait distributes to each element of the list that is bound to the parameter. In the case of a slurpy hash, this implies that the named pairs are in an lvalue context, which actually puts the right side of each named pair into lvalue context.&lt;/p&gt;

&lt;p&gt;Since normal lvalues assume &amp;ldquo;&lt;code&gt;is rw&lt;/code&gt;&amp;rdquo;, I suppose that also implies that you can assign to a pair:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (key =&amp;gt; $var) = &amp;quot;value&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or even do named parameter binding:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (who =&amp;gt; $name, why =&amp;gt; $reason) := (why =&amp;gt; $because, who =&amp;gt; &amp;quot;me&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is the same as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $name   := &amp;quot;me&amp;quot;;
    $reason := $because;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And since a slurpy hash soaks up the rest of the named parameters, this also seems to imply that binding a slurpy &lt;code&gt;rw&lt;/code&gt; hash actually makes the hash values into &lt;code&gt;rw&lt;/code&gt; aliases:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a = &amp;quot;a&amp;quot;; $b = &amp;quot;b&amp;quot;;
    *%hash := (a =&amp;gt; $a, b =&amp;gt; $b);
    %hash{a} = &#39;x&#39;;
    print $a;   # prints &amp;quot;x&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s kinda scary powerful. I&amp;rsquo;m not sure I want to document that&amp;hellip; [&amp;ldquo;Too late!&amp;rdquo; whispers Evil Damian.]&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-copy-is-copy-span&#34;&gt;&lt;span id=&#34;is_copy&#34;&gt;&lt;code&gt;is copy&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This trait requests copy-in semantics. The variable is modifiable by you, but you&amp;rsquo;re only modifying your own private copy. It has the same effects as assigning the argument to your own &lt;code&gt;my&lt;/code&gt; variable. It does &lt;em&gt;not&lt;/em&gt; do copy-out.&lt;/p&gt;

&lt;p&gt;If you want both copy-in and copy-out semantics, declare it &lt;code&gt;rw&lt;/code&gt; and do your own copying back and forth, preferably with something that works even if you exit by exception (if that&amp;rsquo;s what you want):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub cico ($x is rw) {
        my $copy = $x;
        LAST { $x = $copy }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though if you&amp;rsquo;re using a copy you probably only want to copy-out on success, so you&amp;rsquo;d use a &lt;code&gt;KEEP&lt;/code&gt; block instead. Or more succinctly, using the new &lt;code&gt;will&lt;/code&gt; syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub cicomaybe ($x is rw) {
        my $copy will keep { $x = $copy } = $x;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-is-ref-is-ref-span&#34;&gt;&lt;span id=&#34;is_ref&#34;&gt;&lt;code&gt;is ref&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This trait explicitly requests call-by-reference semantics. It lets you read and write an existing argument but doesn&amp;rsquo;t attempt to coerce that argument to an lvalue (or autovivify it) on the caller end, as &lt;code&gt;rw&lt;/code&gt; would. This trait is distinguished from a parameter of type &lt;code&gt;Ref&lt;/code&gt;, which merely asserts that the return type of the parameter is a reference without necessarily saying anything about calling convention. You can without contradiction say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub copyref (Ref $ref is copy) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;meaning you can modify &lt;code&gt;$ref&lt;/code&gt;, but that doesn&amp;rsquo;t change whatever was passed as the argument for that parameter.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-defaults-defaults-span&#34;&gt;&lt;span id=&#34;defaults&#34;&gt;Defaults&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Default values are also traits, but are written as assignments and must come at the end of the formal parameter for psychological reasons.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule defval :w { \= &amp;lt;item&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub trim ( Str $_ is rw, Rule ?$remove = /\s+/ ) {
            s:each/^ &amp;lt;$remove&amp;gt; | &amp;lt;$remove&amp;gt; $//;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lets you call &lt;code&gt;trim&lt;/code&gt; as either:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trim($input);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trim($input, /\n+/);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s very important to understand that the expression denoted by &lt;code&gt;item&lt;/code&gt; is evaluated in the lexical scope of the subroutine definition, not of the caller. If you want to get at the lexical scope of the caller, you have to do it explicitly (see &lt;code&gt;CALLER::&lt;/code&gt; below). Note also that an &lt;code&gt;item&lt;/code&gt; may not contain unbracketed commas, or the parser wouldn&amp;rsquo;t be able to reliably locate the next parameter declaration.&lt;/p&gt;

&lt;p&gt;Although the default looks like an assignment, it isn&amp;rsquo;t one. Nor is it exactly equivalent to &lt;code&gt;//=&lt;/code&gt;, because the default is set only if the parameter doesn&amp;rsquo;t exist, not if it exists but is undefined. That is, it&amp;rsquo;s used only if no argument is bound to the parameter.&lt;/p&gt;

&lt;p&gt;An &lt;code&gt;rw&lt;/code&gt; parameter may only default to a valid lvalue. If you find yourself wanting it to default to an ordinary value because it&amp;rsquo;s undefined, perhaps you really want &lt;code&gt;//=&lt;/code&gt; instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub multprob ($x is rw, $y) {
        $x //= 1.0;     # assume undef means &amp;quot;is certain&amp;quot;
        $x *= $y;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Syntactically, you can put a default on a required parameter, but it would never be used because the argument always exists. So semantic analysis will complain about it. (And I&amp;rsquo;d rather not say that adding a default implies it&amp;rsquo;s optional without the &lt;code&gt;?&lt;/code&gt; zone marker.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-formal-parameter-types-formal-parameter-types-span&#34;&gt;&lt;span id=&#34;formal_parameter_types&#34;&gt;Formal parameter types&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Formal parameters may have any type that any other variable may have, though particular parameters may have particular restrictions. An invocant needs to be an object of an appropriate class or subclass, for instance. As with ordinary variable declarations the type in front is actually the return type, and you can put it afterwards if you like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo (int @array is rw) {...}
    sub foo (@array of int is rw) {...}
    sub foo (@array is Array of int is rw) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The type of the actual argument passed must be compatible with (but not necessarily identical to) the formal type. In particular, for methods the formal type will often indicate a base class of the actual&amp;rsquo;s derived class. People coming from C++ must remember that all methods are &amp;ldquo;virtual&amp;rdquo; in Perl.&lt;/p&gt;

&lt;p&gt;Closure parameters are typically declared with &lt;code&gt;&amp;amp;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub mygrep (&amp;amp;block, *@list is rw) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Within that subroutine, you can then call &lt;code&gt;block()&lt;/code&gt; as an ordinary subroutine with a lexically scoped name. If such a parameter is declared without its own parameter signature, the code makes no assumptions about the actual signature of the closure supplied as the actual argument. (You can always inspect the actual signature at run time, of course.)&lt;/p&gt;

&lt;p&gt;You may, however, supply a signature if you like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub mygrep (&amp;amp;block($foo), *@list is rw) {
        block(foo =&amp;gt; $bar);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With an explicit signature, it would be error to bind a block to &lt;code&gt;&amp;amp;block&lt;/code&gt; that is not compatible. We&amp;rsquo;re leaving &amp;ldquo;compatible&amp;rdquo; undefined for the moment, other than to point out that the signature doesn&amp;rsquo;t have to be identical to be compatible. If the actual subroutine accepted one required parameter and one optional, it would work perfectly fine, for instance. The signature in &lt;code&gt;mygrep&lt;/code&gt; is merely specifying what it requires of the subroutine, namely one positional argument named &amp;ldquo;&lt;code&gt;$foo&lt;/code&gt;&amp;rdquo;. (Conceivably it could even be named something different in the actual routine, provided the compiler turns that call into a positional one because it thinks it already knows the signature.)&lt;/p&gt;

&lt;h2 id=&#34;span-id-calling-subroutines-calling-subroutines-span&#34;&gt;&lt;span id=&#34;calling_subroutines&#34;&gt;Calling subroutines&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;The typical subroutine or method is called a lot more often than it is declared. So while the declaration syntax is rather ornate, we strive for a call syntax that is rather simple. Typically it just looks like a comma-separated list. Parentheses are optional on predeclared subroutine calls, but mandatory otherwise. Parentheses are mandatory on method calls with arguments, but may be omitted for argumentless calls to methods such as attribute accessors. Parentheses are optional on multimethod and macro calls because they always parse like list operators. A rule may be called like a method but is normally invoked within a regex via the &lt;code&gt;&amp;lt;rule&amp;gt;&lt;/code&gt; syntax.&lt;/p&gt;

&lt;p&gt;As in Perl 5, within the list there may be an implicit transition from scalar to list context. For example, the declaration of the standard &lt;code&gt;push&lt;/code&gt; built-in in Perl 6 probably looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *push (@array, *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but you still generally call it as you would in Perl 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push(@foo, 1, 2, 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This call has two of the three kinds of call arguments. It has one positional argument, followed by a variadic list. We could imagine adding options to &lt;code&gt;push&lt;/code&gt; sometime in the future. We &lt;em&gt;could&lt;/em&gt; define it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *push (@array, ?$how, *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s just an optional positional parameter, so you&amp;rsquo;d call it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push(@foo, &amp;quot;rapidly&amp;quot;, 1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that won&amp;rsquo;t do, actually, since we used to allow the list to start at the end of the positional parameters, and any pre-existing &lt;code&gt;push(@foo,1,2,3)&lt;/code&gt; call to the new declaration would end up mapping the &amp;ldquo;&lt;code&gt;1&lt;/code&gt;&amp;rdquo; onto the new optional parameter. Oops&amp;hellip;&lt;/p&gt;

&lt;p&gt;If instead we force new parameters to be in named notation, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *push (@array, *@list, +$how) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;t�en we can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push(@foo, how =&amp;gt; &amp;quot;rapidly&amp;quot;, 1,2,3)&amp;lt;/pre~
and it&#39;s no longer ambiguous.  Since dhow is i� the named-only zone,
it can never be set positionally, and the old calls to:

    push(@foo, 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;still work fine, because &lt;code&gt;*@list&lt;/code&gt; is still at the end of the positional parameter zone. If we instead declare that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *push (@array, +$how, *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could still say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push(@foo, how =&amp;gt; &amp;quot;rapidly&amp;quot;, 1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but this becomes illegal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push(@foo, 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;because the slurpy array is in the named-only zone. We&amp;rsquo;ll need an explicit way to indicate the start of the list in this case. I can think of lots of (mostly bad) ways. You probably can too. We&amp;rsquo;ll come back to this&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-actual-arguments-actual-arguments-span&#34;&gt;&lt;span id=&#34;actual_arguments&#34;&gt;Actual arguments&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So the actual arguments to a Perl function are of three kinds: positional, named, and list. Any or all of these parts may be omitted, but whenever they are there, they &lt;em&gt;must&lt;/em&gt; occur in that order. It&amp;rsquo;s more efficient for the compiler (and less confusing to the programmer) if all the positional arguments come before all the non-positional arguments in the list. Likewise, the named arguments are constrained to occur before the list arguments for efficiency&amp;ndash;otherwise the implementation would have to scan the entire list for named arguments, and some lists are monstrous huge.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;d call these three parts &amp;ldquo;zones&amp;rdquo; as well, but then people would get them confused with our six declarative zones. In fact, extending the zoning metaphor a bit, our three parts are more like houses, stores, and factories (real ones, not OO ones, sheesh). These are the kinds of things you actually &lt;em&gt;find&lt;/em&gt; in residential, commercial, and industrial zones. Similarly, you can think of the three different kinds of argument as the things you&amp;rsquo;re allowed to &lt;em&gt;bind&lt;/em&gt; in the different parameter zones.&lt;/p&gt;

&lt;p&gt;A house is generally a scalar item that is known for its position; after all, &amp;ldquo;there&amp;rsquo;s no &lt;em&gt;place&lt;/em&gt; like home&amp;rdquo;. Um, yeah. Anyway, we usually number our houses. In the US, we don&amp;rsquo;t usually name our houses, though in the UK they don&amp;rsquo;t seem to mind it.&lt;/p&gt;

&lt;p&gt;A store may have a position (a street number), but usually we refer to stores by name. &amp;ldquo;I&amp;rsquo;m going out to Fry&amp;rsquo;s&amp;rdquo; does not refer to a particular location, at least not here in Silicon Valley. &amp;ldquo;I&amp;rsquo;m going out to McDonald&amp;rsquo;s&amp;rdquo; doesn&amp;rsquo;t mean a particular location anywhere in the world, with the possible exception of &amp;ldquo;not Antarctica&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;You don&amp;rsquo;t really care exactly where a factory is&amp;ndash;as long as it&amp;rsquo;s not in your back yard&amp;ndash;you care what it produces. The typical factory is for mass producing a series of similar things. In programming terms, that&amp;rsquo;s like a generator, or a pipe&amp;hellip;or a list. And you mostly worry about how you get vast quantities of stuff into and out of the factory without keeping the neighbors awake at night.&lt;/p&gt;

&lt;p&gt;So our three kinds of arguments map onto the various parameter zones in a similar fashion.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-positional-arguments-the-positional-arguments-span&#34;&gt;&lt;span id=&#34;the_positional_arguments&#34;&gt;The positional arguments&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Obviously, actual positional arguments are mapped onto the formal parameters in the order in which the formal positional parameters are declared. Invocant parameters (if any) must match invocant arguments, the required parameters match positional arguments, and then any additional non-named arguments are mapped onto the optional positional parameters. However, as soon as the first named argument is seen (that cannot be mapped to an explicitly typed &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Hash&lt;/code&gt; parameter) this mapping stops, and any subsequent positional parameters may only be bound by name.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-named-arguments-the-named-arguments-span&#34;&gt;&lt;span id=&#34;the_named_arguments&#34;&gt;The named arguments&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;After the positional argument part, you may pass as many named pairs as you like. These may bind to any formal parameter named in the declaration, whether declared as positional or named. However, it is erroneous to simultaneously bind a parameter both by position and by name. Perl may (but is not required to) give you a warning or error about this. If the problem is ignored, the positional parameter takes precedence, since the name collision might have come in by accident as a result of passing extra arguments intended for a different routine. Problems like this can arise when passing optional arguments to all the base classes of the current class, for instance. It&amp;rsquo;s not yet clear how fail-soft we should be here.&lt;/p&gt;

&lt;p&gt;Named arguments can come in either as &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Hash&lt;/code&gt; references. When parameter mapper sees an argument that is neither a &lt;code&gt;Pair&lt;/code&gt; nor a &lt;code&gt;Hash&lt;/code&gt;, it assumes it&amp;rsquo;s the end of the named part and the beginning of the list part.&lt;/p&gt;

&lt;p&gt;All unbound named arguments are bound to elements of the slurpy hash, if one was declared. If no slurpy hash is declared, an exception is thrown (although some standard methods, like &lt;code&gt;BUILD&lt;/code&gt;, will provide an implicitly declared slurpy hash&amp;ndash;known as &lt;code&gt;%_&lt;/code&gt; by analogy to &lt;code&gt;@_&lt;/code&gt;&amp;ndash;to handle surplus named arguments).&lt;/p&gt;

&lt;p&gt;At the end of named argument processing, any unmapped optional parameter ends up with the value &lt;code&gt;undef&lt;/code&gt; unless a default value is declared for it. Any unmapped required parameter throws an exception.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-slurpy-array2-the-slurpy-array-span&#34;&gt;&lt;span id=&#34;the_slurpy_array2&#34;&gt;The slurpy array&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;All remaining arguments are bound to the slurpy array, if any. If no slurpy array is specified, any remaining arguments cause an exception to be thrown. (You only get an implicit &lt;code&gt;*@_&lt;/code&gt; slurpy array when the signature is omitted entirely. Otherwise we could never validly give the error &amp;ldquo;Too many arguments&amp;rdquo;.)&lt;/p&gt;

&lt;p&gt;No argument processing is done on this list. If you go back to using named pairs at the end of the list, for instance, you&amp;rsquo;ll have to pop those off yourself. But since the list is potentially very long, Perl isn&amp;rsquo;t going to look for those on your behalf.&lt;/p&gt;

&lt;p&gt;Indeed, the list could be infinitely long, and maybe even a little longer than that. Perl 5 always flattens lists before calling the subroutine. In Perl 6, list flattening is done lazily, so a list could contain several infinite entries:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print(1..Inf, 1..Inf);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That might eventually give the &lt;code&gt;print&lt;/code&gt; function heartburn, of course&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-variadic-transitions-variadic-transitions-span&#34;&gt;&lt;span id=&#34;variadic_transitions&#34;&gt;Variadic transitions&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are, then, two basic transitions in argument processing. First is the transition from positional to named arguments. The second is from named arguments to the variadic list. It&amp;rsquo;s also possible to transition directly from positional arguments to the variadic list if optional positional arguments have been completely specified. That is, the slurp array could just be considered the next optional positional parameter in that case, as it is in &lt;code&gt;push&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But what if you don&amp;rsquo;t want to fill out all the optional parameters, and you aren&amp;rsquo;t planning to use named notation to skip the rest of them? How can you make both transitions simultaneously? There are two workarounds. First, suppose we have a &lt;code&gt;push&lt;/code&gt;-like signature such as this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub stuff (@array, ?$how, *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The declarative workaround is to move the optional parameters after the slurp array, so that they are required to be specified as named parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub stuff (@array, *@list, +$how) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can treat the slurp array as a positional parameter. That&amp;rsquo;s the solution we used to add an extra argument to &lt;code&gt;push&lt;/code&gt; earlier, where the list always starts at the second argument.&lt;/p&gt;

&lt;p&gt;On the calling end, you don&amp;rsquo;t have any control of the declaration, but you can always specify one of the arguments as named, either the final positional one, or the list itself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff(@foo, how =&amp;gt; undef, 1,2,3)
    stuff(@foo, list =&amp;gt; (1,2,3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The latter is clearer and arguably more correct, but it has a couple of minor problems. For one thing, you have to know what the parameter name is. It&amp;rsquo;s all very well if you have to know the names of optional parameters, but &lt;em&gt;every&lt;/em&gt; list operator has a list that you really ought to be able to feed without knowing its name.&lt;/p&gt;

&lt;p&gt;So we&amp;rsquo;ll just say that the actual name of the slurpy list parameter is &amp;ldquo;&lt;code&gt;*@&lt;/code&gt;&amp;rdquo;. You can always say this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff(@foo, &#39;*@&#39; =&amp;gt; (1,2,3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s still a lot of extra unnecessary cruft&amp;ndash;but we can do better. List operators are like commands in Unix, where there&amp;rsquo;s a command line containing a program name and some options, and streams of data coming in and going out via pipes. The command in this case is &lt;code&gt;stuff&lt;/code&gt;, and the option is &lt;code&gt;@foo&lt;/code&gt;, which says what it is we&amp;rsquo;re stuffing. But what about the streams of stuff going in and out? Perl 6 has lazy lists, so they are in fact more like streams than they used to be.&lt;/p&gt;

&lt;p&gt;There will be two new operators, called pipe operators, that allow us to hook list generators together with list consumers in either order. So either of these works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff @foo &amp;lt;== 1,2,3
    1,2,3 ==&amp;gt; stuff @foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The (ir)rationale for this is provided in Appendix A.&lt;/p&gt;

&lt;p&gt;To be sure, these newfangled pipe operators do still pass the list as a &amp;ldquo;&lt;code&gt;*@&lt;/code&gt;&amp;rdquo;-named argument, because that allows indirection in the entire argument list. Instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt; stuff @foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you can pull everything out in front, including the positional and named parameters, and build a list that gets passed as &amp;ldquo;splat&amp;rdquo; arguments (described in the next section) to &lt;code&gt;stuff&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list(@foo, how =&amp;gt; &#39;scrambled&#39; &amp;lt;== 1,2,3)
        ==&amp;gt; stuff *;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In other words:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list(@foo, how =&amp;gt; &#39;scrambled&#39; &amp;lt;== 1,2,3) ==&amp;gt; stuff *;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list(@foo, how =&amp;gt; &#39;scrambled&#39; &amp;lt;== 1,2,3) ==&amp;gt; stuff *();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff *(list(@foo, how =&amp;gt; &#39;scrambled&#39; &amp;lt;== 1,2,3));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;splat&amp;rdquo; and the &lt;code&gt;list&lt;/code&gt; counteract each other, producing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff(@foo, how =&amp;gt; &#39;scrambled&#39; &amp;lt;== 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what &lt;code&gt;stuff&lt;/code&gt; actually sees is exactly as if you called it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff(@foo, how =&amp;gt; &#39;scrambled&#39;, &#39;*@&#39; =&amp;gt; (1,2,3));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff @foo, how =&amp;gt; &#39;scrambled&#39;, 1, 2, 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And yes, the &lt;code&gt;==&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;==&lt;/code&gt; operators are big, fat, and obnoxiously noticeable. I like them that way. I think the pipes are important and &lt;em&gt;should&lt;/em&gt; stand out. In postmodern architecture the ducts are just part of the deconstructed decor. (Just don&amp;rsquo;t anyone suggest a &lt;code&gt;==&amp;gt;=&lt;/code&gt; operator. Just&amp;hellip;don&amp;rsquo;t.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;==&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;==&lt;/code&gt; operators have the additional side effect of forcing their blunt end into list context and their pointy end into scalar context. (More precisely, it&amp;rsquo;s not the expression on the pointy end that is in scalar context, but rather the positional arguments of whatever list function is pointed to by the pointy end.) See Appendix A for details.&lt;/p&gt;

&lt;h3 id=&#34;span-id-context-context-span&#34;&gt;&lt;span id=&#34;context&#34;&gt;Context&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As with Perl 5, the scalar arguments are evaluated in scalar context, while the list arguments are evaluated in list context. However, there are a few wrinkles.&lt;/p&gt;

&lt;h4 id=&#34;span-id-overriding-signature-with-overriding-signature-with-span&#34;&gt;&lt;span id=&#34;overriding_signature_with_*&#34;&gt;Overriding signature with &lt;code&gt;*&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Perl 5 has a syntax for calling a function without paying any attention to its prototype, but in Perl 6 that syntax has been stolen for a higher purpose (referential purity). Also, sometimes you&amp;rsquo;d like to be able to ignore part of a signature rather than the whole signature. So Perl 6 has a different notation, unary &lt;code&gt;*&lt;/code&gt;, for disabling signature checking, which we&amp;rsquo;ve mentioned in earlier Apocalypses, and which you&amp;rsquo;ve already seen in the form of the &lt;code&gt;stuff *&lt;/code&gt; above. (Our splat in the &lt;code&gt;stuff *&lt;/code&gt; above is in fact unary, but the optional argument is missing, because the list is supplied via pipe.)&lt;/p&gt;

&lt;p&gt;The first splatted term in an argument list causes all prior terms to be evaluated in scalar context, and all subsequent terms to be evaluated in list context. (Splat is a no-op in list context, so it doesn&amp;rsquo;t matter if there are more splatted terms.) If the function wants more positional arguments, they are assumed to come from the generated list, as if the list had been specified literally in the program at that point as comma-separated values.&lt;/p&gt;

&lt;p&gt;With splat lists, some of the argument processing may have to be deferred from compile time to runtime, so in general such a call may run slower than the ordinary form.&lt;/p&gt;

&lt;h4 id=&#34;span-id-context-unknown-at-compile-time-context-unknown-at-compile-time-span&#34;&gt;&lt;span id=&#34;context_unknown_at_compile_time&#34;&gt;Context unknown at compile time&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If Perl can&amp;rsquo;t figure out the signature of a function at compile time (because, for instance, it&amp;rsquo;s a method and not a function), then it may not be known which arguments are in scalar or list context at the time they are evaluated. This doesn&amp;rsquo;t matter for Perl variables, because in Perl 6, they always return a reference in either scalar or list context. But if you call a function in such an indeterminate context, and the function doesn&amp;rsquo;t have a return value declared that clarifies whether the function behaves differently in scalar or list context, then one of two things must happen. The function must either run in an indeterminate context, or the actual call to the function must be delayed until the context is known. It is not yet clear which of these approaches is the lesser evil. It may well depend on whether the function pays more attention to its dynamic context or to global values. A function with no side effects and no global or dynamic dependencies can be called whenever we like, but we&amp;rsquo;re not here to enforce the functional paradigm. Interesting functions may pay attention to their context, and they may have side effects such as reading from an input stream in a particular order.&lt;/p&gt;

&lt;p&gt;A variant of running in indeterminate context is to simply assume the function is running in list context. (That is, after all, what Perl 5 does on methods and on not-yet-declared subroutines.) In Perl 6, we may see most such ambiguities resolved by explicit use of the &lt;code&gt;&amp;lt;==&lt;/code&gt; operator to force preceding args into scalar context, and the following args into list context. Individual arguments may also be forced into scalar or list context, of course.&lt;/p&gt;

&lt;p&gt;By the way, if you mix unary splat with &lt;code&gt;&amp;lt;==&lt;/code&gt;, only the args to the left of the splat are forced into scalar context. (It can do this because &lt;code&gt;&amp;lt;==&lt;/code&gt; governs everything back to the list operator, since it has a precedence slightly looser than comma.) So, given something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @moreargs = (1,2,3);
    mumble $a, @b, c(), *@moreargs &amp;lt;== @list;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can tell just by looking that &lt;code&gt;$a&lt;/code&gt;, &lt;code&gt;@b&lt;/code&gt;, and &lt;code&gt;c()&lt;/code&gt; are all evaluated in scalar context, while &lt;code&gt;@moreargs&lt;/code&gt; and &lt;code&gt;@list&lt;/code&gt; are both in list context. It is parsed like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mumble( ($a, @b, c(), (*@moreargs)) &amp;lt;== (@list) );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You might also write that like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @moreargs = list(1,2,3 &amp;lt;== @list);
    mumble $a, @b, c(), *@moreargs;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, we can still assume that &lt;code&gt;$a&lt;/code&gt;, &lt;code&gt;@b&lt;/code&gt;, &lt;code&gt;c()&lt;/code&gt; are in scalar context, because as we mentioned in the previous section, the &lt;code&gt;*&lt;/code&gt; forces it. (That&amp;rsquo;s because there&amp;rsquo;s no reason to put the splat if you&amp;rsquo;re already in list context.)&lt;/p&gt;

&lt;p&gt;Before we continue, you probably need a break. Here, have a break:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    *******************************************************
    ******************** Intermission *********************
    *******************************************************
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;span-id-variations-on-a-theme-variations-on-a-theme-span&#34;&gt;&lt;span id=&#34;variations_on_a_theme&#34;&gt;Variations on a theme&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Welcome back.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve covered the basics up till now, but there are a number of miscellaneous variations we left out in the interests of exposition. We&amp;rsquo;ll now go back to visit some of those issues.&lt;/p&gt;

&lt;h3 id=&#34;span-id-typed-slurps-typed-slurps-span&#34;&gt;&lt;span id=&#34;typed_slurps&#34;&gt;Typed slurps&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Sometimes you want to specify that the variadic list has a particular recurring type, or types. This falls out naturally from the slurp array syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub list_of_ints ($a, $b, Int *@ints) { ... }
    sub list_of_scalars (Scalar *@scalars) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These still evaluate the list in list context. But if you declare them as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub intlist ($a, $b, Int *@ints is context(Int)) { ... }
    sub scalarlist (Scalar *@scalars is context(Scalar)) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then these provide a list of &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Scalar&lt;/code&gt; contexts to the caller. If you call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    scalarlist(@foo, %bar, baz())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you get two scalar references and the scalar result of &lt;code&gt;baz()&lt;/code&gt;, not a flattened list. You can have lists without list context in Perl 6!&lt;/p&gt;

&lt;p&gt;If you want to have alternating types in your list, you can. Just specify a tuple type on your context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    strintlist( *@strints is context(Str,Int)) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl 5&amp;rsquo;s list context did not do lazy evaluation, but always flattened immediately. In Perl 6 the default list context &amp;ldquo;&lt;code&gt;is context(Lazy)&lt;/code&gt;&amp;rdquo;. But you can specify &amp;ldquo;&lt;code&gt;is context(Eager)&lt;/code&gt;&amp;rdquo; to get back to Perl 5 semantics of immediate flattening.&lt;/p&gt;

&lt;p&gt;As a sop to the Perl5-to-Perl6 translator (and to people who have to read translated programs), the &lt;code&gt;Eager&lt;/code&gt; context can also be specified by doubling the slurpy &lt;code&gt;*&lt;/code&gt; on the list to make it look like a pair of rollers that will squish anything flat:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub p5func ($arg, **@list) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;eager splat&amp;rdquo; is also available as a unary operator to attempt eager flattening on the rvalue side:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo = **1..Inf;  # Test our &amp;quot;out of memory&amp;quot; handler...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-sublist-formals-sublist-formals-span&#34;&gt;&lt;span id=&#34;sublist_formals&#34;&gt;Sublist formals&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s often the case that you&amp;rsquo;d like to treat a single array argument as if it were an argument list of its own. Well, you can. Just put a sublist signature in square brackets. This is particularly good for declaring multimethods in a functional programming mindset:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi apply (&amp;amp;func, []) { }
    multi apply (&amp;amp;func, [$head, *@tail]) {
        return func($head), apply(&amp;amp;func, @tail);
    }

    @squares := apply { $_ * $_ } [1...];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, in this case, the first multimethod is never called because the infinite list is never null no matter how many elements we pull off the front. But that merely means that &lt;code&gt;@squares&lt;/code&gt; is bound to an infinite list generator. No big deal, as long as you don&amp;rsquo;t try to flatten the list&amp;hellip;&lt;/p&gt;

&lt;p&gt;Note that, unlike the example in the previous section which alternated strings and integers, this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    strintlist( [Str, Int] *@strints ) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;implies single array references coming in, each containing a string and an integer.&lt;/p&gt;

&lt;p&gt;Of course, this may be a bad example insofar as we could just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi apply (&amp;amp;func) { }
    multi apply (&amp;amp;func, $head, *@tail) {
        return func($head), apply(&amp;amp;func, *@tail);
    }

    @squares := apply { $_ * $_ } *1...;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;d be nice to lose the &lt;code&gt;*&lt;/code&gt; though on the calls. Maybe what we really want is a slurpy scalar in front of the slurpy array, where presumably the &lt;code&gt;&amp;lt;==&lt;/code&gt; maps to the first slurpy scalar or hash (or it could be passed positionally):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi apply (&amp;amp;func) { }
    multi apply (&amp;amp;func, *$head, *@tail) {
        return func($head), apply(&amp;amp;func &amp;lt;== @tail);
    }

    @squares := apply { $_ * $_ } 1...;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yow, I think I could like that if I tried.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s say for now that a slurpy scalar parameter just pulls the first (or next) value off of the the slurpy list. The &lt;code&gt;[]&lt;/code&gt; notation is still useful though for when you really do have a single array ref coming in as a parameter.&lt;/p&gt;

&lt;h3 id=&#34;span-id-attributive-parameters-attributive-parameters-span&#34;&gt;&lt;span id=&#34;attributive_parameters&#34;&gt;Attributive parameters&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It is typical in many languages to see object initializers that look like this (give or take a keyword):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function init (a_arg, b_arg, c_arg) {
        a = a_arg;
        b = b_arg;
        c = c_arg;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other languages &lt;em&gt;try&lt;/em&gt; to improve the situation without actually succeeding. In a language resembling C++, it might look more like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method init (int a_arg, int b_arg, int c_arg)
        : a(a_arg), b(b_arg), c(c_arg) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there&amp;rsquo;s still an awful lot of redundancy there, not to mention inconsistent special syntax.&lt;/p&gt;

&lt;p&gt;Since (as proven by Perl 5) signatures are all about syntactic sugar anyway, and since Perl 6 intentionally makes attribute variables visually distinct from ordinary variables, we can simply write this in Perl 6 as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    submethod BUILD ($.a, $.b, $.c) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any parameter that appears to be an attribute is immediately copied directly into the corresponding object attribute, and no lexical parameter is generated. You can mix these with ordinary parameters&amp;ndash;the general rule of thumb for an initializer is that you should see each dotted attribute at least once:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    submethod BUILD ($.a, $.b, $c) {
        $.c = mung($c);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This feature is primarily intended for use in constructors and initializers, but Perl does not try to guess which subroutines fall into that category (other than the fact that Perl 6 will implicitly call certain conventional names like CREATE and BUILD.)&lt;/p&gt;

&lt;p&gt;However, submethods such as BUILD are assumed to have an extra &lt;code&gt;*%_&lt;/code&gt; parameter to soak up any extra unrecognized named arguments. Ordinarily you must declare a slurp-hash explicitly to get that behavior. But BUILD submethods are always called with named arguments (except for the invocant), and often have to ignore arguments intended for other classes participating in the current construction. It&amp;rsquo;s likely that this implicit &lt;code&gt;*%_&lt;/code&gt; feature extends to other routines declared in all-caps as well, and perhaps all submethods.&lt;/p&gt;

&lt;p&gt;As in Perl 5, subroutines declared in all-caps are expected to be called automatically most of the time&amp;ndash;but not necessarily all the time. The BUILD routine is a good example, because it&amp;rsquo;s only called automatically when you rely on the default class initialization rules. But you can override those rules, in which case you may have to call BUILD yourself. More on that in Apocalypse 12. Or go to one of Damian&amp;rsquo;s Perl 6 talks&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-other-kinds-of-subroutines-other-kinds-of-subroutines-span&#34;&gt;&lt;span id=&#34;other_kinds_of_subroutines&#34;&gt;Other kinds of subroutines&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-closures-closures-span&#34;&gt;&lt;span id=&#34;closures&#34;&gt;Closures&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;All blocks are considered closures in Perl 6, even the blocks that declare modules or classes (presuming you use the block form). A closure is just an anonymous subroutine that has access its lexical context. The fact that some closures are immediately associated with names or have other kinds of parameter declarations does not change the fact that an anonymous bare block without parameters is also a kind of subroutine. Of course, if the compiler can determine that the block is only executed inline, it&amp;rsquo;s free to optimize away all the subroutine linkage&amp;ndash;but not the lexical linkage. It can only optimize away the lexical linkage if no external lexicals are accessed (or potentially accessed, in the case of &lt;code&gt;eval&lt;/code&gt;).&lt;/p&gt;

&lt;h4 id=&#34;span-id-pointy-subs-pointy-subs-span-1&#34;&gt;&lt;span id=&#34;pointy_subs&#34;&gt;Pointy subs&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As introduced in Apocalypse 4, loops and topicalizers are often written with a special form of closure declaration known these days as &amp;ldquo;pointy subs&amp;rdquo;. A pointy sub is exactly equivalent to a standard anonymous sub declaration having the same parameters. It&amp;rsquo;s almost pure syntactic sugar&amp;ndash;except that we embrace syntactic sugar in Perl when it serves a psychological purpose (not to be confused with a logical psycho purpose, which we also have).&lt;/p&gt;

&lt;p&gt;Anyway, when you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -&amp;gt; $a, $b, $c { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s almost exactly the same as if you&amp;rsquo;d said:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub ($a, $b, $c) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;only without the parentheses, and with the cute arrow that indicates the direction of data flow to that part of your brain that consumes syntactic glucose at a prodigious rate.&lt;/p&gt;

&lt;p&gt;Since the parentheses around the signature are missing, you can&amp;rsquo;t specify anything that would ordinarily go outside the parentheses, such as the return type or other subroutine traits. But you may still put traits or zone markers on each individual formal parameter.&lt;/p&gt;

&lt;p&gt;Also, as a &amp;ldquo;sub-less&amp;rdquo; declaration, you can&amp;rsquo;t return from it using &lt;code&gt;return&lt;/code&gt;, because despite being a closure, it&amp;rsquo;s supposed to &lt;em&gt;look&lt;/em&gt; like a bare &lt;code&gt;Block&lt;/code&gt; embedded in a larger &lt;code&gt;Routine&lt;/code&gt;, and users will expect &lt;code&gt;return&lt;/code&gt; to exit from the &amp;ldquo;real&amp;rdquo; subroutine. All of which just means that, if you need those fancy extras, use a real &lt;code&gt;sub&lt;/code&gt; sub, not a pointy one.&lt;/p&gt;

&lt;h4 id=&#34;span-id-placeholders-placeholders-span&#34;&gt;&lt;span id=&#34;placeholders&#34;&gt;Placeholders&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Also as discussed in Apocalypse 4, a bare block functioning as a closure can have its parameters declared internally. Such parameters are of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule placeholder { &amp;lt;sigil&amp;gt; \^ &amp;lt;ident&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Placeholder parameters are equivalent to required position parameters declared in alphabetical order. (Er, Unicodical order, really.) For example, the closure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { $^fred &amp;lt;=&amp;gt; $^barney }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;has the same signature as the pointy sub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -&amp;gt; $barney, $fred { $fred &amp;lt;=&amp;gt; $barney }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or the standard anonymous sub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub ($barney, $fred) { $fred &amp;lt;=&amp;gt; $barney }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On first hearing about the alphabetical sorting policy, some otherwise level-headed folks immediately panic, imagining all sorts of ways to abuse the mechanism for the purposes of obfuscation. And surely there are many ways to abuse many of the features in Perl, more so in Perl 6. The point of this mechanism, however, is to make it drop-dead easy to write small, self-contained closures with a small number of parameters that you&amp;rsquo;d probably give single-character alphabetical names to in any event. If you want to get fancier than that, you should probably be using a fancier kind of declaration. I define &amp;ldquo;small number&amp;rdquo; as approximately &lt;em&gt;e&lt;/em&gt; ± π. But as is generally the case in Perl, you get to pick your own definition of &amp;ldquo;small number&amp;rdquo;. (Or at the very least, you get to pick whether to work with a company that has already defined &amp;ldquo;small number&amp;rdquo; for you.)&lt;/p&gt;

&lt;p&gt;As bare rvalue variables embedded in the code, you may not put any traits or zone markers on the placeholders. Again, the desire to do so indicates you should be using a fancier form of declaration.&lt;/p&gt;

&lt;h4 id=&#34;span-id-methods-methods-span&#34;&gt;&lt;span id=&#34;methods&#34;&gt;Methods&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Perl 5 just used subroutines for methods. This is okay as long as you don&amp;rsquo;t want to declare any utility subroutines in your class. But as soon as you do, they&amp;rsquo;re inherited in Perl 5, which is not what you want. In Perl 6, methods and subroutines still share the same namespace, but a method must be declared using the &lt;code&gt;method&lt;/code&gt; keyword. This is good documentation in any event, and further allows us to intuit an invocant where none is declared. (And we know that none is declared if there&amp;rsquo;s no colon after the first argument, at least in the case of an ordinary method.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-submethods-submethods-span&#34;&gt;&lt;span id=&#34;submethods&#34;&gt;Submethods&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;There are certain implementation methods that want to be inherited in general so that you can specify a default implementation, but that you want the class to be able to override without letting derived classes inherit the overridden method from this class. That is, they are scoped like utility subroutines, but can be called as if they are methods, without being visible outside the class. We call these hybrids &amp;ldquo;submethods&amp;rdquo;, and so there&amp;rsquo;s a &lt;code&gt;submethod&lt;/code&gt; keyword to declare them. Submethods are simultaneously subs and methods. You can also think of them as something less than a method, as the &amp;ldquo;sub&amp;rdquo; works in the word &amp;ldquo;subhuman&amp;rdquo;. Or you can think of them as underneath in the infrastructural sense, as in &amp;ldquo;subterranean&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Routines that create, initialize, or destroy the current object tend to fall into this category. Hence, the &lt;code&gt;BUILD&lt;/code&gt; routine we mentioned earlier is ordinarily declared as a submethod, if you don&amp;rsquo;t want to inherit the standard &lt;code&gt;BUILD&lt;/code&gt; method defined in the Object class. But if you override it, your children still inherit &lt;code&gt;BUILD&lt;/code&gt; from Object.&lt;/p&gt;

&lt;p&gt;Contrariwise, if you don&amp;rsquo;t like &lt;code&gt;Object&lt;/code&gt;&amp;rsquo;s default &lt;code&gt;BUILD&lt;/code&gt; method, you can define an entire new class of classes that all default to your own &lt;code&gt;BUILD&lt;/code&gt; method, as long as those classes derive from your new base object with superior characteristics. Each of those derived classes could then define a submethod to override your method only for that class, while classes derived from those classes could still inherit your default.&lt;/p&gt;

&lt;p&gt;And so on, ad OOium.&lt;/p&gt;

&lt;h4 id=&#34;span-id-multimethods-multimethods-span&#34;&gt;&lt;span id=&#34;multimethods&#34;&gt;Multimethods&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Some kinds of programming map easily onto the standard model in which a method has a single invocant. Other kinds of programming don&amp;rsquo;t. Perl 6 supplies support for the latter kind of programming, where the relationships between classes are just as interesting as the classes themselves. In some languages, all methods are multimethods. Perl 6 doesn&amp;rsquo;t go quite that far&amp;ndash;you must declare your multimethods explicitly. To do so, use the &lt;code&gt;multi&lt;/code&gt; keyword in place of &lt;code&gt;method&lt;/code&gt;, and optionally place a colon after the list of invocants in the declaration, unless you want them all to be invocants. Then your multimethod will be registered globally as a being of interest to all the types of its invocants, and will participate in multimethod dispatch.&lt;/p&gt;

&lt;p&gt;It is beyond the scope of this Apocalypse to specify exactly how multimethod dispatch works (see Apocalypse 12, someday), but we can tell you that, in general, you call a multimethod as if it were an ordinary subroutine, and the dispatcher figures out on your behalf how many of the arguments are invocants. This may sound fancy to you, but many of the functions that are built into Perl 5 are &lt;em&gt;not&lt;/em&gt; built into Perl 6, at least, not as keywords. Instead they are either defined as global subroutines or as multimethods, single invocant multimethods in many cases. When you call a function like &lt;code&gt;close($handle)&lt;/code&gt;, it&amp;rsquo;ll first look to see if there&amp;rsquo;s a &lt;code&gt;close&lt;/code&gt; subroutine defined in your scope, and if not, it will dispatch it as a multimethod. Likewise, for something like &lt;code&gt;sysread&lt;/code&gt;, you can call it either as a method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sysread $handle: $buffer, $length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or as a function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sysread $handle, $buffer, $length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the first case, it&amp;rsquo;s explicitly dispatching on the handle, because a colon in place of the first comma indicates an invocant. (That&amp;rsquo;s our new indirect object syntax, in fact. Perl 6 does not support the Perl 5 syntax of just leaving whitespace between the indirect object and the subsequent arguments.)&lt;/p&gt;

&lt;p&gt;In the second case, it looks for a &lt;code&gt;sysread&lt;/code&gt; subroutine, doesn&amp;rsquo;t find it (we hope), and calls multimethod dispatch on it. And it happens that the multimethod dispatch is smart enough to find the ordinary single-invocant &lt;code&gt;sysread&lt;/code&gt; method, even though it may not have been explicitly declared a multimethod. Multimethod dispatch happens to map directly onto ordinary method dispatch when there&amp;rsquo;s only one invocant.&lt;/p&gt;

&lt;p&gt;At least, that&amp;rsquo;s how it works this week&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-rules-rules-span&#34;&gt;&lt;span id=&#34;rules&#34;&gt;Rules&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Rules were discussed in Apocalypse 5. They are essentially methods with an implicit invocant, consisting of the object containing the current pattern matching context. To match the internals of regex syntax, traits attached to rules are typically written as &amp;ldquo;&lt;code&gt;:w&lt;/code&gt;&amp;rdquo; rather than &amp;ldquo;&lt;code&gt;is w&lt;/code&gt;&amp;rdquo;, but they&amp;rsquo;re essentially the same thing underneath.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s possible to call a rule as if it were a method, as long as you give it the right arguments. And a method defined in a grammar can be called as if it were a rule. They share the same namespace, and a rule really is just a method with a funny syntax.&lt;/p&gt;

&lt;h4 id=&#34;span-id-macros-macros-span&#34;&gt;&lt;span id=&#34;macros&#34;&gt;Macros&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A macro is a function that is called immediately upon completion of the parsing of its arguments. Macros must be defined before they are used&amp;ndash;there are no forward declarations of macros, and while a macro&amp;rsquo;s name may be installed in either a package or a lexical scope, its syntactic effect can only be lexical, from the point of declaration (or importation) to the end of the current lexical scope.&lt;/p&gt;

&lt;p&gt;Every macro is associated (implicitly or explicitly) with a particular grammar rule that parses and reduces the arguments to the macro. The formal parameters of a macro are special in that they must be derived somehow from the results of that associated grammar rule. We treat macros as if they were methods on the parse object returned by the grammar rule, so the first argument is passed as if it were an invocant, and it is always bound to the current parse tree object, known as &lt;code&gt;$0&lt;/code&gt; in Apocalypse 5. (A macro is not a true method of that class, however, because its name is in your scope, not the class&amp;rsquo;s.)&lt;/p&gt;

&lt;p&gt;Since the first parameter is treated as an invocant, you may either declare it or leave it implicit in the actual declaration. In either case, the parse tree becomes the current topic for the macro. Hence you may refer to it as either &lt;code&gt;$_&lt;/code&gt; or &lt;code&gt;$0&lt;/code&gt;, even if you don&amp;rsquo;t give it a name.&lt;/p&gt;

&lt;p&gt;Subsequent parameters may be specified, in which case they bind to internal values of &lt;code&gt;$0&lt;/code&gt; in whatever way makes sense. Positional parameters bind to &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. Named parameters bind to named elements of &lt;code&gt;$0&lt;/code&gt;. A slurpy hash is really the same as &lt;code&gt;$0&lt;/code&gt;, since &lt;code&gt;$0&lt;/code&gt; already behaves as a hash. A slurpy array gets &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc., even if already bound to a positional parameter.&lt;/p&gt;

&lt;p&gt;A macro can do anything it likes with the parse tree, but the return value is treated specially by the parser. You can return one of several kinds of values:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A parse tree (the same one, a modified one, or a synthetic one) to be passed up to the outer grammar rule that was doing pattern matching when we hit the macro.&lt;/li&gt;
&lt;li&gt;A closure functioning as a generic routine that is to be immediately inlined, treating the closure as a template. Within the template, any variable referring back to one of the macro&amp;rsquo;s parse parameters will interpolate that parameter&amp;rsquo;s value at that point in the template. (It will be interpolated as a parse tree, a string, or a number depending on the declaration of the parameter.) Any variable not referring back to a parameter is left alone, so that your template can declare its own lexical variables, or refer to a package variable.&lt;/li&gt;
&lt;li&gt;A string, to be shoved into the input stream and reparsed at the point the macro was found, starting in exactly the same grammar state we were before the macro. This is slightly different from returning the same string parsed into a parse tree, because a parse tree must represent a complete construct at some level, while the string could introduce a construct without terminating it. This is the most dangerous kind of return value, and the least likely to produce coherent error messages with decent line numbers for the end user. But it&amp;rsquo;s also very powerful. Hee, hee.&lt;/li&gt;
&lt;li&gt;An &lt;code&gt;undef&lt;/code&gt;, indicating that the macro is only used for its side effects. Such a macro would be one way of introducing an alternate commenting mechanism, for instance. I suppose returning &amp;ldquo;&amp;rdquo; has the same effect, though.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A &lt;code&gt;macro&lt;/code&gt; by default parses any subsequent text using whatever &lt;code&gt;macro&lt;/code&gt; rule is currently in effect. Generally this will be the standard &lt;code&gt;Perl::macro&lt;/code&gt; rule, which parses subsequent arguments as a list operator would&amp;ndash;that is, as a comma-separated list with the same policy on using or omitting parentheses as any other list operator. This default may be overridden with the &amp;ldquo;&lt;code&gt;is parsed&lt;/code&gt;&amp;rdquo; trait.&lt;/p&gt;

&lt;p&gt;If there is no signature at all, &lt;code&gt;macro&lt;/code&gt; defaults to using the null rule, meaning it looks for no argument at all. You can use it for simple word substitutions where no argument processing is needed. Instead of the long-winded:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my macro this () is parsed(/&amp;lt;null&amp;gt;/) { &amp;quot;self&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you can just quietly turn your program into C++:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my macro this { &amp;quot;self&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A lot of Perl is fun, and macros are fun, but in general, you should never use a macro just for the fun of it. It&amp;rsquo;s far too easy to poke someone&amp;rsquo;s eye out with a macro.&lt;/p&gt;

&lt;h3 id=&#34;span-id-outofband-parameters-out-of-band-parameters-span&#34;&gt;&lt;span id=&#34;outofband_parameters&#34;&gt;Out-of-band parameters&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Certain kinds of routines want extra parameters in addition to the ordinary parameter list. Autoloading routines for instance would like to know what function the caller was trying to call. Routines sensitive to topicalizers may wish to know what the topic is in their caller&amp;rsquo;s lexical scope.&lt;/p&gt;

&lt;p&gt;There are several possible approaches. The Perl 5 autoloader actually pokes a package variable into the package with the &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine. It could be argued that something that&amp;rsquo;s in your dynamic scope should be accessed via dynamically scoped variables, and indeed we may end up with a &lt;code&gt;$*AUTOLOAD&lt;/code&gt; variable in Perl 6 that works somewhat like Perl 5&amp;rsquo;s, only better, because &lt;code&gt;AUTOLOAD&lt;/code&gt; kinda sucks. We&amp;rsquo;ll address that in Apocalypse 10, for some definition of &amp;ldquo;we&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Another approach is to give access to the caller&amp;rsquo;s lexical scope in some fashion. The magical &lt;code&gt;caller()&lt;/code&gt; function could return a handle by which you can access the caller&amp;rsquo;s &lt;code&gt;my&lt;/code&gt; variables. And in general, there will be such a facility under the hood, because we have to be able to construct the caller&amp;rsquo;s lexical scope while it&amp;rsquo;s being compiled.&lt;/p&gt;

&lt;p&gt;In the particular case of grabbing the topic from the caller&amp;rsquo;s lexical scope (and it has to be in the caller&amp;rsquo;s &lt;em&gt;lexical&lt;/em&gt; scope because &lt;code&gt;$_&lt;/code&gt; is now lexically scoped in Perl 6), we think it&amp;rsquo;ll happen often enough that there should be a shorthand for it. Or maybe it&amp;rsquo;s more like a &amp;ldquo;midhand&amp;rdquo;. We don&amp;rsquo;t want it too short, or people will unthinkingly abuse it. Something on the order of a &lt;code&gt;CALLER::&lt;/code&gt; prefix, which we&amp;rsquo;ll discuss below.&lt;/p&gt;

&lt;h3 id=&#34;span-id-lexical-context-lexical-context-span&#34;&gt;&lt;span id=&#34;lexical_context&#34;&gt;Lexical context&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Works just like in Perl 5. Why change something that works?&lt;/p&gt;

&lt;p&gt;Well, okay, we are tweaking a few things related to lexical scopes. &lt;code&gt;$_&lt;/code&gt; (also known as the current topic) is always a lexically scoped variable now. In general, each subroutine will implicitly declare its own &lt;code&gt;$_&lt;/code&gt;. Methods, submethods, macros, rules, and pointy subs all bind their first argument to &lt;code&gt;$_&lt;/code&gt;; ordinary subs declare a lexical &lt;code&gt;$_&lt;/code&gt; but leave it undefined. Every sub definition declares its own &lt;code&gt;$_&lt;/code&gt; and hides any outer &lt;code&gt;$_&lt;/code&gt;. The only exception is bare closures that are pretending to be ordinary blocks and don&amp;rsquo;t commandeer &lt;code&gt;$_&lt;/code&gt; for a placeholder. These continue to see the outer scope&amp;rsquo;s &lt;code&gt;$_&lt;/code&gt;, just as they would any other lexically scoped variable declared in the outer scope.&lt;/p&gt;

&lt;h3 id=&#34;span-id-dynamic-context-dynamic-context-span&#34;&gt;&lt;span id=&#34;dynamic_context&#34;&gt;Dynamic context&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;On the flipside, &lt;code&gt;$_&lt;/code&gt; is no longer visible in the dynamic context. You can still temporize (localize) it, but you&amp;rsquo;ll be temporizing the current subroutine&amp;rsquo;s lexical &lt;code&gt;$_&lt;/code&gt;, not the global &lt;code&gt;$_&lt;/code&gt;. Routines which used to use dynamic scoping to view the &lt;code&gt;$_&lt;/code&gt; of a calling subroutine will need some tweaking. See &lt;code&gt;CALLER::&lt;/code&gt; below.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-caller-function-the-caller-function-span&#34;&gt;&lt;span id=&#34;the_caller_function&#34;&gt;The &lt;code&gt;caller&lt;/code&gt; function&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As in Perl 5, the &lt;code&gt;caller&lt;/code&gt; function will return information about the dynamic context of the current subroutine. Rather than always returning a list, it will return an object that represents the selected caller&amp;rsquo;s context. (In a list context, the object can still return the old list as Perl 5-ers are used to.) Since contexts are polymorphic, different context objects might in fact supply different methods. The &lt;code&gt;caller&lt;/code&gt; function doesn&amp;rsquo;t have to know anything about that, though.&lt;/p&gt;

&lt;p&gt;What &lt;code&gt;caller&lt;/code&gt; does know in Perl 6 is that it takes an optional argument. That argument says where to stop when scanning up the call stack, and so can be used to tell &lt;code&gt;caller&lt;/code&gt; which kinds of context you&amp;rsquo;re interested in. By default, it&amp;rsquo;ll skip any &amp;ldquo;wrapper&amp;rdquo; functions (see &amp;ldquo;The &lt;code&gt;.wrap&lt;/code&gt; method&amp;rdquo; below) and return the outermost context that thought it was calling your routine directly. Here&amp;rsquo;s a possible declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *caller (?$where = &amp;amp;CALLER::_, Int +$skip = 0, Str +$label)
        returns CallerContext {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$where&lt;/code&gt; argument can be anything that matches a particular context, including a subroutine reference or any of these Code types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Code Routine Block Sub Method Submethod Multi Macro Bare Parametric
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;_&lt;/code&gt; produces a reference to your current &lt;code&gt;Routine&lt;/code&gt;, though in the signature above we have to use &lt;code&gt;&amp;amp;CALLER::_&lt;/code&gt; to get at the caller&amp;rsquo;s &lt;code&gt;&amp;amp;_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that use of &lt;code&gt;caller&lt;/code&gt; can prevent certain kinds of optimizations, such as tail recursion elimination.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-want-function-the-want-function-span&#34;&gt;&lt;span id=&#34;the_want_function&#34;&gt;The &lt;code&gt;want&lt;/code&gt; function&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;want&lt;/code&gt; function is really just the &lt;code&gt;caller&lt;/code&gt; function in disguise. It also takes an argument telling it which context to pay attention to, which defaults to the one you think it should default to. It&amp;rsquo;s declared like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *want (?$where = &amp;amp;CALLER::_, Int +$skip = 0, Str +$label)
        returns WantContext {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, as a variant of &lt;code&gt;caller&lt;/code&gt;, use of &lt;code&gt;want&lt;/code&gt; can prevent certain kinds of optimizations.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;want&lt;/code&gt; is called in a scalar context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $primary_context = want;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it returns a synthetic object whose type behaves as the junction of all the valid contexts currently in effect, whose numeric overloading returns the count of arguments expected, and whose string overloading produces the primary context as one of &amp;lsquo;Void&amp;rsquo;, &amp;lsquo;Scalar&amp;rsquo;, or &amp;lsquo;List&amp;rsquo;. The boolean overloading produces true unless in a void context.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;want&lt;/code&gt; is called in a list context like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        ($primary, $count, @secondary) = want;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it returns a list of at least two values, indicating the contexts in which the current subroutine was called. The first two values in the list are the primary context (i.e the scalar return value) and the expectation count (see Expectation counts below). Any extra contexts that &lt;code&gt;want&lt;/code&gt; may detect (see Valid contexts below) are appended to these two items.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;want&lt;/code&gt; is used as an object, it has methods corresponding to its valid contexts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        if want.rw { ... }
        unless want.count &amp;lt; 2 { ... }
        when want.List { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;want&lt;/code&gt; function can be used with smart matching:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        if want ~~ List &amp;amp; 2 &amp;amp; Lvalue { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which means it can also be used in a switch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given want {
        when List &amp;amp; 2 &amp;amp; Lvalue { ... }
        when .count &amp;gt; 2 {...}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The numeric value of the &lt;code&gt;want&lt;/code&gt; object is the &amp;ldquo;expectation count&amp;rdquo;. This is an integer indicating the number of return values expected by the subroutine&amp;rsquo;s caller. For void contexts, the expectation count is always zero; for scalar contexts, it is always zero or one; for list contexts it may be any non-negative number. The &lt;code&gt;want&lt;/code&gt; value can simply be used as a number:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if want &amp;gt;= 2 { return ($x, $y) }         # context wants &amp;gt;= 2 values
    else         { return ($x); }            # context wants &amp;lt; 2 values
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;Inf &amp;gt;= 2&lt;/code&gt; is true. (&lt;code&gt;Inf&lt;/code&gt; is not the same as &lt;code&gt;undef&lt;/code&gt;.) If the context is expecting an unspecified number of return values (typically because the result is being assigned to an array variable), the expectation count is &lt;code&gt;Inf&lt;/code&gt;. You shouldn&amp;rsquo;t actually return an infinite list, however, unless &lt;code&gt;want ~~ Lazy&lt;/code&gt;. The opposite of &lt;code&gt;Lazy&lt;/code&gt; context is &lt;code&gt;Eager&lt;/code&gt; context (the Perl 5 list context, which always flattened immediately). &lt;code&gt;Eager&lt;/code&gt; and &lt;code&gt;Lazy&lt;/code&gt; are subclasses of &lt;code&gt;List&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The valid contexts are pretty much as listed in RFC 21, though to the extent that the various contexts can be considered types, they can be specified without quotes in smart matches. Also, types are not all-caps any more. We know we have a &lt;code&gt;Scalar&lt;/code&gt; type&amp;ndash;hopefully we also get types or pseudo-types like &lt;code&gt;Void&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt;, etc. The &lt;code&gt;List&lt;/code&gt; type in particular is an internal type for the temporary lists that are passed around in Perl. Preflattened lists are &lt;code&gt;Eager&lt;/code&gt;, while those lists that are not preflattened are &lt;code&gt;Lazy&lt;/code&gt;. When you call &lt;code&gt;@array.specs&lt;/code&gt;, for instance, you actually get back an object of type &lt;code&gt;Lazy&lt;/code&gt;. Lists (&lt;code&gt;Lazy&lt;/code&gt; or otherwise) are internal generator objects, and in general you shouldn&amp;rsquo;t be doing operations on them, but on the arrays to which they are bound. The bound array manages its hidden generators on your behalf to &amp;ldquo;harden&amp;rdquo; the abstract list into concrete array values on demand.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-caller-pseudopackage-the-caller-pseudopackage-span&#34;&gt;&lt;span id=&#34;the_caller::_pseudopackage&#34;&gt;The &lt;code&gt;CALLER::&lt;/code&gt; pseudopackage&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Just as the &lt;code&gt;SUPER::&lt;/code&gt; pseudopackage lets you name a method somewhere in your set of superclasses, the &lt;code&gt;CALLER::&lt;/code&gt; pseudoclass lets you name a variable that is in the lexical scope of your (dynamically scoped) caller. It may not be used to create a variable that does not already exist in that lexical scope. As such, it is is primarily intended for a particular variable that &lt;em&gt;is&lt;/em&gt; known to exist in every caller&amp;rsquo;s lexical scope, namely &lt;code&gt;$_&lt;/code&gt;. Your caller&amp;rsquo;s current topic is named &lt;code&gt;$CALLER::_&lt;/code&gt;. Your caller&amp;rsquo;s current &lt;code&gt;Routine&lt;/code&gt; reference is named &lt;code&gt;&amp;amp;CALLER::_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note again that, as a form of &lt;code&gt;caller&lt;/code&gt;, use of &lt;code&gt;CALLER::&lt;/code&gt; can prevent certain kinds of optimizations. However, if your signature uses &lt;code&gt;$CALLER::_&lt;/code&gt; as a default value, the optimizer may be able to deal with that as a special case. If you say, for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub myprint (IO $handle, *@list = ($CALLER::_)) {
        print $handle: *@list;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the compiler can just turn the call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    myprint($*OUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;into:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    myprint($*OUT, $_);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our earlier example of &lt;code&gt;trim&lt;/code&gt; might want to default the first argument to the caller&amp;rsquo;s &lt;code&gt;$_&lt;/code&gt;. In which case you can declare it as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub trim ( Str ?$_ is rw = $CALLER::_, Rule ?$remove = /\s+/ ) {
            s:each/^ &amp;lt;$remove&amp;gt; | &amp;lt;$remove&amp;gt; $//;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which lets you call it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trim;   # trims $_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or even this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trim remove =&amp;gt; /\n+/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do not confuse the caller&amp;rsquo;s lexical scope with the &lt;em&gt;callee&lt;/em&gt;&amp;rsquo;s lexical scope. In particular, when you put a bare block into your program that uses &lt;code&gt;$_&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @array {
        mumble { s/foo/bar/ };
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the compiler may not know whether or not the &lt;code&gt;mumble&lt;/code&gt; routine is intending to pass &lt;code&gt;$_&lt;/code&gt; as the first argument of the closure, which &lt;code&gt;mumble&lt;/code&gt; needs to do if it&amp;rsquo;s some kind of looping construct, and doesn&amp;rsquo;t need to do if it&amp;rsquo;s a one-shot. So such a bare block actually compiles down to something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @array {
        mumble(sub ($_ is rw = $OUTER::_) { s/foo/bar/ });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(If you put &lt;code&gt;$CALLER::_&lt;/code&gt; there instead, it would be wrong, because that would be referring to &lt;code&gt;mumble&lt;/code&gt;&amp;rsquo;s &lt;code&gt;$_&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;$OUTER::_&lt;/code&gt;, if &lt;code&gt;mumble&lt;/code&gt; passes an argument to the block, that argument becomes &lt;code&gt;$_&lt;/code&gt; each time &lt;code&gt;mumble&lt;/code&gt; calls the block. Otherwise, it&amp;rsquo;s just the same outer &lt;code&gt;$_&lt;/code&gt;, as if ordinary lexical scoping were in effect. And, indeed, if the compiler knows that &lt;code&gt;mumble&lt;/code&gt; takes a sub argument with a signature of &lt;code&gt;()&lt;/code&gt;, it may optimize it down to ordinary lexical scoping, and if it has a signature of &lt;code&gt;($)&lt;/code&gt;, it can assume it doesn&amp;rsquo;t need the default. A signature of &lt;code&gt;(?$)&lt;/code&gt; means all bets are off again.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-where-return-leave-returns-to-where-return-leave-returns-to-span&#34;&gt;&lt;span id=&#34;where_return/leave_returns_to&#34;&gt;Where &lt;code&gt;return&lt;/code&gt;/&lt;code&gt;leave&lt;/code&gt; returns to&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A &lt;code&gt;return&lt;/code&gt; statement needs to return to where the user thinks it ought to return to. Since any block is a closure, any block is really a subroutine in disguise. But the user doesn&amp;rsquo;t generally want &lt;code&gt;return&lt;/code&gt; to return from the innermost block, but from the innermost block that was actually defined using an explicit &lt;code&gt;sub&lt;/code&gt;-ish keyword. So that&amp;rsquo;s what Perl 6 does. If it can, it will implement the &lt;code&gt;return&lt;/code&gt; internally as a simple jump to the end of the subroutine. If it can&amp;rsquo;t, it implements &lt;code&gt;return&lt;/code&gt; by throwing a control exception that is caught by the proper context frame.&lt;/p&gt;

&lt;p&gt;There will be a &lt;code&gt;leave&lt;/code&gt; function that can return from other scopes. By default it exits from the innermost block (anything matching base class &lt;code&gt;Code&lt;/code&gt;), but, as with &lt;code&gt;caller&lt;/code&gt; and &lt;code&gt;want&lt;/code&gt;, you can optionally select the scope you want to return from. It&amp;rsquo;s declared like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi leave (?$where = Code, *@value, Int +$skip, Str +$label) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which lets you say things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    leave;
    leave Block;
    leave &amp;amp;_ &amp;lt;== 1,2,3; # same as &amp;quot;return 1,2,3&amp;quot;
    leave where =&amp;gt; Parametric, value =&amp;gt; (1,2,3);
    leave Loop, label =&amp;gt; &#39;LINE&#39;, $retval
    leave { $_ ~~ Block and $_ !~ Sub } 1,2,3;
    leave () &amp;lt;== 1,2,3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As it currently stands, the parens aren&amp;rsquo;t optional on that last one, because &lt;code&gt;&amp;lt;==&lt;/code&gt; is a binary operator. You could always define yourself a &amp;ldquo;small&amp;rdquo; return, &lt;code&gt;ret&lt;/code&gt;, that leaves the innermost block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my macro ret { &amp;quot;leave Code &amp;lt;== &amp;quot; }
    # and later...
    { ret 1,2,3 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that unlike a &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;leave&lt;/code&gt; always evaluates any return value in list context. Another thing to iron out is that the context we choose to leave must have set up an exception handler that can handle the control exception that &lt;code&gt;leave&lt;/code&gt; must in some cases throw. This seems to imply that any context must miminally catch a control exception that is bound to its own identity, since &lt;code&gt;leave&lt;/code&gt; is doing the picking, not the exception handlers.&lt;/p&gt;

&lt;h3 id=&#34;span-id-subroutine-object-methods-subroutine-object-methods-span&#34;&gt;&lt;span id=&#34;subroutine_object_methods&#34;&gt;Subroutine object methods&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-the-wrap-method-the-wrap-method-span&#34;&gt;&lt;span id=&#34;the_.wrap_method&#34;&gt;The &lt;code&gt;.wrap&lt;/code&gt; method&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;You may ask a subroutine to wrap itself up in another subroutine in place, so that calls to the original are intercepted and interpreted by the wrapper, even if access is only through the reference:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $id = $subref.wrap({
        # preprocessing here
        call;
        # postprocessing here
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;call&lt;/code&gt; built-in knows how to call the inner function that this function is wrapped around. In a void context, &lt;code&gt;call&lt;/code&gt; arranges for the return value of the wrapped routine to be returned implicitly. Alternately, you can fetch the return value yourself from &lt;code&gt;call&lt;/code&gt; and return it explicitly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $id = $subref.wrap({
        my @retval = call;
        push(@retval, &amp;quot;...and your little dog, too!&amp;quot;;
        return @retval;
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The arguments arrive in whatever form you request them, independently of how the parameters look to the wrapped routine. If you wish to modify the parameters, supply a new argument list to &lt;code&gt;call&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $id = $subref.wrap(sub (*@args) {
        call(*@args,1,2,3);
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You need to be careful not to preflatten those generators, though.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$id&lt;/code&gt; is useful for removing a particular wrapper:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $subref.unwrap($id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We might also at some point allow a built-in &lt;code&gt;sub&lt;/code&gt;-like keyword &lt;code&gt;wrap&lt;/code&gt;. If we don&amp;rsquo;t, someone will write it anyway.&lt;/p&gt;

&lt;p&gt;There is also likely a &lt;code&gt;.wrappers&lt;/code&gt; method that represents the list of all the current wrappers of the subroutine. The ordering and manipulation of this list is beyond the scope of this document, but such activity will be necessary for anyone implementing Aspect-Oriented Programming in Perl 6.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-assuming-method-the-assuming-method-span&#34;&gt;&lt;span id=&#34;the_.assuming_method&#34;&gt;The &lt;code&gt;.assuming&lt;/code&gt; method&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Currying is done with the &lt;code&gt;.assuming&lt;/code&gt; method. It works a bit like the &lt;code&gt;.wrap&lt;/code&gt; method, except that instead of wrapping in place, it returns a new function to you with a different signature, one in which some of the parameters are assumed to be certain values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;say ::= &amp;amp;*print.assuming(handle =&amp;gt; $*TERM);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can even curry built-in operators:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;prefix:½ ::= &amp;amp;infix:/ .assuming(y =&amp;gt; 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(assuming here that built-in infix operators always use &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt;).&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-req-method-the-req-method-span&#34;&gt;&lt;span id=&#34;the_.req_method&#34;&gt;The &lt;code&gt;.req&lt;/code&gt; method&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;.req&lt;/code&gt; method returns the number of required args requested by the sub in question. It&amp;rsquo;s just a shortcut for digging down into the &lt;code&gt;signature&lt;/code&gt; trait and counting up how many required parameters there are. The count includes any invocant (or invocants, for multimethods).&lt;/p&gt;

&lt;p&gt;If you want to know how many optional arguments there are, you can do your own digging. This call is primarily for use by madmen who wish to write variants of &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; that are sensitive to the number of parameters declared for the supplied block. (Certainly the implementation of &lt;code&gt;for&lt;/code&gt; will make heavy use of this information.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-subroutine-traits-subroutine-traits-span&#34;&gt;&lt;span id=&#34;subroutine_traits&#34;&gt;Subroutine traits&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;These are traits that are declared on the subroutine as a whole, not on any individual parameter.&lt;/p&gt;

&lt;h4 id=&#34;span-id-internal-traits-internal-traits-span&#34;&gt;&lt;span id=&#34;internal_traits&#34;&gt;Internal traits&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;signature&lt;/code&gt;, &lt;code&gt;returns&lt;/code&gt;, and &lt;code&gt;do&lt;/code&gt; traits are internal traits containing, respectively, the type signature of the parameters, the type signature of the return value, and the body of the function. Saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub Num foo (int $one, Str *@many) { return +@many[$one] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is short for saying something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo is signature( sig(int $one, Str *@many) )
            is returns( sig(Num) )
            will do { return +@many[$one] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, it&amp;rsquo;s likely that the &amp;ldquo;do&amp;rdquo; trait handler has to set up all the linkage to pass parameters in and to trap &amp;ldquo;return&amp;rdquo; exceptions.&lt;/p&gt;

&lt;p&gt;Many of these pre-defined traits just map straight onto the container object&amp;rsquo;s attribute methods of the same name. Underneath they&amp;rsquo;re just accessors, but we use the trait notation in declarations for several reasons. For one thing, you can string a bunch of them together without repeating the original object, which might be anonymous in any event. It also gives us liberty behind the scenes to promote or demote various traits from mere properties to attributes of every object of a class. It&amp;rsquo;s one of those levels of indirection computer scientists keep talking about&amp;hellip;&lt;/p&gt;

&lt;p&gt;Going the other direction, it allows us to pretend that accessors are just another form of metadata when accessed as a trait. By the same token it allows us to transparently make our metadata active rather than passive, without rewriting our declarations. This seems useful.&lt;/p&gt;

&lt;p&gt;The basic rule of thumb is that you can use any of a container&amp;rsquo;s &lt;code&gt;rw&lt;/code&gt; methods as if it were a trait. For subroutine containers, the example above really turns into something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    BEGIN {
        &amp;amp;foo.signature = sig(int $one, Str *@many);
        &amp;amp;foo.returns = sig(Num);
        &amp;amp;foo.do = { return +@many[$one] }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-is-rw-is-rw-span-1&#34;&gt;&lt;span id=&#34;is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This trait identifies lvalue subs or methods. See the section on lvalue subs below.&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-parsed-rule-is-parsed-rule-span&#34;&gt;&lt;span id=&#34;is_parsed(&lt;rule&gt;)&amp;ldquo;&amp;gt;&lt;code&gt;is parsed(&amp;lt;rule&amp;gt;)&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This trait binds a macro to a grammar rule for parsing it. The grammar rule is invoked as soon as the initial keyword is seen and before anything else is parsed, so you can completely change the grammar on the fly. For example, the &lt;code&gt;sig()&lt;/code&gt; function above might well invoke special parsing rules on its arguments, since what is inside is not an ordinary expression.&lt;/p&gt;

&lt;p&gt;In the absence of an explicit &amp;lt;is parsed&amp;gt; trait, a macro&amp;rsquo;s arguments are parsed with whatever &lt;code&gt;macro&lt;/code&gt; rule is in effect, by default the standard &lt;code&gt;Perl::macro&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-cloned-begin-is-cloned-begin-span&#34;&gt;&lt;span id=&#34;is_cloned(begin)&#34;&gt;&lt;code&gt;is cloned(&amp;quot;BEGIN&amp;quot;)&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Perhaps this is an alternate way of specifying the parsing and semantics of a macro or function. Or perhaps not. Just an idea for now&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-cached-is-cached-span&#34;&gt;&lt;span id=&#34;is_cached&#34;&gt;&lt;code&gt;is cached&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This is the English translation of what some otherwise sane folks call &amp;ldquo;memoization&amp;rdquo;. This trait asserts that Perl can do automatic caching of return values based on the assumption that, for any particular set of arguments, the return value is always the same. It can dramatically speed up certain kinds of recursive functions that shouldn&amp;rsquo;t have been written recursively in the first place. &lt;code&gt;;-)&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-inline-is-inline-span&#34;&gt;&lt;span id=&#34;is_inline&#34;&gt;&lt;code&gt;is inline&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This says you think performance would be enhanced if the code were inlined into the calling code. Of course, it also constitutes a promise that you&amp;rsquo;re not intending to redefine it or wrap it or do almost anything else fancy with it, such as expecting it to get called by a method dispatcher. In early versions of Perl 6, it&amp;rsquo;s likely to be completely ignored, I suspect. (If not, it&amp;rsquo;s likely to be completely broken&amp;hellip;)&lt;/p&gt;

&lt;h4 id=&#34;span-id-pre-post-first-last-etc-pre-post-first-last-etc-span&#34;&gt;&lt;span id=&#34;pre/post/first/last/etc.&#34;&gt;&lt;code&gt;PRE&lt;/code&gt;/&lt;code&gt;POST&lt;/code&gt;/&lt;code&gt;FIRST&lt;/code&gt;/&lt;code&gt;LAST&lt;/code&gt;/etc.&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;These all-caps traits are generally set from the inside of a subroutine as special blocks. &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;LAST&lt;/code&gt; are expected to have side effects. &lt;code&gt;PRE&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; are expected to not have side effects, but return a boolean value indicating whether pre/post conditions have been met. If you declare any &lt;code&gt;PRE&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt; conditions, your routine will automatically be wrapped in a wrapper that evaluates them according to Design-by-Contract principles (ORing preconditions, ANDing postconditions).&lt;/p&gt;

&lt;p&gt;Note that the actual &amp;ldquo;first&amp;rdquo; or &amp;ldquo;last&amp;rdquo; property attached to a subroutine may well be a list of &lt;code&gt;FIRST&lt;/code&gt; or &lt;code&gt;LAST&lt;/code&gt; blocks, since there can be more than one of them.&lt;/p&gt;

&lt;h3 id=&#34;span-id-overriding-builtins-overriding-built-ins-span&#34;&gt;&lt;span id=&#34;overriding_builtins&#34;&gt;Overriding built-ins&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;All built-in functions that can be overridden are either multimethods or global subroutines. To override one of these, just declare your own subroutine of that name in your current package or lexical scope. For instance, the standard non-filehandle print function may well be declared as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *print (*@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just declare your own sub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub print (*@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to override all &lt;code&gt;print&lt;/code&gt; multimethods in the current package, or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub print (*@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to override in the current lexical scope.&lt;/p&gt;

&lt;p&gt;To override or wrap a built-in function for everyone (dangerous), you have to play with the globally named version, but we&amp;rsquo;re not going to tell you how to do that. If you can&amp;rsquo;t figure it out, you shouldn&amp;rsquo;t be doing it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-subs-with-special-parsing-subs-with-special-parsing-span&#34;&gt;&lt;span id=&#34;subs_with_special_parsing&#34;&gt;Subs with special parsing&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Any macro can have special parsing rules if you use the &lt;code&gt;is parsed&lt;/code&gt; trait. But some subs are automatically treated specially.&lt;/p&gt;

&lt;h4 id=&#34;span-id-operator-subroutines-operator-subroutines-span&#34;&gt;&lt;span id=&#34;operator_subroutines&#34;&gt;Operator subroutines&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;In Perl 6, operators are just subroutines with special names. When you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -$a + $b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;re really doing this internally:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    infix:+( prefix:-($a), $b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Operator names start with one of four names followed by a colon:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    prefix:     a unary prefix operator
    infix:      a binary infix operator
    postfix:    a binary suffix operator
    circumfix:  a bracketing operator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything after the colon and up to the next whitespace or left parenthesis will be taken as the spelling of the actual operator. Unicode is specifically allowed. The null operator is not allowed, so if the first thing after the colon is a left parenthesis, it is part of the operator, and if the first thing is whitespace, it&amp;rsquo;s an illegal name. Boom!&lt;/p&gt;

&lt;p&gt;You can make your own lexically scoped operators like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub postfix:! (Int $x) { return factorial($x) }
    print 5!, &amp;quot;\n&amp;quot;;     # print 120
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use a newly declared operator recursively as soon as its name is introduced, including in its own definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub postfix:! (Int $x) { $x&amp;lt;=1 ?? 1 :: $x*($x-1)! }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can declare multimethods that create new syntax like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi postfix:! (Int $x) { $x&amp;lt;=1 ?? 1 :: $x*($x-1)! }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, regardless of the scope of the name, the new &lt;em&gt;syntax&lt;/em&gt; is considered to be a lexically scoped declaration, and is only valid after the name is declared (or imported) and after any precedence traits have been parsed.&lt;/p&gt;

&lt;p&gt;If you want to specify a precedence, you always do it relative to some existing operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi infix:coddle   (PDL $a, PDL $b) is equiv(&amp;amp;infix:+) { ... }
    multi infix:poach    (PDL $a, PDL $b) is looser(&amp;amp;infix:+) { ... }
    multi infix:scramble (PDL $a, PDL $b) is tighter(&amp;amp;infix:+) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you base a tighter operator on a looser one, or a looser one on a tighter one, you don&amp;rsquo;t get back to where you were. It always goes into the cracks no matter how many times you derive.&lt;/p&gt;

&lt;p&gt;Just a note on implementation: if you&amp;rsquo;ve played with numerically oriented precedence tables in the past, and are thinking, &amp;ldquo;but he&amp;rsquo;ll run out of bits in his number eventually.&amp;rdquo; The answer to that is that we don&amp;rsquo;t use precedence numbers. The actual precedence level can be represented internally by an arbitrarily long string of bytes that are compared byte by byte. When you make a tighter or looser operator, the string just gets one byte longer. A looser looser looser looser &lt;code&gt;infix:*&lt;/code&gt; is still tighter than a tighter tighter tighter tighter &lt;code&gt;infix:+&lt;/code&gt;, because the string comparison bails out on the first byte. The first byte compares the built-in multiplication operator against the built-in addition operator, and those are already different, so we don&amp;rsquo;t have to compare any more.&lt;/p&gt;

&lt;p&gt;However, two operators derived by the same path have the same precedence. All binary operators of a given precedence level are assumed to be left associative unless declared otherwise with an &lt;code&gt;assoc(&#39;right&#39;)&lt;/code&gt; or &lt;code&gt;assoc(&#39;non&#39;)&lt;/code&gt; trait. (Unaries pay no attention to associativity&amp;ndash;they always go from the outside in.)&lt;/p&gt;

&lt;p&gt;This may sound complicated, and it is, if you&amp;rsquo;re implementing it internally. But from the user&amp;rsquo;s point of view, it&amp;rsquo;s much less complicated than trying to keep track of numeric precedence levels yourself. By making the precedence levels relative to existing operators, we keep the user from having to think about how to keep those cracks open. And most user-defined operators will have exactly the same precedence as something built-in anyway. Not to mention the fact that it&amp;rsquo;s just plain better documentation to say that an operator works like a familiar operator such as &amp;ldquo;&lt;code&gt;+&lt;/code&gt;&amp;rdquo;. Who the heck can remember what precedence level 17 is, anyway?&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t specify a precedence on an operator, it will default to something reasonable. A named unary operator, whether prefix or postfix, will default to the same precedence as other named unary operators like &lt;code&gt;abs()&lt;/code&gt;. Symbolic unaries default to the same precedence as unary &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; (hence the &lt;code&gt;!&lt;/code&gt; in our factorial example is tighter than the &lt;code&gt;*&lt;/code&gt; of multiplication.) Binaries default to the same precedence as binary &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;. So in our &lt;code&gt;coddle&lt;/code&gt; example above, the &lt;code&gt;is equiv(&amp;amp;infix::+)&lt;/code&gt; is completely redundant.&lt;/p&gt;

&lt;p&gt;Unless it&amp;rsquo;s completely wrong. For multimethods, it&amp;rsquo;s an error to specify two different precedences for the same name. Multimethods that overload an existing name will be assumed to have the same precedence as the existing name.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll note that the rules for the scope of syntax warping are similar to those for macros. In essence, these definitions are macros, but specialized ones. If you declare one as a macro, the body is executed at compile time, and returns a string, a parse tree, or a closure just as a macro would:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # define Pascal comments:
    macro circumfix:(**) () is parsed(/.*?/ { &amp;quot;&amp;quot; }
                                # &amp;quot;Comment? What comment?&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A circumfix operator is assumed to be split symmetrically between prefix and postfix. In this case the circumfix of four characters is split exactly in two, but if you don&amp;rsquo;t want it split in the middle (which is particularly gruesome when there&amp;rsquo;s an odd number of characters) you may specify exactly where the parse rule is interpolated with a special &lt;code&gt;...&lt;/code&gt; marker, which is considered part of the name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    macro circumfix:(*...*) () is parsed(/.*?/ { &amp;quot;&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default parse rule for a circumfix is an ordinary Perl expression of lowest precedence, the same one Perl uses inside ordinary parentheses. The defaults for other kinds of operators depend on the precedence of the operator, which may or may not be reflected in the actual name of the grammatical rule.&lt;/p&gt;

&lt;p&gt;Note that the ternary operator &lt;code&gt;??::&lt;/code&gt; has to be parsed as an infix &lt;code&gt;??&lt;/code&gt; operator with a special parsing rule to find the associated &lt;code&gt;::&lt;/code&gt; part. I&amp;rsquo;m not gonna explain that here, partly because user-defined ternary operators are discouraged, and partly because I haven&amp;rsquo;t actually bothered to figure out the details yet. This Apocalypse is already late enough.&lt;/p&gt;

&lt;p&gt;Also please note that it&amp;rsquo;s perfectly permissible (but not extremely expeditious) to rapidly reduce the Perl grammar to a steaming pile of gopher guts by redefining built-in operators such as commas or parentheses.&lt;/p&gt;

&lt;h4 id=&#34;span-id-named-unaries-named-unaries-span&#34;&gt;&lt;span id=&#34;named_unaries&#34;&gt;Named unaries&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As in Perl 5, a named unary operator by default parses with the same precedence as all other named unary operators like &lt;code&gt;sleep&lt;/code&gt; and &lt;code&gt;rand&lt;/code&gt;. Any sub declared with a single scalar argument counts as a named unary, not just explicit operator definitions. So it doesn&amp;rsquo;t really matter whether you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub plaster ($x) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub prefix:plaster ($x) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-argumentless-subs-argumentless-subs-span&#34;&gt;&lt;span id=&#34;argumentless_subs&#34;&gt;Argumentless subs&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As in Perl 5, a 0-ary subroutine (one with a &lt;code&gt;()&lt;/code&gt; signature) parses without looking for any argument at all, much like the &lt;code&gt;time&lt;/code&gt; built-in. (An optional pair of empty parens are allowed on the call, as in &lt;code&gt;time()&lt;/code&gt;.) Constant subs with a null signature will likely be inlined as they are in Perl 5, though the preferred way to declare constants will be as standard variables with the &lt;code&gt;is constant&lt;/code&gt; trait.&lt;/p&gt;

&lt;h3 id=&#34;span-id-matching-of-forward-declarations-matching-of-forward-declarations-span&#34;&gt;&lt;span id=&#34;matching_of_forward_declarations&#34;&gt;Matching of forward declarations&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If you define a subroutine for which you earlier had a stub declaration, its signature and traits must match the stub&amp;rsquo;s subroutine signature and traits, or it will be considered to be declaring a different subroutine of the same name, which may be any of illegal, immoral, or fattening. In the case of standard subs, it would be illegal, but in the case of multimethods, it would merely be fattening. (Well, you&amp;rsquo;d also get a warning if you called the stub instead of the &amp;ldquo;real&amp;rdquo; definition.)&lt;/p&gt;

&lt;p&gt;The declaration and the definition should have the same defaults. That does not just mean that they should merely &lt;em&gt;look&lt;/em&gt; the same. If you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our $x = 1;
    sub foo ($y = $x) {...}             # default to package var

    {
        my $x = 2;
        sub foo ($y = $x) { print $y }  # default to lexical var
        foo();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then what you&amp;rsquo;ve said is an error if the compiler can catch it, and is erroneous if it can&amp;rsquo;t. In any event, the program may correctly print any of these values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1
    2
    1.5
    12
    1|2
    (1,2)
    Thbthbthbthth...
    1|2|1.5|12|(1|2)|(1,2)|Thbthbthbthth...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-lvalue-subroutines-lvalue-subroutines-span&#34;&gt;&lt;span id=&#34;lvalue_subroutines&#34;&gt;Lvalue subroutines&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The purpose of an lvalue subroutine is to return a &amp;ldquo;proxy&amp;rdquo;&amp;ndash;that is, to return an object that represents a &amp;ldquo;single evaluation&amp;rdquo; of the subroutine while actually allowing multiple accesses within a single transaction. An lvalue subroutine has to pretend to be a storage location, with all the rights, privileges, and responsibilities pertaining thereto. But it has to do this without repeatedly calculating the &lt;em&gt;identity&lt;/em&gt; of whatever it is you&amp;rsquo;re actually modifying underneath&amp;ndash;especially if that calculation entails side effects. (Or is expensive&amp;ndash;meaning that it has the side-effect of chewing up computer resources&amp;hellip;)&lt;/p&gt;

&lt;p&gt;An lvalue subroutine is declared with the &lt;code&gt;is rw&lt;/code&gt; trait. The compiler will take whatever steps necessary to ensure that the returned value references a storage location that can be treated as an lvalue. If you merely return a variable (such as an object attribute), that variable can act as its own proxy. You can also return the result of a call to another lvalue subroutine or method. If you need to do pre- or post-processing on the &amp;ldquo;public&amp;rdquo; value, however, you&amp;rsquo;ll need to return a tied proxy variable.&lt;/p&gt;

&lt;p&gt;But if you know how hard it is to tie variables in Perl 5, you&amp;rsquo;ll be pleasantly surprised that we&amp;rsquo;re providing some syntactic relief for the common cases. In particular, you can say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub thingie is rw {
        return my $var
            is Proxy( for =&amp;gt; $hidden_var,
                      FETCH =&amp;gt; { ... },
                      STORE =&amp;gt; { ... },
                      TEMP  =&amp;gt; { ... },
                      ...
            );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in order to generate a tie class on the fly, and only override the standard proxy methods you need to, while letting others default to doing the standard behavior. This is particularly important when proxying things like arrays and hashes that have oodles of potential service routines.&lt;/p&gt;

&lt;p&gt;But in particular, note that we want to be able to temporize object attributes, which is why there&amp;rsquo;s a &lt;code&gt;TEMP&lt;/code&gt; method in our proxy. In Perl 5 you could only temporize (localize) variables. But we want accessors to be usable exactly as if they were variables, which implies that temporization is part of the interface. When you use a &lt;code&gt;temp&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; context specifier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    temp $obj.foo = 42;
    let $obj.bar = 43;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the proxy attribute returned by the lvalue method needs to know how to temporize the value. More precisely, it needs to know how to restore the old value at the end of the dynamic scope. So what the &lt;code&gt;.TEMP&lt;/code&gt; method returns is a closure that knows how to restore the old value. As a closure, it can simply keep the old value in a lexical created by &lt;code&gt;.TEMP&lt;/code&gt;. The same method is called for both &lt;code&gt;temp&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;. The only difference is that &lt;code&gt;temp&lt;/code&gt; executes the returned closure unconditionally at end of scope, while &lt;code&gt;let&lt;/code&gt; executes the closure conditionally only upon failure (where failure is defined as throwing a non-control exception or returning undef in scalar context or &lt;code&gt;()&lt;/code&gt; in list context).&lt;/p&gt;

&lt;p&gt;After the &lt;code&gt;.TEMP&lt;/code&gt; method returns the closure, you never have to worry about it again. The &lt;code&gt;temp&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; will squirrel away the closure and execute it later when appropriate. That&amp;rsquo;s where the real power of &lt;code&gt;temp&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; comes from&amp;ndash;they&amp;rsquo;re fire-and-forget operators.&lt;/p&gt;

&lt;p&gt;The standard &lt;code&gt;Scalar&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, and &lt;code&gt;Hash&lt;/code&gt; classes also have a &lt;code&gt;.TEMP&lt;/code&gt; method (or equivalent). So &lt;em&gt;any&lt;/em&gt; such variable can be temporized, even lexicals:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $identity = &#39;Clark Kent&#39;;

    for @emergencies {
         temp $identity = &#39;SUPERMAN&#39;;   # still the lexical $identity
         ...
    }

    print $identity;    # prints &#39;Clark Kent&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll talk more about lvalues below in reference to various RFCs that espouse lvalue subs&amp;ndash;all of which were rejected. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-temporizing-any-subroutine-call-temporizing-any-subroutine-call-span&#34;&gt;&lt;span id=&#34;temporizing_any_subroutine_call&#34;&gt;Temporizing any subroutine call&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Lvalue subroutines have a special way to return a proxy that can be temporized, but sometimes that&amp;rsquo;s overkill. Maybe you don&amp;rsquo;t want an lvalue; you just want a subroutine that can do something temporarily in an rvalue context. To do that, you can declare a subroutine with a &lt;code&gt;TEMP&lt;/code&gt; block that works just like the &lt;code&gt;.TEMP&lt;/code&gt; method described earlier. The &lt;code&gt;TEMP&lt;/code&gt; block returns a closure that will be called when the &lt;em&gt;call&lt;/em&gt; to this function goes out of scope.&lt;/p&gt;

&lt;p&gt;So if you declare a function with a &lt;code&gt;TEMP&lt;/code&gt; property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub setdefout ($x) {
        my $oldout = $*OUT;
        $*DEFOUT = $x;
        TEMP {{ $*DEFOUT = $oldout }}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then you can call it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    temp setdefout($MYFILE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and it will automatically undo itself on scope exit. One place where this might be useful is for wrappers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    temp &amp;amp;foo.wrap({...})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The routine will automatically unwrap itself at the end of the current dynamic scope. A &lt;code&gt;let&lt;/code&gt; would similarly put a hypothetical wrapper in place, but keep it wrapped on success.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;TEMP&lt;/code&gt; block is called only if you invoke the subroutine or method with &lt;code&gt;temp&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;. Otherwise the &lt;code&gt;TEMP&lt;/code&gt; block is ignored. So if you just call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    setdefout($MYFILE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the side-effects are permanent.&lt;/p&gt;

&lt;p&gt;That being said&amp;hellip;&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think we&amp;rsquo;ll actually be using explicit &lt;code&gt;TEMP&lt;/code&gt; closures all over the place, because I&amp;rsquo;d like to extend the semantics of &lt;code&gt;temp&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; such that they automatically save state of anything within their dynamic scopes. In essence, Perl writes most of the &lt;code&gt;TEMP&lt;/code&gt; methods for you, and you don&amp;rsquo;t have to worry about them unless you&amp;rsquo;re interfacing to external code or data that doesn&amp;rsquo;t know how to save its own state. (Though there&amp;rsquo;s certainly plenty of all that out in the wide world.)&lt;/p&gt;

&lt;p&gt;See appendix C for more about this line of thought.&lt;/p&gt;

&lt;h2 id=&#34;span-id-the-rfcs-the-rfcs-span&#34;&gt;&lt;span id=&#34;the_rfcs&#34;&gt;The RFCs&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Let me reiterate that there&amp;rsquo;s little difference between an RFC accepted with major caveats and a rejected RFC from which some ideas may have been stolen. Please don&amp;rsquo;t take any of this personally&amp;ndash;I ignore author names when evaluating RFCs.&lt;/p&gt;

&lt;h3 id=&#34;span-id-rejected-rfcs-rejected-rfcs-span&#34;&gt;&lt;span id=&#34;rejected_rfcs&#34;&gt;Rejected RFCs&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-59-html-id-rfc-59-proposal-to-utilize-as-the-prefix-to-magic-subroutines-rfc-59-proposal-to-utilize-code-code-as-the-prefix-to-magic-subroutines-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/59.html&#34; id=&#34;rfc_59:_proposal_to_utilize_*_as_the_prefix_to_magic_subroutines&#34;&gt;RFC 59: Proposal to utilize &lt;code&gt;*&lt;/code&gt; as the prefix to magic subroutines&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;There are several problems with doing this.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;*&lt;/code&gt; prefix is already taken for two other meanings. (It indicates a completely global symbol or a splatlist.) We could come up with something else, but we&amp;rsquo;re running out of keyboard. And I don&amp;rsquo;t think it&amp;rsquo;s important enough to inflict a Unicode character on people.&lt;/li&gt;
&lt;li&gt;It would be extra clutter that conveys little extra information over what is already conveyed by all-caps.&lt;/li&gt;
&lt;li&gt;All-caps routines are a fuzzy set. Some of these routines are always called implicitly, while others are only &lt;em&gt;usually&lt;/em&gt; called implicitly. We&amp;rsquo;d have to be continually making arbitrary decisions on where to cut it off.&lt;/li&gt;
&lt;li&gt;Some routines are in the process of migrating into (or out of) the core. We don&amp;rsquo;t want to force people to rewrite their programs when that happens.&lt;/li&gt;
&lt;li&gt;People are already used to the all-caps convention.&lt;/li&gt;
&lt;li&gt;Most importantly, I have an irrational dislike for anything that resembles Python&amp;rsquo;s &lt;code&gt;__foo__&lt;/code&gt; convention. &lt;code&gt;:-)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So we&amp;rsquo;ll continue to half-heartedly reserve the all-caps space for Perl magic.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-75-html-id-rfc-75-structures-and-interface-definitions-rfc-75-structures-and-interface-definitions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/75.html&#34; id=&#34;rfc_75:_structures_and_interface_definitions&#34;&gt;RFC 75: structures and interface definitions&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;In essence, this proposal turns every subroutine call into a constructor of a parameter list object. That&amp;rsquo;s an interesting way to look at it, but the proposed notation for class declaration suffers from some problems. It&amp;rsquo;s run-time rather than compile-time, and it&amp;rsquo;s based on a value list rather than a statement list. In other words, it&amp;rsquo;s not what we&amp;rsquo;re gonna do, because we&amp;rsquo;ll have a more standard-looking way of declaring classes. (On the other hand, I think the proposed functionality can probably be modeled by suitable use of constructors.)&lt;/p&gt;

&lt;p&gt;The proposal also runs afoul of the rule that a lexically scoped variable ought generally to be declared explicitly at the beginning of its lexical scope. The parameters to subroutines will be lexically scoped in Perl 6, so there needs to be something equivalent to a &lt;code&gt;my&lt;/code&gt; declaration at the beginning.&lt;/p&gt;

&lt;p&gt;Unifying parameter passing with &lt;code&gt;pack&lt;/code&gt;/&lt;code&gt;unpack&lt;/code&gt; syntax is, I think, a false economy. &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; are serialization operators, while parameter lists are about providing useful aliases to caller-provided data without any implied operation. The fact that both deal with lists of values on some level doesn&amp;rsquo;t mean we should strain to make them the same on every level. That will merely make it impossible to implement subroutine calls efficiently, particularly since the Parrot engine is register-based, not stack-based as this RFC assumes. Register-based machines don&amp;rsquo;t access parameters by offsets from the stack pointer.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-107-html-id-rfc-107-lvalue-subs-should-receive-the-rvalue-as-an-argument-rfc-107-lvalue-subs-should-receive-the-rvalue-as-an-argument-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/107.html&#34; id=&#34;rfc_107:_lvalue_subs_should_receive_the_rvalue_as_an_argument&#34;&gt;RFC 107: lvalue subs should receive the rvalue as an argument&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This would make it hard to dynamically scope an attribute. You&amp;rsquo;d have to call the method twice&amp;ndash;once to get the old value, and once to set the new value.&lt;/p&gt;

&lt;p&gt;The essence of the lvalue problem is that you&amp;rsquo;d like to separate the identification of the object from its manipulation. Forcing the new value into the same argument list as arguments meant to identify the object is going to mess up all sorts of things like assignment operators and temporization.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-118-html-id-rfc-118-lvalue-subs-parameters-explicit-assignment-and-wantarray-changes-rfc-118-lvalue-subs-parameters-explicit-assignment-and-code-wantarray-code-changes-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/118.html&#34; id=&#34;rfc_118:_lvalue_subs:_parameters,_explicit_assignment,_and_wantarray()_changes&#34;&gt;RFC 118: lvalue subs: parameters, explicit assignment, and &lt;code&gt;wantarray()&lt;/code&gt; changes&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This proposal has a similar problem in that it doesn&amp;rsquo;t separate the identity from the operation.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-132-html-id-rfc-132-subroutines-should-be-able-to-return-an-lvalue-rfc-132-subroutines-should-be-able-to-return-an-lvalue-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/132.html&#34; id=&#34;rfc_132:_subroutines_should_be_able_to_return_an_lvalue&#34;&gt;RFC 132: Subroutines should be able to return an lvalue&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This RFC proposes a keyword &lt;code&gt;lreturn&lt;/code&gt; to return an lvalue.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d rather the lvalue hint be available to the compiler, I think, even if the body has not been compiled yet. So it needs to be declared in the signature somehow. The compiler would like to know whether it&amp;rsquo;s even legal to assign to the subroutine. Plus it might have to deal with the returned value as a different sort of object.&lt;/p&gt;

&lt;p&gt;At least this proposal doesn&amp;rsquo;t confuse identification with modification. The lvalue is presumably an object with a &lt;code&gt;STORE&lt;/code&gt; method that works independently of the original arguments. But this proposal also doesn&amp;rsquo;t provide any mechanism to do postprocessing on the stored value.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-149-html-id-rfc-149-lvalue-subroutines-implicit-and-explicit-assignment-rfc-149-lvalue-subroutines-implicit-and-explicit-assignment-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/149.html&#34; id=&#34;rfc_149:_lvalue_subroutines:_implicit_and_explicit_assignment&#34;&gt;RFC 149: Lvalue subroutines: implicit and explicit assignment&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This is sort of the don&amp;rsquo;t-have-your-cake-and-don&amp;rsquo;t-eat-it-too approach. The implicit assignment doesn&amp;rsquo;t allow for virtual attributes. The explicit assignment doesn&amp;rsquo;t allow for delayed modification.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-154-html-id-rfc-154-simple-assignment-lvalue-subs-should-be-on-by-default-rfc-154-simple-assignment-lvalue-subs-should-be-on-by-default-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/154.html&#34; id=&#34;rfc_154:_simple_assignment_lvalue_subs_should_be_on_by_default&#34;&gt;RFC 154: Simple assignment lvalue subs should be on by default&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Differentiating &amp;ldquo;simple&amp;rdquo; lvalue subs is a problem. A user ought to just be able to say something fancy like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    temp $obj.attr += 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and have it behave right, provided &lt;code&gt;.attr&lt;/code&gt; allows that.&lt;/p&gt;

&lt;p&gt;Even with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.attr = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we have a real problem with knowing what can be done at compile time, since we might not know the exact type of &lt;code&gt;$obj&lt;/code&gt;. Even if &lt;code&gt;$obj&lt;/code&gt; is declared with a type, it&amp;rsquo;s only an &amp;ldquo;isa&amp;rdquo; assertion. We could enforce things based on the declared type with the assumption that a derived type won&amp;rsquo;t violate the contract, but I&amp;rsquo;m a little worried about large semantic changes happening just because one adds an optional type declaration. It seems safer that the untyped method behave just like the typed method, only with run-time resolution rather than compile-time resolution. Anything else would violate the principle of least surprise. So if it is not known whether &lt;code&gt;$obj.attr&lt;/code&gt; can be an lvalue, it must be assumed that it can, and compiled with a mechanism that will work consistently, or throw a run-time exception if it can&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;The same goes for argument lists, actually. &lt;code&gt;$obj.meth(@foo)&lt;/code&gt; can&amp;rsquo;t assume that &lt;code&gt;@foo&lt;/code&gt; is either scalar or list until it knows the signature of the &lt;code&gt;.meth&lt;/code&gt; method. And it probably doesn&amp;rsquo;t know that until dispatch time, unless it can analyze the entire set of available methods in advance. In general, modification of an invalid lvalue (an object without a write method, essentially) has to be handled by throwing an exception. This may well mean that it is illegal for a method to have an &lt;code&gt;rw&lt;/code&gt; parameter!&lt;/p&gt;

&lt;p&gt;Despite the fact that there are similar constraints on the arguments and on the lvalue, we cannot combine them, because the values are needed at different times. The arguments are needed when identifying the object to modify, since lvalue objects often act as proxies for other objects elsewhere.` Think of subscripting an array, for instance, where the subscripts function as arguments, so you can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $elem := @a[0][1][2];
    $elem = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise we should be able to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ref := a(0,1,2);
    $ref = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and have &lt;code&gt;$ref&lt;/code&gt; be the lvalue returned by &lt;code&gt;a()&lt;/code&gt;. It&amp;rsquo;s the implied &amp;ldquo;&lt;code&gt;is rw&lt;/code&gt;&amp;rdquo; on the left that causes &lt;code&gt;a()&lt;/code&gt; to return an lvalue, just as a subroutine parameter that is &amp;ldquo;&lt;code&gt;rw&lt;/code&gt;&amp;rdquo; causes lvaluehood to be passed to its actual argument.&lt;/p&gt;

&lt;p&gt;Since we can&amp;rsquo;t in general know at compile time whether a method is &amp;ldquo;simple&amp;rdquo; or not, we don&amp;rsquo;t know whether it&amp;rsquo;s appropriate to treat an assignment as an extra argument or as a parameter to an internal &lt;code&gt;STORE&lt;/code&gt; method. We have to compile the call assuming there&amp;rsquo;s a separate &lt;code&gt;STORE&lt;/code&gt; method on the lvalue object. Which means there&amp;rsquo;s no such thing as a &amp;ldquo;simple&amp;rdquo; lvalue from the viewpoint of the caller.&lt;/p&gt;

&lt;h3 id=&#34;span-id-accepted-rfcs-accepted-rfcs-span&#34;&gt;&lt;span id=&#34;accepted_rfcs&#34;&gt;Accepted RFCs&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-168-html-id-rfc-168-builtin-functions-should-be-functions-rfc-168-built-in-functions-should-be-functions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/168.html&#34; id=&#34;rfc_168:_builtin_functions_should_be_functions&#34;&gt;RFC 168: Built-in functions should be functions&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This all seems fine to me in principle. All built-in functions and multimethods exist in the &amp;ldquo;&lt;code&gt;*&lt;/code&gt;&amp;rdquo; space, so &lt;code&gt;system()&lt;/code&gt; is really &lt;code&gt;&amp;amp;*system();&lt;/code&gt; in Perl 6 .&lt;/p&gt;

&lt;p&gt;We do need to consider whether &amp;ldquo;&lt;code&gt;sub system&lt;/code&gt;&amp;rdquo; changes the meaning of calls to &lt;code&gt;system()&lt;/code&gt; earlier in the lexical scope. Or are built-ins imported as third-class keywords like &lt;code&gt;lock()&lt;/code&gt; is in Perl 5? It&amp;rsquo;s probably best if we detect the ambiguous situation and complain. A &amp;ldquo;late&amp;rdquo; definition of &lt;code&gt;system()&lt;/code&gt; could be considered a redefinition, in fact, any definition of &lt;code&gt;system()&lt;/code&gt; could be considered a redefinition. We could require &amp;ldquo;&lt;code&gt;is redefined&lt;/code&gt;&amp;rdquo; or some such on all such redefinitions.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;&lt;code&gt;lock&lt;/code&gt;&amp;rdquo; situation arises when we add a new built-in, however. Do we want to force people to add in an &amp;ldquo;&lt;code&gt;is redefined&lt;/code&gt;&amp;rdquo; where they didn&amp;rsquo;t have to before? Worse, if their definition of &amp;ldquo;&lt;code&gt;lock&lt;/code&gt;&amp;rdquo; is retroactive to the front of the file, merely adding &amp;ldquo;&lt;code&gt;sub lock is redefined&lt;/code&gt;&amp;rdquo; is not necessarily good enough to become retroactive.&lt;/p&gt;

&lt;p&gt;This is not a problem with &lt;code&gt;my&lt;/code&gt; subs, since they have to be declared in advance. If we defer committing compilation of package-named subs to the end of the compilation unit, then we can just say that the current package overrides the &amp;ldquo;&lt;code&gt;*&lt;/code&gt;&amp;rdquo; package. All built-ins become &amp;ldquo;third class&amp;rdquo; keywords in that case. But does that mean that a built-in can&amp;rsquo;t override ordinary function-call syntax? Built-ins should at least be able to be used as list operators, but in Perl 5 you couldn&amp;rsquo;t use your own sub as a list operator unless it was predeclared. Maybe we could relax that.&lt;/p&gt;

&lt;p&gt;Since there are no longer any barewords, we can assume that any unrecognized word is a subroutine or method call of some sort even in the absence of parens. We could assume all such words are list operators. That works okay for overriding built-ins that actually *are* list operators&amp;ndash;but not all of them are. If you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print rand 1, 2;
    sub rand (*@x) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then it cannot be determined whether &lt;code&gt;rand&lt;/code&gt; should be parsed as a unary operator &lt;code&gt;($)&lt;/code&gt; or as a list operator &lt;code&gt;(*@)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Perl has to be able to parse its unary operators. So that code must be interpreted as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print rand(1), 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At that point in the parse, we&amp;rsquo;ve essentially committed to a signature of &lt;code&gt;($)&lt;/code&gt;, which makes the subsequent sub declaration a redefinition with a different signature, which is illegal. But when someone says:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print foo 1, 2;
    sub foo (*@x) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s legal until someone defines &lt;code&gt;&amp;amp;*foo($)&lt;/code&gt;. We can protect ourselves from the backward compatibility problem by use of parens. When there are parens, we can probably defer the decision about the binding of its arguments to the end of the compilation. So either of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print foo(1), 2;
    sub foo (*@x) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print foo(1, 2);
    sub foo (*@x) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;remain legal even if we later add a unary &lt;code&gt;&amp;amp;*foo&lt;/code&gt; operator, as long as no other syntactic monkey business is going on with the functions args. So I think we keep the rule that says post-declared subs have to be called using parens, even though we could theoretically relax it.&lt;/p&gt;

&lt;p&gt;On the other hand, this means that any unrecognized word followed by a list may unambiguously be taken to be a multimethod being called as a list operaotr. After all, we don&amp;rsquo;t know when someone will be adding more multimethods. I currently think this is a feature, but I could be sadly mistaken. It has happened once or twice in the past.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-57-html-id-rfc-57-subroutine-prototypes-and-parameters-rfc-57-subroutine-prototypes-and-parameters-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/57.html&#34; id=&#34;rfc_57:_subroutine_prototypes_and_parameters&#34;&gt;RFC 57: Subroutine prototypes and parameters&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;We ended up with something like this proposal, though with some differences. Instead of &lt;code&gt;=&lt;/code&gt;, we&amp;rsquo;re using &lt;code&gt;=&amp;gt;&lt;/code&gt; to specify names because it&amp;rsquo;s a pair constructor in Perl 6, so there&amp;rsquo;s little ambiguity with positional parameters. Unless a positional parameter is explicitly declared with a &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Hash&lt;/code&gt; type, it&amp;rsquo;s assumed not to be interested in named arguments.&lt;/p&gt;

&lt;p&gt;Also, as the RFC points out, use of &lt;code&gt;=&lt;/code&gt; would be incompatible with lvalue subs, which we&amp;rsquo;re supporting.&lt;/p&gt;

&lt;p&gt;The RFC allows for mixing of positional and named parameters, both in declaration and in invocation. I think such a feature would provide far more confusion than functionality, so we won&amp;rsquo;t allow it. You can always process your own argument list if you want to. You could even install your own signature handler in place of Perl&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;The RFC suggests treating the first parameter with a default as the first optional parameter. I think I&amp;rsquo;d rather mark optional parameters explicitly, and then disallow defaults on required parameters as a semantic constraint.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also suggested that something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub waz ($one, $two, 
             $three = add($one, $two), 
             $four  = add($three, 1)) {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;be allowed, where defaults can refer back to previous parameters. It seems as though we could allow that, if we assume that symbols are introduced in signatures as soon as they are seen. That would be consistent with how we&amp;rsquo;ve said &lt;code&gt;my&lt;/code&gt; variables are introduced. It does mean that a prototype that defaults to the prior &lt;code&gt;$_&lt;/code&gt; would have to be written like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $myclosure = sub ($_ = $OUTER::_) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, that&amp;rsquo;s exactly what:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $myclosure = { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;means in the absence of placeholder variables, so the situation will likely not arise all that often. So I&amp;rsquo;d say yes, defaults should be able to refer back to previous parameters in the same signature, unless someone thinks of a good reason not to.&lt;/p&gt;

&lt;p&gt;As explained in Apocalypse 4, &lt;code&gt;$OUTER::&lt;/code&gt; is for getting at an outer lexical scope. This ruling about formal parameters means that, effectively, the lexical scope of a subroutine &amp;ldquo;starts to begin&amp;rdquo; where the formal parameters are declared, and &amp;ldquo;finishes beginning&amp;rdquo; at the opening brace. Whether a given symbol in the signature actually belongs to the inner scope or the outer scope depends on whether it&amp;rsquo;s already been introduced by the inner scope. Our sub above needed &lt;code&gt;$OUTER::_&lt;/code&gt; because &lt;code&gt;$_&lt;/code&gt; had already been introduced as the name of the first argument. Had some other name been introduced, &lt;code&gt;$_&lt;/code&gt; might still be taken to refer to the outer &lt;code&gt;$_&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $myclosure = sub ($arg = $_) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If so, use of &lt;code&gt;$OUTER::_&lt;/code&gt; would be erroneous in that case, because the subroutine&amp;rsquo;s implicit &lt;code&gt;$_&lt;/code&gt; declaration wouldn&amp;rsquo;t happen till the opening curly, and instead of getting &lt;code&gt;$OUTER::_&lt;/code&gt;, the user would unexpectedly be getting &lt;code&gt;$OUTER::OUTER::_&lt;/code&gt;, as it were. So instead, we&amp;rsquo;ll say that the implicit introduction of the new sub&amp;rsquo;s &lt;code&gt;$_&lt;/code&gt; variable &lt;em&gt;always&lt;/em&gt; happens after the &lt;code&gt;&amp;lt;subintro&amp;gt;&lt;/code&gt; and before the &lt;code&gt;&amp;lt;signature&amp;gt;&lt;/code&gt;, so any use of &lt;code&gt;$_&lt;/code&gt; as a default in a signature or as an argument to a property can only refer to the subroutine&amp;rsquo;s own topic, if any. To refer to any external &lt;code&gt;$_&lt;/code&gt; you must say either &lt;code&gt;$CALLER::_&lt;/code&gt; or &lt;code&gt;$OUTER::_&lt;/code&gt;. This approach seems much cleaner.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-160-html-id-rfc-160-functioncall-named-parameters-with-compiler-optimizations-rfc-160-function-call-named-parameters-with-compiler-optimizations-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/160.html&#34; id=&#34;rfc_160:_functioncall_named_parameters_(with_compiler_optimizations)&#34;&gt;RFC 160: Function-call named parameters (with compiler optimizations)&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;For efficiency, we have to be able to hoist the semantics from the signature into the calling module when that&amp;rsquo;s practical, and that has to happen at compile time. That means the information has to be in the signature, not embedded in a &lt;code&gt;fields()&lt;/code&gt; function within the body of the subroutine. In fact, my biggest complaint about this RFC is that it arbitrarily separates the prototype characters, the parameter names, and the variable names. That&amp;rsquo;s a recipe for things getting out of sync.&lt;/p&gt;

&lt;p&gt;Basically, this RFC has a lot of the right ideas, but just doesn&amp;rsquo;t go far enough in the signature direction, based on the (at the time) laudable notion that we were interested in keeping Perl 6 as close to Perl 5 as possible. Which turned out not to be &lt;em&gt;quite&lt;/em&gt; the case. &lt;code&gt;:-)&lt;/code&gt; Our new signatures look more hardwired than the attribute syntax proposed here, but it&amp;rsquo;s all still very hookable underneath via the sub and parameter traits. And everything is together that should be together.&lt;/p&gt;

&lt;p&gt;Although the signature is really just a trait underneath, I thought it important to have special syntax for it, just as there&amp;rsquo;s special syntax for the body of the function. Signatures are very special traits, and people like special things to look special. It&amp;rsquo;s just more of those darn psychological reasons that keep popping up in the design of Perl.&lt;/p&gt;

&lt;p&gt;Still and all, the current design is optimized for many of the same sensitivities described in this RFC.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-128-html-id-rfc-128-subroutines-extend-subroutine-contexts-to-include-name-parameters-and-lazy-arguments-rfc-128-subroutines-extend-subroutine-contexts-to-include-name-parameters-and-lazy-arguments-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/128.html&#34; id=&#34;rfc_128:_subroutines:_extend_subroutine_contexts_to_include_name_parameters_and_lazy_arguments&#34;&gt;RFC 128: Subroutines: Extend subroutine contexts to include name parameters and lazy arguments&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This RFC also has lots of good ideas, but tends to stay a little too close to Perl 5 in various areas where I&amp;rsquo;ve decided to swap the defaults around. For instance, marking reference parameters in prototypes rather than slurpy parameters in signatures, identifying lazy parameters rather than flattening, and defaulting to &lt;code&gt;rw&lt;/code&gt; (autovivifying lvalue args) rather than &lt;code&gt;constant&lt;/code&gt; (rvalue args).&lt;/p&gt;

&lt;p&gt;Context classes are handled by the automatic coercion to references within scalar context, and by type junctions.&lt;/p&gt;

&lt;p&gt;Again, I don&amp;rsquo;t buy into two-pass, fill-in-the-blanks argument processing.&lt;/p&gt;

&lt;p&gt;Placeholders are now just for argument declaration, and imply no currying. Currying on the other hand is done with an explicit &lt;code&gt;.assuming&lt;/code&gt; method, which requires named args that will be bound to the corresponding named parameters in the function being curried.&lt;/p&gt;

&lt;p&gt;Or should I say functions? When module and class writers write systems of subroutines or methods, they usually go to great pains to make sure all the parameter names are consistent. Why not take advantage of that?&lt;/p&gt;

&lt;p&gt;So currying might even be extended to classes or modules, where all methods or subs with a given argument name are curried simultaneously:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my module MyIO ::= (use IO::Module).assuming(ioflags =&amp;gt; &amp;quot;:crlf&amp;quot;);
    my class UltAnswer ::= (use Answer a,b,c).assuming(answer =&amp;gt; 42);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you curry a class&amp;rsquo;s invocant, it would turn the class into a module instead of another class, since there are no longer any methods if there are no invocants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my module UltAnswer ::=
        (use Answer a,b,c).assuming(self =&amp;gt; new Answer: 42);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or something like that. If you think this implies that there are class and module objects that can be sufficiently introspected to do this sort of chicanery, you&amp;rsquo;d be right. On the other hand, given that we&amp;rsquo;ll have module name aliasing anyway to support running multiple versions of the same module, why not support multiple curried versions without explicit renaming of the module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (use IO::Module).assuming(ioflags =&amp;gt; &amp;quot;:crlf&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then for the rest of this scope, IO::Module really points to your aliased idea of IO::Module, without explicitly binding it to a different name. Well, that&amp;rsquo;s for Apocalypse 11, really&amp;hellip;&lt;/p&gt;

&lt;p&gt;One suggestion from this RFC I&amp;rsquo;ve taken to heart, which is to banish the term &amp;ldquo;prototype&amp;rdquo;. You&amp;rsquo;ll note we call them signatures now. (You may still call Perl 5&amp;rsquo;s prototypes &amp;ldquo;prototypes&amp;rdquo;, of course, because Perl 5&amp;rsquo;s prototypes really &lt;em&gt;were&lt;/em&gt; a prototype of signatures.)&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-344-html-id-rfc-344-elements-of-should-be-readonly-by-default-rfc-344-elements-of-code-code-should-be-read-only-by-default-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/344.html&#34; id=&#34;rfc_344:_elements_of_@__should_be_readonly_by_default&#34;&gt;RFC 344: Elements of &lt;code&gt;@_&lt;/code&gt; should be read-only by default&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;I admit it, I waffled on this one. Up until the last moment, I was going to reject it, because I wanted &lt;code&gt;@_&lt;/code&gt; to work exactly like it does in Perl 5 in subs without a signature. It seemed like a nice sop towards backward compatibility.&lt;/p&gt;

&lt;p&gt;But when I started writing about why I was rejecting it, I started thinking about whether a sig-less sub is merely a throwback to Perl 5, or whether we&amp;rsquo;ll see it continue as a viable Perl 6 syntax. And if the latter, perhaps it should be designed to work right rather than merely to work the same. The vast majority of subroutines in Perl 5 refrain from modifying their arguments via &lt;code&gt;@_&lt;/code&gt;, and it somehow seems wrong to punish such good deeds.&lt;/p&gt;

&lt;p&gt;So I changed my mind, and the default signature on a sub without a signature is simply &lt;code&gt;(*@_)&lt;/code&gt;, meaning that &lt;code&gt;@_&lt;/code&gt; is considered an array of constants by default. This will probably have good effects on performance, in general. If you really want to write through the &lt;code&gt;@_&lt;/code&gt; parameter back into the actual arguments, you&amp;rsquo;ll have to declare an explicit signature of &lt;code&gt;(*@_ is rw)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The Perl5-to-Perl6 translator will therefore need to translate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub (*@_ is rw) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;unless it can be determined that elements of &lt;code&gt;@_&lt;/code&gt; are not modified within the sub. (It&amp;rsquo;s okay to shift a constant &lt;code&gt;@_&lt;/code&gt; though, since that doesn&amp;rsquo;t change the elements passed to the call; remember that for slurpy arrays the implied &amp;ldquo;&lt;code&gt;is constant&lt;/code&gt;&amp;rdquo; or explicit &amp;ldquo;&lt;code&gt;is rw&lt;/code&gt;&amp;rdquo; distributes to the individual elements.)&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-194-html-id-rfc-194-standardise-function-pre-and-posthandling-rfc-194-standardise-function-pre-and-post-handling-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/194.html&#34; id=&#34;rfc_194:_standardise_function_pre_and_posthandling&#34;&gt;RFC 194: Standardise Function Pre- and Post-Handling&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Yes, this needs to be standardized, but we&amp;rsquo;ll be generalizing to the notion of wrappers, which can automatically keep their pre and post routines in sync, and, more importantly, keep a single lexical scope across the related pre and post processing. A wrapper is installed with the &lt;code&gt;.wrap&lt;/code&gt; method, which can have optional parameters to tell it how to wrap, and which can return an identifier by which the particular wrapper can be named when unwrapping or otherwise rearranging the wrappings. A wrapper automatically knows what function it&amp;rsquo;s wrapped around, and invoking the &lt;code&gt;call&lt;/code&gt; builtin automatically invokes the next level routine, whether that&amp;rsquo;s the actual routine or another layer of wrapper. That does matter, because with that implicit knowledge &lt;code&gt;call&lt;/code&gt; doesn&amp;rsquo;t need to be given the name of the routine to invoke.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The implementation is dependent on what happens to typeglobs in Perl 6, how does one inspect and modify the moral equivalent of the symbol table?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is not really a problem, since we&amp;rsquo;ve merely split the typeglob up into separate entries.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Also: what will become of prototypes? Will it become possible to declare return types of functions?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yes. Note that if you do introspection on a sub ref, by default you&amp;rsquo;re going to get the signature and return type of the actual routine, not of any wrappers. There needs to be some method for introspecting the wrappers as well, but it&amp;rsquo;s not the default.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;As pointed out in [JP:HWS] certain intricacies are involved: what are the semantic of caller()? Should it see the prehooks? If yes, how?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It seems to me that sometimes you want to see the wrappers, and sometimes you don&amp;rsquo;t. I think &lt;code&gt;caller&lt;/code&gt; needs some kind of argument that says which levels to recognize and which levels to ignore. It&amp;rsquo;s not necessarily a simple priority either. One invocation may want to find the innermost enclosing loop, while another might want the innermost enclosing &lt;code&gt;try&lt;/code&gt; block. A general matching term will be supplied on such calls, defaulting to ignore the wrappers.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How does this relate to the proposed generalized want() [DC:RFC21]?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;want()&lt;/code&gt; function can be viewed as based on &lt;code&gt;caller()&lt;/code&gt;, but with a different interface to the information available at the the particular call level.&lt;/p&gt;

&lt;p&gt;I worry that generalized wrappers will make it impossible to compile fast subroutine calls, if we always have to allow for run-time insertion of handlers. Of course, that&amp;rsquo;s no slower than Perl 5, but we&amp;rsquo;d like to do better than Perl 5. Perhaps we can have the default be to have wrappable subs, and then turn that off with specific declarations for speed, such as &amp;ldquo;&lt;code&gt;is inline&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-271-html-id-rfc-271-subroutines-pre-and-post-handlers-for-subroutines-rfc-271-subroutines-pre-and-post-handlers-for-subroutines-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/271.html&#34; id=&#34;rfc_271:_subroutines_:_pre_and_post_handlers_for_subroutines&#34;&gt;RFC 271: Subroutines : Pre- and post- handlers for subroutines&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;I find it odd to propose using &lt;code&gt;PRE&lt;/code&gt; for something with side effects like flock. Of course, this RFC was written before &lt;code&gt;FIRST&lt;/code&gt; blocks existed&amp;hellip;&lt;/p&gt;

&lt;p&gt;On the other hand, it&amp;rsquo;s possible that a system of &lt;code&gt;PRE&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; blocks would need to keep &amp;ldquo;dossiers&amp;rdquo; of its own internal state independent of the &amp;ldquo;real&amp;rdquo; data. So I&amp;rsquo;m not exactly sure what the effective difference is between &lt;code&gt;PRE&lt;/code&gt; and &lt;code&gt;FIRST&lt;/code&gt;. But we can always put a &lt;code&gt;PRE&lt;/code&gt; into a lexical wrapper if we need to keep info around till the &lt;code&gt;POST&lt;/code&gt;. So we can keep &lt;code&gt;PRE&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; with the semantics of simply returning boolean expressions, while &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;LAST&lt;/code&gt; are evaluated primarily for side effects.&lt;/p&gt;

&lt;p&gt;You might think that you wouldn&amp;rsquo;t need a signature on any pre or post handler, since it&amp;rsquo;s gonna be the same as the primary. However, we have to worry about multimethods of the same name, if the handlers are defined outside of the subroutine. Again, embedding PRE and POST blocks either in the routine itself or inside a wrapper around the routine should handle that. (And turning the problem into one of being able to generate a reference to a multimethod with a particular signature, in essence, doing method dispatch without actually dispatching at the end.)&lt;/p&gt;

&lt;p&gt;My gut feeling is that &lt;code&gt;$_[-1]&lt;/code&gt; is a bad place to keep the return value. With the &lt;code&gt;call&lt;/code&gt; interface we&amp;rsquo;re proposing, you just harvest the return value of &lt;code&gt;call&lt;/code&gt; if you&amp;rsquo;re interested in the return value. Or perhaps this is a good place for a return signature to actually have formal variables bound to the return values.&lt;/p&gt;

&lt;p&gt;Also, defining pre and post conditions in terms of exceptions is probably a mistake. If they&amp;rsquo;re just boolean expressions, they can be ANDed and ORed together more easily in the approved DBC fashion.&lt;/p&gt;

&lt;p&gt;We haven&amp;rsquo;t specified a declarative form of wrapper, merely a &lt;code&gt;.wrap&lt;/code&gt; method that you can call at run time. However, as with most of Perl, anything you can do at run time, you can also do at compile time, so it&amp;rsquo;d be fairly trivial to come up with a syntax that used a &lt;code&gt;wrap&lt;/code&gt; keyword in place of a &lt;code&gt;sub&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    wrap split(Regex ?$re, ?$src = $CALLER::_, ?$limit = Inf) {
        print &amp;quot;Entering split\n&amp;quot;;
        call;
        print &amp;quot;Leaving split\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I keep mistyping &amp;ldquo;wrap&amp;rdquo; as &amp;ldquo;warp&amp;rdquo;. I suppose that&amp;rsquo;s not so far off, actually&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-21-html-id-rfc-21-subroutines-replace-wantarray-with-a-generic-c-lt-want-gt-function-rfc-21-subroutines-replace-code-wantarray-code-with-a-generic-code-want-code-function-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/21.html&#34; id=&#34;rfc_21:_subroutines:_replace_wantarray_with_a_generic_c&amp;lt;want&amp;gt;_function&#34;&gt;RFC 21: Subroutines: Replace &lt;code&gt;wantarray&lt;/code&gt; with a generic &lt;code&gt;want&lt;/code&gt; function&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Overall, I like it, except that it&amp;rsquo;s reinventing several wheels. It seems that this has evolved into a powerful method for each sub to do its own overloading based on return type. How does this play with a more declarative approach to return types? I dunno. For now we&amp;rsquo;re assuming multmethod dispatch only pays attention to argument types. We might get rid of a lot of calls to &lt;code&gt;want&lt;/code&gt; if we could dispatch on return type as well. Perhaps we could do primary dispatch on the arguments and then do tie-breaking on return type when more then one multimethod has the same parameter profile.&lt;/p&gt;

&lt;p&gt;I also worry a bit that we&amp;rsquo;re assuming an interpreter here that &lt;em&gt;can&lt;/em&gt; keep track of all the context information in a way suitable for searching by the called subroutine. When running on top of a JVM or CLR, this info might not be convenient to provide, and I&amp;rsquo;d hate to have to keep a descriptor of every call, or do some kind of double dispatch, just because the called routine &lt;em&gt;might&lt;/em&gt; want to use &lt;code&gt;want()&lt;/code&gt;, or might want to call another routine that might want to use &lt;code&gt;want&lt;/code&gt;, or so on. Maybe the situation is not that bad.&lt;/p&gt;

&lt;p&gt;I sometimes wonder if &lt;code&gt;want&lt;/code&gt; should be a method on the context object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given caller.want {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or perhaps the two could be coalesced into a single call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given context { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But for the moment let&amp;rsquo;s assume for readability that there&amp;rsquo;s a &lt;code&gt;want&lt;/code&gt; function distinct from &lt;code&gt;caller&lt;/code&gt;, though with a similar signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *want (?$where = &amp;amp;CALLER::_, Int +$skip = 0, Str +$label)
        returns WantContext {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with &lt;code&gt;caller&lt;/code&gt;, calling &lt;code&gt;want&lt;/code&gt; with no arguments looks for the context of the currently executing subroutine or method. Like &lt;code&gt;return&lt;/code&gt;, it specifically ignores bare blocks and routines interpreting bare blocks, and finds the context for the lexically enclosing explicit sub or method declaration, named by &lt;code&gt;&amp;amp;_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll note that unlike in the proposal, we don&amp;rsquo;t pass a list to &lt;code&gt;want&lt;/code&gt;, so we don&amp;rsquo;t support the implicit &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; that is proposed for the arguments to &lt;code&gt;want&lt;/code&gt;. But that&amp;rsquo;s one of the re-invented wheels, anyway, so I&amp;rsquo;m not too concerned about that. What we really want is a &lt;code&gt;want&lt;/code&gt; that works well with smart matching and switch statements.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-23-html-id-rfc-23-higher-order-functions-rfc-23-higher-order-functions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/23.html&#34; id=&#34;rfc_23:_higher_order_functions&#34;&gt;RFC 23: Higher order functions&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;In general, this RFC proposes some interesting semantic sugar, but the rules are too complicated. There&amp;rsquo;s really no need for special numbered placeholders. And the special &lt;code&gt;^_&lt;/code&gt; placeholder is too confusing. Plus we really need regular sigils on our placeholder variables so we can distinguish &lt;code&gt;$^x&lt;/code&gt; from &lt;code&gt;@^x&lt;/code&gt; from &lt;code&gt;%^x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But the main issue is that the RFC is confusing two separate concepts (though that can be blamed on the languages this idea was borrowed from). Anyway, it turns out we&amp;rsquo;ll have an explicit pre-binding method called &lt;code&gt;.assuming&lt;/code&gt; for actual currying.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll make the self-declaring parameters a separate concept, called placeholder variables. They don&amp;rsquo;t curry. Some of the examples of placeholders in the RFC are actually replaced by topics and junctions in our smart matching mode, but there are still lots of great uses for placeholder variables.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-176-html-id-rfc-176-subroutine-generic-entity-documentation-rfc-176-subroutine-generic-entity-documentation-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/176.html&#34; id=&#34;rfc_176:_subroutine_/_generic_entity_documentation&#34;&gt;RFC 176: subroutine / generic entity documentation&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This would be trivial to do with declared traits and here docs. But it might be better to use a POD directive that is accessible to the program. An entity might even have implicit traits that bind to nearby chunks of the right sort. Maybe we could get Don Knuth to come up with something literate&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-298-html-id-rfc-298-make-subroutines-39-prototypes-accessible-from-perl-rfc-298-make-subroutines-prototypes-accessible-from-perl-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/298.html&#34; id=&#34;rfc_298:_make_subroutines&amp;#39;_prototypes_accessible_from_perl&#34;&gt;RFC 298: Make subroutines&amp;rsquo; prototypes accessible from Perl&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;While I&amp;rsquo;m all in favor of a sub&amp;rsquo;s signature being available for inspection, this RFC goes beyond that to make indirection in the signature the norm. This seems to be a solution in search of a problem. I&amp;rsquo;m not sure the confusion of the indirection is worth the ability to factor out common parameter lists. Certainly parameter lists must have introspection, but using it to &lt;em&gt;set&lt;/em&gt; the prototype seems potentially confusing. That being said, the signatures are just traits, so this may be one of those things that is permitted, but not advised, like shooting your horse in the middle of the desert, or chewing out your SO for burning dinner. Implicit declaration of lexically scoped variables will undoubtedly be considered harmful by somebody someday. [Damian says, &amp;ldquo;Me. Today.&amp;rdquo;]&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-334-html-id-rfc-334-perl-should-allow-specially-attributed-subs-to-be-called-as-c-functions-rfc-334-perl-should-allow-specially-attributed-subs-to-be-called-as-c-functions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/334.html&#34; id=&#34;rfc_334:_perl_should_allow_specially_attributed_subs_to_be_called_as_c_functions&#34;&gt;RFC 334: Perl should allow specially attributed subs to be called as C functions&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Fine, Dan, you implement it. ;-)&lt;/p&gt;

&lt;p&gt;Did I claim I ignore the names of RFC authors? Hmm.&lt;/p&gt;

&lt;p&gt;The syntax for the suggested:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo : C_visible(&amp;quot;i&amp;quot;, &amp;quot;iii&amp;quot;) {#sub body}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is probably a bit more verbose in real life:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my int sub foo (int $a, int $b, int $c)
         is callable(&amp;quot;C&amp;quot;,&amp;quot;Python&amp;quot;,&amp;quot;COBOL&amp;quot;) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we can&amp;rsquo;t figure out the &amp;ldquo;i&amp;rdquo; and &amp;ldquo;iii&amp;rdquo; bits from introspection of the &lt;code&gt;signature&lt;/code&gt; and &lt;code&gt;returns&lt;/code&gt; traits, we haven&amp;rsquo;t done introspection right. And if we&amp;rsquo;re gonna have an optional type system, I can&amp;rsquo;t think of a better place to use it than for interfaces to optional languages.&lt;/p&gt;

&lt;h2 id=&#34;span-id-acknowledgements-acknowledgements-span&#34;&gt;&lt;span id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;This work was made possible by a grant from the Perl Foundation. I would like to thank everyone who made this dissertation possible by their generous support. So, I will&amp;hellip;&lt;/p&gt;

&lt;p&gt;Thank you all very, very, very, very much!!!&lt;/p&gt;

&lt;p&gt;I should also point out that I would have been stuck forever on some of these design issues without the repeated prodding (as in cattle) of the Perl 6 design team. So I would also like to publicly thank Allison, chromatic, Damian, Dan, Hugo, Jarkko, Gnat, and Steve. Thanks, you guys! Many of the places we said &amp;ldquo;I&amp;rdquo; above, I should have said &amp;ldquo;we&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d like to publicly thank O&amp;rsquo;Reilly &amp;amp; Associates for facilitating the design process in many ways.&lt;/p&gt;

&lt;p&gt;I would also like to thank my wife Gloria, but not publicly.&lt;/p&gt;

&lt;h2 id=&#34;span-id-future-plans-future-plans-span&#34;&gt;&lt;span id=&#34;future_plans&#34;&gt;Future Plans&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;From here on out, the Apocalypses are probably going to be coming out in priority order rather than sequential order. The next major one will probably be Apocalypse 12, Objects, though it may take a while since (like a lot of people in Silicon Valley) I&amp;rsquo;m in negative cash flow at the moment, and need to figure out how to feed my family. But we&amp;rsquo;ll get it done eventually. Some Apocalypses might be written by other people, and some of them hardly need to be written at all. In fact, let&amp;rsquo;s write Apocalypse 7 right now&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;span-id-apocalypse-7-formats-apocalypse-7-formats-span&#34;&gt;&lt;span id=&#34;apocalypse_7:_formats&#34;&gt;Apocalypse 7: Formats&lt;/span&gt;&lt;/h1&gt;

&lt;p&gt;Gone from the core. See Damian.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;span-id-appendix-a-rationale-for-pipe-operators-appendix-a-rationale-for-pipe-operators-span&#34;&gt;&lt;span id=&#34;appendix_a:_rationale_for_pipe_operators&#34;&gt;Appendix A: Rationale for pipe operators&lt;/span&gt;&lt;/h1&gt;

&lt;p&gt;As we pointed out in the text, the named form of passing a list has the disadvantage that you have to know what the formal parameter&amp;rsquo;s name is. We could get around that by saying that a null name maps to the slurp array. In other words, we could define a &lt;code&gt;=&amp;gt;&lt;/code&gt; unary operator that creates a null key:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff(@foo, =&amp;gt;(1,2,3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can at least lose the outer parens in this case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff @foo, =&amp;gt;(1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But darn it, we can&amp;rsquo;t get rid of those pesky inner parens because of the precedence of &lt;code&gt;=&amp;gt;&lt;/code&gt; with respect to comma. So perhaps it&amp;rsquo;s time for a new operator with looser precedence than comma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff @foo *: 1,2,3         # * to match * zone marker
    stuff @foo +* 1,2,3         # put the * on the list side
    stuff @foo *=&amp;gt; 1,2,3        # or combine with =&amp;gt; above
    stuff @foo ==&amp;gt; 1,2,3        # maybe just lengthen =&amp;gt;
    stuff @foo &amp;lt;== 1,2,3        # except the dataflow is to the left
    stuff @foo with 1,2,3       # could use a word
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whichever one we pick, it&amp;rsquo;d still probably want to construct a special pair internally, because we have to be able to use it indirectly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = (\@foo, &#39;*@&#39; =&amp;gt; (1,2,3));
    stuff *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if we&amp;rsquo;re going to have a special operator to switch explicitly to the list part, it really needs to earn its keep, and do more work. A special operator could also force scalar context on the left and list context on the right. So with implied scalar context we could omit the backslash above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = (@foo with 1,2,3);
    stuff *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all well and good, and some language designers would stop right there, if not sooner. But if we think about this in relation to cascaded list operators, we&amp;rsquo;ll see a different pattern emerging. Here&amp;rsquo;s a left-to-right variant on the Schwartzian Transform:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @x := map {...} @input;
    my @y := sort {...} with @x;
    my @z := map {...} with @y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we think of data flowing left-to-right, it&amp;rsquo;s more like a pipe operator from a shell, except that we&amp;rsquo;re naming our pipes &lt;code&gt;@x&lt;/code&gt; and &lt;code&gt;@y&lt;/code&gt;. But it&amp;rsquo;d be nice not to have to name the temporary array values. If we do have a pipe operator in Perl, it&amp;rsquo;s not going to be &lt;code&gt;|&lt;/code&gt;, for two reasons. First, &lt;code&gt;|&lt;/code&gt; is taken for junctions. Second, piping is a big, low-precedence operation, and I want a big fat operator that will show up to the eye. Of our candidate list above, I think the big, fat arrows really stand out, and look like directed pipes. So assuming we have the &lt;code&gt;==&amp;gt;&lt;/code&gt; operator to go with the &lt;code&gt;&amp;lt;==&lt;/code&gt;, we could write our ST like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @input     ==&amp;gt;
    map {...}  ==&amp;gt;
    sort {...} ==&amp;gt;
    map {...}  ==&amp;gt;
    push my @z;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That argues that the scalar-to-list transition operator should be &lt;code&gt;&amp;lt;==&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @x := map {...} @input;
    my @y := sort {...} &amp;lt;== @x;
    my @z := map {...} &amp;lt;== @y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that means this should maybe dwim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = (@foo &amp;lt;== 1,2,3);
    stuff *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmm.&lt;/p&gt;

&lt;p&gt;That does imply that &lt;code&gt;&amp;lt;==&lt;/code&gt; is (at least in this case) a data composition operator, unlike the &lt;code&gt;==&amp;gt;&lt;/code&gt; operator which merely sends the output of one function to the next. Maybe that&amp;rsquo;s not a problem. But people might see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @x &amp;lt;== 1,2,3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and expect it does assignment when it in fact doesn&amp;rsquo;t. Internally it would really do something more like appending a named argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @x, &#39;*@&#39; =&amp;gt; (1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or however we decide to mark the beginning of the &amp;ldquo;real&amp;rdquo; list within a larger list.&lt;/p&gt;

&lt;p&gt;But I do rather like the looks of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push @foo &amp;lt;== 1,2,3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;not to mention the symmetrical:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt;
    push @foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note however that the pointy end of &lt;code&gt;==&amp;gt;&lt;/code&gt; &lt;em&gt;must&lt;/em&gt; be bound to a function that takes a list. You can&amp;rsquo;t say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt;
    my @foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;because you can&amp;rsquo;t say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @foo &amp;lt;== 1,2,3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or rather, you can, if we allow:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (@foo &amp;lt;== 1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but it would mean the Wrong Thing. Ouch. So maybe that should not be legal. The asymmetry was bugging me anyway.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s say that &lt;code&gt;&amp;lt;==&lt;/code&gt; and &lt;code&gt;==&amp;gt;&lt;/code&gt; must always be bound on their pointy end to a slurpy function, and if you want to build an indirect argument list, you have to use some kind of explicit list function such as &lt;code&gt;args&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = args @foo &amp;lt;== 1,2,3;
    stuff *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;args&lt;/code&gt; function would really be a no-op, much like other context enforcers such as &lt;code&gt;scalar&lt;/code&gt; and &lt;code&gt;list&lt;/code&gt;. In fact, I&amp;rsquo;d be tempted to just use &lt;code&gt;list&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list @foo &amp;lt;== 1,2,3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But unless we can get people to see &lt;code&gt;&amp;lt;==&lt;/code&gt; as a strange kind of comma, that will likely be misread as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list(@foo) &amp;lt;== 1,2,3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;when it&amp;rsquo;s really this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list(@foo &amp;lt;== 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, using &lt;code&gt;list&lt;/code&gt; would cut out the need for yet another built-in, for which there is much to be said&amp;hellip; I&amp;rsquo;d say, let&amp;rsquo;s go with &lt;code&gt;list&lt;/code&gt; on the assumption that people &lt;em&gt;will&lt;/em&gt; learn to read &lt;code&gt;&amp;lt;==&lt;/code&gt; as a pipe comma. If someone wants to use &lt;code&gt;args&lt;/code&gt; for clarity, they can always just alias &lt;code&gt;list&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;args ::= &amp;amp;*list;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More likely, they&amp;rsquo;ll just use the parenthesized form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list(@foo &amp;lt;== 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I suppose there could also be a prefix unary form, in case they want to use it without scalar arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list(&amp;lt;== 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or in case they want to put a comma after the scalar arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list(@foo, &amp;lt;== 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, it could be argued that we should &lt;em&gt;only&lt;/em&gt; have the unary form, since in this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stan @array, ollie &amp;lt;== 1,2,3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s visually ambiguous whether the pointy pipe belongs to &lt;code&gt;stan&lt;/code&gt; or &lt;code&gt;ollie&lt;/code&gt;. It could be ambiguous to the compiler as well. With a unary operator, it unambiguously belongs to &lt;code&gt;ollie&lt;/code&gt;. You&amp;rsquo;d have to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stan @array, ollie, &amp;lt;== 1,2,3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to make it belong to &lt;code&gt;stan&lt;/code&gt;. And yet, it&amp;rsquo;d be really strange for a unary &lt;code&gt;&amp;lt;==&lt;/code&gt; to force the arguments to its left into scalar context if the operator doesn&amp;rsquo;t govern those arguments syntactically. And I still think I want &lt;code&gt;&amp;lt;==&lt;/code&gt; to do that. And it&amp;rsquo;s probably better to disambiguate with parentheses anyway. So we keep it a binary operator. There&amp;rsquo;s no unary variant, either prefix or postfix. You can always say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list( () &amp;lt;== 1,2,3 )
    list( @foo &amp;lt;== () )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, &lt;code&gt;==&amp;gt;&lt;/code&gt; is also always a binary operator. As the reverse of &lt;code&gt;&amp;lt;==&lt;/code&gt;, it forces its left side into list context, and it also forces all the arguments of the list operator on the right into scalar context. Just as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mumble @foo &amp;lt;== @bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tells you that &lt;code&gt;@foo&lt;/code&gt; is in scalar context and &lt;code&gt;@bar&lt;/code&gt; is in list context regardless of the signature of mumble, so too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @bar ==&amp;gt;
    mumble @foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tells you exactly the same thing. This is particularly useful when you have a method with an unknown signature that you have to dispatch on:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @bar ==&amp;gt;
    $objects[$x].mumble(@foo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;==&amp;gt;&lt;/code&gt; unambiguously indicates that all the other arguments to &lt;code&gt;mumble&lt;/code&gt; are in scalar context. It also allows &lt;code&gt;mumble&lt;/code&gt;&amp;rsquo;s signature to check to see if the number of scalar arguments is within the correct range, counting only required and optional parameters, since we don&amp;rsquo;t have to allow for extra arguments to slop into the slurp array.&lt;/p&gt;

&lt;p&gt;If we do want extra list arguments, we could conceivably allow both kinds of pipe at once:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @bar ==&amp;gt;
    $objects[$x].mumble(@foo &amp;lt;== 1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we did that, it could be equivalent to either:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $objects[$x].mumble(@foo &amp;lt;== 1,2,3,@bar)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $objects[$x].mumble(@foo &amp;lt;== @bar,1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since I can argue it both ways, we&amp;rsquo;ll have to disallow it entirely. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Seriously, the conservative thing to do is to disallow it until we know what we want it to mean, if anything.&lt;/p&gt;

&lt;p&gt;On the perl6-language list, an operator was discussed that would do argument rearrangement, but this is a little different in that it is constrained (by default) to operate only with the slurpy list part of the input to a function. This is as it should be, if you think about it. When you pipe things around in Unix, you don&amp;rsquo;t expect the command line switches to come in via the pipe, but from the command line. The scalar arguments of a list operator function as the command line, and the list argument functions as the pipe.&lt;/p&gt;

&lt;p&gt;That being said, if you want to pull the scalar arguments from the front of the pipe, we already have a mechanism for that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list(@foo &amp;lt;== 1,2,3);
    stuff *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By extension, we also have this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list(@foo &amp;lt;== 1,2,3) ==&amp;gt;
      stuff *();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So there&amp;rsquo;s no need for a special syntax to put the invocant after all the arguments. It&amp;rsquo;s just this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list(@foo &amp;lt;== 1,2,3) ==&amp;gt;
     $object.stuff *();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Possibly the &lt;code&gt;*()&lt;/code&gt; could be inferred in some cases, but it may be better not to if we can&amp;rsquo;t do it consistently. If &lt;code&gt;stuff&lt;/code&gt;&amp;rsquo;s signature started with optional positional parameters, we wouldn&amp;rsquo;t know whether the pipe starts with positional arguments or list elements. I think that passing positionals at the front of the pipe is rare enough that it ought to be specially marked with &lt;code&gt;*()&lt;/code&gt;. Maybe we can reduce it to a &lt;code&gt;*&lt;/code&gt;, like a unary that has an optional argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list(@foo &amp;lt;== 1,2,3) ==&amp;gt;
     $object.stuff *;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way, you may think that we&amp;rsquo;re being silly calling these pipes, since we&amp;rsquo;re just passing lists around. But remember that these can potentially be lazy lists produced by a generator. Indeed, a common idiom might be something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;$*IN&amp;gt; ==&amp;gt; process() ==&amp;gt; print;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which arguably reads better than:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print process &amp;lt;$*IN&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another possibility is that we extend the argumentless &lt;code&gt;*&lt;/code&gt; to mark where the list goes in constructs that take lists but aren&amp;rsquo;t officially list operators:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt;
    my @foo = (*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But maybe we should just make:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt; my @foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;do what people will expect it to. Since we require the &lt;code&gt;list&lt;/code&gt; operator for the other usage, it&amp;rsquo;s easy enough to recognize that this is not a list operator, and that we should therefore assign it. It seems to have a kind of inevitability about it.&lt;/p&gt;

&lt;p&gt;Damian: &amp;ldquo;Certainly, if we don&amp;rsquo;t support it, someone (*ahem*) will immediately write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi infix:==&amp;gt; (Lazy $list, @array is rw) { @array = $list }
    multi infix:&amp;lt;== (@array is rw, Lazy $list) { @array = $list }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;So we might as well make it standard.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;On the other hand&amp;hellip;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m suddenly wondering if assignment and binding can change precedence on the right like list operators do if it&amp;rsquo;s known we&amp;rsquo;re assigning to a list. I, despite my credentials as TheLarry, keep finding myself writing list assignments like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @foo := 0..9,&#39;a&#39;..&#39;z&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oops. But what if it wasn&amp;rsquo;t an oops. What if that parsed like a list operator, and slurped up all the commas to the right? Parens would still be required around a list on the left though. And it might break weird things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (@a = (1,2), @b = (3,4))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But how often do you do a list assignment inside a list? On the other hand, making list assignment a different precedence than scalar is weird. But it&amp;rsquo;d have to be that way if we still wanted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ($a = 1, $b = 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to work as a C programmer expects. Still, I think I like it. In particular, it&amp;rsquo;d let us write what we mean explicitly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt;
    my @foo = *;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So let&amp;rsquo;s go ahead and do that, and then maybe someone (*ahem*) might just forget to overload the pipe operators on arrays.*&lt;/p&gt;

&lt;p&gt;* The words &amp;ldquo;fat&amp;rdquo;, &amp;ldquo;slim&amp;rdquo;, and &amp;ldquo;none&amp;rdquo; come to mind.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;span-id-appendix-b-how-to-bind-strange-arguments-to-weird-parameters-appendix-b-how-to-bind-strange-arguments-to-weird-parameters-span&#34;&gt;&lt;span id=&#34;appendix_b:_how_to_bind_strange_arguments_to_weird_parameters&#34;&gt;Appendix B: How to bind strange arguments to weird parameters&lt;/span&gt;&lt;/h1&gt;

&lt;p&gt;It may seem like the declaration syntax has too many options (and it does), but it&amp;rsquo;s actually saving you a good deal of complexity. When you say something excruciatingly fancy like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method x ($me: $req, ?$opt, *%named, *@list, +$namedopt) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;re actually getting a whole pile of semantics resembling this pseudocode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method x (*@list) {
        my %named;
        my $argnum = 0;

        # find beginning of named arguments
        while exists @list[$argnum] and @list[$argnum] !~ Pair|Hash {
            $argnum++;
            last if $argnum == 3;               # force transition to named or list
        }
        my $posmax = $argnum;

        # pull out named actuals (pairs or hashes)
        while exists @list[$argnum] and @list[$argnum] ~~ Pair|Hash {
            %named.add(@list[$argnum++].pairs);
        }

        # the invocant comes in like this
        my $_   := $posmax &amp;gt; 0 ?? @list[0] :: delete %named{me}  // die &amp;quot;Not enough args&amp;quot;;
        my $me  := $_;                          # only if invocant declared

        # required parameters are bound like this
        my $req := $posmax &amp;gt; 1 ?? @list[1] :: delete %named{req} // die &amp;quot;Not enough args&amp;quot;;

        # optional positional parameters are bound like this
        my $opt := $posmax &amp;gt; 2 ?? @list[2] :: delete %named{opt};

        # optional named parameters are bound like this
        my $namedopt := delete %named{namedopt};

        # trim @list down to just the remaining list
        splice(@list, 0, $argnum, ());

        if defined @list {
            die &amp;quot;Can&#39;t have two lists&amp;quot; if exists %named{&#39;*@&#39;};
        }
        else {
            @list := delete %named{&#39;*@&#39;} // [];
        }

        ...     # Your ad here.
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only hopefully it runs a lot faster. Regardless, I know which version I&amp;rsquo;d rather write&amp;hellip;&lt;/p&gt;

&lt;p&gt;Or maintain&amp;hellip;&lt;/p&gt;

&lt;p&gt;You can get even more semantics than that if we need to process default values or do run-time type checking. It also gets hairier if you have any positional parameters declared as &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Hash&lt;/code&gt;. On the other hand, the compiler can probably optimize away lots of the linkage code in general, particularly when it can compare the actual arguments against the signature at compile time and, for instance, turn named arguments into positional arguments internally. Or prebuild a hash of the named args. Even if it can&amp;rsquo;t do that, it could generate specially marked lists that already know where the named arguments start and stop so we don&amp;rsquo;t have to scan for those boundaries. This gets easier if the caller marks the list part with &lt;code&gt;&amp;lt;==&lt;/code&gt; or &lt;code&gt;==&amp;gt;&lt;/code&gt;. Though it gets harder again if they use splat to pass indirect positional arguments.&lt;/p&gt;

&lt;p&gt;Note also that we don&amp;rsquo;t necessarily have to build a real &lt;code&gt;%named&lt;/code&gt; slurphash. The &lt;code&gt;%named&lt;/code&gt; hash can just be a proxy for a function that scans those args known to contain named arguments, whether pairs or hashes. In general, although there may be quite a few optional parameters, most of them aren&amp;rsquo;t set in the average call, so the brute-force approach of scanning the call list linearly for each possible parameter may well be faster than trying to build a real hash (particularly if any or all of named parameters already come in as a hash).&lt;/p&gt;

&lt;p&gt;It might be tricky to make bound named arguments disappear from the proxy hash, however. In the code above, you&amp;rsquo;ll note that we actually delete named arguments from &lt;code&gt;%named&lt;/code&gt; as we bind them to positional parameters. A proxy hash might have to figure out how to hide &amp;ldquo;used&amp;rdquo; values somehow. Or maybe we just leave them visible as aliases to bound parameters. I don&amp;rsquo;t profess to know which is better. Could be a pragma for it&amp;hellip;seems the usual cure for festering bogons these days&amp;hellip;&lt;/p&gt;

&lt;p&gt;In our pseudocode above, we don&amp;rsquo;t ever actually evaluate the arguments of the entire list, because it could be a generated list like &lt;code&gt;1..Inf&lt;/code&gt;, and flattening that kind of list would chew up just a &lt;em&gt;wee&lt;/em&gt; bit too much memory. If &lt;code&gt;@list&lt;/code&gt; were an ordinary array, its boolean value would tell us if it will produce any values, but that&amp;rsquo;s not really what we want. What we really want to know is whether the caller specified anything, not whether what they specified is going to produce any values. If you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push @foo, 1..0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the range doesn&amp;rsquo;t generate any values, but you shouldn&amp;rsquo;t look anywhere else for the list either. That is,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt;
    push @foo, 1..0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;should probably be an error. It&amp;rsquo;s equivalent to saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push @foo, &#39;*@&#39;=&amp;gt;(1,2,3), 1..0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or some such. We try to catch that in our pseudocode above.&lt;/p&gt;

&lt;p&gt;When you bind a lazy list to an array name such as &lt;code&gt;@_&lt;/code&gt; or &lt;code&gt;@list&lt;/code&gt;, by default it&amp;rsquo;s going to try to give the appearance that the array is all there, even if behind the scenes it is having to generate values for you. In this case, we don&amp;rsquo;t want to flatten the list, so instead of trying to access any of the values of the variadic list, we just ask if it is defined. In Perl 6, an ordinary array is considered defined if it either has some flattened arguments in it already, or it has an associated list generator definition of how to produce more elements. We can figure this out without changing the state of the array.&lt;/p&gt;

&lt;p&gt;Contrast this with the array&amp;rsquo;s boolean value, which is true only if it is &lt;em&gt;known&lt;/em&gt; that there are actual elements in the array. If an array has no remaining flattened elements but has a definition for how to produce more, the boolean evaluation must evaluate the definition sufficiently to determine whether there will be at least one more value. In the case of a range object, it can ask the range object without actually flattening another element, but in the limiting case of a random generator subroutine, it would have to go ahead and call the wretched generator to get the next flattened element, so that it can know to return false if there were no next element.&lt;/p&gt;

&lt;p&gt;Note that even the flat view of the array doesn&amp;rsquo;t necessarily flatten until you actually access the array, in which case it flattens as much as it needs to in order to produce the value you requested, and no more.&lt;/p&gt;

&lt;p&gt;We need a name for the list of internal generators bound to the array. Since they&amp;rsquo;re behaving as specifications for the array, we&amp;rsquo;ll get at them using the predefined &lt;code&gt;.specs&lt;/code&gt; method that arrays support.&lt;/p&gt;

&lt;p&gt;So, for instance, if you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @foo := (0..9,&#39;a&#39;..&#39;z&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo.length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would return &lt;code&gt;36&lt;/code&gt;, but:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo.specs.length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would return 2, one for each range object. (That&amp;rsquo;s presuming you didn&amp;rsquo;t already ask for the length of the array, since in general asking for the length of an array flattens it completely and blows away the specs&amp;ndash;though perhaps in this case the range specs can calculate their lengths non-destructively.)&lt;/p&gt;

&lt;p&gt;Anyway, in the absence of such a flattening event, both &lt;code&gt;@foo&lt;/code&gt; and &lt;code&gt;@foo.specs&lt;/code&gt; are true. However, if instead you&amp;rsquo;d given it a null range:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @foo := 1..0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then &lt;code&gt;@foo.specs&lt;/code&gt; would be true at least temporarily, but &lt;code&gt;@foo&lt;/code&gt; would be false, because the flattened list contains no values.&lt;/p&gt;

&lt;p&gt;Now here&amp;rsquo;s where it gets interesting. As you process a flat array view, the corresponding specs mutate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @flat = 1..10;
    shift @flat;
    print @flat.specs;   # prints 2..10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The specs aren&amp;rsquo;t just a queue, but also a stack:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @flat = 1..10;
    pop @flat;
    print @flat.specs;   # prints 1..9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you can &lt;code&gt;pop&lt;/code&gt; an array without committing to flattening the entire list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @flat = (1..Inf, 1..10);
    pop @flat;
    print @flat.specs;   # prints 1..Inf, 1..9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you pop the array 9 more times, the resulting null spec pops itself from the specs list, and you get a single spec of &lt;code&gt;1..Inf&lt;/code&gt; out of &lt;code&gt;@flat.specs&lt;/code&gt;. (Continuing to pop &lt;code&gt;@flat&lt;/code&gt; returns &lt;code&gt;Inf&lt;/code&gt; forever, of course, with no change to the spec.)&lt;/p&gt;

&lt;p&gt;However, if you access the last element using the &lt;em&gt;length&lt;/em&gt; of the array, it may try to flatten, and fail:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @flat = (1..Inf, 1..10);
    $last = @flat[@flat - 1];   # Kaboom!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Still, we should be able to detect the attempt to flatten an infinite list and give a better diagnostic than Perl 5&amp;rsquo;s &amp;ldquo;Out of memory&amp;rdquo;. Either that, or someone should just up and figure out how to subscript arrays using transfinite numbers.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;span-id-appendix-c-hypotheticality-and-flight-recorders-appendix-c-hypotheticality-and-flight-recorders-span&#34;&gt;&lt;span id=&#34;appendix_c:_hypotheticality_and_flight_recorders&#34;&gt;Appendix C: Hypotheticality and Flight Recorders&lt;/span&gt;&lt;/h1&gt;

&lt;p&gt;[This is a portion of a letter I sent to the design team. This stuff is still in discussion with the internals folks, so please take this as informative rather than definitive. But I just thought you might like to see how sausage is made. &lt;code&gt;:-)&lt;/code&gt; &amp;ndash;Larry]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    : Seems like you&#39;re going to have to explain the C&amp;lt;TEMP&amp;gt;/C&amp;lt;RESTORE&amp;gt; 
    : relationship in A6, Larry, since C&amp;lt;RESTORE&amp;gt; isn&#39;t even mentioned
    : there at present.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;d like to explain it primarily by making both of them unnecessary most of the time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    : But maybe after a good nights sleep, eh? ;-)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay, I&amp;rsquo;ve had a night&amp;rsquo;s sleep. Whether it was a good one remains to be seen. But here&amp;rsquo;s what I&amp;rsquo;m after. Forget implementation for a moment. What&amp;rsquo;s the interface that people want, in the abstract? You were starting to think this way yourself with &amp;ldquo;&lt;code&gt;suppose {...}&lt;/code&gt;&amp;rdquo;. So let&amp;rsquo;s do some supposin&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll talk about caller and callee here, but I&amp;rsquo;m really talking about the user&amp;rsquo;s abstract view vs. the user&amp;rsquo;s implementation view, so it applies to variables, lvalue routines, and rvalue routines alike.&lt;/p&gt;

&lt;p&gt;On the caller side, people want to be able to make a temporary assumption or a hypothesis. There is some scope over which the hypothesis is stated, and then some scope over which the hypothesis is assumed. At the end of that scope, the hypothesis may or may not be retracted. (I&amp;rsquo;m trying not to state this in terms of &lt;code&gt;temp&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;, just to keep our current ideas out of it.)&lt;/p&gt;

&lt;p&gt;Historically, the scope of the hypothesis &lt;em&gt;statement&lt;/em&gt; is a single variable/value, because &lt;code&gt;local&lt;/code&gt; only knew how to temporize that kind of thing. The scope of the hypothesis assumption has always extended to the end of the current dynamic scope.&lt;/p&gt;

&lt;p&gt;In the very abstract view, supposing is a transactional function with two arguments, the first one of which establishes a scope in which any state change is labelled as provisional. The second argument establishes a scope in which we work out the ramifications of that supposing, which may include other supposings. In classical terms, they&amp;rsquo;re the &lt;em&gt;protasis&lt;/em&gt; and &lt;em&gt;apodosis&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    suppose { &amp;lt;pro&amp;gt; } { &amp;lt;apo&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end of the second scope we decide whether to succeed or fail. On failure, we unsuppose everything that was supposed from the beginning, and upon success, we allow certain new &amp;ldquo;facts&amp;rdquo; to leak out into a larger reality (which may itself be a hypothesis, but leave that aside for the moment). It&amp;rsquo;s basically commit/rollback.&lt;/p&gt;

&lt;p&gt;It could also be written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    suppose &amp;lt;pro&amp;gt; {
        &amp;lt;apo&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to make it look more like an &lt;code&gt;if&lt;/code&gt;. But up till now we&amp;rsquo;ve written it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        temp &amp;lt;pro&amp;gt;;
        &amp;lt;apo&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which actually works out fine as a syntax, since every statement is in a sense conditional on preceding statements. If we want to allow a hypothetical result to leak out, we use &amp;ldquo;let&amp;rdquo; instead of &amp;ldquo;temp&amp;rdquo;. Whatever. I&amp;rsquo;m not caring about the syntax yet, just the abstract interface.&lt;/p&gt;

&lt;p&gt;And the abstract interface wants both &amp;lt;pro&amp;gt; and &amp;lt;apo&amp;gt; to be as general as possible. We already have a completely general &amp;lt;apo&amp;gt;, but we&amp;rsquo;ve severely restricted the &amp;lt;pro&amp;gt; so far to be (in Perl 5) a storage location, or in Perl 6 (Seb), anything with a &lt;code&gt;.TEMP&lt;/code&gt; method. You&amp;rsquo;d like to be able to turn anything involving state changes into an &amp;lt;pro&amp;gt;, but we can&amp;rsquo;t. We can only do it to values that cooperate.&lt;/p&gt;

&lt;p&gt;So the real question is what does cooperation look like from the &amp;ldquo;callee&amp;rdquo; end of things? What&amp;rsquo;s the best interface for cooperating? I submit that the best interface for that does not look like &lt;code&gt;TEMP =&amp;gt; {}&lt;/code&gt;, or &lt;code&gt;RESTORE {}&lt;/code&gt;. It looks like nothing at all!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo { $x = 1234; }
    $x = 0;
    {
        temp foo();
        print $x;       # prints 1234
    }
    print $x;           # prints 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How might this work in practice? If Perl (as a language) is aware of when it is making a state change, and if it also aware of when it is doing so in a hypothetical context (*any* hypothetical context in the dynamic scope), then Perl (as a language) can save its own record of that state change, filing it with the proper hypothetical context management authorities, to be undone (or committed) at the appropriate moment.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s fine as long as we&amp;rsquo;re running in Perl. Where an explicit &lt;code&gt;TEMP&lt;/code&gt; method is useful is in the interface to foreign code or data that doesn&amp;rsquo;t support dynamically scoped hypotheticality. If a Proxy is proxying for a Perl variable or attribute, however, then the &lt;code&gt;STORE&lt;/code&gt; already knows its dynamic context, and handles &lt;code&gt;temp&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; implicitly just as any other Perl code running in hypothetical context would.&lt;/p&gt;

&lt;p&gt;As for a hypothesis within a hypothesis, I think it just means that when you refrain from &lt;code&gt;UNDO&lt;/code&gt;ing the &lt;code&gt;let&lt;/code&gt; state changes, you actually &lt;code&gt;KEEP&lt;/code&gt; them into a higher undo list, if there is one. (In practice, this may mean there aren&amp;rsquo;t separate &lt;code&gt;LAST&lt;/code&gt; and &lt;code&gt;UNDO&lt;/code&gt; lists. Just a &lt;code&gt;LAST&lt;/code&gt; list, in which some entries do a &lt;code&gt;KEEP&lt;/code&gt; or &lt;code&gt;UNDO&lt;/code&gt; at the last moment. Otherwise a &lt;code&gt;let&lt;/code&gt; within a &lt;code&gt;let&lt;/code&gt; has to poke something onto both a keep list and an undo list. But maybe it comes out to the same thing.)&lt;/p&gt;

&lt;p&gt;(In any event, we do probably need a name for the current innermost supposition we&amp;rsquo;re in the dynamic scope of. I have my doubts that &lt;code&gt;$?_&lt;/code&gt; is that name, however. &lt;code&gt;$0&lt;/code&gt; is closer to it. Can thrash that out later.)&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all very powerful. But here&amp;rsquo;s where it borders on disruptive technology. I mentioned a while back the talk by Todd A. Proebsting on Disruptive Language Technologies. In it he projects which new disruptive language technologies will take over the world someday. The one that stuck in my head was the flight data recorder, where every state change for the last N instructions was recorded for analysis in case of failure. Sound familiar?&lt;/p&gt;

&lt;p&gt;Taken together with my hypotheticality hypothesis, I think this likely indicates a two-birds-with-one-stone situation that we must design for. If state changes are automatically stored in a type-appropriate manner, we don&amp;rsquo;t necessarily have to generate tons of artificial closures merely to create artificial lexical variables just so we have them around later at the right moment. I don&amp;rsquo;t mind writing double closures for things like macros, where they&amp;rsquo;re not in hot code. But &lt;code&gt;let&lt;/code&gt; and friends need to be blazing fast if we&amp;rsquo;re ever going to use Perl for logic programming, or even recursive descent parsing. And if we want a flight data recorder, it had better not hang on the outside of the airplane where it&amp;rsquo;ll induce drag.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s what I think is wrong with our Sebastopolian formulation of &lt;code&gt;.TEMP&lt;/code&gt;. Am I making any sense?&lt;/p&gt;

&lt;p&gt;Larry&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apocalypse 5</title>
      <link>http://localhost:1313/pub/2002/06/04/apo5.html/</link>
      <pubDate>Tue, 04 Jun 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/06/04/apo5.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is the Apocalypse on Pattern Matching, generally having to do with what we call &amp;ldquo;regular expressions&amp;rdquo;, which are only marginally related to real regular expressions. Nevertheless, the term has grown with the capabilities of our pattern matching engines, so I&amp;rsquo;m not going to try to fight linguistic necessity here. I will, however, generally call them &amp;ldquo;regexes&amp;rdquo; (or &amp;ldquo;regexen&amp;rdquo;, when I&amp;rsquo;m in an Anglo-Saxon mood).&lt;/p&gt;

&lt;p&gt;Here are the RFCs covered in this Apocalypse. PSA stands for &amp;ldquo;problem, solution, acceptance&amp;rdquo;, my private rating of how this RFC will fit into Perl 6. Doubtless I have misclassified &lt;em&gt;your&lt;/em&gt; RFC, though the other ratings are pretty accurate. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RFC   PSA   Title
    ---   ---   -----
    072   aaa   Variable-length lookbehind. 
    093   abb   Regex: Support for incremental pattern matching
    110   bbb   counting matches
    112   acc   Assignment within a regex
    135   acr   Require explicit m on matches, even with ?? and // as delimiters.
    144   aaa   Behavior of empty regex should be simple
    145   acr   Brace-matching for Perl Regular Expressions
    150   acc   Extend regex syntax to provide for return of a hash of matched subpatterns
    156   aaa   Replace first match function (C&amp;lt;?...?&amp;gt;) with a flag to the match command.
    164   ccr   Replace =~, !~, m//, s///, and tr// with match(), subst(), and trade()
    165   acc   Allow Variables in tr///
    166   abc   Alternative lists and quoting of things
    191   bbc   smart container slicing
    197   cdr   Numeric Value Ranges In Regular Expressions
    198   adr   Boolean Regexes
    261   dbr   Pattern matching on perl values
    274   acc   Generalised Additions to Regexs
    276   aaa   Localising Paren Counts in qr()s.
    308   dar   Ban Perl hooks into regexes
    316   bcr   Regex modifier for support of chunk processing and prefix matching
    317   aaa   Access to optimisation information for regular expressions
    331   acc   Consolidate the $1 and \1 notations
    332   abc   Regex: Make /$/ equivalent to /\z/ under the &#39;/s&#39; modifier
    348   bcc   Regex assertions in plain Perl code
    360   acb   Allow multiply matched groups in regexes to return a listref of all matches
    361   abb   Simplifying split()
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interestingly, there were no withdrawn RFCs for pattern matching. That means either that there were no cork-brained ideas proposed, or that regex culture is so cork-brained already that the cork-brained ideas blend right in. I know where my money is&amp;hellip; &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;In fact, regular expression culture is a mess, and I share some of the blame for making it that way. Since my mother always told me to clean up my own messes, I suppose I&amp;rsquo;ll have to do just that.&lt;/p&gt;

&lt;p&gt;For prior Apocalypses, I&amp;rsquo;ve used the RFCs as a springboard for discussion of my thinking, but this one is special, because none of the RFCs were courageous enough (or foolhardy enough) to look at the big picture and propose radical change where it&amp;rsquo;s needed. But Perl has often been tagged as a language in which it&amp;rsquo;s easy to write programs that are difficult to read, and it&amp;rsquo;s no secret that regular expression syntax that has been the chief culprit. Funny that other languages have been borrowing Perl&amp;rsquo;s regular expressions as fast as they can&amp;hellip;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s primarily because we took several large steps in Perl 5 to enhance regex capabilities. We took one large step forwards with the &lt;code&gt;/x&lt;/code&gt; option, which allowed whitespace between regex tokens. But we also took several large steps sideways with the &lt;code&gt;(?...)&lt;/code&gt; extension syntax. I call them steps sideways, but they were simultaneously steps forward in terms of functionality and steps backwards in terms of readability. At the time, I rationalized it all in the name of backward compatibility, and perhaps that approach was correct for that time and place. It&amp;rsquo;s not correct now, since the Perl 6 approach is to break everything that needs breaking all at once.&lt;/p&gt;

&lt;p&gt;And unfortunately, there&amp;rsquo;s a lot of regex culture that needs breaking.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;header&#34;&gt; &lt;/span&gt;&lt;/strong&gt;
Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;•&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=17#accepted%20rfcs&#34;&gt;Accepted RFCs&lt;/a&gt;&lt;/strong&gt;&lt;/span&gt;&lt;br /&gt;
&lt;br /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=17#rfc%20072:%20variablelength%20lookbehind.&#34;&gt;RFC 072: Variable-length lookbehind&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=17#rfc%20093:%20regex:%20support%20for%20incremental%20pattern%20matching&#34;&gt;RFC 093: Regex: Support for incremental pattern matching&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=18#rfc%20110:%20counting%20matches&#34;&gt;RFC 110: counting matches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=18#rfc%20112:%20assignment%20within%20a%20regex&#34;&gt;RFC 112: Assignment within a regex&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=19#rfc%20144:%20behavior%20of%20empty%20regex%20should%20be%20simple&#34;&gt;RFC 144: Behavior of empty regex should be simple&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=19#rfc%20150:%20extend%20regex%20syntax%20to%20provide%20for%20return%20of%20a%20hash%20of%20matched%20subpatterns&#34;&gt;RFC 150: Extend regex syntax to provide for return of a hash of matched subpatterns&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=19#rfc%20156:%20replace%20first%20match%20function%20(...)%20with%20a%20flag%20to%20the%20match%20command.&#34;&gt;RFC 156: Replace first match function (?...?) with a flag to the match command&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=19#rfc%20165:%20allow%20variables%20in%20tr///&#34;&gt;RFC 165: Allow Variables in tr///&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=20#rfc%20166:%20alternative%20lists%20and%20quoting%20of%20things&#34;&gt;RFC 166: Alternative lists and quoting of things&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=20#rfc%20191:%20smart%20container%20slicing&#34;&gt;RFC 191: smart container slicing&amp;quot;&amp;gt;RFC 191: smart container slicing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=21#rfc%20274:%20generalized%20additions%20to%20regexs&#34;&gt;RFC 274: Generalized Additions to Regexs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=21#rfc%20276:%20localising%20paren%20counts%20in%20qr()s.&#34;&gt;RFC 276: Localising Paren Counts in qr()s.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=21#rfc%20317:%20access%20to%20optimisation%20information%20for%20regular%20expressions&#34;&gt;RFC 317: Access to optimisation information for regular expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=21#rfc%20331:%20consolidate%20the%20$1%20and%20\1%20notations&#34;&gt;RFC 331: Consolidate the $1 and \1 notations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=21#rfc%20332:%20regex:%20make%20/$/%20equivalent%20to%20/\z/%20under%20the%20&amp;#39;/s&amp;#39;%20modifier&#34;&gt;RFC 332: Regex: Make /$/ equivalent to /\z/ under the &#39;/s&#39; modifier&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=22#rfc%20348:%20regex%20assertions%20in%20plain%20perl%20code&#34;&gt;RFC 348: Regex assertions in plain Perl code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=22#rfc%20360:%20allow%20multiply%20matched%20groups%20in%20regexes%20to%20return%20a%20listref%20of%20all%20matches&#34;&gt;RFC 360: Allow multiply matched groups in regexes to return a listref of all matches&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=23#rfc%20361:%20simplifying%20split()&#34;&gt;RFC 361: Simplifying split()&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;br /&gt;
&lt;br /&gt;
&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;•&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rejected%20rfcs&#34;&gt;Rejected RFCs&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20135:%20require%20explicit%20m%20on%20matches,%20even%20with%20%20and%20//%20as%20delimiters.&#34;&gt;RFC 135: Require explicit m on matches, even with ?? and // as delimiters.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20145:%20bracematching%20for%20perl%20regular%20expressions&#34;&gt;RFC 145: Brace-matching for Perl Regular Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20164:%20replace%20=~,%20!~,%20m//,%20s///,%20and%20tr//%20with%20match(),%20subst(),%20and%20trade()&#34;&gt;RFC 164: Replace =~, !~, m//, s///, and tr// with match(), subst(), and trade()&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20197:%20numeric%20value%20ranges%20in%20regular%20expressions&#34;&gt;RFC 197: Numeric Value Ranges In Regular Expressions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20198:%20boolean%20regexes&#34;&gt;RFC 198: Boolean Regexes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20261:%20pattern%20matching%20on%20perl%20values&#34;&gt;RFC 261: Pattern matching on perl values&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20308:%20ban%20perl%20hooks%20into%20regexes&#34;&gt;RFC 308: Ban Perl hooks into regexes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/06/04/apo5.html?page=24#rfc%20316:%20regex%20modifier%20for%20support%20of%20chunk%20processing%20and%20prefix%20matching&#34;&gt;RFC 316: Regex modifier for support of chunk processing and prefix matching&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span class=&#34;secondary&#34;&gt; • &lt;a href=&#34;http://localhost:1313/pub/2001/04/02/wall.html&#34;&gt;Apocalypse One&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/05/03/wall.html&#34;&gt;Apocalypse Two&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html&#34;&gt;Apocalypse Three&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html&#34;&gt;Apocalypse Four&lt;/a&gt;&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;
&lt;a href=&#34;http://conferences.oreilly.com/oscon/&#34;&gt;O&amp;#39;Reilly Open Source Convention -- July 22-26, San Diego, CA.&lt;/a&gt;
&lt;p&gt;&lt;strong&gt;From the Frontiers of Research to the Heart of the Enterprise&lt;/strong&gt;&lt;/p&gt;
&lt;p&gt;Don&#39;t miss Larry Walls&#39;s presentation, &lt;a href=&#34;http://conferences.oreillynet.com/cs/os2002/view/e_sess/2642&#34;&gt;Introducing The Perl 6 Language&lt;/a&gt; at the O&#39;Reilly Open Source Convention in July. The conference includes many &lt;a href=&#34;http://conferences.oreillynet.com/pub/w/15/track_perl.html&#34;&gt;sessions&lt;/a&gt; and &lt;a href=&#34;http://conferences.oreillynet.com/pub/w/15/tutorial_perl.html&#34;&gt;tutorials&lt;/a&gt; of interest to Perl developers.&lt;/p&gt;
&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Regex culture has gone wrong in a variety of ways, but it&amp;rsquo;s not my intent to assign blame&amp;ndash;there&amp;rsquo;s plenty of blame to go around, and plenty of things that have gone wrong that are nobody&amp;rsquo;s fault in particular. For example, it&amp;rsquo;s nobody&amp;rsquo;s fault that you can&amp;rsquo;t realistically complement a character set anymore. It&amp;rsquo;s just an accident of the way Unicode defines combining characters. The whole notion of character classes is mutating, and that will have some bearing on the future of regular expression syntax.&lt;/p&gt;

&lt;p&gt;Given all this, I need to warn you that this Apocalypse is going to be somewhat radical. We&amp;rsquo;ll be proposing changes to certain &amp;ldquo;sacred&amp;rdquo; features of regex culture, and this is guaranteed to result in future shock for some of our more conservative citizens. Do not be alarmed. We will provide ways for you to continue programming in old-fashioned regular expressions if you desire. But I hope that once you&amp;rsquo;ve thought about it a little and worked through some examples, you&amp;rsquo;ll like most of the changes we&amp;rsquo;re proposing here.&lt;/p&gt;

&lt;p&gt;So although the RFCs did contribute greatly to my thinking for this Apocalypse, I&amp;rsquo;m going to present my own vision first for where regex culture should go, and then analyze the RFCs with respect to that vision.&lt;/p&gt;

&lt;p&gt;First, let me enumerate some of the things that are wrong with current regex culture.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Too much history&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Too compact and &amp;ldquo;cute&amp;rdquo;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poor Huffman coding&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Too much reliance on too few metacharacters&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Different things look too similar&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poor end-weight design&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Too much reliance on modifiers&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Too many special rules and boobytraps&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Backreferences not useful enough&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Too hard to match a literal string&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Two-level interpretation is problematic&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Too little abstraction&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Little support for named captures&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Difficult to use nested patterns&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Little support for grammars&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Inability to define variants&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Poor integration with &amp;ldquo;real&amp;rdquo; language&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Missing backtracking controls&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Difficult to define assertions&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;m sure there are other problems, but that&amp;rsquo;ll do for starters. Let&amp;rsquo;s look at each of these in more detail.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-much-history-too-much-history-span&#34;&gt;&lt;span id=&#34;too much history&#34;&gt;Too much history&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Most of the other problems stem from trying to deal with a rich history. Now there&amp;rsquo;s nothing wrong with history per se, but those of us who are doomed to repeat it find that many parts of history are suboptimal and contradictory. Perl has always tried to err on the side of incorporating as much history as possible, and sometimes Perl has succeeded in that endeavor.&lt;/p&gt;

&lt;p&gt;Cultural continuity has much to be said for it, but what can you do when the culture you&amp;rsquo;re trying to be continuous with is itself discontinuous? As it says in Ecclesiastes, there&amp;rsquo;s a time to build up, and a time to tear down. The first five versions of Perl mostly built up without tearing down, so now we&amp;rsquo;re trying to redress that omission.&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-compact-and-cute-too-compact-and-cute-span&#34;&gt;&lt;span id=&#34;too compact and cute&#34;&gt;Too compact and &amp;ldquo;cute&amp;rdquo;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Regular expressions were invented by computational linguists who love to write examples like &lt;code&gt;/aa*b*(cd)*ee/&lt;/code&gt;. While these are conducive to reasoning about pattern matching in the abstract, they aren&amp;rsquo;t so good for pattern matching in the concrete. In real life, most atoms are longer than &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;b&lt;/code&gt;&amp;rdquo;. In real life, tokens are more recognizable if they are separated by whitespace. In the abstract, &lt;code&gt;/a+/&lt;/code&gt; is reducible to &lt;code&gt;/aa*/&lt;/code&gt;. In real life, nobody wants to repeat a 15 character token merely to satisfy somebody&amp;rsquo;s idea of theoretical purity. So we have shortcuts like the &lt;code&gt;+&lt;/code&gt; quantifier to say &amp;ldquo;one or more&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Now, you may rightly point out that &lt;code&gt;+&lt;/code&gt; is something we already have, and we already introduced &lt;code&gt;/x&lt;/code&gt; to allow whitespace, so why is this bullet point here? Well, there&amp;rsquo;s a lot of inertia in culture, and the problem with &lt;code&gt;/x&lt;/code&gt; is that it&amp;rsquo;s not the default, so people don&amp;rsquo;t think to turn it on when it would probably do a lot of good. The culture is biased in the wrong direction. Whitespace around tokens should be the norm, not the exception. It should be acceptable to use whitespace to separate tokens that could be confused. It should not be considered acceptable to define new constructs that contain a plethora of punctuation, but we&amp;rsquo;ve become accustomed to constructs like &lt;code&gt;(?&amp;lt;=...)&lt;/code&gt; and &lt;code&gt;(??{...})&lt;/code&gt; and &lt;code&gt;[\r\n\ck\p{Zl}\p{Zp}]&lt;/code&gt;, so we don&amp;rsquo;t complain. We&amp;rsquo;re frogs who are getting boiled in a pot full of single-character morphemes, and we don&amp;rsquo;t notice.&lt;/p&gt;

&lt;h3 id=&#34;span-id-poor-huffman-coding-poor-huffman-coding-span&#34;&gt;&lt;span id=&#34;poor huffman coding&#34;&gt;Poor Huffman coding&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Huffman invented a method of data compaction in which common characters are represented by a small number of bits, and rarer characters are represented by more bits. The principle is more general, however, and language designers would do well to pay attention to the &amp;ldquo;other&amp;rdquo; Perl slogan: Easy things should be easy, and hard things should be possible. However, we haven&amp;rsquo;t always taken our own advice. Consider those two regex constructs we just saw:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (?&amp;lt;=...)
    (??{...})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which one do you think is likely to be the most common in everyday use? Guess which one is longer&amp;hellip;&lt;/p&gt;

&lt;p&gt;There are many examples of poor Huffman coding in current regexes. Consider these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (...)
    (?:...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is it really the case that grouping is rarer than capturing? And by two gobbledygooky character&amp;rsquo;s worth? Likewise there are many constructs that are the same length that shouldn&amp;rsquo;t be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (?:...)
    (?#...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Grouping is much more important than the ability to embed a comment. Yet they&amp;rsquo;re the same length currently.&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-much-reliance-on-too-few-metacharacters-too-much-reliance-on-too-few-metacharacters-span&#34;&gt;&lt;span id=&#34;too much reliance on too few metacharacters&#34;&gt;Too much reliance on too few metacharacters&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A lot of our Huffman troubles came about because we were trying to shoehorn new capabilities into an old syntax without breaking anything. The &lt;code&gt;(?...)&lt;/code&gt; construct succeeded at that goal, but it was new wine in old wineskins, as they say. More successful was the &lt;code&gt;*?&lt;/code&gt; minimal matching hack, but it&amp;rsquo;s still symptomatic of the problem that we only had three characters to choose from that would have worked at that point in the grammar. We&amp;rsquo;ve pretty nearly exhausted the available backslash sequences.&lt;/p&gt;

&lt;p&gt;The waterbed theory of linguistic complexity says that if you push down one place, it goes up somewhere else. If you arbitrarily limit yourself to too few metacharacters, the complexity comes out somewhere else. So it seems obvious to me that the way out of this mess is to grab a few more metacharacters. And the metacharacters I want to grab are&amp;hellip;well, we&amp;rsquo;ll see in a moment.&lt;/p&gt;

&lt;h3 id=&#34;span-id-different-things-look-too-similar-different-things-look-too-similar-span&#34;&gt;&lt;span id=&#34;different things look too similar&#34;&gt;Different things look too similar&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Consider these constructs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (??{...})
    (?{...})
    (?#...)
    (?:...)
    (?i:...)
    (?=...)
    (?!...)
    (?&amp;lt;=...)
    (?&amp;lt;!...)
    (?&amp;gt;...)
    (?(...)...|...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These all look quite similar, but some of them do radically different things. In particular, the &lt;code&gt;(?&amp;lt;...)&lt;/code&gt; does not mean the opposite of the &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;. The underlying visual problem is the overuse of parentheses, as in Lisp. Programs are more readable if different things look different.&lt;/p&gt;

&lt;h3 id=&#34;span-id-poor-endweight-design-poor-end-weight-design-span&#34;&gt;&lt;span id=&#34;poor endweight design&#34;&gt;Poor end-weight design&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In linguistics, the notion of end-weight is the idea that people tend to prefer sentences where the short things come first and the long things come last. That minimizes the amount of stuff you have to remember while you&amp;rsquo;re reading or listening. Perl violates this with regex modifiers. It&amp;rsquo;s okay when you say something short like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s/foo/bar/g
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But when you say something like we find in RFC 360:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while ($text =~ /name:\s*(.*?)\n\s*
                    children:\s*(?:(?@\S+)[, ]*)*\n\s*
                    favorite\ colors:\s*(?:(?@\S+)[, ]*)*\n/sigx) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s not until you read the &lt;code&gt;/sigx&lt;/code&gt; at the end that you know how to read the regex. This actually causes problems for the Perl 5 parser, which has to defer parsing the regular expression till it sees the &lt;code&gt;/x&lt;/code&gt;, because that changes how whitespace and comments work.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-much-reliance-on-modifiers-too-much-reliance-on-modifiers-span&#34;&gt;&lt;span id=&#34;too much reliance on modifiers&#34;&gt;Too much reliance on modifiers&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;/s&lt;/code&gt; modifier in the previous example changes the meaning of the &lt;code&gt;.&lt;/code&gt; metacharacter. We could, in fact, do away with the &lt;code&gt;/s&lt;/code&gt; modifier entirely if we only had two different representations for &amp;ldquo;any character&amp;rdquo;, one of which matched a newline, and one which didn&amp;rsquo;t. A similar argument applies to the &lt;code&gt;/m&lt;/code&gt; modifier. The whole notion of something outside the regex changing the meaning of the regex is just a bit bogus, not because we&amp;rsquo;re afraid of context sensitivity, but because we need to have better control within the regex of what we mean, and in this case the context supplied outside the regex is not precise enough. (Perl 5 has a way to control the inner contexts, but it uses the self-obfuscating &lt;code&gt;(?...)&lt;/code&gt; notation.)&lt;/p&gt;

&lt;p&gt;Modifiers that control how the regex is used as a whole do make some sense outside the regex. But they still have the end-weight problem.&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-many-special-rules-and-boobytraps-too-many-special-rules-and-boobytraps-span&#34;&gt;&lt;span id=&#34;too many special rules and boobytraps&#34;&gt;Too many special rules and boobytraps&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Without knowing the context, you cannot know what the pattern &lt;code&gt;//&lt;/code&gt; will do. It might match a null string, or it might match the previously successful match.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;local&lt;/code&gt; operator behaves differently inside regular expressions than it does outside.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s too easy to write a null pattern accidentally. For instance, the following will never match anything but the null string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /
    | foo
    | bar
    | baz
    /x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Even when it&amp;rsquo;s intentional, it may not look intentional:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (a|b|c|)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s hard to read because it&amp;rsquo;s difficult to make the absence of something visible.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s too easy to confuse the multiple meanings of dot. Or the multiple meanings of &lt;code&gt;^&lt;/code&gt;, and &lt;code&gt;$&lt;/code&gt;. And the opposite of &lt;code&gt;\A&lt;/code&gt; is frequently not &lt;code&gt;\Z&lt;/code&gt;, but &lt;code&gt;\z&lt;/code&gt;. Tell me again, when do I say &lt;code&gt;\1&lt;/code&gt;, and when do I say &lt;code&gt;$1&lt;/code&gt;? Why are they different?&lt;/p&gt;

&lt;h3 id=&#34;span-id-backreferences-not-useful-enough-backreferences-not-useful-enough-span&#34;&gt;&lt;span id=&#34;backreferences not useful enough&#34;&gt;Backreferences not useful enough&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Speaking of &lt;code&gt;\1&lt;/code&gt;, backreferences have a number of shortcomings. The first is actually getting ahold of the right backreference. Since captures are numbered from the beginning, you have to count, and you can easily count wrong. For many purposes it would be better if you could ask for the last capture, or the one before that. Or perhaps if there were a way to restart the numbering part way through&amp;hellip;&lt;/p&gt;

&lt;p&gt;Another major problem with backreferences is that you can&amp;rsquo;t easily modify one to search for a variant. Suppose you match an opening parenthesis, bracket, or curly. You&amp;rsquo;ll like to search for everything up to the corresponding closing parenthesis, bracket, or curly, but there&amp;rsquo;s no way to transmogrify the opening version to the closing version, because the backref search is hardwired independently of ordinary variable matching. And that&amp;rsquo;s because Perl doesn&amp;rsquo;t instantiate &lt;code&gt;$1&lt;/code&gt; soon enough. And that&amp;rsquo;s because Perl relies on variable interpolation to get subexpressions into regexes. Which leads us to&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-hard-to-match-a-literal-string-too-hard-to-match-a-literal-string-span&#34;&gt;&lt;span id=&#34;too hard to match a literal string&#34;&gt;Too hard to match a literal string&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Since regexes undergo an interpolation pass before they&amp;rsquo;re compiled, anything you interpolate is forced to be treated as a regular expression. Often that&amp;rsquo;s not what you want, so we have the klunky &lt;code&gt;\Q$string\E&lt;/code&gt; mechanism to hide regex metacharacters. And that&amp;rsquo;s because&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-twolevel-interpretation-is-problematic-two-level-interpretation-is-problematic-span&#34;&gt;&lt;span id=&#34;twolevel interpretation is problematic&#34;&gt;Two-level interpretation is problematic&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The problem with &lt;code&gt;\Q$string\E&lt;/code&gt; arises because of the fundamental mistake of using interpolation to build regexes instead of letting the regex control how it treats the variables it references. Regexes aren&amp;rsquo;t strings, they&amp;rsquo;re programs. Or, rather, they&amp;rsquo;re strings only in the sense that any piece of program is a string. Just as you have to work to eval a string as a program, you should have to work to eval a string as a regular expression. Most people tend to expect a variable in a regular expression to match its contents literally. Perl violates that expectation. And because it violates that expectation, we can&amp;rsquo;t make &lt;code&gt;$1&lt;/code&gt; synonymous with &lt;code&gt;\1&lt;/code&gt;. And interpolated parentheses throw off the capture count, so you can&amp;rsquo;t easily use interpolation to call subrules, so we invented &lt;code&gt;(??{$var})&lt;/code&gt; to get around that. But then you can&amp;rsquo;t actually get at the parentheses captured by the subrule. The ramifications go on and on.&lt;/p&gt;

&lt;h3 id=&#34;span-id-too-little-abstraction-too-little-abstraction-span&#34;&gt;&lt;span id=&#34;too little abstraction&#34;&gt;Too little abstraction&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Historically, regular expressions were considered a very low-level language, a kind of glorified assembly language for the regex engine. When you&amp;rsquo;re only dealing with ASCII, there is little need for abstraction, since the shortest way to say &lt;code&gt;[a-z]&lt;/code&gt; is just that. With the advent of the eighth bit, we started getting into a little bit of trouble, and POSIX started thinking about names like &lt;code&gt;[:alpha:]&lt;/code&gt; to deal with locale difficulties. But as with the problem of conciseness, the culture was still biased away from naming abstractly anything that could be expressed concretely.&lt;/p&gt;

&lt;p&gt;However, it&amp;rsquo;s almost impossible to write a parser without naming things, because you have to be able to name the separate grammar rules so that the various rules can refer to each other.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s difficult to deal with any subset of Unicode without naming it. These days, if you see &lt;code&gt;[a-z]&lt;/code&gt; in a program, it&amp;rsquo;s probably an outright bug. It&amp;rsquo;s much better to use a named character property so that your program will work right in areas that don&amp;rsquo;t just use ASCII.&lt;/p&gt;

&lt;p&gt;Even where we do allow names, it tends to be awkward because of the cultural bias against it. To call a subrule by name in Perl 5 you have to say this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (??{$rule})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That has 4 or 5 more characters than it ought to. Dearth of abstraction produces bad Huffman coding.&lt;/p&gt;

&lt;h3 id=&#34;span-id-little-support-for-named-captures-little-support-for-named-captures-span&#34;&gt;&lt;span id=&#34;little support for named captures&#34;&gt;Little support for named captures&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Make that &amp;ldquo;no support&amp;rdquo; in Perl, unless you include assignment to a list. This is just a part of the bias against naming things. Instead we are forced to number our capturing parens and count. That works okay for the top-level regular expression, when we can do list assignment or assign &lt;code&gt;$1&lt;/code&gt; to &lt;code&gt;$foo&lt;/code&gt;. But it breaks down as soon as you start trying to use nested regexes. It also breaks down when the capturing parentheses match more than once. Perl handles this currently by returning only the last match. This is slightly better than useless, but not by much.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-difficult-to-use-nested-patterns-difficult-to-use-nested-patterns-span&#34;&gt;&lt;span id=&#34;difficult to use nested patterns&#34;&gt;Difficult to use nested patterns&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;For many of the reasons we&amp;rsquo;ve mentioned, it&amp;rsquo;s difficult to make regexes refer to each other, and even if you do, it&amp;rsquo;s almost impossible to get the nested information back out of them. And there are entire classes of parsing problems that are not solvable without recursive definitions.&lt;/p&gt;

&lt;h3 id=&#34;span-id-little-support-for-grammars-little-support-for-grammars-span&#34;&gt;&lt;span id=&#34;little support for grammars&#34;&gt;Little support for grammars&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Even if it were easier for regexes to refer to other regexes, we&amp;rsquo;d still have the problem that those other regexes aren&amp;rsquo;t organized in any meaningful way. They might be off in variables that come and go at the whim of the surrounding context.&lt;/p&gt;

&lt;p&gt;When we have an organized system of parsing rules, we call it a grammar. One advantage of having a grammar is that you can optimize based on the assumption that the rules maintain their relationship to each other. For instance, if you think of grammar rules as a funny kind of subroutine, you can write an optimizer to inline some of the subrules&amp;ndash;but only if you know the subrule is fixed in the grammar.&lt;/p&gt;

&lt;p&gt;Without support for grammar classes, there&amp;rsquo;s no decent way to think of deriving one grammar from another. And if you can&amp;rsquo;t derive one grammar from another, you can&amp;rsquo;t easily evolve your language to handle new kinds of problems.&lt;/p&gt;

&lt;h3 id=&#34;span-id-inability-to-define-variants-inability-to-define-variants-span&#34;&gt;&lt;span id=&#34;inability to define variants&#34;&gt;Inability to define variants&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If we want to have variant grammars for Perl dialects, then what about regex dialects? Can regexes be extended either at compile time or at run time? Perl 5 has some rudimentary overloading magic for rewriting regex strings, but that&amp;rsquo;s got the same problems as source filters for Perl code; namely that you just get the raw regex source text and have to parse it yourself. Once again the fundamental assumption is that a regex is a funny kind of string, existing only at the behest of the surrounding program.&lt;/p&gt;

&lt;p&gt;Do we think of regexes as a real, living language?&lt;/p&gt;

&lt;h3 id=&#34;span-id-poor-integration-with-rich-languages-poor-integration-with-rich-languages-span&#34;&gt;&lt;span id=&#34;poor integration with rich languages&#34;&gt;Poor integration with rich languages&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s face it, in the culture of computing, regex languages are mostly considered second-class citizens, or worse. &amp;ldquo;Real&amp;rdquo; languages like C and C++ will exploit regexes, but only through a strict policy of apartheid. Regular expressions are our servants or slaves; we tell them what to do, they go and do it, and then they come back to say whether they succeeded or not.&lt;/p&gt;

&lt;p&gt;At the other extreme, we have languages like Prolog or Snobol where the pattern matching is built into the very control structure of the language. These languages don&amp;rsquo;t succeed in the long run because thinking about that kind of control structure is rather difficult in actual fact, and one gets tired of doing it constantly. The path to freedom is not to make everyone a slave.&lt;/p&gt;

&lt;p&gt;However, I would like to think that there is some happy medium between those two extremes. Coming from a C background, Perl has historically treated regexes as servants. True, Perl has treated them as trusted servants, letting them move about in Perl society better than any other C-like language to date. Nevertheless, if we emancipate regexes to serve as co-equal control structures, and if we can rid ourselves of the regexist attitudes that many of us secretly harbor, we&amp;rsquo;ll have a much more productive society than we currently do. We need to empower regexes with a sense of control (structure). It needs to be just as easy for a regex to call Perl code as it is for Perl code to call a regex.&lt;/p&gt;

&lt;h3 id=&#34;span-id-missing-backtracking-controls-missing-backtracking-controls-span&#34;&gt;&lt;span id=&#34;missing backtracking controls&#34;&gt;Missing backtracking controls&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl 5 started to give regexes more control of their own destiny with the &amp;ldquo;grab&amp;rdquo; construct, &lt;code&gt;(?&amp;gt;...)&lt;/code&gt;, which tells the regex engine that when it fails to match the rest of the pattern, it should not backtrack into the innards of the grab, but skip back to before it. That&amp;rsquo;s a useful notion, but there are problems. First, the notation sucks, but you knew that already. Second, it doesn&amp;rsquo;t go far enough. There&amp;rsquo;s no way to backtrack out of just the current grouping. There&amp;rsquo;s no way to backtrack out of just the current rule. Both of these are crucial for giving first-class status to the control flow of regexes.&lt;/p&gt;

&lt;h3 id=&#34;span-id-difficult-to-define-assertions-difficult-to-define-assertions-span&#34;&gt;&lt;span id=&#34;difficult to define assertions&#34;&gt;Difficult to define assertions&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Notionally, a regex is an organization of assertions that either succeed or fail. Some assertions are easily expressed in traditional regex language, while others are more easily expressed in a procedural language like Perl.&lt;/p&gt;

&lt;p&gt;The natural (but wrong) solution is to try to reinvent Perl expressions within regex language. So, for instance, I&amp;rsquo;m rejecting those RFCs that propose special assertion syntax for numerics or booleans. The better solution is to make it easier to embed Perl assertions within regexes.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-brave-new-world-brave-new-world-span&#34;&gt;&lt;span id=&#34;brave new world&#34;&gt;Brave New World&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve just made a ton of negative assertions about the current state of regex culture. Now I&amp;rsquo;d like you to perform a cool mental trick and turn all those negatives assertions into positive assertions about what I&amp;rsquo;m going to say, because I&amp;rsquo;m not intending to give the rationale again, but just present the design as it stands. Damian will discuss an extended example in his Exegesis 5, which will show the big picture of how these various features work together to produce a much more readable whole.&lt;/p&gt;

&lt;p&gt;So anyway, here&amp;rsquo;s what&amp;rsquo;s new.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-metacharacter-reform-metacharacter-reform-span&#34;&gt;&lt;span id=&#34;metacharacter reform&#34;&gt;Metacharacter Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Some things stay the same: &lt;code&gt;(...)&lt;/code&gt; captures text just as it did before, and the quantifiers &lt;code&gt;*&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;?&lt;/code&gt; are also unchanged. The vertical bar &lt;code&gt;|&lt;/code&gt; still separates alternatives. The backslash &lt;code&gt;\&lt;/code&gt; still protects the following character from its ordinary interpretation. The &lt;code&gt;?&lt;/code&gt; suffix character still does minimal matching. (Note that these are by far the most commonly used metacharacters, so many ordinary regexes will look nearly identical in Perl 5 and Perl 6.)&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;/x&lt;/code&gt; extended syntax is now the default, &lt;code&gt;#&lt;/code&gt; is now always a metacharacter indicating a comment, and whitespace is now always &amp;ldquo;meta&amp;rdquo;. Whitespace is now the standard way to separate regex tokens that would otherwise be confused as a single token.&lt;/p&gt;

&lt;p&gt;Even in character classes, whitespace is not taken literally any more. Backwhack the space if you mean it literally, or use &lt;code&gt;&amp;lt;sp&lt;/code&gt;&amp;gt;, or &lt;code&gt;\040&lt;/code&gt;, or &lt;code&gt;\x20&lt;/code&gt;, or &lt;code&gt;\c[SPACE]&lt;/code&gt;. But speaking of character classes&amp;hellip;&lt;/p&gt;

&lt;p&gt;Perhaps the most radical change is that I&amp;rsquo;ve taken &lt;code&gt;[...]&lt;/code&gt; away from character classes and made it the non-capturing grouping operator, because grouping is more fundamental than character classes, and explicit character classes are becoming less common than named character classes. (You can still do character classes, just not with bare square brackets.)&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve also stolen &lt;code&gt;{...}&lt;/code&gt; from generalized quantifiers and made them into closure delimiters. (Use &lt;code&gt;&amp;lt;n,m&amp;gt;&lt;/code&gt; for the generalized quantifier now.)&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve stolen three new metacharacters. The new extensible metasyntax for assertions uses angle brackets, &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;. And the colon &lt;code&gt;:&lt;/code&gt; is now used for declaration and backtracking control. (Recall Larry&amp;rsquo;s 2nd Law of Language Redesign: Larry gets the colon.) The colon always introduces a token that controls the meaning of what is around it. The nature of the token depends on what follows the colon. Both the colon syntax and angle syntax are extensible. (Backslash syntax is also extensible.)&lt;/p&gt;

&lt;p&gt;This may sound like we&amp;rsquo;re complexifying things, but we&amp;rsquo;re really simplifying. We now have the following regex invariants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (...)       # always delimits a capturing group
    [...]       # always delimits a non-capturing group
    {...}       # always delimits a closure
    &amp;lt;...&amp;gt;       # always delimits an assertion
    :...        # always introduces a metasyntactic token
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note that we&amp;rsquo;re using &amp;ldquo;assertion&amp;rdquo; here in the broad sense of anything that either matches or fails, whether or not it has a width.)&lt;/p&gt;

&lt;p&gt;The nature of the angle assertion is controlled by the first character inside it. If the first character is alphabetic, it&amp;rsquo;s a grammatical assertion, and the entire first word controls the meaning. The word is first looked up in the current grammar, if any. If not found there, it is checked to see if it is one of the built-in grammar rules such as those defined by the Unicode property classes. If the first character is not alphabetic, there will be special rules in the current grammar or in the Perl grammar for looking up the parse rule. For instance, by default, any assertion that begins with &lt;code&gt;!&lt;/code&gt; is simply negated. Assertions that start with a digit are assumed to be a range assertion (&lt;code&gt;&amp;lt;n,m&amp;gt;&lt;/code&gt;) regarding the previous atom. (Taking the last two together, you can say &lt;code&gt;&amp;lt;!n,m&amp;gt;&lt;/code&gt; to exclude a range.) Assertions that start with &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, or &lt;code&gt;&amp;amp;&lt;/code&gt; are assumed to interpolate an indirect regex rule stored in a variable or returned by a subroutine. An assertion that starts with a parenthesis is a closure being used as an assertion. An assertion that starts with a square bracket or another angle bracket is a character class. An assertion that starts with a quote asserts the match of a literal string. And so on.&lt;/p&gt;

&lt;p&gt;Some metacharacters are still used but have a slightly different meaning, in part to get rid of the &lt;code&gt;/s&lt;/code&gt; and &lt;code&gt;/m&lt;/code&gt; modifiers, and in part because most strings in Perl 6 will come from the filehandle pre-chomped. So anchors &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; now always mean the &lt;em&gt;real&lt;/em&gt; beginning and ending of the string. Use &lt;code&gt;^^&lt;/code&gt; and &lt;code&gt;$$&lt;/code&gt; to match the beginnings and endings of lines &lt;em&gt;within&lt;/em&gt; a string. (They&amp;rsquo;re doubled because they&amp;rsquo;re &amp;ldquo;fancier&amp;rdquo;, because they can match in multiple places, and because they&amp;rsquo;ll be rarer, so Huffman says they should be longer.) The &lt;code&gt;^^&lt;/code&gt; and &lt;code&gt;$$&lt;/code&gt; also match where &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt; would.&lt;/p&gt;

&lt;p&gt;The dot &lt;code&gt;.&lt;/code&gt; now always matches any character including newline. (Use &lt;code&gt;\N&lt;/code&gt; to match a non-newline. Or better, use an autochomping filehandle, if you&amp;rsquo;re processing line-by-line.)&lt;/p&gt;

&lt;p&gt;In a sense, the sigils &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt;, &lt;code&gt;%&lt;/code&gt;, and &lt;code&gt;&amp;amp;&lt;/code&gt; are different metacharacters because they don&amp;rsquo;t interpolate, but are now subject to the interpretation of the regex engine. This allows us to change the default behavior of ordinary &amp;ldquo;interpolation&amp;rdquo; to a literal match, and also lets us put in lvalue-ish constructs like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $name := (\S+) /
    / @kids := [(\S+) \s+]* /
    / %pets := [(\S+) \: (\S+) \s+]* /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Notice also the delicate interplay of quantified non-capturing brackets with capturing parens, particularly for gathering multiple values or even multiple key/value pairs.)&lt;/p&gt;

&lt;p&gt;Here are some of the metacharacter differences in table form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                   New
    ---                   ---
    /pat pat #text        /pat pat #text
        pat/x                 pat/              # Look Ma, no /x!
    /patpat(?#text)/       /pat pat &amp;lt;(&#39;text&#39;)&amp;gt;/ # can always use whitespace

    /pat pat/             / pat\ pat /          # match whitespace literally
                          / pat \s* pat /       # or generically
                          / pat \h* pat /       # or horizontally
                          / pat &amp;lt;&#39; &#39;&amp;gt; pat /     # or as a literal string
                          / pat &amp;lt;sp&amp;gt; pat /      # or by explicit rule
                          /:w pat pat/          # or by implicit rule

    /^pat$/               /^pat\n?$/            # ^ and $ mean string
    /^pat$/m              /^^pat$$/             # no more /m
    /\A...(^pat$)*...\z/m /^...(^^pat$$)*...$/  # no more \A or \z
    /.*\n/                /\N*\n/               # \N is negated \n
                          /.*?\n/               # this still works
    /.*/s                 /.*/                  # . always matches &amp;quot;any&amp;quot;

    \Q$string\E           $string               # interpret literally

    (?{ code })           { code }              # call code, ignore return
                          { code or fail }      # use code as an assertion

    (??{$rule})           &amp;lt;$var&amp;gt;                # call $var as regex
                          &amp;lt;name&amp;gt;                # call rule from current grammar
                          &amp;lt;Other::rule&amp;gt;         # call rule from some Other grammar
                          &amp;lt;*rule&amp;gt;               # bypass local rule to call built-in
                          &amp;lt;@array&amp;gt;              # call array of alternate rules
                          &amp;lt;%hash&amp;gt;               # parse keyword as key to rule
                          &amp;lt;@array[1]&amp;gt;           # call a rule from an array
                          &amp;lt;%hash{&amp;quot;x&amp;quot;}&amp;gt;          # call a rule from a hash
                          &amp;lt;&amp;amp;sub(1,2,3)&amp;gt;         # call a rule returned by a sub
                          &amp;lt;{ code }&amp;gt;            # call return value as anonymous rule
                          &amp;lt;( code )&amp;gt;            # call code as boolean assertion

                          &amp;lt;name(expr)&amp;gt;          # call rule, passing Perl args
                          { .name(expr) }       # same thing.

                          &amp;lt;$var(expr)&amp;gt;          # call rule indirectly by name
                          { .$var(expr) }       # same thing.

                          &amp;lt;name pat&amp;gt;            # call rule, passing regex arg
                          { .name(/pat/) }      # same thing.

                          # maybe...
                          &amp;lt;name: text&amp;gt;          # call rule, passing string
                          { .name(q&amp;lt;text&amp;gt;) }    # same thing.

    [\040\t\p{Zs}]        \h                    # horizontal whitespace
    [\r\n\ck\p{Zl}\p{Zp}] \v                    # vertical whitespace
    [a-z]                 &amp;lt;[a-z]&amp;gt;               # equivalently non-international
                          &amp;lt;alpha&amp;gt;               # more international
    [[:alpha:][:digit:]   &amp;lt;&amp;lt;alpha&amp;gt;&amp;lt;digit&amp;gt;&amp;gt;      # POSIX classes are built-in rules

    {n,m}                 &amp;lt;n,m&amp;gt;                 # assert repeat count
    {$n,$m}               &amp;lt;$n,$m&amp;gt;               # indirect repeat counts

    (?&amp;gt;.*)                [.*]:                 # don&#39;t backtrack through [.*]
                          .*:                   # brackets not necessary on atom
                          (.*):                 # same, but capture
                          &amp;lt;xyz&amp;gt;:                # don&#39;t backtrack into subrule

                          :                     # skip previous atom when backtracking
                          ::                    # fail all |&#39;s when backtracking
                          :::                   # fail current rule when backtracking

                          :=                    # bind a name to following atom
    my ($x) = /(.*)/      my $x; / $x:=(.*) /   # may now bind it inside regex

    (?i)                  :i                    # ignore case in the following
                          :ignorecase           # same thing, self-documenting form
    (?i:...)              [:i ...]              # can limit scope without capture
                          (:i ...)              # can limit scope with capture
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Declarations like &lt;code&gt;:i&lt;/code&gt; are lexically scoped and do not pass to any subrules. Each rule maintains its own sensitivity. There is no built-in operator to turn case ignorance back off&amp;ndash;just call a different rule and it&amp;rsquo;s automatically case sensitive again. (If you want a parameterized subrule, that can be arranged. It&amp;rsquo;s just a method, after all. Proof of this assertion is left to future generations of hackers.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-backslash-reform-backslash-reform-span&#34;&gt;&lt;span id=&#34;backslash reform&#34;&gt;Backslash Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are some changes to backslash sequences. Character properties &lt;code&gt;\p&lt;/code&gt; and &lt;code&gt;\P&lt;/code&gt; are no longer needed&amp;ndash;predefined character classes are just considered intrinsic grammar rules. (You can negate any &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; assertion by using &lt;code&gt;&amp;lt;!...&amp;gt;&lt;/code&gt; instead.) As mentioned in a previous Apocalypse, the &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt;, and &lt;code&gt;\Q&lt;/code&gt; sequences no longer use &lt;code&gt;\E&lt;/code&gt; to terminate&amp;ndash;they now require bracketing characters of some sort. And &lt;code&gt;\Q&lt;/code&gt; will rarely be needed due to regex policy changes. In fact, they may all go away since it&amp;rsquo;s easy to say things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $(lc $foo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For any bracketing construct, square brackets are preferred, but others are allowed:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    \x[...]     # preferred, indicates simple bracketing
    \x(...)     # okay, but doesn&#39;t capture.
    \x{...}     # okay, but isn&#39;t a closure.
    \x&amp;lt;...&amp;gt;     # okay, but isn&#39;t an assertion
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;\c&lt;/code&gt; sequence is now a bracketing construct, having been extended from representing control characters to any named character.&lt;/p&gt;

&lt;p&gt;Backreferences such as &lt;code&gt;\1&lt;/code&gt; are gone in favor of the corresponding variable &lt;code&gt;$1&lt;/code&gt;. &lt;code&gt;\A&lt;/code&gt;, &lt;code&gt;\Z&lt;/code&gt;, and &lt;code&gt;\z&lt;/code&gt; are gone with the disappearance of &lt;code&gt;/s&lt;/code&gt; and &lt;code&gt;/m&lt;/code&gt;. The position assertion &lt;code&gt;\G&lt;/code&gt; is gone in favor of a &lt;code&gt;:c&lt;/code&gt; modifier that forces continuation from where the last match left off. That&amp;rsquo;s because &lt;code&gt;\G&lt;/code&gt; was almost never used except at the front of a regex. In the unlikely event that you want to assert that you&amp;rsquo;re at the old final position elsewhere in your regex, you can always test the current position (via the &lt;code&gt;.pos&lt;/code&gt; method) with an assertion:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $oldpos = pos $string;
    $string =~ m/... &amp;lt;( .pos == $oldpos )&amp;gt; .../;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may be thinking of &lt;code&gt;.pos&lt;/code&gt; as the final position of the previous match, but that&amp;rsquo;s not what it is. It&amp;rsquo;s the &lt;em&gt;current&lt;/em&gt; position of the current match. It&amp;rsquo;s just that, between matches, the current position of the current match happens to be the same as the final position of the current match, which happens to be the last match, which happens to be done. But as soon as you start another match, the last match is no longer the current match.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;:c&lt;/code&gt; continuation is needed only on constructs that ordinarily force the search to start from the beginning. Subrules automatically continue at the current location, since their initial position is controlled by some other rule.&lt;/p&gt;

&lt;p&gt;There are two new backslash sequences, &lt;code&gt;\h&lt;/code&gt; and &lt;code&gt;\v&lt;/code&gt;, which match horizontal and vertical whitespace respectively, including Unicode spacing characters and control codes. Note that &lt;code&gt;\r&lt;/code&gt; is considered vertical even though it theoretically moves the carriage sideways. Finally, &lt;code&gt;\n&lt;/code&gt; matches a logical newline, which is not necessarily a linefeed character on all architectures. After all, that&amp;rsquo;s why it&amp;rsquo;s an &amp;ldquo;n&amp;rdquo;, not an &amp;ldquo;l&amp;rdquo;. Your program should not break just because you happened to run it on a file from a partition mounted from a Windows machine. (Within an interpolated string, &lt;code&gt;\n&lt;/code&gt; still produces whatever is the normal newline for the current architecture.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    \x0a                \x0a                    # same
    \x{263a}            \x263a                  # brackets required only if ambiguous
    \x{263a}abc         \x[263a]abc             # brackets required only if ambiguous
    \0123               \0123                   # same (no ambiguity with $123 now)
    \0123               \0[123]                 # can use brackets here too

    \p{prop}            &amp;lt;prop&amp;gt;                  # properties are just grammar rules
    \P{prop}            &amp;lt;!prop&amp;gt;

    [\040\t\p{Zs}]      \h                      # horizontal whitespace
    space               \h                      # not exact, but often more correct
    [\r\n\ck\p{Zl}\p{Zp}] \v                    # vertical whitespace

    \Qstring\E          \q[string]
                        &amp;lt;&#39;string with spaces&#39;&amp;gt;  # match literal string
                        &amp;lt;&#39; &#39;&amp;gt;                   # match literal space

    \E                  gone                    # use \Q[...] instead

    \A                  ^                       # ^ now invariant
    \a                  \c[BEL]                 # alarm (bell)

    \Z                  \n?$                    # clearer
    \z                  $                       # $ now invariant
    \G                  &amp;lt;( .pos == $oldpos )&amp;gt;   # match at particular position
                                                # typically just use m:c/pat/

    \N{CENT SIGN}       \c[CENT SIGN]           # named character
    \c[                 \e                      # escape
    \cX                 \c[^X]                  # control char
    \n                  \c[LF]                  # specifically a linefeed
    \x0a\x0d            \x[0a;0d]               # CRLF
    \x0a\x0d            \c[CR;LF]               # CRLF (conjectural)
    \C                  [:u0 .]                 # forced byte in utf8 (dangerous)
    [^\N[CENT SIGN]]    \C[CENT SIGN]           # match any char but CENT SIGN

    \Q$var\E            $var                    # always assumed literal,
    \1                  $1                      # so $1 is literal backref
    /$1/                my $old1 = $1; /$old1/  # must use temporary here

    \r?\n               \n                      # \n asserts logical newline

    [^\n]               \N                      # not a logical newline
                        \C[LF]                  # not a linefeed

    [^\t]               \T                      # not a tab (these are conjectural)
    [^\r]               \R                      # not a return
    [^\f]               \F                      # not a form feed
    [^\e]               \E                      # not an escape
    [^\x1B]             \X1B                    # not specified hex char
    [^\x{263a}]         \X[263a]                # not a Unicode SMILEY

    \X                  &amp;lt;.&amp;gt;                     # a grapheme (combining char seq)
                        [:u2 .]                 # At level 2+, dot means grapheme
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Under level 2 Unicode support, a character is assumed to mean a grapheme, that is, a sequence consisting of a base character followed by 0 or more combining characters. That not only affects the meaning of the &lt;code&gt;.&lt;/code&gt; character, but also any negated character, since a negated character is really a negative lookahead assertion followed by the traversal of a single character. For instance, &lt;code&gt;\N&lt;/code&gt; really means:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [&amp;lt;!before \n&amp;gt; . ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it doesn&amp;rsquo;t really matter how many characters &lt;code&gt;\n&lt;/code&gt; actually matches. &lt;code&gt;\N&lt;/code&gt; always matches a single character&amp;ndash;whatever that is&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-modifier-reform-modifier-reform-span&#34;&gt;&lt;span id=&#34;modifier reform&#34;&gt;Modifier Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You can&amp;rsquo;t use colon for a regex delimiter any more. That&amp;rsquo;s because regex modifiers may now be placed in front of a regex construct:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:w:i:e /foo/bar/           # :words :ignorecase :each
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That can also be written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s/:w:i:e foo/bar/           # :words :ignorecase :each
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Single character modifiers may be bundled like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:wie /foo/bar/             # :words :ignorecase :each
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;but only if the sequence as a whole is not already defined as a long modifier, since ambiguity will be resolved in favor of the long modifier. Long modifiers may &lt;em&gt;not&lt;/em&gt; be bundled with any other modifier. So this is legal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:once:wie /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but not these (unless you&amp;rsquo;ve defined them):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:wieonce /foo/bar/
    s:oncewie /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Not only is colon disallowed as a regex delimiter, but you may no longer use parentheses as the delimiters either. This will allow us to parameterize modifiers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:myoption($x) /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This rule also allows us to differentiate &lt;code&gt;s///&lt;/code&gt; from an &lt;code&gt;s()&lt;/code&gt; function, &lt;code&gt;tr///&lt;/code&gt; from &lt;code&gt;tr()&lt;/code&gt;, etc. If you want matching brackets for the delimiters I&amp;rsquo;d suggest that you use square brackets, since they now mean grouping without capturing.&lt;/p&gt;

&lt;p&gt;Several modifiers, &lt;code&gt;/x&lt;/code&gt;, &lt;code&gt;/s&lt;/code&gt;, and &lt;code&gt;/m&lt;/code&gt;, are no longer needed and have been retired. It&amp;rsquo;s unclear whether &lt;code&gt;/o&lt;/code&gt; is necessary any more. We will assume it&amp;rsquo;s gone unless it&amp;rsquo;s shown that caching can&amp;rsquo;t handle the problem. Note that the regex now has more control over when to cache subrules because it is no longer subject to the vagaries of standard interpolation.&lt;/p&gt;

&lt;p&gt;The old &lt;code&gt;/c&lt;/code&gt; modifier is gone because regexes never reset the position on failure any more. To do that, set &lt;code&gt;$string.pos = 0&lt;/code&gt; explicitly. But note also that assigning to a string automatically resets its position to &lt;code&gt;0&lt;/code&gt;, so any string in your typical loop is going to start with its current search position already set &lt;code&gt;0&lt;/code&gt;. Modifying a string in place causes the position to move to the end of the replacement section by default, if the position was within the span replaced. (This is consistent with &lt;code&gt;s///&lt;/code&gt; semantics.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;/e&lt;/code&gt; modifier is also gone, since it did reverse parsing magic, and &lt;code&gt;:e&lt;/code&gt; will be short for &lt;code&gt;:each&lt;/code&gt;&amp;ndash;see below. It&amp;rsquo;s still easy to substitute the value of an expression though:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s/pat/$( code )/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or even&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s(/pat/, { code });
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s a new modifier, &lt;code&gt;:once&lt;/code&gt;, that causes a match to succeed only once (like the old &lt;code&gt;?...?&lt;/code&gt; construct). To reset it, use the &lt;code&gt;.reset&lt;/code&gt; method on the regex object. (If you haven&amp;rsquo;t named the regex object, too bad&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Another new modifier is &lt;code&gt;:w&lt;/code&gt;, which causes an implicit match of whitespace wherever there&amp;rsquo;s literal whitespace in a pattern. In other words, it replaces every sequence of actual whitespace in the pattern with a &lt;code&gt;\s+&lt;/code&gt; (between two identifiers) or a &lt;code&gt;\s*&lt;/code&gt; (between anything else). So&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:w/ foo bar \: ( baz )*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;really means (expressed in Perl 5 form):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:p5/\s*foo\s+bar\s*:(\s*baz\s*)*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can still control the handling of whitespace under &lt;code&gt;:w&lt;/code&gt;, since we extend the rule to say that any explicit whitespace-matching token can&amp;rsquo;t match whitespace implicitly on either side. So:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:w/ foo\ bar \h* \: (baz)*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;really means (expressed in Perl 5 form):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:p5/\s*foo bar[\040\t\p{Zs}]*:\s*(baz)*/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first space in&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /[:w foo bar]/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;matches &lt;code&gt;\s*&lt;/code&gt; before &amp;ldquo;&lt;code&gt;foo&lt;/code&gt;&amp;rdquo;. That&amp;rsquo;s usually what you want, but if it&amp;rsquo;s not what you want, you have a little problem. Unfortunately you can&amp;rsquo;t just say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /[:wfoo bar]/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That won&amp;rsquo;t work because it&amp;rsquo;ll look for the &lt;code&gt;:wfoo&lt;/code&gt; modifier. However, there are several ways to get the effect you want:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /[:w()foo bar]/ 
    /[:w[]foo bar]/ 
    /[:w\bfoo bar]/ 
    /[:w::foo bar]/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That last one is just our friend the &lt;code&gt;::&lt;/code&gt; operator in disguise. If you backtrack into it, you&amp;rsquo;re leaving the brackets anyway, so it&amp;rsquo;s essentially a no-op.&lt;/p&gt;

&lt;p&gt;The new &lt;code&gt;:c&lt;/code&gt;/&lt;code&gt;:cont&lt;/code&gt; modifier forces the regex to continue at the current &amp;ldquo;pos&amp;rdquo; of the string. It may only be used outside the regex. (Well, it could be used inside but it&amp;rsquo;d be redundant.) The modifier also forces the regex to match only the next available thing. That&amp;rsquo;s not quite the same as the &lt;code&gt;^&lt;/code&gt; anchor, though, because it not only disables the implicit scanning done by &lt;code&gt;m//&lt;/code&gt; and &lt;code&gt;s///&lt;/code&gt;, but it also works on more than the first iteration. It forces all matches to be contiguous, in other words. So &lt;code&gt;:c&lt;/code&gt; is short for both &amp;ldquo;continue&amp;rdquo; and &amp;ldquo;contiguous&amp;rdquo;. If you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $_ = &amp;quot;foofoofoo foofoofoo&amp;quot;;
    s:each:cont/foo/FOO/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    FOOFOOFOO foofoofoo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This may seem odd, but it&amp;rsquo;s precisely the semantics of any embedded regex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $_ = &amp;quot;foofoofoo foofoofoo&amp;quot;;
    $rx = rx/foo/;
    m/&amp;lt;$rx&amp;gt;*/;          # matches &amp;quot;foofoofoo&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A modifier that starts with a number causes the pattern to match that many times. It may only be used outside the regex. It may not be bundled, because ordinals are distinguished from cardinals. That is, how it treats those multiple matches depends on the next character. If you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:3x /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then it changes the first 3 instances. But if you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:3rd /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it changes only the 3rd instance. You can say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:1st /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but that&amp;rsquo;s just the default, and should not be construed as equivalent to &lt;code&gt;:once&lt;/code&gt;, which matches only once, ever. (Unless you &lt;code&gt;.reset&lt;/code&gt; it, of course.)&lt;/p&gt;

&lt;p&gt;You can combine cardinals and ordinals:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:3x:3rd /foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That changes the 3rd, 6th, and 9th occurrences. To change every other quote character, say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:each:2nd /&amp;quot;/\&amp;amp;rquot;/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;:each&lt;/code&gt; is synonymous with &lt;code&gt;:3x&lt;/code&gt; (for large values of &lt;code&gt;3&lt;/code&gt;). Note that &lt;code&gt;:each&lt;/code&gt; does not, in fact, generate every possible match, because it disallows overlaps. To get every possible match, use the &lt;code&gt;:any&lt;/code&gt; modifier. Saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $_ = &amp;quot;abracadabra&amp;quot;;
    @all = m:any /a[^a]+a/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    abra aca ada abra
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It can even match multiple times at the same spot as long as the rest of the regex progresses somehow. Saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @all = m:any /a.*?a/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;produces:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    abra abraca abracada abracadabra aca acada acadabra ada adabra abra
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $sentence.m:any /^ &amp;lt;english&amp;gt; $/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;ll get every possible parsing of the sentence according to the rules of &lt;code&gt;english&lt;/code&gt; (not to be confused with the rules of English, which are already confusing enough, except when they aren&amp;rsquo;t).&lt;/p&gt;

&lt;p&gt;To indicate varying levels of Unicode support we have these modifiers, which may be used either inside or outside a regex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    :u0         # use bytes       (. is byte)
    :u1         # level 1 support (. is codepoint)
    :u2         # level 1 support (. is grapheme)
    :u3         # level 1 support (. is language dependent)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These modifiers say nothing about the state of the data, but in general internal Perl data will already be in Normalization Form C, so even under &lt;code&gt;:u1&lt;/code&gt;, the precomposed characters will usually do the right thing. Note that these modifiers are for overriding the default support level, which was probably set by pragma at the top of the file.&lt;/p&gt;

&lt;p&gt;Finally, there&amp;rsquo;s the &lt;code&gt;:p5&lt;/code&gt; modifier, which causes the rest of the regex (or group) to be parsed as a Perl 5 regular expression, including any interpolated strings. (But it still doesn&amp;rsquo;t enable Perl 5&amp;rsquo;s trailing modifiers.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    ?pat?               m:once/pat/             # match once only
    /pat/i              m:i/pat/                # ignorecase
                        /:i pat/                # ignorecase
    /pat/x              /pat/                   # always extended
    /pat\s*pat/         /:w pat pat/            # match word sequence
    /(?i)$p5pat/        m:p5/(?i)$p5pat/        # use Perl 5 syntax
    $n = () = /.../g    $n = +/.../;            # count occurrences
    for $i (1..3){s///} s:3///;                 # do 3 times
    /^pat$/m            /^^pat$$/               # no more /m
    /./s                /./                     # no more /s
    /./                 /\N/                    # . now works like /s
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-keyword-and-context-reform-keyword-and-context-reform-span&#34;&gt;&lt;span id=&#34;keyword and context reform&#34;&gt;Keyword and Context Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Deferred regex rules are now defined with &lt;code&gt;rx//&lt;/code&gt; rather than &lt;code&gt;qr//&lt;/code&gt;, because a regular expression is no longer a kind of quoted string.&lt;/p&gt;

&lt;p&gt;Actually, just as you can define closures without an explicit &lt;code&gt;sub&lt;/code&gt;, any &lt;code&gt;//&lt;/code&gt; or &lt;code&gt;rx//&lt;/code&gt; declares a deferred regex if it&amp;rsquo;s not in a context that executes it immediately. A regex is executed automatically if it&amp;rsquo;s in a boolean, numeric, or string context. But assignment to an untyped variable is not such a context, nor is passing the regex as an untyped parameter to a function. (Of course, an explicitly declared RULE parameter doesn&amp;rsquo;t provide an evaluating context either.)&lt;/p&gt;

&lt;p&gt;So these are equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $foo = /.../;            # create regex object
    my $foo = rx[...];          # create regex object
    my $foo = rule {...};       # create regex object
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, these are equivalent:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @x = split /.../;
    @x = split rx[...];
    @x = split rule {...};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;rule&amp;rdquo; syntax is just a way of declaring a deferred regex as if it were a subroutine or method. More on that later.&lt;/p&gt;

&lt;p&gt;To force an immediate evaluation of a deferred regex where it wouldn&amp;rsquo;t ordinarily be, you can use the appropriate unary operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $foo = ?/.../;   # boolean context, return whether matched, 
    my $foo = +/.../;   # numeric context, return count of matches
    my $foo = _/.../;   # string context, return captured/matched string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The standard match and substitution forms also force immediate evaluation regardless of context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $result = m/.../;           # do match on topic string
    $result = s/.../.../;       # do substitution on topic string
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These forms also force the regex to start matching at the beginning of the string in question and scan forward through the string for the match, as if there were an implicit &lt;code&gt;.*?&lt;/code&gt; in front of every iteration. (Both of these behaviors are suppressed if you use the &lt;code&gt;:c&lt;/code&gt;/&lt;code&gt;:cont&lt;/code&gt; modifier). In contrast, the meaning of the deferred forms is dependent on context. In particular, a deferred regex naturally assumes &lt;code&gt;:c&lt;/code&gt; when used as a subrule. That is, it continues where the last match left off, and the next thing has to match right there at the head of the string.&lt;/p&gt;

&lt;p&gt;In any other context, including list context, a deferred regex is &lt;em&gt;not&lt;/em&gt; immediately evaluated, but produces a reference to the regex object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $rx = /.../;     # not evaluated
    my @foo = $rx;      # ERROR: type mismatch.
    my @foo = ($rx);    # One element, a regex object.
    my @foo = (/.../);  # Same thing.
    my @foo := $rx;     # Set autogrow rule for @foo.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To evaluate repeatedly in list context, treat the regex object as you would any other iterator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @foo = &amp;lt;$rx&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use the more explicit form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @foo = m/&amp;lt;$rx&amp;gt;/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Those aren&amp;rsquo;t identical, since the former assumes &lt;code&gt;:c&lt;/code&gt; and starts up at the current position of the unmentioned topic, while the latter explicitly resets the position to the beginning before scanning. Also, since the deferred regex assumes a &lt;code&gt;:c&lt;/code&gt; modifier, &lt;code&gt;&amp;lt;$rx&amp;gt;&lt;/code&gt; won&amp;rsquo;t scan through the string like &lt;code&gt;m//&lt;/code&gt;. It can return multiple values to the list, but they have to be contiguous. You can get the scanning effect of &lt;code&gt;m//&lt;/code&gt; by prepending the pattern with &lt;code&gt;.*?&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But it&amp;rsquo;s vitally important to understand this fundamental change, that &lt;code&gt;//&lt;/code&gt; is no longer a short form of &lt;code&gt;m//&lt;/code&gt;, but rather a short form of &lt;code&gt;rx//&lt;/code&gt;. If you want to add modifiers to a &lt;code&gt;//&lt;/code&gt;, you have to turn it into an &lt;code&gt;rx//&lt;/code&gt;, not an &lt;code&gt;m//&lt;/code&gt;. It&amp;rsquo;s now &lt;em&gt;wrong&lt;/em&gt; to call &lt;code&gt;split&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    split m/.../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(That is, it&amp;rsquo;s wrong unless you actually want the return value of the pattern match to be used as the literal split delimiter.)&lt;/p&gt;

&lt;p&gt;The old &lt;code&gt;?...?&lt;/code&gt; syntax is gone. Indeed, it has to go for us to get the unary &lt;code&gt;?&lt;/code&gt; operator.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    ?pat?               m:once/pat/
    qr//                rx//
                        rule { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-null-string-reform-null-string-reform-span&#34;&gt;&lt;span id=&#34;null string reform&#34;&gt;Null String Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The null pattern is now illegal. To match whatever you used to match with a null pattern, use one of these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    //                  /&amp;lt;prior&amp;gt;/       # match what prior match did
    //                  /&amp;lt;null&amp;gt;/        # match the null string between chars
    (a|b|)              (a|b|&amp;lt;null&amp;gt;)    # match a null alternative
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, as an assertion, &amp;lt;null&amp;gt; always succeeds. You never want to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;null&amp;gt; | single | double | triple | home run /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;because you&amp;rsquo;ll never get to first base.&lt;/p&gt;

&lt;h3 id=&#34;span-id-extension-syntax-reform-extension-syntax-reform-span&#34;&gt;&lt;span id=&#34;extension syntax reform&#34;&gt;Extension Syntax Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are no longer any &lt;code&gt;(?...)&lt;/code&gt; sequences, because parens now always capture. Some of the replacement sequences take their intrinsic scoping from &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;, while others are associated with other bracketing characters, or with any arbitrary atom that could be a bracketed construct. Looking at the metasyntax problem from the perspective of a Perl5-to-Perl6 translator, here&amp;rsquo;s what the various Perl 5 extension constructs translate to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    (??{$rule})         &amp;lt;$rule&amp;gt;         # call regex in variable
    (?{ code })         { code }        # call Perl code, ignore result
    (?#...)             &amp;lt;(&#39;...&#39;)&amp;gt;       # in-line comment, rarely needed
    (?:...)             [...]           # non-capturing brackets
    (?=...)             &amp;lt;before ...&amp;gt;    # positive lookahead
    (?!...)             &amp;lt;!before ...&amp;gt;   # negative lookahead
    (?&amp;lt;=...)            &amp;lt;after ...&amp;gt;     # positive lookbehind
    (?&amp;lt;!...)            &amp;lt;!after ...&amp;gt;    # negative lookbehind
    (?&amp;gt;...)             [...]:          # grab (any atom)

    (?(cond)yes|no)     [ cond :: yes | no ]
    (?(1)yes|no)        [ &amp;lt;(defined $1)&amp;gt; :: yes | no ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;$rule&amp;gt;&lt;/code&gt; construct does a &amp;ldquo;delayed&amp;rdquo; call of another regular expression stored in the &lt;code&gt;$rule&lt;/code&gt; variable. If it is a regex object, it&amp;rsquo;s just called as if it were a subroutine, so there&amp;rsquo;s no performance problem. If it&amp;rsquo;s a string, it is compiled as a regex and executed. The compiled form is cached as a property of the string, so it doesn&amp;rsquo;t have to be recompiled unless the string changes. (This implies that we can have properties that invalidate themselves when their base object is modified.) In either case, the evaluated regex is treated as a subrule, and any captures it does are invisible to the outer regex unless the outer regex takes steps to retrieve them. In any event, subrule parens never change the paren count of the outer rule.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;{code}&lt;/code&gt; form doesn&amp;rsquo;t return anything meaningful&amp;ndash;it is used for its side effects. Any such closure may behave as an assertion. It merely has to throw an exception in order to fail. To throw such an exception (on purpose) one may use &lt;code&gt;fail&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $_ = &amp;quot;666&amp;quot;;
    / (\d+) { $1 &amp;lt; 582 or fail }/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with any assertion, the failing closure starts backtracking at the location of the closure. In this case, it backtracks into the &lt;code&gt;\d+&lt;/code&gt; and ends up matching &amp;ldquo;&lt;code&gt;66&lt;/code&gt;&amp;rdquo; rather than &amp;ldquo;&lt;code&gt;666&lt;/code&gt;&amp;rdquo;. If you didn&amp;rsquo;t want that, use &lt;code&gt;\d+:&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s more succinct, however, to use the code assertion syntax. Just put angles around a parenthesized Perl expression:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\d+) &amp;lt;( $1 &amp;lt; 582 )&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I find the parens to be vaguely reminiscent of the parentheses you have to put around conditionals in C (but not Perl (anymore)). Also, the parentheses are meant to remind you that you only want to put an expression there, not a full statement.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t use a bare closure to try to interpolate a calculated regex, since the result will be ignored. Instead, use the &lt;code&gt;&amp;lt;{expr}&amp;gt;&lt;/code&gt; form to do that. As with &lt;code&gt;&amp;lt;&amp;amp;rule()&amp;gt;&lt;/code&gt;, the result will be interpreted as a subrule, not as if it were interpolated.&lt;/p&gt;

&lt;p&gt;Since a string is usually true, you can just assert it to get the effect of an inline comment: &lt;code&gt;&amp;lt;(&amp;quot;this is a comment&amp;quot;)&amp;gt;&lt;/code&gt;. But I&amp;rsquo;ve never used one except to show it as an example. Line ending comments are usually much clearer. (Just bear in mind you can&amp;rsquo;t put the final regex delimiter on the same line, because it won&amp;rsquo;t be seen in the comment.) You could also use the &lt;code&gt;{&#39;...&#39;}&lt;/code&gt; construct for comments, but then you risk warnings about &amp;ldquo;useless use of a string in void context&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;[...]&lt;/code&gt; is the new non-capturing bracket notation. It seems to work very well for this purpose&amp;ndash;I tried the other brackets and they tend to &amp;ldquo;disappear&amp;rdquo; faster than square brackets. So we reserve &lt;code&gt;(...)&lt;/code&gt; and &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; for constructs where the visual distance between opening and closing is typically shorter than for square brackets or curlies. The square brackets also work nicely when lined up vertically with vertical bars. Here&amp;rsquo;s a declaration of a named rule from the class Perl6Grammar. It parses Perl 6 statements. (Think of it as a funny looking method declaration.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule state  { &amp;lt;label&amp;gt;
                    [ &amp;lt;control&amp;gt;          {.control}
                    | &amp;lt;sideff&amp;gt; &amp;lt;eostate&amp;gt; {.sideff}
                    | &amp;lt;@other_statements&amp;gt;
                    ]
                };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Huffman coding says that rarer forms should be longer, and that&amp;rsquo;s the case with the lookahead and lookbehind assertions, &lt;code&gt;&amp;lt;before ...&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;after ...&amp;gt;&lt;/code&gt;. (The negations are formed via the general &lt;code&gt;&amp;lt;!...&amp;gt;&lt;/code&gt; rule.) Note that these prepositions are interpreted as assertions, not operations. For example, &lt;code&gt;&amp;lt;before X&amp;gt;&lt;/code&gt; is to be read &amp;ldquo;Assert that we are before X&amp;rdquo; rather than &amp;ldquo;Look before where we are for X&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The new &lt;code&gt;:&lt;/code&gt; operator replaces the &lt;code&gt;(?&amp;gt;...)&lt;/code&gt; construct. It modifies whatever comes before it, much like &lt;code&gt;*&lt;/code&gt; does, so it&amp;rsquo;s naturally scoped if the preceding atom (or quantified atom) is a bracketed construct. Parsers can use this every time they commit to the parsing of a token or phrase to tell the regex engine that there&amp;rsquo;s no point in backtracking through the atom in question, so backtracking will skip backwards over the atom and continue with some earlier branch point. The following takes a long time to fail if it has to look at every sequence of &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; to see if there is a &amp;ldquo;&lt;code&gt;b&lt;/code&gt;&amp;rdquo; after it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaac&amp;quot; =~ /^ a* b /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But we already know that the only possible match is the longest one. So if you put in the colon, it fails in one pass because the &lt;code&gt;*&lt;/code&gt; grabs everything and gives nothing back on backtracking.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;aaaaaaaaaaaaaaaaaaaaaaaaaaaaac&amp;quot; =~ /^ a*: b /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use colon on a longer sequence too. The following might match a list of expressions separated by comma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;expr&amp;gt; [ , &amp;lt;expr&amp;gt; ]*: /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is an error to use &lt;code&gt;:&lt;/code&gt; on any atom that does no backtracking. This will help to catch errors where you&amp;rsquo;ve forgotten to backslash a literal colon in things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /^From: (.*)/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl 6 has no need for a special conditional construct like Perl 5&amp;rsquo;s &lt;code&gt;(?(cond)yes|no)&lt;/code&gt;. That&amp;rsquo;s because with a slight tweak, ordinary alternation can do the same thing. That tweak is our next backtracking modifier, the &lt;code&gt;::&lt;/code&gt; operator. If you backtrack across it, it fails all the way out of the current list of alternatives. Consider an ordinary list of alternatives:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [ &amp;lt;A&amp;gt; &amp;lt;X&amp;gt; | &amp;lt;B&amp;gt; &amp;lt;Y&amp;gt; | &amp;lt;C&amp;gt; &amp;lt;Z&amp;gt; ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The way the rules of backtracking work, if either &lt;code&gt;&amp;lt;A&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;X&amp;gt;&lt;/code&gt; fail, it backtracks to the next alternative. Likewise for &lt;code&gt;&amp;lt;B&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;Y&amp;gt;&lt;/code&gt;. In the case of &lt;code&gt;&amp;lt;C&amp;gt;&lt;/code&gt; or &lt;code&gt;&amp;lt;Z&amp;gt;&lt;/code&gt;, there is no next alternative, so it naturally fails out of the entire construct. That&amp;rsquo;s not how a conditional is supposed to work, because in the conditional, only the condition determines which case is executed. Once you&amp;rsquo;ve committed to a particular case, it has to stand or fall as if the conditional hadn&amp;rsquo;t been there. So all we need for our purposes is to have is something that separates the assertions that matter from those that don&amp;rsquo;t. That&amp;rsquo;s what &lt;code&gt;::&lt;/code&gt; does, and it reads rather well as a &amp;ldquo;then&amp;rdquo;, or as a &amp;ldquo;corresponds to&amp;rdquo;. If you write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [ &amp;lt;A&amp;gt; :: &amp;lt;X&amp;gt;
    | &amp;lt;B&amp;gt; :: &amp;lt;Y&amp;gt;
    | &amp;lt;C&amp;gt; :: &amp;lt;Z&amp;gt;
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the failure of &lt;code&gt;&amp;lt;A&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;B&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;C&amp;gt;&lt;/code&gt; proceeds to the next case (if any), while any failure in &lt;code&gt;&amp;lt;X&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Y&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;Z&amp;gt;&lt;/code&gt; is guaranteed to backtrack out of the front of the alternative list and revise a former choice (just as the success of &lt;code&gt;&amp;lt;X&amp;gt;&lt;/code&gt;, &lt;code&gt;&amp;lt;Y&amp;gt;&lt;/code&gt;, or &lt;code&gt;&amp;lt;Z&amp;gt;&lt;/code&gt; is guaranteed to &amp;ldquo;forward track&amp;rdquo; out of the end of the alternative list and try to match more). It&amp;rsquo;s a natural mapping to existing regex semantics. Here&amp;rsquo;s a more realistic example from the Perl 6 grammar. It parses statement modifiers. (The &lt;code&gt;&amp;lt;ws&amp;gt;&lt;/code&gt; rule parses optional whitespace.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule modifier { if     &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_cond(0,$expr) }
                  | unless &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_cond(1,$expr) }
                  | while  &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_loop(0,$expr) }
                  | until  &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_loop(1,$expr) }
                  | for    &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_for($expr)   }
                  | &amp;lt;@other_modifiers&amp;gt;  # user defined
                  | &amp;lt;null&amp;gt;              # no modifier
                  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In each case, once we recognize a keyword (and its following whitespace), we need to look for an expression, and then call a closure that builds the syntax tree. If either of those fails, the entire modifier rule fails. We only get to the last two alternatives on failure of assertions before the &lt;code&gt;::&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that the &lt;code&gt;::&lt;/code&gt; only says that we can&amp;rsquo;t backtrack from the &amp;ldquo;then&amp;rdquo; into the &amp;ldquo;if&amp;rdquo;. It says nothing about backtracking into the alternative list as a whole. The alternatives are still choice points, so the regex engine is allowed to backtrack into the alternative list and try another alternative. (To disable that, simply put a &lt;code&gt;:&lt;/code&gt; after the closing bracket of the alternative list.)&lt;/p&gt;

&lt;p&gt;There is nothing in Perl 5 corresponding to the &lt;code&gt;:::&lt;/code&gt; operator, but it works just like &lt;code&gt;::&lt;/code&gt;, only more so. If you backtrack across it, it fails all the way out of the current rule definition (though not out of any rule invoking this definition). That is, it fails all the way out of the innermost lexically enclosing &lt;code&gt;/.../&lt;/code&gt;, &lt;code&gt;m/.../&lt;/code&gt;, &lt;code&gt;s/...//&lt;/code&gt;, &lt;code&gt;rx/.../&lt;/code&gt;, or &lt;code&gt;rule {...}&lt;/code&gt;, skipping out through any enclosing nestings of &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;, &lt;code&gt;[...]&lt;/code&gt;, or &lt;code&gt;(...)&lt;/code&gt;. (A pattern nested within a closure is classified as its own rule, however, so it never gets the chance to pass out of a &lt;code&gt;{...}&lt;/code&gt; closure.)&lt;/p&gt;

&lt;p&gt;Since the alternatives in our last example are at the top level of the regex, we could have used the &lt;code&gt;:::&lt;/code&gt; operator to get the same effect as &lt;code&gt;::&lt;/code&gt;, because terminating the rule and terminating the alternation amount to the same thing in that case. You can think of all of these as variants on Prolog&amp;rsquo;s &amp;ldquo;cut&amp;rdquo; operator.&lt;/p&gt;

&lt;p&gt;If you backtrack over the &lt;code&gt;::::&lt;/code&gt; operator, it will delete your program from the disk. &lt;code&gt;;-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Actually, the real name of the real &lt;code&gt;::::&lt;/code&gt; operator is &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. It fails the entire match if you backtrack over it, not just the current rule. That is, it fails all the way out of the &lt;em&gt;outermost&lt;/em&gt; dynamically enclosing &lt;code&gt;/.../&lt;/code&gt;, &lt;code&gt;m/.../&lt;/code&gt;, &lt;code&gt;s/...//&lt;/code&gt;, &lt;code&gt;rx/.../&lt;/code&gt;, or &lt;code&gt;rule {...}&lt;/code&gt; that is executing on the current string.&lt;/p&gt;

&lt;p&gt;There is one &amp;ldquo;cut&amp;rdquo; operator that is beyond &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;; it is appropriately named &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt;, for two reasons. First of all, it&amp;rsquo;s a real cut operator in that, if you backtrack over it, the current match fails completely, just like &lt;code&gt;&amp;lt;commit&amp;gt;&lt;/code&gt;. But that&amp;rsquo;s just a side effect of the other reason, which is that &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt; cuts off the front of the string that you&amp;rsquo;re currently matching on, turning the current position into the new beginning of the string. When you&amp;rsquo;re matching on a potentially infinite string, it&amp;rsquo;s important that you have a way of discarding that part of the match that you&amp;rsquo;ve already committed to. In Perl 5, the only way to do that was with a coordinated system of &lt;code&gt;s/^pat//&lt;/code&gt; operations. With the &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt; assertion, however, you can just match normally, and cut at one spot in your top-level rule when you reach an &amp;ldquo;accept&amp;rdquo; state.&lt;/p&gt;

&lt;p&gt;In the realm of idle speculation, we could go as far as to define a variant of &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt; that would render &lt;code&gt;s///&lt;/code&gt; slightly redundant:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s/foo/bar/;
    m/foo &amp;lt;replace(&amp;quot;bar&amp;quot;)&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that we don&amp;rsquo;t need any special forms for controlling the scope of a &amp;ldquo;fail&amp;rdquo; in a closure. Just prefix the closure with the appropriate backtracking operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / pattern ::: { code() or fail } /  # fails entire rule
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-character-class-reform-character-class-reform-span&#34;&gt;&lt;span id=&#34;character class reform&#34;&gt;Character Class Reform&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As we mentioned earlier, character classes are becoming more like standard grammar rules, because the definition of &amp;ldquo;character&amp;rdquo; is getting fuzzier. This is part of the motivation for demoting enumerated character classes and stealing the square brackets for another purpose. Actually, for old times&amp;rsquo; sake you still use square brackets on enumerated character classes, but you have to put an extra set of angles around it. But this actually tends to save keystrokes when you want to use any named character classes or Unicode properties, particularly when you want to combine them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    [a-z]               &amp;lt;[a-z]&amp;gt;
    [[:alpha:]]         &amp;lt;alpha&amp;gt;
    [^[:alpha:]]        &amp;lt;-alpha&amp;gt;
    [[:alpha:][:digit]] &amp;lt;&amp;lt;alpha&amp;gt;&amp;lt;digit&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The outer &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; also naturally serves as a container for any extra syntax we decide to come up with for character set manipulation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;[_]+&amp;lt;alpha&amp;gt;+&amp;lt;digit&amp;gt;-&amp;lt;Swedish&amp;gt;&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-state-state-span&#34;&gt;&lt;span id=&#34;state&#34;&gt;State&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;[This section gets pretty abstruse. It&amp;rsquo;s okay if your eyes glaze over.]&lt;/p&gt;

&lt;p&gt;Every regex match maintains a state object, and any closure within the regex is actually an anonymous method of that object, which means in turn that the closure&amp;rsquo;s topic is the current state object. Since a unary dot introduces a method call on the current topic, it follows that you can call any method in the state object that way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /(.*) { print .pos }/       # print current position
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The state object may in fact be an instance of a grammar class. A grammar object has additional methods that know how to build a parse tree. Its rules also know how to refer to each other or to rules of related grammars.&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;$_&lt;/code&gt; within the closure refers to this state object, not the original search string. If you search on the state object, however, it pretends that you wanted to continue the search on the original string. If the internal search succeeds, the position of the external state is updated as well, just as if the internal search had been a rule invoked directly from the outer regex.&lt;/p&gt;

&lt;p&gt;Because the state object is aware of how the tree is being built, when backtracking occurs the object can destroy parts of the parse tree that were conjectured in error. Because the grammar&amp;rsquo;s action methods have control of the regex state, they can access named fields in the regex without having to explicitly pass them to the method call.&lt;/p&gt;

&lt;p&gt;For instance, in our earlier example we passed &lt;code&gt;$expr&lt;/code&gt; explicitly to build the parse tree, but the method can actually figure that out itself. So we could have just written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule modifier { if     &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_cond(0) }
                  | unless &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_cond(1) }
                  | while  &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_loop(0) }
                  | until  &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_loop(1) }
                  | for    &amp;lt;ws&amp;gt; :: &amp;lt;expr&amp;gt; { .new_for }
                  | &amp;lt;@other_modifiers&amp;gt;  # user defined
                  | &amp;lt;null&amp;gt;              # no modifier
                  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;See Variable Scoping below for where &lt;code&gt;@other_modifiers&lt;/code&gt; gets looked up.&lt;/p&gt;

&lt;p&gt;Within a closure, &lt;code&gt;$_&lt;/code&gt; represents the current state of the current regex, and by extension, the current state of all the regexes participating in the current match. (The type of the state object is the current grammar class, which may be an anonymous type if the current grammar has no name. If the regex is not a member of a grammar, it&amp;rsquo;s of type RULE.) Part of the state of the current regex is the current node of the parse tree that is being built. When the current regex succeeds, the state object becomes a result object, and is returned to the calling regex. The calling regex can refer to the returned object as a &amp;ldquo;hypothetical&amp;rdquo; variable, the name of which is either implicitly generated from the name of the rule, or explicitly bound using &lt;code&gt;:=&lt;/code&gt;. Through that variable you can get at anything captured by the subrule. (That is what &lt;code&gt;$expr&lt;/code&gt; was doing earlier.)&lt;/p&gt;

&lt;p&gt;When the entire match succeeds, the top-level node is returned as a result object that has various values in various contexts, whether boolean, numeric, or string context. The name of the result object is &lt;code&gt;$0&lt;/code&gt;. The result object contains all the other information, such as &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. Unlike &lt;code&gt;$&amp;amp;&lt;/code&gt; in Perl 5, &lt;code&gt;$0&lt;/code&gt; is lexically scoped to the enclosing block. By extension, &lt;code&gt;$1&lt;/code&gt;, etc. are also lexically scoped.&lt;/p&gt;

&lt;p&gt;As a kind of iterator, a regex stored in a variable doesn&amp;rsquo;t expand in list context unless you put angles around it or use it with &lt;code&gt;m//&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $rx = /(xxx)/;
    print 1,2,&amp;lt;$rx($_)&amp;gt;;

    print 1,2,&amp;lt;/(xxx)/&amp;gt;;

    my &amp;amp;rx := /(xxx)/;
    print 1,2,&amp;lt;rx($_)&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$0&lt;/code&gt;, &lt;code&gt;$1&lt;/code&gt;, etc. are not set in iterated cases like this. Each list item is a result object, though, and you can still get at the internal values that way.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-hypothetical-variables-er-values-hypothetical-variables-er-values-span&#34;&gt;&lt;span id=&#34;hypothetical variables, er values&#34;&gt;Hypothetical Variables, er Values&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Values that are determined within a regular expression should usually be viewed as speculative, subject to cancellation if backtracking occurs. This applies not only to the values captured by &lt;code&gt;(...)&lt;/code&gt; within the regex, but also to values determined within closures embedded in the regex. The scope of these values is rather strange, compared to ordinary variables. They are dynamically scoped, but not like &lt;code&gt;temp&lt;/code&gt; variables. A temporary variable is restored at the end of the current block. A hypothetical variable keeps its value after the current block exits, and in fact keeps that value clear to the end of its natural lifetime if the regex succeeds (where the natural lifetime depends on where it&amp;rsquo;s declared). But if failure causes backtracking over where the variable was set, then it is restored to its previous state. Perl 5 actually coerced the &lt;code&gt;local&lt;/code&gt; operator into supporting this behavior, but that was a mistake. In Perl 6 &lt;code&gt;temp&lt;/code&gt; will keep consistent semantics, and restore values on exit from the current block. A new word, &lt;code&gt;let&lt;/code&gt;, will indicate the desire to set a variable to a hypothetical value. (I was tempted to use &amp;ldquo;suppose&amp;rdquo;, but &amp;ldquo;let&amp;rdquo; is shorter, and tends to mean the same thing, at least to mathematicians.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $x;
    / (\S*) { let $x = .pos } \s* foo /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this pattern, &lt;code&gt;$x&lt;/code&gt; will be set to the ending position of &lt;code&gt;$1&lt;/code&gt;&amp;ndash;but only if the pattern succeeds. If it fails, &lt;code&gt;$x&lt;/code&gt; is restored to &lt;code&gt;undef&lt;/code&gt; when the closure is backtracked. It&amp;rsquo;s possible to do things in a closure that the regex engine doesn&amp;rsquo;t know how to backtrack, of course, but a hypothetical value doesn&amp;rsquo;t fall into that category. For things that do fall into that category, perhaps we need to define a &lt;code&gt;BACK&lt;/code&gt; block that is like &lt;code&gt;UNDO&lt;/code&gt;, but scoped to backtracking.&lt;/p&gt;

&lt;p&gt;Sometimes we&amp;rsquo;ll talk about declaring a hypothetical variable, but as with &lt;code&gt;temp&lt;/code&gt; variables, we&amp;rsquo;re not actually declaring the variable itself, but the dynamic scope of its new value. In Perl 6, you can in fact say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $x = 0;
    ...
    {
        temp $x = 1;    # temporizes the lexical variable
        ...
    }
    # $x restored to 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(This is primarily useful for dynamically scoping a file-scoped lexical, which is slightly safer than temporizing a package variable since nobody can see it outside the file.)&lt;/p&gt;

&lt;p&gt;You may declare a hypothetical variable only when the topic is a regex state. This is not as much of a hardship as it might seem. Suppose your closure calls out to some other routine, and passes the regex state as an argument, &lt;code&gt;$rx_state&lt;/code&gt;. It suffices to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $rx_state { let $x = .pos }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As it happens, &lt;code&gt;$1&lt;/code&gt; and friends are all simply hypothetical variables. When we say &amp;ldquo;hypothetical variable&amp;rdquo;, we aren&amp;rsquo;t speaking of where the variable is stored, but rather how its contents are treated dynamically. If a regex sets a hypothetical variable that was declared with either &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;our&lt;/code&gt; beforehand, then the regex modifies that lexical or package variable, and &lt;code&gt;let&lt;/code&gt; is purely a run-time operation.&lt;/p&gt;

&lt;p&gt;On the other hand, if the variable is not pre-declared, it&amp;rsquo;s actually stored in the regex state object. In this case, the &lt;code&gt;let&lt;/code&gt; also serves to declare the variable as lexically scoped to the rest of the regex, in addition to its run-time action. Such a variable is not directly visible outside the regex, but you can get at it through the &lt;code&gt;$0&lt;/code&gt; object (always presuming the match succeeded). For a regex variable named &lt;code&gt;$maybe&lt;/code&gt;, its external name is &lt;code&gt;$0._var_{&#39;maybe&#39;}&lt;/code&gt;. The &lt;code&gt;$0&lt;/code&gt; object can behave as a hash, so &lt;code&gt;$0{maybe}&lt;/code&gt; is the short way to say that.&lt;/p&gt;

&lt;p&gt;All other variable names are stored with their sigil, so the external name for &lt;code&gt;@maybe&lt;/code&gt; is &lt;code&gt;$0{&#39;@maybe&#39;}&lt;/code&gt;, and for &lt;code&gt;%maybe&lt;/code&gt; is &lt;code&gt;$0{&#39;%maybe&#39;}&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$1&lt;/code&gt; is a special case&amp;ndash;it&amp;rsquo;s visible outside the regex, not because it&amp;rsquo;s predeclared, but because Perl already knows that the numbered variable &lt;code&gt;$1&lt;/code&gt; is really stored as a subarray of the $0 object: &lt;code&gt;$0[1]&lt;/code&gt;. The numbered variables are available only through the array, not the hash.&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;$0&lt;/code&gt; represents the state of the currently executing regex, you can&amp;rsquo;t use it within a rule to get at the result of a completed subrule. When you successfully call a subrule named &lt;code&gt;&amp;lt;somerule&amp;gt;&lt;/code&gt;, the regex state is automatically placed in a hypothetical variable named &lt;code&gt;$somerule&lt;/code&gt;. (Rules accessed indirectly must be captured explicitly, or they won&amp;rsquo;t have a name by which you can get to them. More on that in the next section.)&lt;/p&gt;

&lt;p&gt;As the current recursive regex executes, it automatically builds a tree of hashes corresponding to all captured hypothetical variables. So from outside the regex, you could get at the &lt;code&gt;$1&lt;/code&gt; of the subrule &lt;code&gt;&amp;lt;somerule&amp;gt;&lt;/code&gt; by saying &lt;code&gt;$0{somerule}[1]&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-named-captures-named-captures-span&#34;&gt;&lt;span id=&#34;named captures&#34;&gt;Named Captures&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Suppose you want to use a hypothetical variable to bind a name to a capture:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\S+) { let $x := $1 } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A shorthand for that is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $x:=(\S+) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parens are numbered independently of any name, so &lt;code&gt;$x&lt;/code&gt; is an alias for &lt;code&gt;$1&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may also use arrays to capture appropriately quantified patterns:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / @x := (\S+ \s*)* /                # including space
    / @x := [ (\S+) \s* ]* /            # excluding space
    / @x := [ (\S+) (\s*) ]* /          # each element is [word, space]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in general, naming square brackets doesn&amp;rsquo;t cause the square brackets to capture, but rather provides a destination for the parens within the square brackets. Only parens and rules can capture. It&amp;rsquo;s illegal to name square brackets that don&amp;rsquo;t capture something inside.&lt;/p&gt;

&lt;p&gt;You can also capture to a hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / %x := [ (\S+)\: \s* (.*) ]* /     # key/value pairs
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After that match, &lt;code&gt;$1&lt;/code&gt; returns a list of keys, and &lt;code&gt;$2&lt;/code&gt; returns a list of values. You can capture just the keys:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / %x := [ (\S+) \s* ]* /            # just enter keys, values are undef
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can capture a closure&amp;rsquo;s return value too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $x := { &amp;quot;I&#39;m in scalar context&amp;quot; } /
    / @x := { &amp;quot;I&amp;quot;, &amp;quot;am&amp;quot;, &amp;quot;in&amp;quot;, &amp;quot;list&amp;quot;, &amp;quot;context&amp;quot; } /
    / %x := { &amp;quot;I&amp;quot; =&amp;gt; &amp;quot;am in hash context&amp;quot; } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that these do not use parens. If you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $x := ({ code }) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it would capture whatever text was traversed by the closure, but ignore the closure&amp;rsquo;s actual return value.&lt;/p&gt;

&lt;p&gt;You can reorder paren groups by naming them with numeric variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $2:=(.*?), \h* $1:=(.*) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you use a numeric variable, the numeric variables will start renumbering from that point, so subsequent captures can be of a known number (which clobbers any previous association with that number). So for instance you can reset the numbers for each alternative:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $1 := (.*?) (\:)  (.*) { process $1, $2, $3 }
    | $1 := (.*?) (=\&amp;gt;) (.*) { process $1, $2, $3 }
    | $1 := (.*?) (-\&amp;gt;) (.*) { process $1, $2, $3 }
    /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also possible to refer to captures relative to the current location. &lt;code&gt;$-1&lt;/code&gt; refers to the immediately preceding capture (what used to be known as &lt;code&gt;$+&lt;/code&gt;). &lt;code&gt;$-2&lt;/code&gt; refers to the one before that. If you use anything above &lt;code&gt;$-3&lt;/code&gt; we&amp;rsquo;ll come and take you away to the insane asylum.&lt;/p&gt;

&lt;p&gt;Subrules called via &lt;code&gt;&amp;lt;rule&amp;gt;&lt;/code&gt; also capture their result in hypothetical variables. It&amp;rsquo;s possible to name the results of any &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt;, but grammar rules already have a name by default, so you don&amp;rsquo;t have to give them names unless you call the same rule more than once. So, presuming you have grammar rules defining &amp;ldquo;key&amp;rdquo; and &amp;ldquo;value&amp;rdquo;, you can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;key&amp;gt; \: &amp;lt;value&amp;gt; { let %hash{$key} = $value } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, in a typical grammar the typical rule may not return a string, but a reference to an anonymous object representing a node of the parse tree. But that depends on what the subrule decides to capture. If the only thing captured in the subrule is a single string, that&amp;rsquo;s what you get. (If nothing is captured, you get the entire match.)&lt;/p&gt;

&lt;p&gt;Any capture that will capture multiple items will, if asked to put it into a scalar variable, produce an anonymous list automatically. This should rarely be a surprise, since it&amp;rsquo;s obvious by inspection whether you&amp;rsquo;ve quantified the capture or not. So if you say any of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $x := &amp;lt;word&amp;gt;*/
    / $x := &amp;lt;word&amp;gt;+/
    / $x := &amp;lt;word&amp;gt;&amp;lt;1,3&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then you&amp;rsquo;ve &amp;ldquo;pluralized&amp;rdquo; the naming, and you can expect to get some number of values in &lt;code&gt;$x&lt;/code&gt; as an anonymous list. However, the &lt;code&gt;?&lt;/code&gt; quantifier specifically doesn&amp;rsquo;t pluralize. If you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $x := &amp;lt;word&amp;gt;?/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then &lt;code&gt;$x&lt;/code&gt; will either be the result of the subrule or &lt;code&gt;undef&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can name the results of a zero-width assertion, but you&amp;rsquo;d typically only get the null string out of it. This can still be useful, since it contrasts with the undefined value you&amp;rsquo;d have if the assertion fails. (It is possible with an explicit capture to return a non-zero-width string from a zero-width assertion, however.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-variable-scoping-variable-scoping-span&#34;&gt;&lt;span id=&#34;variable scoping&#34;&gt;Variable Scoping&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;When you refer to a variable &lt;code&gt;@foo&lt;/code&gt; as an rvalue in a regex, it searches for an existing variable in the following places:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;We first look to see if the variable is already declared lexically with either &lt;code&gt;my @foo&lt;/code&gt; or &lt;code&gt;our @foo&lt;/code&gt;. If so declared, we&amp;rsquo;re done.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Next we look for &lt;code&gt;@foo&lt;/code&gt; in the current regex&amp;rsquo;s name table. The name of the variable is really &lt;code&gt;$0{&#39;@foo&#39;}&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the regex belongs to a grammar, we next look for &lt;code&gt;@foo&lt;/code&gt; in the grammar object. If there, its real name is &lt;code&gt;@.foo&lt;/code&gt;, or some such. (It might be objected that the grammar object is not yet constructed when the regex is compiled. After all, the regex is probably being passed to the grammar object&amp;rsquo;s constructor. But I think if such a variable is declared as an object attribute we know that there &lt;em&gt;will&lt;/em&gt; be such a variable/accessor later when we have finished constructing, and that seems like enough info to know how to compile the regex.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Next we look for &lt;code&gt;@foo&lt;/code&gt; as a declared core global variable &lt;code&gt;@*foo&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Finally, if &amp;ldquo;strict vars&amp;rdquo; is not in effect, we assume that &lt;code&gt;@foo&lt;/code&gt; is stored in the current package. Otherwise it&amp;rsquo;s a stricture error.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-variable-interpretation-variable-interpretation-span&#34;&gt;&lt;span id=&#34;variable interpretation&#34;&gt;Variable Interpretation&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As we mentioned earlier, bare scalars match their contents literally. (Use &lt;code&gt;&amp;lt;$var&amp;gt;&lt;/code&gt; instead to match a regex defined in &lt;code&gt;$var&lt;/code&gt;.) Subscripted arrays and hashes behave just like a scalar as long as the subscripts aren&amp;rsquo;t slices.&lt;/p&gt;

&lt;p&gt;If you use a bare array (unsubscripted), it will match if &lt;em&gt;any&lt;/em&gt; element of the array matches literally at that point. (A slice of an array or hash also behaves this way.) If you say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = (&amp;quot;^&amp;quot;, &amp;quot;$&amp;quot;, &amp;quot;.&amp;quot;);
    / @array /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s as if you said&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / \^ | \$ | \. /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if you you slice it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / @array[0..1] /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it won&amp;rsquo;t match the dot.&lt;/p&gt;

&lt;p&gt;If you want the array to be considered as a set of regex alternatives, enclose in angles:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = (&amp;quot;^foo$&amp;quot;, &amp;quot;^bar$&amp;quot;, &amp;quot;^baz$&amp;quot;);
    / &amp;lt;@array&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bare hashes in a regex provide a sophisticated match-via-lookup mechanism. Bare hashes are matched as follows:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Match a key at the current point in the string.&lt;/p&gt;

&lt;p&gt;1a. If the hash has its &lt;code&gt;keymatch&lt;/code&gt; property set to some regex, use that regex to match the key.&lt;/p&gt;

&lt;p&gt;1b. Otherwise, use &lt;code&gt;/\w+:/&lt;/code&gt; to match the key.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If a key isn&amp;rsquo;t found at the current position in the string, the match fails.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Otherwise, get the value in the hash corresponding to the matched key.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the is no entry for that key, the match fails.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the hash doesn&amp;rsquo;t have a &lt;code&gt;valuematch&lt;/code&gt; property, the match succeeds immediately.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Otherwise use the hash&amp;rsquo;s &lt;code&gt;valuematch&lt;/code&gt; property (typically itself a regex) to extract the value at the current point in the string.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If no value can be extracted, matching of the hash fails.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;If the extracted value string is &lt;code&gt;eq&lt;/code&gt; to the key&amp;rsquo;s actual value, matching of the original hash immediately succeeds.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Otherwise, matching of the original hash fails.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So matching a bare hash is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule {
        $key := &amp;lt;{ %hash.prop{keymatch} // /\w+:/ }&amp;gt;    # find key
        &amp;lt;( exists %hash{$key} )&amp;gt;                        # if exists
        [ &amp;lt;( not defined %hash.prop{valuematch} )&amp;gt; ::   # done?
            &amp;lt;null&amp;gt;                                      # succeed
        |                                               # else
            $val := &amp;lt;%hash.prop{valuematch}&amp;gt;            # find value
                &amp;lt;( $val eq %hash{$val} )&amp;gt;               # assert eq
        ]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A typical &lt;code&gt;valuematch&lt;/code&gt; might look like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule {
        \s* =\&amp;gt; \s*             # match =&amp;gt; 
        $q:=(&amp;lt;[&amp;quot;&#39;]&amp;gt;)            # match initial quote 
        $0:=( [ \\. | . ]*? )   # return matched value
        $q                      # match trailing quote 
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In essence, the presence or absence of the &lt;code&gt;valuematch&lt;/code&gt; property controls whether the hash tries to match only keys, or both keys and values.&lt;/p&gt;

&lt;p&gt;A hash may be used inside angles as well. In that case, it finds the key by the same method (steps 1 and 2 above), but always treats the corresponding hash value as a regex (regardless of any properties the hash might have). The parse then continues according to the rule found in the hash. For example, we could parse a set of control structures with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule { &amp;lt;%controls&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;%controls&lt;/code&gt; hash can have keys like &amp;ldquo;&lt;code&gt;if&lt;/code&gt;&amp;rdquo; and &amp;ldquo;&lt;code&gt;while&lt;/code&gt;&amp;rdquo; in it. The corresponding entry says how to parse the rest of an &lt;code&gt;if&lt;/code&gt; or a &lt;code&gt;while&lt;/code&gt; statement. For example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        %controls = ( 
            if     =&amp;gt; / &amp;lt;condition&amp;gt;      &amp;lt;closure&amp;gt; /,
            unless =&amp;gt; / &amp;lt;condition&amp;gt;      &amp;lt;closure&amp;gt; /,
            while  =&amp;gt; / &amp;lt;condition&amp;gt;      &amp;lt;closure&amp;gt; /,
            until  =&amp;gt; / &amp;lt;condition&amp;gt;      &amp;lt;closure&amp;gt; /,
            for    =&amp;gt; / &amp;lt;list_expr&amp;gt;      &amp;lt;closure&amp;gt; /,
            loop   =&amp;gt; / &amp;lt;loop_controls&amp;gt;? &amp;lt;closure&amp;gt; /,
        );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;%controls&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is really much as if we&amp;rsquo;d said:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [ if     \b &amp;lt;%controls{if}&amp;gt;
    | unless \b &amp;lt;%controls{unless}&amp;gt; 
    | while  \b &amp;lt;%controls{while}&amp;gt;
    | until  \b &amp;lt;%controls{until}&amp;gt; 
    | for    \b &amp;lt;%controls{for}&amp;gt; 
    | loop   \b &amp;lt;%controls{loop}&amp;gt;
    ]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only it actually works more like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $k=&amp;lt;{ %controls.prop{keymatch} // /\w+:/ }&amp;gt; &amp;lt;%controls{$k}&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in Perl 6 it&amp;rsquo;s perfectly valid to use &lt;code&gt;//&lt;/code&gt; inside an expression embedded in a regex delimited by slashes. That&amp;rsquo;s because a regex is no longer considered a string, so we don&amp;rsquo;t have to find the end of it before we parse it. Since we can parse it in one pass, the expression parser can handle the &lt;code&gt;//&lt;/code&gt; when it gets to it without worrying about the outer slash, and the final slash is recognized as the terminator by the regex parser without having to worry about anything the expression parser saw.&lt;/p&gt;

&lt;p&gt;A bare subroutine call may be used in a regex, provided it starts with &lt;code&gt;&amp;amp;&lt;/code&gt; and uses parentheses around the arguments. The return value of the subroutine is matched literally. The subroutine may have side effects, and may throw an exception to fail.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-defining-your-own-rules-defining-your-own-rules-span&#34;&gt;&lt;span id=&#34;defining your own rules&#34;&gt;Defining Your Own Rules&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Suppose your name is Hugo and you don&amp;rsquo;t like to use &lt;code&gt;!&lt;/code&gt; to negate an assertion. You can define your own assertion like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my rule not (str $rx) { &amp;lt;!&amp;lt;{&amp;quot;&amp;lt;$rx&amp;gt;&amp;quot;}&amp;gt;&amp;gt; }            # define Hugo not
    / &amp;lt;not [a-z]&amp;gt; /     # same as &amp;lt;![a-z]&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That rule would be lexically scoped because of the &lt;code&gt;my&lt;/code&gt;. If you think it looks like a &lt;code&gt;sub&lt;/code&gt; declaration, you&amp;rsquo;re right. In fact, it&amp;rsquo;s possible you could even declare it anonymously like a closure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $not = rule (str $rx) { &amp;lt;!&amp;lt;{&amp;quot;&amp;lt;$rx&amp;gt;&amp;quot;}&amp;gt;&amp;gt; };
    / &amp;lt;$not tonight dear&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But maybe you don&amp;rsquo;t want it lexically scoped because you&amp;rsquo;re writing a grammar for general use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grammar HugoGrammar {
         rule not ($rx) { &amp;lt;!$rx&amp;gt; }
         rule identifier { &amp;lt;not before \d&amp;gt; \w+ }
         rule \j { \c[LF] }
         rule parse { ^ &amp;lt;identifier&amp;gt; \j $ }
    }

    HugoGrammar.parse($line);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case a rule is simply a method in a grammar class, and a grammar class is any class derived implicitly or explicitly from the universal RULE grammar class. The built-in regex assertions like &lt;code&gt;&amp;lt;before \w&amp;gt;&lt;/code&gt; are really just calls to methods in the RULE class. The namespace of a grammar is simply the method namespace of the current class, which is the class&amp;rsquo;s methods plus all inherited methods.&lt;/p&gt;

&lt;p&gt;In addition to normal subrules, we allow some funny looking method names like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule :a { ... }
    rule \a { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Modules that mutate Perl&amp;rsquo;s grammar on the fly can do so by deriving an anonymous grammar class from the default Perl6Grammar, and installing extra rules on the fly. The current regex state then continues parsing the rest of the lexical scope using some rule from the new rule set. Subsequent grammatical mutations will be derived from the current anonymous grammar unless you switch explicitly to an entirely different grammar.&lt;/p&gt;

&lt;p&gt;Since we&amp;rsquo;re writing grammar rules as if they were methods, we have access to the full syntax of method declaration, including formal parameter lists and compile-time properties. So we can easily annotate rules with pragmatic information such as operator precedence levels when you don&amp;rsquo;t want to write a strictly recursive-descent parser, for instance. (And we don&amp;rsquo;t want to, for Perl.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-accepted-rfcs-accepted-rfcs-span&#34;&gt;&lt;span id=&#34;accepted rfcs&#34;&gt;Accepted RFCs&lt;/span&gt;&lt;/h3&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-72-html-id-rfc-072-variablelength-lookbehind-rfc-072-variable-length-lookbehind-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/72.html&#34; id=&#34;rfc 072: variablelength lookbehind.&#34;&gt;RFC 072: Variable-length lookbehind.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This seems good to me. It&amp;rsquo;s just a SMOP to reverse the ordering of nodes in the syntax tree, and I think we can pretty well determine when it&amp;rsquo;s impossible to reverse the tree. The operation of a reversed syntax tree will not be totally transparent, however, so it will be necessary to document that quantifiers will actually be working right-to-left rather than left-to-right. (It&amp;rsquo;s probably also a good idea to document that many syntactic constructs can&amp;rsquo;t actually be reliably recognized in reverse. An attempt to do so probably means you needed to do a lookahead earlier, rather than a lookbehind later.)&lt;/p&gt;

&lt;p&gt;The syntax of lookbehind uses the new assertion syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;after ...&amp;gt;         # positive lookbehind
    &amp;lt;!after ...&amp;gt;        # negative lookbehind
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yes, the &lt;code&gt;pos()&lt;/code&gt; function could return multiple values in list context, but I think it&amp;rsquo;s more reasonable for the individual captured elements to know where their positions are. The &lt;code&gt;pos&lt;/code&gt; function is really just a special case of a more general data structure contained in the regex result object from the last successful match. In which case, maybe it really needs to have a better name than &lt;code&gt;pos&lt;/code&gt;. Maybe &lt;code&gt;$0&lt;/code&gt; or something. Then we get &lt;code&gt;$0.beg&lt;/code&gt; and &lt;code&gt;$0.end&lt;/code&gt;, &lt;code&gt;$1.beg&lt;/code&gt;, and &lt;code&gt;$1.end&lt;/code&gt;, etc. Since &lt;code&gt;@$0&lt;/code&gt; returns a list of captures, you can do &lt;code&gt;@$0^.beg&lt;/code&gt; and &lt;code&gt;@$0^.end&lt;/code&gt; if you want a list of beginnings and endings. Did I mention that the magical &lt;code&gt;@+&lt;/code&gt; and &lt;code&gt;@-&lt;/code&gt; arrays are gonna be real dead? Never could remember which one was which anyway&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-93-html-id-rfc-093-regex-support-for-incremental-pattern-matching-rfc-093-regex-support-for-incremental-pattern-matching-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/93.html&#34; id=&#34;rfc 093: regex: support for incremental pattern matching&#34;&gt;RFC 093: Regex: Support for incremental pattern matching&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I don&amp;rsquo;t think this proposal is powerful enough. &amp;ldquo;Infinite&amp;rdquo; strings are a more powerful concept. But I don&amp;rsquo;t think infinite strings are powerful enough either!&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re certainly going to have &amp;ldquo;infinite&amp;rdquo; arrays for which missing elements are defined by a generator (where the action could be as simple as reading more data from some other source). We could do the same thing for strings directly, or we could define strings that are implemented underneath via arrays (of strings or of stringifiable objects), and achieve infinitude that way. This latter approach has the benefit that the array element boundaries could be meaningful as zero-width boundaries between, say, tokens in a token stream. We&amp;rsquo;re thinking that &lt;code&gt;&amp;lt;,&amp;gt;&lt;/code&gt; could match such a boundary.&lt;/p&gt;

&lt;p&gt;But beyond that, such arrays-as-strings could allow us to associate hidden metadata with the tokens, if the abstract string is constructed from a list of objects, or a list of strings with properties. This is typically how a parser would receive data from a lexical analyzer. It&amp;rsquo;s the parser&amp;rsquo;s job to transform the linear stream of objects into a parse tree of objects.&lt;/p&gt;

&lt;p&gt;Matching against such boundaries or metadata would not be possible unless ether the regex engine is aware that it is matching against an array, or the string emulation provides visibility through the abstract string into the underlying array. The latter may be preferable, since (by the rules of the &lt;code&gt;=~&lt;/code&gt; matrix discussed in Apocalypse 4) &lt;code&gt;@array =~ /regex/&lt;/code&gt; is currently interpreted as matching against each element of the array individually rather than sequentially, and there are other uses for a string that&amp;rsquo;s really an array. In fact, &lt;code&gt;@array =~ /regex/&lt;/code&gt; could conceivably be matching against a set of infinite strings in parallel, though that seems a bit scary.&lt;/p&gt;

&lt;p&gt;Even if we don&amp;rsquo;t care about the boundaries between array elements, this approach gives us the ability to read a file in chunks and not worry that the pattern won&amp;rsquo;t match because it happens to span a boundary.&lt;/p&gt;

&lt;p&gt;It might be objected that matching against a subroutine rather than an infinite string or array has the benefit of not promising to keep around the entire string or array in memory. But this is not really a feature, since in general a regex can potentially backtrack all the way to the beginning of the string. And there&amp;rsquo;s nothing to say that the front of the infinite string or array has to stay around anyway. Whether to throw away the head of a string or array should really depend on the programmer, and I don&amp;rsquo;t think there&amp;rsquo;s a more intuitive way to manage that than to simply let the programmer whack off the front of the string or array using operators like &lt;code&gt;substr&lt;/code&gt; or &lt;code&gt;splice&lt;/code&gt;, or the new &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt; assertion.&lt;/p&gt;

&lt;p&gt;Indeed, the very existence of the string/array precludes the caching problem that RFC 316 complains about.&lt;/p&gt;

&lt;p&gt;The question remains how to declare such a string/array. If we decided to do a magical name identification, we could conceivably declare&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $@array;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then both &lt;code&gt;$array&lt;/code&gt; and &lt;code&gt;@array&lt;/code&gt; refer to the same object, but treated as a string when you say &lt;code&gt;$array&lt;/code&gt; and as an array when you say &lt;code&gt;@array)&lt;/code&gt;. One is tempted to set up the input routine by saying&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $@array is from { &amp;lt;$input&amp;gt; };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Additional lines (or chunks) would then come from the &lt;code&gt;&amp;lt;$input&amp;gt;&lt;/code&gt; iterator.&lt;/p&gt;

&lt;p&gt;But really, the infinite nature of the array is a feature of the underlying object, not the variable. After all, we want to be able to say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array := 1..Inf;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;even with an ordinary array.&lt;/p&gt;

&lt;p&gt;So we could even make this work:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $@array := &amp;lt;$input&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But I think we need to break the aliasing down, which will give us more flexibility at the expense of more verbiage:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @array := &amp;lt;$input&amp;gt;;              # @array now bound to iterator
    my $array is ArrayString(@array);   # an ordinary tie
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That would let us do cool and/or sick things like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @lines := &amp;lt;$article&amp;gt;;
    my $_ is ArrayString(@lines);

    s/^ .*? \n&amp;lt;2,&amp;gt; //;  # delete header from $_ AND @lines!
    for @lines { ... }  # process remaining lines
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;for&lt;/code&gt; loop potentially runs forever, since &lt;code&gt;@lines&lt;/code&gt; is implicitly extended from an iterator. The array is automatically extended on the end, but it&amp;rsquo;s not automatically shifted on the front. So if you really did want the loop to run forever without exhausting memory, you&amp;rsquo;d need to say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    substr($_, 0, $_.pos, &amp;quot;&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same effect can be effected within a regex by asserting &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt;, which makes the current position the new string beginning. (If you backtrack over &lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt;, the entire match will fail.)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-110-html-id-rfc-110-counting-matches-rfc-110-counting-matches-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/110.html&#34; id=&#34;rfc 110: counting matches&#34;&gt;RFC 110: counting matches&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I think we can avoid using any options if we make a pattern count matches when used in a numeric context. If in doubt, make it explicit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $count = +/foo/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If it turns out we do need an option, it&amp;rsquo;ll probably be &lt;code&gt;:n&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-112-html-id-rfc-112-assignment-within-a-regex-rfc-112-assignment-within-a-regex-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/112.html&#34; id=&#34;rfc 112: assignment within a regex&#34;&gt;RFC 112: Assignment within a regex&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC is basically covered by the &lt;code&gt;$foo:=(...)&lt;/code&gt; notation, plus variations. The RFC claims that such assignments are not done till the end, except that they are done ahead of closures. I&amp;rsquo;d rather state it the other way around: it always appears that the current hypothetical binding is assigned if you check, but as long as the optimizer can determine that you aren&amp;rsquo;t looking, it doesn&amp;rsquo;t have to keep up appearances. Contrariwise, if &lt;code&gt;$foo&lt;/code&gt; is just a fancy way of saying &lt;code&gt;$1&lt;/code&gt;, there may in fact be no more overhead in maintaining &lt;code&gt;$foo&lt;/code&gt; than &lt;code&gt;$1&lt;/code&gt;. Either is really just pointing into a table of offsets into the string. That&amp;rsquo;s assuming we get the scoping right on hypothetical variables.&lt;/p&gt;

&lt;p&gt;Some excerpts from the RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The camel and the docs include this example:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       if (/Time: (..):(..):(..)/) {
            $hours = $1;
            $minutes = $2;
            $seconds = $3;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;This then becomes:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      /Time: (?$hours=..):(?$minutes=..):(?$seconds=..)/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      /Time\: $hours:=(..) \: $minutes:=(..) \: $seconds:=(..)/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;It may be appropriate for any assignments made before a code callout to be localized so they can unrolled should the expression finally fail.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Rather than localized (or temporized), they are hypothesized.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The first versions of this RFC did not allow for backrefs. I now think this was a shortcoming. It can be done with &lt;code&gt;(??{quotemeta $foo})&lt;/code&gt;, but I find this clumsy, a better way of using a named back ref might be &lt;code&gt;(?\$foo)&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Backrefs are now unified with hypothetical variables, so the issue doesn&amp;rsquo;t arise. Just use &lt;code&gt;$foo&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Using this method for capturing wanted content, it might be desirable to stop ordinary brackets capturing, and needing to use &lt;code&gt;(?:...)&lt;/code&gt;. I therefore suggest that as an enhancement to regexes that /b (bracket?) ordinary brackets just group, without capture - in effect they all behave as &lt;code&gt;(?:...)&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s no need for a &lt;code&gt;/b&lt;/code&gt; now that we have &lt;code&gt;[...]&lt;/code&gt; for non-capturing brackets.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-144-html-id-rfc-144-behavior-of-empty-regex-should-be-simple-rfc-144-behavior-of-empty-regex-should-be-simple-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/144.html&#34; id=&#34;rfc 144: behavior of empty regex should be simple&#34;&gt;RFC 144: Behavior of empty regex should be simple&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I agree, the behavior should be simple. However, rather than always matching, I propose to make it an error to actually have a null pattern, or a null choice in a list of alternatives. Use an explicit &lt;code&gt;&amp;lt;null&amp;gt;&lt;/code&gt; if that&amp;rsquo;s what you mean. (It&amp;rsquo;s not a problem if &lt;code&gt;$foo&lt;/code&gt; is null in &lt;code&gt;/$foo/&lt;/code&gt;, since variables are now managed by the regex engine and not by interpolation.)&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-150-html-id-rfc-150-extend-regex-syntax-to-provide-for-return-of-a-hash-of-matched-subpatterns-rfc-150-extend-regex-syntax-to-provide-for-return-of-a-hash-of-matched-subpatterns-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/150.html&#34; id=&#34;rfc 150: extend regex syntax to provide for return of a hash of matched subpatterns&#34;&gt;RFC 150: Extend regex syntax to provide for return of a hash of matched subpatterns&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;$foo:=(...)&lt;/code&gt; notation essentially covers that case. One can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / %hash{foo}:=(...) %hash{bar}:=(...) /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Fancier things can be done with closures.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-156-html-id-rfc-156-replace-first-match-function-with-a-flag-to-the-match-command-rfc-156-replace-first-match-function-code-code-with-a-flag-to-the-match-command-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/156.html&#34; id=&#34;rfc 156: replace first match function (...) with a flag to the match command.&#34;&gt;RFC 156: Replace first match function (&lt;code&gt;?&amp;hellip;?&lt;/code&gt;) with a flag to the match command.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Having a &lt;code&gt;:f&lt;/code&gt; modifier seems like a reasonable way to do it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    m:f/.../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though it&amp;rsquo;s vaguely possible we should be having a set of verbs that parse like &lt;code&gt;split&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    split /.../
    count /.../
    first /.../
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s not clear whether those are actually methods, and if so, on which object, the string or the regex. In any event, I don&amp;rsquo;t think we have to nail that down quite yet. I&amp;rsquo;m accepting the basic premise of this RFC that the &lt;code&gt;?...?&lt;/code&gt; construct is going away, one way or another.&lt;/p&gt;

&lt;p&gt;At the moment, it looks like this option is spelled &lt;code&gt;:once&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-165-html-id-rfc-165-allow-variables-in-tr-rfc-165-allow-variables-in-tr-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/165.html&#34; id=&#34;rfc 165: allow variables in tr///&#34;&gt;RFC 165: Allow Variables in tr///&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;If interpolation of patterns by default is wrong, I think extending the &lt;code&gt;tr///&lt;/code&gt; interface via scalar interpolation is doubly wrong. Run-time generated transliterations should be based on mappings that aren&amp;rsquo;t so position dependent. That is, rather than specifying it as two long lists:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    abc12xyz =&amp;gt; ABC34XYZ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we specify something more like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    abc =&amp;gt; ABC
    12  =&amp;gt; 34
    xyz =&amp;gt; XYZ
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That looks more like a list of pairs of scalars than a pair of scalars. In fact, internally, it&amp;rsquo;s done like a funny parallel substitution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    s:e(/a/A/,
        /b/B/,
        /c/C/,
        /1/3/,
        /2/4/,
        /x/X/,
        /y/Y/,
        /z/Z/)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In any event, it&amp;rsquo;s more like &lt;code&gt;tr/@foo/@bar/&lt;/code&gt; than &lt;code&gt;tr/$foo/$bar/&lt;/code&gt;. But then, why stick with the fake string notation? Why not just say &lt;code&gt;tr(@foo,@bar)&lt;/code&gt; if that&amp;rsquo;s what we mean? Then we&amp;rsquo;re not limited to character substitutions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $string.tr [ &amp;quot; &amp;quot;     , &amp;quot;&amp;lt;&amp;quot;   , &amp;quot;&amp;gt;&amp;quot;   , &amp;quot;\n&amp;quot;   ],
               [ &amp;quot;&amp;amp;nbsp;&amp;quot;, &amp;quot;&amp;amp;lt;&amp;quot;, &amp;quot;&amp;amp;gt;&amp;quot;, &amp;quot;&amp;lt;br&amp;gt;&amp;quot; ];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or how about &lt;code&gt;tr(%trans)&lt;/code&gt;?&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %upper = {
        &amp;quot;a-z&amp;quot; =&amp;gt; &amp;quot;A-Z&amp;quot;,
    }
    $string.tr %upper;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or just pair lists of some sort:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $string.tr(&amp;quot;a-c&amp;quot; =&amp;gt; &amp;quot;x-z&amp;quot;,
               &amp;quot;1-2&amp;quot; =&amp;gt; &amp;quot;3-4&amp;quot;,
               &amp;quot;A-C&amp;quot; =&amp;gt; &amp;quot;X-Z&amp;quot;,
              );

    @trans = [
        &amp;quot;a-z&amp;quot; =&amp;gt; &amp;quot;A-Z&amp;quot;,
        @tr_danish,
    ];

    $string.tr(@trans)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-166-html-id-rfc-166-alternative-lists-and-quoting-of-things-rfc-166-alternative-lists-and-quoting-of-things-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/166.html&#34; id=&#34;rfc 166: alternative lists and quoting of things&#34;&gt;RFC 166: Alternative lists and quoting of things&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Alternative lists of literals are included simply by mentioning the array:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /@names/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternative lists of subrules are included with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /&amp;lt;@names&amp;gt;/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s no longer any need for quoting constructs because variables match as literals by default. You have to use angle brackets to get interpretation of a string as a subrule. (But it&amp;rsquo;s still preferable to precompile your regexen.)&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-191-html-id-rfc-191-smart-container-slicing-rfc-191-smart-container-slicing-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/191.html&#34; id=&#34;rfc 191: smart container slicing&#34;&gt;RFC 191: smart container slicing&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;As proposed, this might prevent us from using a regex object as a key to a hash. However, with some tweaking, it&amp;rsquo;ll fit in with how slicing is done in Perl 6.&lt;/p&gt;

&lt;p&gt;Perl 6 will DWIM subscripts based on their appearance. Obviously,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash{&amp;quot;foo&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;has a single subscript. And just as obviously,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash{&amp;quot;a&amp;quot; .. &amp;quot;z&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;has 26 subscripts or so. In the absence of any scalar guidance, a subscript will be interpreted in list context. So&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash{ @array }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will automatically slice on the list of keys in the array. Any function will be called in a list context by default, giving it the opportunity to return multiple values. Perl 6 subscripts are naturally biased toward slicing. To unbias it, here are some of the specifically recognized subscripts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash{&amp;quot;foo&amp;quot;}        # scalar literal
    %hash{bar}          # scalar literal
    %hash{1}            # scalar literal
    %hash{$x}           # scalar variable
    %hash{\$x}          # scalar reference
    %hash{[&amp;quot;a&amp;quot;, &amp;quot;b&amp;quot;]}   # array reference
    %hash{{&amp;quot;a&amp;quot; =&amp;gt; &amp;quot;b&amp;quot;}} # hash reference
    %hash{ &amp;quot;a&amp;quot; =&amp;gt; &amp;quot;b&amp;quot; } # pair reference
    %hash{ /pat/ }      # rule reference
    %hash{ _ expr }     # force expr to return a single string
    %hash{ + expr }     # force expr to return a single number
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Boolean expressions and closures look like singular values but cause a match against all possible values of the subscript.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash{ ?1 }         # select all subscripts
    %hash{ ?/pat/ }     # select subscripts for which pat matches
    %hash{ $_ =~ /pat/ }# select subscripts for which pat matches
    %hash{ $_ ge &amp;quot;a&amp;quot; }  # select lowercase keys (assuming ASCII)
    %hash{ .ge &amp;quot;a&amp;quot; }    # same thing, maybe
    %hash{ { expr } }   # select subscripts for which closure returns true
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Multiple slice subscripts are separated by semicolons, so that you can use commas within each slice subscript for list building. This is more important for multi-dimensional arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @array is dim(9,9,9) = cubic();

    @3d_slice = @array[ @x; @y; @z ];
    @3d_slice = @array[ 0,1,3,8 ; 0,1,3,8; ?1 ];
    @3d_slice = @array[ 0..9 ; 0..9:-1; ?test($_) ];
    @3d_slice = @array[ !($_ % 2) ; 0..9:3; ?test($_) ];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-274-html-id-rfc-274-generalized-additions-to-regexs-rfc-274-generalized-additions-to-regexs-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/274.html&#34; id=&#34;rfc 274: generalized additions to regexs&#34;&gt;RFC 274: Generalized Additions to Regexs&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This proposal has significant early/late binding issues. A definition that forces run-time overhead is not as useful as it might be. On the other hand, a pure compile-time mechanism is not as general as it might be&amp;ndash;but a compile-time mechanism can always compile in a run-time mechanism if it chooses to defer evaluation.&lt;/p&gt;

&lt;p&gt;So it seems like this is a good place for syntactic warpage of some sort or other. That would make it possible to do both compile-time and run-time bindings. We&amp;rsquo;ll be using the &lt;code&gt;&amp;lt;...&amp;gt;&lt;/code&gt; notation for our extensible syntax, and the grammar rules for parsing that particular part of Perl syntax will be just as easy to tweak as any other Perl grammar rule.&lt;/p&gt;

&lt;p&gt;That being said, the very fact that we can associate a grammar with the regex means that it&amp;rsquo;s easy to define any instance of &lt;code&gt;&amp;lt;word&amp;gt;&lt;/code&gt; to mean whatever you want it to. (In a sense, these subrules are the very callbacks that the RFC proposes.) These subrules can be bound either at Perl compile time or at Perl run time. They can be defined to take a string, regex, or Perl expression as an argument. The latter two cases are efficient because they come in as a regex or code reference respectively.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Following on, if (?{&amp;hellip;}) etc code is evaluated in forward match, it would be a good idea to likewise support some code block that is ignored on a forward match but is executed when the code is unwound due to backtracking.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yes, though hypothetical values take some of the pressure off for this. But if a closure contained a BACK block, it could be automatically fired off on backtracking. As with LAST et al., I suppose there&amp;rsquo;s a corresponding &lt;code&gt;back&lt;/code&gt; property on variables. In a sense, saying&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    let $var = $newval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is much like saying&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our $var is back { .set($oldval) } = $newval
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;except that &lt;code&gt;$var&lt;/code&gt; may well be stored in the regex state object rather than in a global symbol table.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-276-html-id-rfc-276-localising-paren-counts-in-qr-s-rfc-276-localising-paren-counts-in-qr-s-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/276.html&#34; id=&#34;rfc 276: localising paren counts in qr()s.&#34;&gt;RFC 276: Localising Paren Counts in qr()s.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I agree totally. As for the problem of pulling captures out of a subrule, it&amp;rsquo;s up to the subrule to determine what it &amp;ldquo;returns&amp;rdquo;. We could make some intelligent defaults, though different kinds of rules might want different defaults. One approach might be to say that if there is a single capture, that is returned as the result. If there is no capture, it&amp;rsquo;s as if the entire subpattern were captured. If there are multiple captures, they are returned as an anonymous list. So &lt;code&gt;$1&lt;/code&gt; from such a subrule might come through like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $sub:=&amp;lt;subrule&amp;gt; { print $sub[1] } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;subrule&amp;gt; { print $subrule[1] } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But named captures and named rules intrude on this idyllic picture. You&amp;rsquo;d also like a default anonymous hash value returned that is keyed by all the named captures or rules. The question is whether that forces numbered captures to come through the hash interface. Or maybe that&amp;rsquo;s just always the case, so to get at &lt;code&gt;$1&lt;/code&gt; of a subrule, you&amp;rsquo;d say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $sub:=&amp;lt;subrule&amp;gt; { print $sub{&#39;1&#39;} } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there are reasons for wanting to treat the result object as an array, so that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / $sub:=&amp;lt;subrule&amp;gt; { process(@$sub) } /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;processes all the numbered captures from the subrule. So I think the return object behaves either like a hash or an array as appropriate. (Note that such an array might be declared to have an origin at 1 rather than 0.)&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-317-html-id-rfc-317-access-to-optimisation-information-for-regular-expressions-rfc-317-access-to-optimisation-information-for-regular-expressions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/317.html&#34; id=&#34;rfc 317: access to optimisation information for regular expressions&#34;&gt;RFC 317: Access to optimisation information for regular expressions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Seems like a no-brainer. All such information is likely to be available to Perl anyway, given that we&amp;rsquo;d like to do the parser, optimizers, and code generators in Perl if at all possible.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-331-html-id-rfc-331-consolidate-the-1-and-1-notations-rfc-331-consolidate-the-code-1-code-and-code-1-code-notations-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/331.html&#34; id=&#34;rfc 331: consolidate the $1 and \1 notations&#34;&gt;RFC 331: Consolidate the &lt;code&gt;$1&lt;/code&gt; and &lt;code&gt;\1&lt;/code&gt; notations&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I like the title of this RFC. It fits in with the new &lt;code&gt;my&lt;/code&gt; policy of immediate introduction. However, there are certain difficulties with the proposed implementation. The statement-by-statement setting of the &lt;code&gt;@/&lt;/code&gt; array looks pretty ugly to me. I&amp;rsquo;d rather have a consistent view of hypothetical variables that can live on outside the regex in question without regard to statement boundaries. In the rare event that someone needs to refer to &lt;code&gt;$1&lt;/code&gt; (or anything else) from a prior regex, a temporary variable should be used.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-332-html-id-rfc-332-regex-make-equivalent-to-z-under-the-39-s-39-modifier-rfc-332-regex-make-equivalent-to-z-under-the-s-modifier-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/332.html&#34; id=&#34;rfc 332: regex: make /$/ equivalent to /\z/ under the &amp;#39;/s&amp;#39; modifier&#34;&gt;RFC 332: Regex: Make /$/ equivalent to /\z/ under the &amp;lsquo;/s&amp;rsquo; modifier&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Another RFC that is accepted in principle, but that doesn&amp;rsquo;t go far enough. The &lt;code&gt;/s&lt;/code&gt; modifier is going away, along with &lt;code&gt;/m&lt;/code&gt;. A &lt;code&gt;$&lt;/code&gt; will always mean end-of-string, and &lt;code&gt;$$&lt;/code&gt; will match at the end of any line. (The current process id is now &lt;code&gt;$*PID&lt;/code&gt;, by the way, so there&amp;rsquo;s no conflict there. But how often to you want to write a pattern to match the current process id anyway?)&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-348-html-id-rfc-348-regex-assertions-in-plain-perl-code-rfc-348-regex-assertions-in-plain-perl-code-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/348.html&#34; id=&#34;rfc 348: regex assertions in plain perl code&#34;&gt;RFC 348: Regex assertions in plain Perl code&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC makes some good points, though the code assertion syntax will be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;( code )&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The RFC also makes a case for getting rid of the special behavior of &lt;code&gt;local&lt;/code&gt; in Perl 5, which treated &lt;code&gt;local&lt;/code&gt; differently within a regex. However, something very like the &lt;code&gt;local&lt;/code&gt; behavior will still be needed for making hypotheses, though the RFC is correct that it&amp;rsquo;s not needed in the typical code assertion, In Perl 6, localization is done with &lt;code&gt;temp&lt;/code&gt;, and it will not do the hypothetical variable hack that Perl 5 did. Instead there will be an explicit lvalue modifier, &lt;code&gt;let&lt;/code&gt;, which specifically requests a variable&amp;rsquo;s value to be scoped to the success of the current point in the regex. These hypothetical variables actually have much broader use than this RFC suggests.&lt;/p&gt;

&lt;p&gt;Perl 5&amp;rsquo;s hardwired use of &lt;code&gt;$^R&lt;/code&gt; just translates to an appropriately named hypothetical variable in Perl 6.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-360-html-id-rfc-360-allow-multiply-matched-groups-in-regexes-to-return-a-listref-of-all-matches-rfc-360-allow-multiply-matched-groups-in-regexes-to-return-a-listref-of-all-matches-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/360.html&#34; id=&#34;rfc 360: allow multiply matched groups in regexes to return a listref of all matches&#34;&gt;RFC 360: Allow multiply matched groups in regexes to return a listref of all matches&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I think that parens that can potentially match multiple times will automatically produce a list rather than matching the final one. It&amp;rsquo;s not as if we can&amp;rsquo;t tell whether something&amp;rsquo;s inside a quantifier&amp;hellip;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the RFC&amp;rsquo;s proposed solution:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while ($text =~ /name:\s*(.*?)\n\s*
                    children:\s*(?:(?@\S+)[, ]*)*\n\s*
                    favorite\ colors:\s*(?:(?@\S+)[, ]*)*\n/sigx) {
        # now we have:
        #  $1 = &amp;quot;John Abajace&amp;quot;;
        #  $2 = [&amp;quot;Tom&amp;quot;, &amp;quot;Dick&amp;quot;, &amp;quot;Harry&amp;quot;]
        #  $3 = [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Apart from the change in behavior of &lt;code&gt;(...)&lt;/code&gt; within a quantifier, I have the urge to rewrite this example for several reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;The C&lt;/x&gt; and C&lt;/s&gt; flags no longer exist.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The C&lt;/i&gt; and C&lt;/g&gt; flags must be pulled out to the front for visibility.
        (And the C&lt;/g&gt; flag is renamed C&amp;lt;:e&amp;gt;).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;There&amp;rsquo;s now a C&amp;lt;\h&amp;gt; for horizontal whitespace, and C&amp;lt;\H&amp;gt; for the negation
        of that.  (Not that RFC is incorrect to use C&amp;lt;\s&amp;gt;.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The negation of C&amp;lt;\n&amp;gt; is now C&amp;lt;\N&amp;gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;The C&amp;lt;:&amp;gt; character is now a metacharacter, and so must be backslashed.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Character classes are now represented with C&amp;lt;&amp;lt; &amp;lt;[&amp;hellip;]&amp;gt; &amp;gt;&amp;gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Grouping is now represented with C&amp;lt;[&amp;hellip;]&amp;gt;.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;With these changes, and making better use of whitespace, the sample regex ends up looking like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for ($text =~ m:ie[
                            name             \: \h*   (\N*?)            \n
                        \h* children         \: \h* [ (\S+) &amp;lt;[,\h]&amp;gt;* ]* \n
                        \h* favorite\ colors \: \h* [ (\S+) &amp;lt;[,\h]&amp;gt;* ]* \n
                      ]
          )
    {
             # now we have:
             #  $1 = &amp;quot;John Abajace&amp;quot;;
             #  $2 = [&amp;quot;Tom&amp;quot;, &amp;quot;Dick&amp;quot;, &amp;quot;Harry&amp;quot;]
             #  $3 = [&amp;quot;red&amp;quot;, &amp;quot;green&amp;quot;, &amp;quot;blue&amp;quot;]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think in the long run people will find this more readable once they&amp;rsquo;re used to it. Certainly tabularizing the parallelisms will make any typing errors stand out.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-361-html-id-rfc-361-simplifying-split-rfc-361-simplifying-code-split-code-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/361.html&#34; id=&#34;rfc 361: simplifying split()&#34;&gt;RFC 361: Simplifying &lt;code&gt;split()&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The RFC makes five suggestions. I&amp;rsquo;ll consider them one by one.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The first argument to split is currently interpreted as a regexp, regardless of whether or not it actually is one. (Yes, &lt;code&gt;split &#39;.&#39;, $foo&lt;/code&gt; doesn&amp;rsquo;t split on dot &amp;ndash; it&amp;rsquo;s currently the same an &lt;code&gt;split /./, $foo&lt;/code&gt;.) I suggest that split be changed to treat only regexps as regexps, and everything else as literals.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Fine, I think. If the first argument to &lt;code&gt;split&lt;/code&gt; is untyped, it should parse correctly, either evaluating a quoted string immediately or deferring interpretation of a regex. One could even do something like split on the first delimiter matched by another pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    split _/(,|;)/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That would split on either all commas or all semicolons, depending on which it found first in the string. The _ forces the regex to return a string, which is whatever was captured by the parens in this case.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Empty trailing fields are currently suppressed (although a -1 as the third argument disables this). I suggest that empty trailing fields be retained by default.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Probably okay, though we need a way to translate old code. It was originally done this way because split on whitespace would typically return an extra field after the newline. But most newlines will be prechomped in Perl 6.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;When not in list context, split currently splits into &lt;code&gt;@_&lt;/code&gt;. I suggest that this side-effect be removed.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Fine. It&amp;rsquo;s easy enough to translate to an explicit assignment.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;split ?pat?&lt;/code&gt; in any context currently splits into &lt;code&gt;@_&lt;/code&gt;. I suggest that this side-effect be removed.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Fine. I don&amp;rsquo;t think anyone uses that.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;split &#39; &#39;&lt;/code&gt; (but not &lt;code&gt;split / /&lt;/code&gt;) currently splits on whitespace, but also removes leading empty fields. I suggest that this irregularity be removed.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The question is, what to replace it with, since it&amp;rsquo;s a very handy construct. We could use a different conventional pattern:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = split /&amp;lt;ws&amp;gt;/, $string;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or we could say that it&amp;rsquo;s now a split on whitespace only if the split argument is unspecified. That wouldn&amp;rsquo;t work very well with the old syntax, where we often have to supply the second argument. But given that the &lt;code&gt;=~&lt;/code&gt; operator now serves as a topicalizer for any term, we could translate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = split &#39; &#39;, $string;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = $string =~ split;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oddly, this probably also works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $string =~ (@array = split);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or maybe even this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = split given $string;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But I think I like the OO notation better here anyway:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = $string.split;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, split may not be a function at all. The default split might just be a string method and use unary dot:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = .split;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We still have the third argument to deal with, but that&amp;rsquo;s likely to be specified like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = $string.split(limit =&amp;gt; 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We could conceivably make a different method for word splitting, much like REXX does:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = .words;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then a limit could be the first argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = .words(3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there almost doesn&amp;rsquo;t need to be such a method, since&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = m/ [ (\S*) \s* ]* /;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will do the right thing. Admittedly, a &lt;code&gt;.words&lt;/code&gt; method would be much more readable&amp;hellip;&lt;/p&gt;

&lt;p&gt;Fortunately, &lt;code&gt;split&lt;/code&gt; is a function, so I can put off that decision till Apocalypse 29. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S05.html&#34;&gt;Synopsis 05&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-rejected-rfcs-rejected-rfcs-span&#34;&gt;&lt;span id=&#34;rejected rfcs&#34;&gt;Rejected RFCs&lt;/span&gt;&lt;/h3&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-135-html-id-rfc-135-require-explicit-m-on-matches-even-with-and-as-delimiters-rfc-135-require-explicit-m-on-matches-even-with-and-as-delimiters-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/135.html&#34; id=&#34;rfc 135: require explicit m on matches, even with  and // as delimiters.&#34;&gt;RFC 135: Require explicit m on matches, even with ?? and // as delimiters.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Squish that gnat&amp;hellip; &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A decent Perl parser is still going to have to keep track of whether a term or an operator is expected. And while we&amp;rsquo;re simplifying the grammar in many ways, it&amp;rsquo;s also the case that we&amp;rsquo;re letting users install their own grammar rules to perform syntactic warpage. Besides, people &lt;em&gt;like&lt;/em&gt; to write patterns with &lt;code&gt;/.../&lt;/code&gt;. So rather than impoverishing Perl&amp;rsquo;s syntax artificially, let&amp;rsquo;s make the standard parser more accessible by writing it all in Perl 6 regexes.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-145-html-id-rfc-145-bracematching-for-perl-regular-expressions-rfc-145-brace-matching-for-perl-regular-expressions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/145.html&#34; id=&#34;rfc 145: bracematching for perl regular expressions&#34;&gt;RFC 145: Brace-matching for Perl Regular Expressions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Good problem, not-so-good solution from a complexity point of view. I&amp;rsquo;d like to leverage existing character class and backref notations maybe. If there were simply some way to tell a backref to invert any match characters, that might do it. Or maybe reverse them when you remember them, and leave the backref ignorant? (Downside is nested brackets would probably need recursive patterns.)&lt;/p&gt;

&lt;p&gt;Recursion might be advisable anyway&amp;ndash;you can&amp;rsquo;t really pick up the arguments to a function, for instance, without also handling things like quoted strings, which may have different bracketing rules than outside of strings. Certainly matching &lt;code&gt;\&amp;quot;&lt;/code&gt; would be dependent on whether you&amp;rsquo;re inside or outside of a string. Given that recursion is often necessary, I&amp;rsquo;m not sure making this construct recurse itself is all that useful.&lt;/p&gt;

&lt;p&gt;Along the lines of how &lt;code&gt;tr///&lt;/code&gt; works (or ought to work), I think it&amp;rsquo;d be more generally useful to have character remapping facility within a backref generator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (
     &amp;lt;[ \( \[ \{ \&amp;lt; ] =&amp;gt;
      [ \) \] \} \&amp;gt; ]&amp;gt; )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That might match a left bracket of some sort but return the corresponding right bracket as &lt;code&gt;$1&lt;/code&gt;. But maybe we should just use an &amp;ldquo;existing&amp;rdquo; mechanism to translate strings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %closing = {
        &#39;[&#39; =&amp;gt; &#39;]&#39;,
        &#39;(&#39; =&amp;gt; &#39;)&#39;,
        &#39;{&#39; =&amp;gt; &#39;}&#39;,
        &#39;&amp;lt;&#39; =&amp;gt; &#39;&amp;gt;&#39;,
    };
    rule balanced {
        &amp;lt;![\[\(\{\&amp;lt;\]\)\}\&amp;gt;]&amp;gt;*  # any non-brackets
        [                       # followed by either
            $                   #   end of string
        |                       # or
            $b := &amp;lt;[[({&amp;lt;]&amp;gt;      #   an opening bracket
            &amp;lt;self&amp;gt;              #   containing a balanced expr
            %closing{$b}        #   followed by corresponding close bracket
            &amp;lt;self&amp;gt;              #   followed by a balanced expr
        ]
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-164-html-id-rfc-164-replace-m-s-and-tr-with-match-subst-and-trade-rfc-164-replace-m-s-and-tr-with-match-subst-and-code-trade-code-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/164.html&#34; id=&#34;rfc 164: replace =~, !~, m//, s///, and tr// with match(), subst(), and trade()&#34;&gt;RFC 164: Replace =~, !~, m//, s///, and tr// with match(), subst(), and &lt;code&gt;trade()&lt;/code&gt;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;All operators will have a way to name them, which means it&amp;rsquo;s possible to alias them to any other name. Rearranging the formal order of parameters would be a little harder, however. We need inlining to do that efficiently. Still, now that &lt;code&gt;//&lt;/code&gt; doesn&amp;rsquo;t evaluate in a typeless context, it&amp;rsquo;s relatively straightforward to define a subroutine or method that does&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    subst $string, /foo/, {&amp;quot;bar&amp;quot;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in whatever order you like.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-197-html-id-rfc-197-numeric-value-ranges-in-regular-expressions-rfc-197-numeric-value-ranges-in-regular-expressions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/197.html&#34; id=&#34;rfc 197: numeric value ranges in regular expressions&#34;&gt;RFC 197: Numeric Value Ranges In Regular Expressions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;If we go down this road, eventually we reinvent all of Perl syntax in regular expressions. Not that I&amp;rsquo;m against TMTOWTDI, but I&amp;rsquo;d rather have a better way to run Perl code from within a regex and have it &amp;ldquo;succeed&amp;rdquo; or &amp;ldquo;fail&amp;rdquo;, and maybe better ways to test ranges from Perl code. Anything beyond that could be done with syntactic warpage.&lt;/p&gt;

&lt;p&gt;In any event, overloading &lt;code&gt;()&lt;/code&gt; and &lt;code&gt;[]&lt;/code&gt; for this would be mentally treacherous, not to mention completely opaque to non-mathematicians. We&amp;rsquo;ll stick with the standard boolean assertion:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\d+) &amp;lt;( $1 =~ 1..10 )&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Interestingly, that can also be written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / &amp;lt;( _/\d+/ =~ 1..10 )&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-198-html-id-rfc-198-boolean-regexes-rfc-198-boolean-regexes-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/198.html&#34; id=&#34;rfc 198: boolean regexes&#34;&gt;RFC 198: Boolean Regexes&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Again, I&amp;rsquo;m not much in favor of inventing new regex syntax that duplicates ordinary Perl syntax. I think we need richer ways of interconnecting related regexes via ordinary Perl syntax. Certainly it helps to have an easy way to specify a Perl assertion:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    / (\w+) &amp;lt;( %count{$1} &amp;gt; 3 )&amp;gt; /
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there&amp;rsquo;s something to be said for forcing submatch assertions to be defined externally to the current regex, much like we discourage inline code where subroutine calls are in order.&lt;/p&gt;

&lt;p&gt;So anyway, I think most of the submatches like onion rings should be handled simply by searching on captured strings within a closure. Booleans can be put into closures as well, but the new &lt;code&gt;::&lt;/code&gt; operator makes it pretty easy to AND and OR assertions together in a more regexly fashion without reinventing the wheel.&lt;/p&gt;

&lt;p&gt;As proposed, there will be a &amp;ldquo;fail&amp;rdquo; token, but it&amp;rsquo;s spelled &lt;code&gt;&amp;lt;fail&amp;gt;&lt;/code&gt;, not &lt;code&gt;\F&lt;/code&gt;. And the &amp;ldquo;true&amp;rdquo; token is spelled &lt;code&gt;&amp;lt;null&amp;gt;&lt;/code&gt;. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-261-html-id-rfc-261-pattern-matching-on-perl-values-rfc-261-pattern-matching-on-perl-values-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/261.html&#34; id=&#34;rfc 261: pattern matching on perl values&#34;&gt;RFC 261: Pattern matching on perl values&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This reminds me a bit of unification in Prolog. It&amp;rsquo;s not explained very well here, and I&amp;rsquo;m wondering if it will be too hard to explain in general. I think this is probably too powerful a concept for the typical Perl programmer, who is lucky to understand simple lvalues that always do what they&amp;rsquo;re told.&lt;/p&gt;

&lt;p&gt;This sort of matching can probably be provided as syntactic warpage, though I&amp;rsquo;m not sure if that prevents useful optimizations. Anyway, this sort of thing is unlikely to make it into the Perl 6 core unless it generalizes usefully to function argument lists, and it may be too powerful for there too. For that purpose it would resemble a form of overloading, but with the &amp;ldquo;types&amp;rdquo; specified by keys. I suspect real types are more useful.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-308-html-id-rfc-308-ban-perl-hooks-into-regexes-rfc-308-ban-perl-hooks-into-regexes-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/308.html&#34; id=&#34;rfc 308: ban perl hooks into regexes&#34;&gt;RFC 308: Ban Perl hooks into regexes&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We must be able to call back into Perl code if we want to write parsers conveniently in Perl. Think of how yacc works. Certainly the way that Perl 5 does it is ugly, I&amp;rsquo;ll admit. We can beautify that.&lt;/p&gt;

&lt;p&gt;But the whole point of Perl is to have all the most useful &amp;ldquo;Krakken tentacles&amp;rdquo;. And I don&amp;rsquo;t really care if it makes it hard to put the Perl regex engine into some other language. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-316-html-id-rfc-316-regex-modifier-for-support-of-chunk-processing-and-prefix-matching-rfc-316-regex-modifier-for-support-of-chunk-processing-and-prefix-matching-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/316.html&#34; id=&#34;rfc 316: regex modifier for support of chunk processing and prefix matching&#34;&gt;RFC 316: Regex modifier for support of chunk processing and prefix matching&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Infinite strings (via infinite arrays) seem like a more useful concept. It would be easy for the extension subroutine to fail and produce the results desired in this RFC, but without the necessity of the extra syntax specified by the RFC. A match naturally fails when it gets to the end of its string without finishing the pattern. Incremental matching can also easily be done via infinite strings, and the user interface can be a simple as we like, as long as extension rule is somehow associated with the string in question.&lt;/p&gt;

&lt;p&gt;I think &lt;code&gt;pos()&lt;/code&gt; is rather too low-level a concept for general use. Certainly it needs to be there, but I think we need some way of implying that one regex is a continuation of a previous one, but within some higher-level syntactic construct, so that it&amp;rsquo;s easy to write parsers without invoking &lt;code&gt;pos()&lt;/code&gt; or &lt;code&gt;\g&lt;/code&gt; or &lt;code&gt;/c&lt;/code&gt; all over the place.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-cut-cut-span&#34;&gt;&lt;span id=&#34;&lt;cut&gt;&amp;rdquo;&amp;gt;&lt;code&gt;&amp;lt;cut&amp;gt;&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Well, I could say a lot more, but that&amp;rsquo;s it for this time. I hope you&amp;rsquo;re excited by all this, in a positive sort of way. But if your jaw lost all of its bounce when it hit the table, I expect Damian&amp;rsquo;s upcoming Exegesis 5 will do a better job of showing how this all fits together into a pretty picture.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apocalypse 4</title>
      <link>http://localhost:1313/pub/2002/01/15/apo4.html/</link>
      <pubDate>Tue, 15 Jan 2002 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2002/01/15/apo4.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;header&#34;&gt;&lt;/span&gt;&lt;/strong&gt;
Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;strong&gt;&lt;span class=&#34;secondary&#34;&gt; &lt;/span&gt;&lt;/strong&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=2#accepted%20rfcs&#34;&gt;Accepted RFCs&lt;/a&gt;
&lt;span class=&#34;smalltext&#34;&gt; &lt;/span&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=2#rfc%20022:%20control%20flow:%20builtin%20switch%20statement&#34;&gt;RFC 022: Control flow: Builtin switch statement&lt;/a&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=2#table%201:%20matching%20a%20switch%20value%20against%20a%20case%20value&#34;&gt;Table 1: Matching a switch value against a case value&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=3#rfc%20088:%20omnibus%20structured%20exception/error%20handling%20mechanism&#34;&gt;RFC 088: Omnibus Structured Exception/Error Handling Mechanism&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=6#rfc%20199:%20shortcircuiting%20builtin%20functions%20and%20userdefined%20subroutines&#34;&gt;RFC 199: Short-circuiting built-in functions and user-defined subroutines&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=6#rfc%20006:%20lexical%20variables%20made%20default&#34;&gt;RFC 006: Lexical variables made default&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=6#rfc%20330:%20global%20dynamic%20variables%20should%20remain%20the%20default&#34;&gt;RFC 330: Global dynamic variables should remain the default&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=6#rfc%20083:%20make%20constants%20look%20like%20variables&#34;&gt;RFC 083: Make constants look like variables&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=6#rfc%20337:%20common%20attribute%20system%20to%20allow%20userdefined,%20extensible%20attributes&#34;&gt;RFC 337: Common attribute system to allow user-defined, extensible attributes&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=7#rfc%20173:%20allow%20multiple%20loop%20variables%20in%20foreach%20statements&#34;&gt;RFC 173: Allow multiple loop variables in foreach statements&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=7#rfc%20019:%20rename%20the%20local%20operator&#34;&gt;RFC 019: Rename the local operator&lt;/a&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=7#rfc%20064:%20new%20pragma%20&amp;#39;scope&amp;#39;%20to%20change%20perl&amp;#39;s%20default%20scoping&#34;&gt;RFC 064: New pragma &#39;scope&#39; to change Perl&#39;s default scoping&lt;/a&gt;
&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;&lt;/strong&gt; &lt;/span&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rejected%20rfcs&#34;&gt;Rejected RFCs&lt;/a&gt;
&lt;span class=&#34;smalltext&#34;&gt; &lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20089:%20controllable%20data%20typing&#34;&gt;RFC 089: Controllable Data Typing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20106:%20yet%20another%20lexical%20variable%20proposal:%20lexical%20variables%20made%20default&#34;&gt;RFC 106: Yet another lexical variable proposal: lexical variables made default&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20119:%20object%20neutral%20error%20handling%20via%20exceptions&#34;&gt;RFC 119: Object neutral error handling via exceptions&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20120:%20implicit%20counter%20in%20for%20statements,%20possibly%20$#.&#34;&gt;RFC 120: Implicit counter in for statements, possibly $#.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20262:%20index%20attribute&#34;&gt;RFC 262: Index Attribute&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20167:%20simplify%20do%20block%20syntax&#34;&gt;RFC 167: Simplify do BLOCK Syntax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20209:%20fuller%20integer%20support%20in%20perl.&#34;&gt;RFC 209: Fuller integer support in Perl.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20279:%20my()%20syntax%20extensions%20and%20attribute%20declarations&#34;&gt;RFC 279: &lt;code&gt;my()&lt;/code&gt; syntax extensions and attribute declarations&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20297:%20attributes%20for%20compiler%20hints&#34;&gt;RFC 297: Attributes for compiler hints&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20309:%20allow%20keywords%20in%20sub%20prototypes&#34;&gt;RFC 309: Allow keywords in sub prototypes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20340:%20with%20takes%20a%20context&#34;&gt;RFC 340: with takes a context&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=8#rfc%20342:%20pascallike%20with&#34;&gt;RFC 342: Pascal-like &amp;quot;with&amp;quot;&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;&lt;/strong&gt; &lt;/span&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#withdrawn%20rfcs&#34;&gt;Withdrawn RFCs&lt;/a&gt;
&lt;span class=&#34;smalltext&#34;&gt; &lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#rfc%20063:%20exception%20handling%20syntax&#34;&gt;RFC 063: Exception handling syntax&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#rfc%20113:%20better%20constants%20and%20constant%20folding&#34;&gt;RFC 113: Better constants and constant folding&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
&lt;span class=&#34;secondary&#34;&gt; &lt;strong&gt;&lt;/strong&gt; &lt;/span&gt;
&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#other%20decisions&#34;&gt;Other decisions&lt;/a&gt;
&lt;span class=&#34;smalltext&#34;&gt; &lt;/span&gt;
&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#cstyle%20for%20loop&#34;&gt;C-style for loop&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#cstyle%20do%20%7B%7D%20while%20expr%20no%20longer%20supported&#34;&gt;C-style do {} while EXPR no longer supported&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#bare%20blocks&#34;&gt;Bare blocks&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2002/01/15/apo4.html?page=9#continue%20block&#34;&gt;continue block&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt; &lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This Apocalypse is all about syntax in the large. The corresponding chapter in the Camel book is entitled &amp;ldquo;Statements and Declarations&amp;rdquo;, but it could just as easily have been entitled, &amp;ldquo;All About Blocks&amp;rdquo;. The basic underlying question is &amp;ldquo;What exactly do those curlies mean?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;For Perl 5 and earlier, the answer to that question was, &amp;ldquo;Too many things&amp;rdquo;. Or rather, too many things with inconsistent rules. We&amp;rsquo;ll continue to use curlies for much of what we&amp;rsquo;ve used them for up till now, but by making a few critical simplifications, the rules will be much more consistent. In particular, built-ins will parse with the same rules as user-defined constructs. It should be possible to make user-extensible syntax look just like built-in syntax. Perl 5 started down this road, but didn&amp;rsquo;t get all the way there. In Perl 6, all blocks operate under the same rules. Effectively, every block is a kind of closure that can be run by user-defined constructs as well as built-ins.&lt;/p&gt;

&lt;p&gt;Associated with block structure are the various constructs that make use of block structure. Compound constructs like loops and conditionals use blocks explicitly, whereas declarations refer to their enclosing block implicitly. This latter feature was also inconsistently applied in Perl 5. In Perl 6, the rule is simple: A lexically scoped declaration is in effect from the declaration to the end of its enclosing block. Since blocks are delimited &lt;em&gt;only&lt;/em&gt; by curlies or by the ends of the current compilation unit (file or string), that implies that we can&amp;rsquo;t allow multi-block constructs in which lexically scoped variables &amp;ldquo;leak&amp;rdquo; or &amp;ldquo;tunnel&amp;rdquo; from the end of one block to the beginning of the next. A right curly (without an intervening left curly) absolutely stops the current lexical scope. This has direct bearing on some of these RFCs. For instance, RFC 88 proposes to let lexical scope leak from a &lt;code&gt;try&lt;/code&gt; block into its corresponding &lt;code&gt;finally&lt;/code&gt; block. This will not be allowed. (We&amp;rsquo;ll find a different way to solve that particular issue.)&lt;/p&gt;

&lt;p&gt;While lexical declarations may not leak out of a block, control flow must be able to leak out of blocks in a controlled fashion. Obviously, falling off the end of a block is the most &amp;ldquo;normal&amp;rdquo; way, but we need to exit blocks in other &amp;ldquo;abnormal&amp;rdquo; ways as well. Perl 5 has several different ways of exiting a block: &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, &lt;code&gt;last&lt;/code&gt;, &lt;code&gt;redo&lt;/code&gt;, and &lt;code&gt;die&lt;/code&gt;, for instance. The problem is that these various keywords are hard-wired to transfer control outward to a particular built-in construct, such as a subroutine definition, a loop, or an &lt;code&gt;eval&lt;/code&gt;. That works against our unifying concept that every block is a closure. In Perl 6, all these abnormal means of block exit are unified under the concept of exceptions. A &lt;code&gt;return&lt;/code&gt; is a funny kind of exception that is trapped by a &lt;code&gt;sub&lt;/code&gt; block. A &lt;code&gt;next&lt;/code&gt; is an exception that is trapped by a loop block. And of course &lt;code&gt;die&lt;/code&gt; creates a &amp;ldquo;normal&amp;rdquo; exception that is trapped by any block that chooses to trap such exceptions. Perl 6 does not require that this block be an &lt;code&gt;eval&lt;/code&gt; or &lt;code&gt;try&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;You may think that this generalization implies excessive overhead, since generally exception handling must work its way up the call stack looking for an appropriate handler. But any control flow exception can be optimized away to a &amp;ldquo;goto&amp;rdquo; internally when its target is obvious and there are no user-defined blocks to be exited in between. Most subroutine return and loop control operators will know which subroutine or loop they&amp;rsquo;re exiting from because it&amp;rsquo;ll be obvious from the surrounding lexical scope. However, if the current subroutine contains closures that are being interpreted elsewhere in user-defined functions, it&amp;rsquo;s good to have the general exception mechanism so that all needed cleanup can be automatically accomplished and consistent semantics maintained. That is, we want user-defined closure handlers to stay out of the user&amp;rsquo;s face in the same way that built-ins do. Control flow should pretend to work like the user expects, even when it doesn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;Here are the RFCs covered in this Apocalypse. PSA stands for &amp;ldquo;problem, solution, acceptance&amp;rdquo;, my private rating of how this RFC will fit into Perl 6. Interestingly, this time I&amp;rsquo;ve rejected more RFCs than I accepted. I must be getting cruel and callous in my old age. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RFC   PSA    Title
    ---   ---    -----
    006   acc    Lexical variables made default
    019   baa    Rename the C&amp;lt;local&amp;gt; operator
    022   abc    Control flow: Builtin switch statement
    063   rr     Exception handling syntax
    064   bdc    New pragma &#39;scope&#39; to change Perl&#39;s default scoping
    083   aab    Make constants look like variables
    088   bbc    Omnibus Structured Exception/Error Handling Mechanism
    089   cdr    Controllable Data Typing
    106   dbr    Yet another lexical variable proposal: lexical variables made default
    113   rr     Better constants and constant folding
    119   bcr    Object neutral error handling via exceptions
    120   bcr    Implicit counter in for statements, possibly $#   
    167   bcr    Simplify do BLOCK Syntax
    173   bcc    Allow multiple loop variables in foreach statements
    199   abb    Short-circuiting built-in functions and user-defined subroutines
    209   cdr    Fuller integer support in Perl   
    262   cdr    Index Attribute
    279   cdr    my() syntax extensions and attribute declarations
    297   dcr    Attributes for compiler hints
    309   adr    Allow keywords in sub prototypes
    330   acc    Global dynamic variables should remain the default
    337   bcc    Common attribute system to allow user-defined, extensible attributes
    340   dcr    with takes a context
    342   bcr    Pascal-like &amp;quot;with&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-accepted-rfcs-accepted-rfcs-span&#34;&gt;&lt;span id=&#34;accepted rfcs&#34;&gt;Accepted RFCs&lt;/span&gt;&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Previous Apocalypses&lt;/p&gt;
&lt;p&gt;• &lt;a href=&#34;http://localhost:1313/pub/2001/04/02/wall.html&#34;&gt;Apocalypse One&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/05/03/wall.html&#34;&gt;Apocalypse Two&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html&#34;&gt;Apocalypse Three&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Note that, although these RFCs are in the &amp;ldquo;accepted&amp;rdquo; category, most are accepted with major caveats (a &amp;ldquo;&lt;code&gt;c&lt;/code&gt;&amp;rdquo; acceptance rating), or at least some &amp;ldquo;buts&amp;rdquo; (a &amp;ldquo;&lt;code&gt;b&lt;/code&gt;&amp;rdquo; rating). I&amp;rsquo;ll try to list all those caveats here, but where there are systematic changes, I may indicate these generally in this document without attempting to rewrite the RFC in every detail. Those who implement these features must be sensitive to these systematic changes and not just uncritically implement everything the RFC says.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d like to talk about exceptions first, but before that I have to deal with the switch statement, because I think it&amp;rsquo;s silly not to unify exception handlers with switch statements.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-22-html-id-rfc-022-control-flow-builtin-switch-statement-rfc-022-control-flow-builtin-switch-statement-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/22.html&#34; id=&#34;rfc 022: control flow: builtin switch statement&#34;&gt;RFC 022: Control flow: Builtin switch statement&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Some OO purists say that any time you want to use a switch statement, you ought to make the discriminant of the switch statement into a type, and use method dispatch instead. Fortunately, we are not OO purists here, so forget that argument.&lt;/p&gt;

&lt;p&gt;Another argument against having a switch statement in Perl 6 is that we never had it in the first five versions of Perl. But it would be incorrect to say that we didn&amp;rsquo;t miss it. What actually happened was that every time we started discussing how to add a switch statement, it wasn&amp;rsquo;t obvious how far to go. A switch statement in Perl ought to do more than a switch statement in C (or in most any other language, for that matter). So the fact that we haven&amp;rsquo;t added a switch statement so far says more about how hard it is to design a good one than about how much we wanted a lousy one. Eventually the ever inventive Damian Conway came up with his famous design, with a Perl 5 module as proof of concept, and pretty much everyone agreed that he was on the right track, for some definition of &amp;ldquo;right&amp;rdquo; (and &amp;ldquo;track&amp;rdquo;). This RFC is essentially that design (not surprisingly, since Damian wrote it), so it will be accepted, albeit with several tweaks.&lt;/p&gt;

&lt;p&gt;In the first place, as a quasi-linguist, I loathe the keywords &lt;code&gt;switch&lt;/code&gt; and &lt;code&gt;case&lt;/code&gt;. I would prefer keywords that read better in English. Much as I love verbing nouns, they don&amp;rsquo;t work as well as real verbs or real prepositions when topicalizers are called for. After thrashing over several options with Damian and other folks, we&amp;rsquo;ve settled on using &lt;code&gt;given&lt;/code&gt; instead of &lt;code&gt;switch&lt;/code&gt;, and &lt;code&gt;when&lt;/code&gt; instead of &lt;code&gt;case&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given EXPR {
        when EXPR { ... }
        when EXPR { ... }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The other great advantage of using different words is that people won&amp;rsquo;t expect it to work exactly like any other switch statement they may be familiar with.&lt;/p&gt;

&lt;p&gt;That being said, I should point out that it is still called &amp;ldquo;the switch statement&amp;rdquo;, and the individual components are still &amp;ldquo;cases&amp;rdquo;. But you don&amp;rsquo;t have to put &amp;ldquo;switch&amp;rdquo; or &amp;ldquo;case&amp;rdquo; into constant-width font, because they&amp;rsquo;re not keywords.&lt;/p&gt;

&lt;p&gt;Because curlies are so extremely overloaded in Perl 5, I was at first convinced that we would need a separator of some sort between the expression and the block, maybe a &lt;code&gt;:&lt;/code&gt; or &lt;code&gt;=&lt;/code&gt;``&amp;gt; or some such. Otherwise it would be too ambigous to come upon a left curly when expecting an operator&amp;ndash;it would be interpreted as a hash subscript instead. Damian&amp;rsquo;s RFC proposes to require parentheses in certain situations to disambiguate the expression.&lt;/p&gt;

&lt;p&gt;But I&amp;rsquo;ve come to the conclusion that I&amp;rsquo;d rather screw around (a little) with the &amp;ldquo;insignificant whitespace&amp;rdquo; rule than to require an extra unnatural delimiter. If we observe current practice, we note that 99% of the time, when people write a hash subscript they do so without any whitespace before it. And 99% of the time, when they write a block, they do put some whitespace in front of it. So we&amp;rsquo;ll just dwim it using the whitespace. (No, we&amp;rsquo;re not going all the way to whole-hog whitespace dwimmery&amp;ndash;Python will remain the best/worst example of that approach.)&lt;/p&gt;

&lt;p&gt;Subscripts are the only valid use of curlies when an operator is expected. (That is, subscripts are essentially postfix operators.) In contrast, hash composers and blocks are terms, not operators. Therefore, we will make the rule that a left curly that has whitespace in front of it will never be interpreted as a subscript in Perl 6. (If you think this is totally bizarre thing to do, consider that this new approach is actually consistent with how Perl 5 already parses variables within interpolated strings.) If there is any space before the curly, we force it to start a term, not an operator, which means that the curlies in question must delimit either a hash composer or a block. And it&amp;rsquo;s a hash composer only if it contains a &lt;code&gt;=&lt;/code&gt;`&lt;code&gt;&amp;amp;gt; pair constructor at the top level (or an explicit&lt;/code&gt;hash` keyword on the front.) Therefore it&amp;rsquo;s possible to unambiguously terminate an expression by following it with a block, as in the constructs above.&lt;/p&gt;

&lt;p&gt;Interestingly, this one tweak to the whitespace rule also means that we&amp;rsquo;ll be able to simplify the parentheses out of other similar built-in constructs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if $foo { ... }
    elsif $bar { ... }
    else { ... }

    while $more { ... }

    for 1..10 { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I think throwing out two required punctuation characters for one required whitespace is an excellent trade in terms of readability, particularly when it already matches common practice. (You can still put in the parens if you want them, of course, just for old times&amp;rsquo; sake.) This tweak also allows greater flexibility in how user-defined constructs are parsed. If you want to define your own constructs, they should be able to follow the same syntax rules as built-ins.&lt;/p&gt;

&lt;p&gt;By a similar chain of logic (or illogic), I also want to tweak the whitespace rules for the trailing curly. There are severe problems in any C-derived language that allows user-defined constructs containing curlies (as Perl does). Even C doesn&amp;rsquo;t entirely escape the head-scratching puzzle of &amp;ldquo;When do I put a semicolon after a curly?&amp;rdquo; A &lt;code&gt;struct&lt;/code&gt; definition requires a terminating semicolon, for instance, while an &lt;code&gt;if&lt;/code&gt; or a &lt;code&gt;while&lt;/code&gt; doesn&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;In Perl, this problem comes up most often when people say &amp;ldquo;Why do I have to put a semicolon after &lt;code&gt;do {}&lt;/code&gt; or &lt;code&gt;eval {}&lt;/code&gt; when it looks like a complete statement?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Well, in Perl 6, you don&amp;rsquo;t, if the final curly is on a line by itself. That is, if you use an expression block as if it were a statement block, it behaves as one. The win is that these rules are consistent across all expression blocks, whether user-defined or built-in. Any expression block construct can be treated as either a statement or a component of an expression. Here&amp;rsquo;s a block that is being treated as a term in an expression:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $x = do {
        ...
    } + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, if you write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $x = do {
        ...
    }
    + 1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the + will be taken erroneously as the start of a new statement. (So don&amp;rsquo;t do that.)&lt;/p&gt;

&lt;p&gt;Note that this special rule only applies to constructs that take a block (that is, a closure) as their last (or only) argument. Operators like &lt;code&gt;sort&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; are unaffected. However, certain constructs that used to be in the statement class may become expression constructs in Perl 6. For instance, if we change &lt;code&gt;BEGIN&lt;/code&gt; to an expression construct we can now use a &lt;code&gt;BEGIN&lt;/code&gt; block inside an expression to force compile-time evaluation of a non-static expression:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $value = BEGIN { call_me_once() } + call_me_again();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, a one-line &lt;code&gt;BEGIN&lt;/code&gt; would then have to have a semicolon.&lt;/p&gt;

&lt;p&gt;Anyway, back to switch statements. Damian&amp;rsquo;s RFC proposes various specific kinds of dwimmery, and while some of those dwims are spot on, others may need adjustment. In particular, there is an assumption that the programmer will know when they&amp;rsquo;re dealing with an object reference and when they&amp;rsquo;re not. But everything will be an object reference in Perl 6, at some level or other. The underlying characteristics of any object are most generally determined by the answer to the question, &amp;ldquo;What methods does this object respond to?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Unfortunately, that&amp;rsquo;s a run-time question in general. But in specific, we&amp;rsquo;d like to be able to optimize many of these switch statements at compile time. So it may be necessary to supply typological hints in some cases to do the dwimmery efficiently. Fortunately, most cases are still fairly straightforward. A &lt;code&gt;1&lt;/code&gt; is obviously a number, and a &lt;code&gt;&amp;quot;foo&amp;quot;&lt;/code&gt; is obviously a string. But unary &lt;code&gt;+&lt;/code&gt; can force anything to a number, and unary &lt;code&gt;_&lt;/code&gt; can force anything to a string. Unary &lt;code&gt;?&lt;/code&gt; can force a boolean, and unary &lt;code&gt;.&lt;/code&gt; can force a method call. More complicated thoughts can be represented with closure blocks.&lt;/p&gt;

&lt;p&gt;Another thing that needs adjustment is that the concept of &amp;ldquo;isa&amp;rdquo; matching seems to be missing, or at least difficult to express. We need good &amp;ldquo;isa&amp;rdquo; matching to implement good exception handling in terms of the switch mechanism. This means that we need to be able to say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $! {
        when Error::Overflow { ... }
        when Error::Type { ... }
        when Error::ENOTTY { ... }
        when /divide by 0/ { ... }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and expect it to check &lt;code&gt;$!.isa(Error::Overflow)&lt;/code&gt; and such, along with more normal pattern matching. In the case of the actual exception mechanism, we won&amp;rsquo;t use the keyword &lt;code&gt;given&lt;/code&gt;, but rather &lt;code&gt;CATCH&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when Error::Overflow { ... }
        when Error::Type { ... }
        when Error::ENOTTY { ... }
        when /divide by 0/ { ... }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;CATCH&lt;/code&gt; is a &lt;code&gt;BEGIN&lt;/code&gt;-like block that can turn any block into a &amp;ldquo;try&amp;rdquo; block from the inside out. But the insides of the &lt;code&gt;CATCH&lt;/code&gt; are an ordinary switch statement, where the discriminant is simply the current exception object, &lt;code&gt;$!&lt;/code&gt;. More on that later&amp;ndash;see RFC 88 below.&lt;/p&gt;

&lt;p&gt;Some of you may recall that I&amp;rsquo;ve stated that Perl 6 will have no barewords. That&amp;rsquo;s still the case. A token like &lt;code&gt;Error::Overflow&lt;/code&gt; is not a bareword because it&amp;rsquo;s a declared class. Perl 6 recognizes package names as symbolic tokens. So when you call a class method as &lt;code&gt;Class::Name.method()&lt;/code&gt;, the &lt;code&gt;Class::Name&lt;/code&gt; is actually a class object (that just happens to stringify to &amp;ldquo;&lt;code&gt;Class::Name&lt;/code&gt;&amp;rdquo;). But the class method can be called without a symbolic lookup on the package name at run time, unlike in Perl 5.&lt;/p&gt;

&lt;p&gt;Since &lt;code&gt;Error::Overflow&lt;/code&gt; is just such a class object, it can be distinguished from other kinds of objects in a switch statement, and an &amp;ldquo;isa&amp;rdquo; can be inferred. It would be nice if we could go as far as to say that any object can be called with any class name as a method name to determine whether it &amp;ldquo;isa&amp;rdquo; member of that class, but that could interfere with use of class name methods to implement casting or construction. So instead, since switch statements are into heavy dwimmery anyway, I think the switch statement will have to recognize any &lt;code&gt;Class::Name&lt;/code&gt; known at compile time, and force it to call &lt;code&gt;$!.isa(Class::Name)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Another possible adjustment will involve the use of switch statements as a means of parallelizing regular expression evaluation. Specifically, we want to be able to write parsers easily in Perl, which means that we need some way of matching a token stream against something like a set of regular expressions. You can think of a token stream as a funny kind of string. So if the &amp;ldquo;given&amp;rdquo; of a switch statement is a token stream, the regular expressions matched against it may have special abilities relating to the current parse&amp;rsquo;s data structure. All the regular expressions of such a switch statement will likely be implicitly anchored to the current parse location, for instance. There may be special tokens referring to terminals and non-terminals. Basically, think of something like a yacc grammar, where alternative pattern/action grammar rules are most naturally expressed via switch statement cases. More on that in the next Apocalypse.&lt;/p&gt;

&lt;p&gt;Another possible adjustment is that the proposed &lt;code&gt;else&lt;/code&gt; block could be considered unnecessary. The code following the final &lt;code&gt;when&lt;/code&gt; is automatically an &amp;ldquo;else&amp;rdquo;. Here&amp;rsquo;s a duodecimal digit converter:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $result = given $digit {
        when &amp;quot;T&amp;quot; { 10 }
        when &amp;quot;E&amp;quot; { 11 }
        $digit;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Nevertheless, it&amp;rsquo;s probably good documentation to line up all the blocks, which means it would be good to have a keyword. However, for reasons that will become clearer when we talk about exception handlers, I don&amp;rsquo;t want to use &lt;code&gt;else&lt;/code&gt;. Also, because of the identification of &lt;code&gt;when&lt;/code&gt; and &lt;code&gt;if&lt;/code&gt;, it would not be clear whether an &lt;code&gt;else&lt;/code&gt; should automatically supply a &lt;code&gt;break&lt;/code&gt; at the end of its block as the ordinary &lt;code&gt;when&lt;/code&gt; case does.&lt;/p&gt;

&lt;p&gt;So instead of &lt;code&gt;else&lt;/code&gt;, I&amp;rsquo;d like to borrow a bit more from C and use &lt;code&gt;default&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $result = given $digit {
        when &amp;quot;T&amp;quot; { 10 }
        when &amp;quot;E&amp;quot; { 11 }
        default  { $digit }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unlike in C, the &lt;code&gt;default&lt;/code&gt; case must come last, since Perl&amp;rsquo;s cases are evaluated (or at least pretend to be evaluated) in order. The optimizer can often determine which cases can be jumped to directly, but in cases where that can&amp;rsquo;t be determined, the cases are evaluated in order much like cascaded &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elsif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt; conditions. Also, it&amp;rsquo;s allowed to intersperse ordinary code between the cases, in which case the code must be executed only if the cases above it fail to match. For example, this should work as indicated by the print statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $given {
        print &amp;quot;about to check $first&amp;quot;;
        when $first { ... }
        print &amp;quot;didn&#39;t match $first; let&#39;s try $next&amp;quot;;
        when $next { ... }
        print &amp;quot;giving up&amp;quot;;
        default { ... }
        die &amp;quot;panic: shouldn&#39;t see this&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can still define &lt;code&gt;when&lt;/code&gt; as a variant of &lt;code&gt;if&lt;/code&gt;, which makes it possible to intermix the two constructs when (or if) that is desirable. So we&amp;rsquo;ll leave that identity in&amp;ndash;it always helps people think about it when you can define a less familiar construct in terms of a more familiar one. However, the &lt;code&gt;default&lt;/code&gt; isn&amp;rsquo;t quite the same as an &lt;code&gt;else&lt;/code&gt;, since &lt;code&gt;else&lt;/code&gt; can&amp;rsquo;t stand on its own. A &lt;code&gt;default&lt;/code&gt; is more like an &lt;code&gt;if&lt;/code&gt; that&amp;rsquo;s always true. So the above code is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $given {
        print &amp;quot;about to check $first&amp;quot;;
        if $given =~ $first { ...; break }
        print &amp;quot;didn&#39;t match $first; let&#39;s try $next&amp;quot;;
        if $given =~ $next { ...; break }
        print &amp;quot;giving up&amp;quot;;
        if 1 { ...; break; }
        die &amp;quot;panic: shouldn&#39;t see this&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We do need to rewrite the relationship table in the RFC to handle some of the tweaks and simplifications we&amp;rsquo;ve mentioned. The comparison of bare refs goes away. It wasn&amp;rsquo;t terribly useful in the first place, since it only worked for scalar refs. (To match identities we&amp;rsquo;ll need an explicit &lt;code&gt;.id&lt;/code&gt; method in any event. We won&amp;rsquo;t be relying on the default numify or stringify methods to produce unique representations.)&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve rearranged the table to be applied in order, so that default interpretations come later. Also, the &amp;ldquo;Matching Code&amp;rdquo; column in the RFC gave alternatives that aren&amp;rsquo;t resolved. In these cases I&amp;rsquo;ve chosen the &amp;ldquo;true&amp;rdquo; definition rather than the &amp;ldquo;exists&amp;rdquo; or &amp;ldquo;defined&amp;rdquo; definition. (Except for certain set manipulations with hashes, people really shouldn&amp;rsquo;t be using the defined/undefined distinction to represent true and false, since both true and false are considered defined concepts in Perl.)&lt;/p&gt;

&lt;p&gt;Some of the table entries distinguish an array from a list. Arrays look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when [1, 3, 5, 7, 9] { &amp;quot;odd digit intersection&amp;quot; }
    when @array          { &amp;quot;array intersection&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;while a list looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when 1, 3, 5, 7, 9    { &amp;quot;odd digit&amp;quot; }
    when @foo, @bar, @baz { &amp;quot;intersection with at least one array&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Ordinarily lists and arrays would mean the same thing in scalar context, but &lt;code&gt;when&lt;/code&gt; is special in differentiating explicit arrays from lists. Within a &lt;code&gt;when&lt;/code&gt;, a list is a recursive disjunction. That is, the comma-separated values are treated as individual cases OR-ed together. We could use some other explicit notation for disjunction such as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when any(1, 3, 5, 7, 9) { &amp;quot;odd&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that seems a lot of trouble for a very common case of case, as it were. We could use vertical bars as some languages do, but I think the comma reads better.&lt;/p&gt;

&lt;p&gt;Anyway, here&amp;rsquo;s another simplification. The following table will &lt;em&gt;also&lt;/em&gt; define how the Perl 6 &lt;code&gt;=~&lt;/code&gt; operator works! That allows us to use a recursive definition to handle matching against a disjunctive list of cases. (See the first entry in the table below.) Of course, for precedence reasons, to match a list of things using &lt;code&gt;=~&lt;/code&gt; you&amp;rsquo;ll have to use parens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $digit =~ (1, 3, 5, 7, 9) and print &amp;quot;That&#39;s odd!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Alternatively, you can look at this table as the definition of the &lt;code&gt;=~&lt;/code&gt; operator, and then say that the switch statement is defined in terms of &lt;code&gt;=~&lt;/code&gt;. That is, for any switch statement of the form&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given EXPR1 {
        when EXPR2 { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s equivalent to saying this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (scalar(EXPR1)) {
        if ($_ =~ (EXPR2)) { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-table-1-matching-a-switch-value-against-a-case-value-table-1-matching-a-switch-value-against-a-case-value-span&#34;&gt;&lt;span id=&#34;table 1: matching a switch value against a case value&#34;&gt;Table 1: Matching a switch value against a case value&lt;/span&gt;&lt;/h4&gt;

&lt;pre&gt;&lt;code&gt;    $a      $b        Type of Match Implied    Matching Code
    ======  =====     =====================    =============

    expr    list      recursive disjunction    match if $a =~ any($b)
    list    list      recursive disjunction*   match if any($a) =~ any($b)

    hash    sub(%)    hash sub truth           match if $b(%$a)
    array   sub(@)    array sub truth          match if $b(@$a)
    expr    sub($)    scalar sub truth         match if $b($a)
    expr    sub()     simple closure truth*    match if $b()

    hash    hash      hash key intersection*   match if grep exists $a{$_}, $b.keys
    hash    array     hash value slice truth   match if grep {$a{$_}} @$b
    hash    regex     hash key grep            match if grep /$b/, keys %$a
    hash    scalar    hash entry truth         match if $a{$b}

    array   array     array intersection*      match if any(@$a) =~ any(@$b)
    array   regex     array grep               match if grep /$b/, @$a
    array   number    array entry truth        match if $a[$b]
    array   expr      array as list            match if any($a) =~ $b

    object  class     class membership         match if $a.isa($b)
    object  method    method truth             match if $a.$b()

    expr    regex     pattern match            match if $a =~ /$b/
    expr    subst     substitution match       match if $a =~ subst
    expr    number    numeric equality         match if $a == $b
    expr    string    string equality          match if $a eq $b
    expr    boolean   simple expression truth* match if $b
    expr    undef     undefined                match unless defined $a

    expr    expr      run-time guessing        match if ($a =~ $b) at runtime
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In order to facilitate optimizations, these distinctions are made syntactically at compile time whenever possible. For each comparison, the reverse comparison is also implied, so &lt;code&gt;$a&lt;/code&gt;/&lt;code&gt;$b&lt;/code&gt; can be thought of as either given/when or when/given. (We don&amp;rsquo;t reverse the matches marked with * are because it doesn&amp;rsquo;t make sense in those casees.)&lt;/p&gt;

&lt;p&gt;If type of match cannot be determined at compile time, the default is to try to apply the very same rules in the very same order at run time, using the actual types of the arguments, not their compile-time type appearance. Note that there are no run-time types corresponding to &amp;ldquo;method&amp;rdquo; or &amp;ldquo;boolean&amp;rdquo;. Either of those notions can be expressed at runtime as a closure, of course.&lt;/p&gt;

&lt;p&gt;In fact, whenever the default behavior is not what you intend, there are ways to force the arguments to be treated as you intend:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Intent      Natural           Forced
    ======      =======           ======
    array       @foo              [list] or @{expr}
    hash        %bar              {pairlist} or %{expr}
    sub(%)      { %^foo.aaa }     sub (%foo) { ... }
    sub(@)      { @^bar.bbb }     sub (@bar) { ... }
    sub($)      { $^baz.ccc }     sub ($baz) { ... }
    number      numeric literal   +expr int(expr) num(expr)
    string      string literal    _expr str(expr)
    regex       //, m//, qr//     /$(expr)/
    method      .foo(args)        { $_.$method(args) }
    boolean     $a == $b          ?expr or true expr or { expr }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A method must be written with a unary dot to distinguish it from other forms. The method may have arguments. In essence, when you write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    .foo(1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it is treated as if you wrote&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { $_.foo(1,2,3) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then the closure is evaluated for its truth.&lt;/p&gt;

&lt;p&gt;A class match works only if the class name is known at compile time. Use &lt;code&gt;.isa(&amp;quot;Class&amp;quot;)&lt;/code&gt; for more complicated situations.&lt;/p&gt;

&lt;p&gt;Boolean expressions are recognized at compile time by the presence of a top-level operator that is a comparison or logical operator. As the table shows, an argumentless closure (a &lt;code&gt;sub ()&lt;/code&gt;, that is) also functions as a boolean. However, it&amp;rsquo;s probably better documentation to use the &lt;code&gt;true&lt;/code&gt; function, which does the opposite of &lt;code&gt;not&lt;/code&gt;. (Or the unary &lt;code&gt;?&lt;/code&gt; operator, which does the opposite of unary &lt;code&gt;!&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;It might be argued that boolean expressions have no place here at all, and that you should use &lt;code&gt;if&lt;/code&gt; if that&amp;rsquo;s what you mean. (Or use a &lt;code&gt;sub()&lt;/code&gt; closure to force it to ignore the given.) However, the &amp;ldquo;comb&amp;rdquo; structure of a switch is an extremely readable way to write even ordinary boolean expressions, and rather than forcing people to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    anyblock {
        when { $a == 1 } { ... }
        when { $b == 2 } { ... }
        when { $c == 3 } { ... }
        default          { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;d rather they be able to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    anyblock {
        when $a == 1 { ... }
        when $b == 2 { ... }
        when $c == 3 { ... }
        default      { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This also fits better into the use of &amp;ldquo;when&amp;rdquo; within &lt;code&gt;CATCH&lt;/code&gt; blocks:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when $!.tag eq &amp;quot;foo&amp;quot; { ... }
        when $!.tag eq &amp;quot;bar&amp;quot; { ... }
        default              { die }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To force all the &lt;code&gt;when&lt;/code&gt; clauses to be interpreted as booleans without using a boolean operator on every case, simply provide an empty given, to be read as &amp;ldquo;given nothing&amp;hellip;&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given () {
        when $a.isa(Ant) { ... }
        when $b.isa(Bat) { ... }
        when $c.isa(Cat) { ... }
        default          { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;when&lt;/code&gt; can be used by other topicalizers than just &lt;code&gt;given&lt;/code&gt;. Just as &lt;code&gt;CATCH&lt;/code&gt; will imply a given of &lt;code&gt;$!&lt;/code&gt;, a &lt;code&gt;for&lt;/code&gt; loop (the &lt;code&gt;foreach&lt;/code&gt; variety) will also imply a given of the loop variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @foo {
        when 1   { ... }
        when 2   { ... }
        when &amp;quot;x&amp;quot; { ... }
        default  { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By symmetry, a &lt;code&gt;given&lt;/code&gt; will by default alias &lt;code&gt;$_&lt;/code&gt; to the &amp;ldquo;given&amp;rdquo;. Basically, the only difference between a &lt;code&gt;given&lt;/code&gt; and a &lt;code&gt;for&lt;/code&gt; is that a &lt;code&gt;given&lt;/code&gt; takes a scalar expression, while a &lt;code&gt;for&lt;/code&gt; takes a pre-flattened list and iterates over it.&lt;/p&gt;

&lt;p&gt;Suppose you want to preserve &lt;code&gt;$_&lt;/code&gt; and alias &lt;code&gt;$g&lt;/code&gt; to the value instead. You can say that like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $value -&amp;gt; $g {
        when 1 { /foo/ }
        when 2 { /bar/ }
        when 3 { /baz/ }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the same way, a loop&amp;rsquo;s values can be aliased to one or more loop variables.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @foo -&amp;gt; $a, $b {  # two at a time
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That works a lot like the definition of a subroutine call with two formal parameters, &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt;. (In fact, that&amp;rsquo;s precisely what it is.) You can use modifiers on the formal paramaters just as you would in a subroutine type signature. This implies that the aliases are automatically declared as &lt;code&gt;my&lt;/code&gt; variables. It also implies that you can modify the formal parameter with an &lt;code&gt;rw&lt;/code&gt; property, which allows you to modify the original elements of the array through the variable. The default loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @foo { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is really compiled down to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @foo -&amp;gt; $_ is rw { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since &lt;code&gt;for&lt;/code&gt; and &lt;code&gt;given&lt;/code&gt; work by passing arguments to a closure, it&amp;rsquo;s a small step to generalize that in the other direction. Any method definition is a topicalizer within the body of the method, and will assume a &amp;ldquo;given&amp;rdquo; of its &lt;code&gt;$self&lt;/code&gt; object (or whatever you have named it). Bare closures topicalize their first argument, implicitly aliasing it to &lt;code&gt;$_&lt;/code&gt; unless &lt;code&gt;$^a&lt;/code&gt; or some such is used. That is, if you say this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grep { $_ eq 3 } @list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s equivalent to this more explicit use of a curried function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grep { $^a eq 3 } @list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But even a &lt;code&gt;grep&lt;/code&gt; can use the aliasing syntax above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    grep -&amp;gt; $x { $x eq 3 } @list
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Outside the scope of any topicalizer, a &lt;code&gt;when&lt;/code&gt; will assume that its given was stored in &lt;code&gt;$_&lt;/code&gt; and will test implicitly against that variable. This allows you to use &lt;code&gt;when&lt;/code&gt; in your main loop, for instance, even if that main loop was supplied by Perl&amp;rsquo;s &lt;code&gt;-n&lt;/code&gt; or &lt;code&gt;-p&lt;/code&gt; switch. Whenever a loop is functioning as a switch, the break implied by finishing a case functions as a &lt;code&gt;next&lt;/code&gt;, not a &lt;code&gt;last&lt;/code&gt;. Use &lt;code&gt;last&lt;/code&gt; if that&amp;rsquo;s what you mean.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;when&lt;/code&gt; is the only defaulting construct that pays attention to the current topicalizer regardless of which variable it is associated with. All other defaulting constructs pay attention to a fixed variable, typically &lt;code&gt;$_&lt;/code&gt;. So be careful what you&amp;rsquo;re matching against if the given is aliased to something other than &lt;code&gt;$_&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $_ = &amp;quot;foo&amp;quot;;
    given &amp;quot;bar&amp;quot; -&amp;gt; $f {
        if /foo/   { ... } # true, matches against $_
        when /bar/ { ... } # true, matches against $f
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oh, one other tweak. The RFC proposes to overload &lt;code&gt;next&lt;/code&gt; to mean &amp;ldquo;fall through to the next case&amp;rdquo;. I don&amp;rsquo;t think this is wise, since we&amp;rsquo;ll often want to use loop controls within a switch statement. Instead, I think we should use &lt;code&gt;skip&lt;/code&gt; to do that. (To be read as &amp;ldquo;Skip to the next statement.&amp;rdquo;)&lt;/p&gt;

&lt;p&gt;Similarly, if we make a word to mean to explicitly break out of a topicalizer, it should not be &lt;code&gt;last&lt;/code&gt;. I&amp;rsquo;d suggest &lt;code&gt;break&lt;/code&gt;! It will, of course, be unnecessary to break out of the end of a &lt;code&gt;when&lt;/code&gt; case because the &lt;code&gt;break&lt;/code&gt; is implied. However, there are times when you might want to break out of a &lt;code&gt;when&lt;/code&gt; block early. Also, since we&amp;rsquo;re allowing &lt;code&gt;when&lt;/code&gt; modifiers that do not implicitly break, we could use an explicit break for that situation. You might see cases like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given $x {
        warn(&amp;quot;Odd value&amp;quot;)        when !/xxx/;
        warn(&amp;quot;No value&amp;quot;), break  when undef;

        when /aaa/ { break when 1; ... }
        when /bbb/ { break when 2; ... }
        when /ccc/ { break when 3; ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So it looks to me like we need a break.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-88-html-id-rfc-088-omnibus-structured-exception-error-handling-mechanism-rfc-088-omnibus-structured-exception-error-handling-mechanism-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/88.html&#34; id=&#34;rfc 088: omnibus structured exception/error handling mechanism&#34;&gt;RFC 088: Omnibus Structured Exception/Error Handling Mechanism&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC posits some requirements for exception handling (all of which I agree with), but I do have some additional requirements of my own:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The exception-catching syntax must be considered a form of switch statement.&lt;/li&gt;
&lt;li&gt;It should be easy to turn any kind of block into a &amp;ldquo;try&amp;rdquo; block, especially a subroutine.&lt;/li&gt;
&lt;li&gt;Even &lt;code&gt;try&lt;/code&gt;-less try blocks must also be able to specify mandatory cleanup on exit.&lt;/li&gt;
&lt;li&gt;It should be relatively easy to determine how much cleanup is necessary regardless of how a block was exited.&lt;/li&gt;
&lt;li&gt;It must be possible to base the operation of &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;next&lt;/code&gt;, and &lt;code&gt;last&lt;/code&gt; on exception handling.&lt;/li&gt;
&lt;li&gt;The cleanup mechanism should mesh nicely with the notions of post condition processing under design-by-contract.&lt;/li&gt;
&lt;li&gt;The exception-trapping syntax must not violate encapsulation of lexical scopes.&lt;/li&gt;
&lt;li&gt;At the same time, the exception-trapping syntax should not force declarations out of their natural scope.&lt;/li&gt;
&lt;li&gt;Non-linear control flow must stand out visually, making good use of block structure, indentation and even keyword case. &lt;code&gt;BEGIN&lt;/code&gt; and &lt;code&gt;END&lt;/code&gt; blocks are to be considered prior art.&lt;/li&gt;
&lt;li&gt;Non-yet-thrown exceptions must be a useful concept.&lt;/li&gt;
&lt;li&gt;Compatibility with the syntax of any other language is specifically NOT a goal.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;RFC 88 is massive, weighing in at more than 2400 lines. Annotating the entire RFC would make this Apocalypse far too big. (&amp;ldquo;Too late!&amp;rdquo; says Damian.) Nonetheless, I will take the approach of quoting various bits of the RFC and recasting those bits to work with my additional requirements. Hopefully this will convey my tweaks most succinctly.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what the RFC gives as its first example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    exception &#39;Alarm&#39;;

    try {
        throw Alarm &amp;quot;a message&amp;quot;, tag =&amp;gt; &amp;quot;ABC.1234&amp;quot;, ... ;
        }

    catch Alarm =&amp;gt; { ... }

    catch Error::DB, Error::IO =&amp;gt; { ... }

    catch $@ =~ /divide by 0/ =&amp;gt; { ... }

    catch { ... }

    finally { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s how I see that being written in Perl 6:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my class X::Alarm is Exception { }     # inner class syntax?

    try {
        throw X::Alarm &amp;quot;a message&amp;quot;, tag =&amp;gt; &amp;quot;ABC.1234&amp;quot;, ... ;

        CATCH {
            when X::Alarm             { ... }
            when Error::DB, Error::IO { ... }
            when /divide by 0/        { ... }
            default                   { ... }
        }
        POST { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The outer block does not have to be a &lt;code&gt;try&lt;/code&gt; block. It could be a subroutine, a loop, or any other kind of block, including an &lt;code&gt;eval&lt;/code&gt; string or an entire file. We will call such an outer block a try block, whether or not there is an explicit &lt;code&gt;try&lt;/code&gt; keyword.&lt;/p&gt;

&lt;p&gt;The biggest change is that the various handlers are moved inside of the try block. In fact, the &lt;code&gt;try&lt;/code&gt; keyword itself is mere documentation in our example, since the presence of a &lt;code&gt;CATCH&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt; block is sufficient to signal the need for trapping. Note that the &lt;code&gt;POST&lt;/code&gt; block is completely independent of the &lt;code&gt;CATCH&lt;/code&gt; block. (The &lt;code&gt;POST&lt;/code&gt; block has a corresponding &lt;code&gt;PRE&lt;/code&gt; block for design-by-contract programmers.) Any of these blocks may be placed anywhere in the surrounding block&amp;ndash;they are independent of the surrounding control flow. (They do have to follow any declarations they refer to, of course.) Only one &lt;code&gt;CATCH&lt;/code&gt; is allowed, but any number of &lt;code&gt;PRE&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; blocks. (In fact, we may well encourage ourselves to place &lt;code&gt;POST&lt;/code&gt; blocks near the constructors to be cleaned up after.) &lt;code&gt;PRE&lt;/code&gt; blocks within a particular try block are evaluated in order before anything else in the block. &lt;code&gt;POST&lt;/code&gt; blocks will be evaluated in reverse order, though order dependencies between &lt;code&gt;POST&lt;/code&gt; blocks are discouraged. &lt;code&gt;POST&lt;/code&gt; blocks are evaluated after everything else in the block, including any &lt;code&gt;CATCH&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;try {}&lt;/code&gt; without a &lt;code&gt;CATCH&lt;/code&gt; is equivalent to Perl 5&amp;rsquo;s &lt;code&gt;eval {}&lt;/code&gt;. (In fact, &lt;code&gt;eval&lt;/code&gt; will go back to evaluating only strings in Perl 6, and &lt;code&gt;try&lt;/code&gt; will evaluate only blocks.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;CATCH&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; blocks are naturally in the lexical scope of the try block. They may safely refer to lexically scoped variables declared earlier in the try block, even if the exception is thrown during the elaboration sequence. (The run-time system will guarantee that individual variables test as undefined (and hence false) before they are elaborated.)&lt;/p&gt;

&lt;p&gt;The inside of the &lt;code&gt;CATCH&lt;/code&gt; block is precisely the syntax of a switch statement. The discriminant of the switch statement is the exception object, &lt;code&gt;$!&lt;/code&gt;. Since the exception object stringifies to the error message, the &lt;code&gt;when /divide by 0/&lt;/code&gt; case need not be explicitly compared against &lt;code&gt;$!&lt;/code&gt;. Likewise, explicit mention of a declared class implies an &amp;ldquo;isa&amp;rdquo; lookup, another built-in feature of the new switch statement.&lt;/p&gt;

&lt;p&gt;In fact, a &lt;code&gt;CATCH&lt;/code&gt; of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH { 
        when xxx { ... }          # 1st case
        when yyy { ... }          # 2nd case
        ...                       # other cases, maybe a default
    }

 means something vaguely like:

    BEGIN {
        %MY.catcher = {
            given current_exception() -&amp;gt; $! {

                when xxx { ... }          # 1st case from above
                when yyy { ... }          # 2nd case from above
                ...                       # other cases, maybe a default

                die;            # rethrow $! as implicit default
            }
            $!.markclean;       # handled cleanly, in theory
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The unified &amp;ldquo;current exception&amp;rdquo; is &lt;code&gt;$!&lt;/code&gt;. Everywhere this RFC uses &lt;code&gt;$@&lt;/code&gt;, it should be read as &lt;code&gt;$!&lt;/code&gt; instead. (And the too-precious &lt;code&gt;@@&lt;/code&gt; goes away entirely in favor of an array stored internally to the &lt;code&gt;$!&lt;/code&gt; object that can be accessed as &lt;code&gt;@$!&lt;/code&gt; or &lt;code&gt;$![-1]&lt;/code&gt;.) (For the legacy Perl 5 parser, &lt;code&gt;$@&lt;/code&gt; and &lt;code&gt;$?&lt;/code&gt; will be emulated, but that will not be available to the Perl 6 parser.)&lt;/p&gt;

&lt;p&gt;Also note that the &lt;code&gt;CATCH&lt;/code&gt; block implicitly supplies a rethrow (the &lt;code&gt;die&lt;/code&gt; above) after the cases of the switch statement. This will not be reached if the user has supplied an explicit &lt;code&gt;default&lt;/code&gt; case, since the &lt;code&gt;break&lt;/code&gt; of that default case will always bypass the implicit &lt;code&gt;die&lt;/code&gt;. And if the switch rethrows the exception (either explicitly or implicitly), &lt;code&gt;$!&lt;/code&gt; is not marked as clean, since the &lt;code&gt;die&lt;/code&gt; will bypass the code that marks the exception as &amp;ldquo;cleanly caught&amp;rdquo;. It should be considered an invariant that any &lt;code&gt;$!&lt;/code&gt; in the normal control flow outside of a &lt;code&gt;CATCH&lt;/code&gt; is considered &amp;ldquo;cleanly caught&amp;rdquo;, according to the definition in the RFC. Unclean exceptions should only be seen inside &lt;code&gt;CATCH&lt;/code&gt; blocks, or inside any &lt;code&gt;POST&lt;/code&gt; blocks that have to execute while an exception is propagating to an outer block because the current try block didn&amp;rsquo;t handle it. (If the current try block does successfully handle the exception in its &lt;code&gt;CATCH&lt;/code&gt;, any &lt;code&gt;POST&lt;/code&gt; blocks at the same level see a &lt;code&gt;$!&lt;/code&gt; that is already marked clean.)&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;code&gt;eval {die &amp;quot;Can&#39;t foo.&amp;quot;}; print $@;&lt;/code&gt; &lt;em&gt;continues to work as before.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;That will instead look like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { die &amp;quot;Can&#39;t foo&amp;quot; }; print $!;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in Perl 6. A &lt;code&gt;try&lt;/code&gt; with no &lt;code&gt;CATCH&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... CATCH { default { } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(And that&amp;rsquo;s another reason I didn&amp;rsquo;t want to use &lt;code&gt;else&lt;/code&gt; for the default case of a switch statement&amp;ndash;an &lt;code&gt;else&lt;/code&gt; without an &lt;code&gt;if&lt;/code&gt; looks really bizarre&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Just as an aside, what I&amp;rsquo;m trying to do here is untangle the exception trapping semantics of &lt;code&gt;eval&lt;/code&gt; from its code parsing and running semantics. In Perl 6, there is no &lt;code&gt;eval {}&lt;/code&gt;. And &lt;code&gt;eval $string&lt;/code&gt; really means something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { $string.parse.run }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This RFC does not require core Perl functions to use exceptions for signalling errors.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;However, Perl core functions will by default signal failure using unthrown proto-exceptions (that is, interesting values of undef) that can easily be turned into thrown exceptions via &lt;code&gt;die&lt;/code&gt;. By &amp;ldquo;interesting values of undef&amp;rdquo;, I don&amp;rsquo;t mean undef with properties. I mean full-fledged exception objects that just happen to return false from their &lt;code&gt;.defined&lt;/code&gt; and &lt;code&gt;.true&lt;/code&gt; methods. However, the &lt;code&gt;.str&lt;/code&gt; method successfully returns the error message, and the &lt;code&gt;.int&lt;/code&gt; method returns the error code (if any). That is, they do stringify and numify like &lt;code&gt;$!&lt;/code&gt; ought to. An exception becomes defined and true when it is thrown. (Control exceptions become false when cleanly caught, to avoid spoofing old-style exception handlers.)&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This means that all exceptions propagate unless they are cleanly caught, just as in Perl 5. To prevent this, use:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { fragile(); } catch { } # Go on no matter what.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will simply be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { fragile; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But it means the same thing, and it&amp;rsquo;s still the case that all exceptions propagate unless they are cleanly caught. In this case, the caught exception lives on in &lt;code&gt;$!&lt;/code&gt; as a new proto-exception that could be rethrown by a new &lt;code&gt;die&lt;/code&gt;, much as we used to use &lt;code&gt;$@&lt;/code&gt;. Whether an exception is currently considered &amp;ldquo;cleanly caught&amp;rdquo; can be reflected in the state of the &lt;code&gt;$!&lt;/code&gt; object itself. When &lt;code&gt;$!&lt;/code&gt; passes through the end of a &lt;code&gt;CATCH&lt;/code&gt;, it is marked as clean, so that subsequent attempts to establish a new &lt;code&gt;$!&lt;/code&gt; know that they can clear out the old &lt;code&gt;@$!&lt;/code&gt; stack. (If the current &lt;code&gt;$!&lt;/code&gt; is not clean, it should just add its information without deleting the old information&amp;ndash;otherwise an error in a &lt;code&gt;CATCH&lt;/code&gt; could delete the exception information you will soon be wanting to print out.)&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... } catch &amp;lt;test&amp;gt; =&amp;gt; { ... } finally { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { ... CATCH { when &amp;lt;test&amp;gt; { ... } } POST { ... } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The angle brackets aren&amp;rsquo;t really there&amp;ndash;I&amp;rsquo;m just copying the RFC&amp;rsquo;s metasyntax here.)&lt;/p&gt;

&lt;p&gt;Note that we&amp;rsquo;re assuming a test that matches the &amp;ldquo;boolean&amp;rdquo; entry from the switch dwimmery matrix. If not, you can always wrap closure curlies around the test:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { ... CATCH { when { &amp;lt;test&amp;gt; } { ... } } POST { ... } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That will force the test to be called as a subroutine that ignores its argument, which happens to be &lt;code&gt;$!&lt;/code&gt;, the exception object. (Recall that the implied &amp;ldquo;given&amp;rdquo; of a &lt;code&gt;CATCH&lt;/code&gt; statement sets &lt;code&gt;$!&lt;/code&gt; as the given value. That given value is automatically passed to any &amp;ldquo;when&amp;rdquo; cases that look like subroutines or closures, which are free either to ignore the passed value, or access it as &lt;code&gt;$_&lt;/code&gt; or &lt;code&gt;$^a&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Or you might just prefer to use the unary &lt;code&gt;true&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { ... CATCH { when true &amp;lt;test&amp;gt; { ... } } POST { ... } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I personally find that more readable than the closure.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The test argument of the catch clause is optional, and is described below.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The test argument of a &lt;code&gt;when&lt;/code&gt; clause is NOT optional, since it would be impossible to distinguish a conditional closure from the following block. Use &lt;code&gt;default&lt;/code&gt; for the default case.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, and &lt;code&gt;finally&lt;/code&gt; blocks should share the same lexical scope, in the way that &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; do.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Actually, this is not so&amp;ndash;the &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; blocks don&amp;rsquo;t share the same lexical scope even in Perl 5. But we&amp;rsquo;ll solve this issue without &amp;ldquo;tunneling&amp;rdquo; in any case. (And we&amp;rsquo;ll change the &lt;code&gt;continue&lt;/code&gt; block into a &lt;code&gt;NEXT&lt;/code&gt; block that goes inside, so we can refer to lexical variables from within it.)&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Note that &lt;code&gt;try&lt;/code&gt; is a keyword, not a function. This is so that a &lt;code&gt;;&lt;/code&gt; is not needed at the end of the last block. This is because a &lt;code&gt;try&lt;/code&gt;/&lt;code&gt;catch&lt;/code&gt;/&lt;code&gt;finally&lt;/code&gt; now looks more like an &lt;code&gt;if&lt;/code&gt;/&lt;code&gt;elsif&lt;/code&gt;/&lt;code&gt;else&lt;/code&gt;, which does not require such a &lt;code&gt;;&lt;/code&gt;, than like an eval, which does).&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Again, this entire distinction goes away in Perl 6. Any expression block that terminates with a right curly on its own line will be interpreted as a statement block. And &lt;code&gt;try&lt;/code&gt; is such an expression block.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&lt;code&gt;$@&lt;/code&gt; contains the current exception, and &lt;code&gt;@@&lt;/code&gt; contains the current exception stack, as defined above under &lt;code&gt;die&lt;/code&gt;. The &lt;code&gt;unshift&lt;/code&gt; rule guarantees that &lt;code&gt;$@ == $@[0]&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Why an &lt;code&gt;unshift?&lt;/code&gt; A stack is most naturally represented in the other direction, and I can easily imagine some kinds of handlers that might well treat it like a stack, stripping off some entries and pushing others.&lt;/p&gt;

&lt;p&gt;Also, &lt;code&gt;@@&lt;/code&gt; is a non-starter because everything about the current exception should all be in a single data structure. Keeping the info all in one place makes it easy to rethrow an exception without losing data, even if the exception was marked as cleanly caught. Furthermore I don&amp;rsquo;t think that the exception stack needs to be Huffman coded that badly.&lt;/p&gt;

&lt;p&gt;So &lt;code&gt;$!&lt;/code&gt; contains the current exception, and &lt;code&gt;$!.stack&lt;/code&gt; accesses the current exception stack. Through the magic of overloading, the &lt;code&gt;$!&lt;/code&gt; object can likely be used as an array even though it isn&amp;rsquo;t one, in which case &lt;code&gt;@$!&lt;/code&gt; refers to that stack member. The &lt;code&gt;push&lt;/code&gt; rule guarantees that &lt;code&gt;$!.id == $![-1].id&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;RFC (speaking of the &lt;code&gt;exception&lt;/code&gt; declaration):&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If the given name matches &lt;code&gt;/::/&lt;/code&gt;, something like this happens:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @MyError::App::DB::Foo::ISA = &#39;MyError::App::DB&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;and all non-existent parent classes are automatically created as inheriting from their parent, or &lt;code&gt;Exception&lt;/code&gt; in the tail case. If a parent class is found to exist and not inherit from &lt;code&gt;Exception&lt;/code&gt;, a run-time error exception is raised.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;If I understand this, I think I disagree. A package ought to able to contain exceptions without being an exception class itself. There certainly ought to be a shorthand for exceptions within the current package. I suspect they&amp;rsquo;re inner classes of some sort, or inner classes of an inner package, or some such.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If the given name does not match &lt;code&gt;/::/&lt;/code&gt; (say it&amp;rsquo;s just &lt;code&gt;Alarm&lt;/code&gt;), this happens instead:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @Alarm::ISA = &#39;Exception&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;This means that every exception class isa &lt;code&gt;Exception&lt;/code&gt;, even if &lt;code&gt;Exception::&lt;/code&gt; is not used at the beginning of the class name.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Ack! This could be really bad. What if two different modules declare an &lt;code&gt;Alarm&lt;/code&gt; exception with different derivations?&lt;/p&gt;

&lt;p&gt;I think we need to say that unqualified exceptions are created within the current package, or maybe within the X subpackage of the current package. If we have inner classes, they could even be lexically scoped (and hence anonymous exceptions outside the current module). That might or might not be a feature.&lt;/p&gt;

&lt;p&gt;I also happen to think that &lt;code&gt;Exception&lt;/code&gt; is too long a name to prefix most common exceptions, even though they&amp;rsquo;re derived from that class. I think exceptions will be better accepted if they have pithier names like X::Errno that are derived from &lt;code&gt;Exception&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our class X::Control is Exception;
    our class X::Errno is Exception;
    our class X::NumericError is Exception;

    our class C::NEXT is X::Control;
    our class E::NOSPC is X::Errno;
    our class X::FloatingUnderflow is X::NumericError;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or maybe those could be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    c::NEXT
    e::NOSPC
    x::FloatingUnderflow
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;if we decide uppercase names are too much like user-defined package names. But that looks strange. Maybe we just reserve single letter top-level package names for Perl. Heck, let&amp;rsquo;s just reserve all top-level package names for Perl. Er, no, wait&amp;hellip; &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;RFC 80 suggests that exception objects numerify to the system&amp;rsquo;s &lt;em&gt;errno&lt;/em&gt; number when those are available. That&amp;rsquo;s a possibility, though by the current switch rules we might have to write&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when +$ENOSPC { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to force &lt;code&gt;$ENOSPC&lt;/code&gt; to do a numeric comparison. It may well be better to go ahead and make the errno numbers into exception classes, even if we have to write something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when X::ENOSPC { ... }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s longer, but I think it&amp;rsquo;s clearer. Possibly that&amp;rsquo;s &lt;code&gt;E::NOSPC&lt;/code&gt; instead. But in any event, I can&amp;rsquo;t imagine getting people to prefix every exception with &amp;ldquo;&lt;code&gt;Exception::&lt;/code&gt;&amp;rdquo;. That&amp;rsquo;s just gonna discourage people from using exceptions. I&amp;rsquo;m quite willing to at least reserve the &lt;code&gt;X&lt;/code&gt; top-level class for exceptions. I think &lt;code&gt;X::&lt;/code&gt; is quite sufficiently distinctive.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { my $f = open &amp;quot;foo&amp;quot;; ... } finally { $f and close $f; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        my $f = open &amp;quot;foo&amp;quot;; ...
        POST { $f and close $f }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;$f&lt;/code&gt; is naturally in scope and guaranteed to have a boolean value, even if the exception is thrown before the declaration statement is elaborated! (An implementation need not allocate an actual variable before the &lt;code&gt;my&lt;/code&gt;. The code of the &lt;code&gt;POST&lt;/code&gt; block could always be compiled to know that &lt;code&gt;$f&lt;/code&gt; is to be assumed undefined if the allocating code has not yet been reached.)&lt;/p&gt;

&lt;p&gt;We could go as far as to make&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        POST { close $f }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;do something reasonable even without the guard. Maybe an undefined object could &amp;ldquo;emulate&amp;rdquo; any method for you within a &lt;code&gt;POST&lt;/code&gt;. Maybe &lt;code&gt;try&lt;/code&gt; is really a unary operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        POST { try close $f }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or some such. I dunno. This needs more thought along transactional lines&amp;hellip;&lt;/p&gt;

&lt;p&gt;Time passes&amp;hellip;&lt;/p&gt;

&lt;p&gt;Actually, now that I&amp;rsquo;ve thought on it, it would be pretty easy to put wrappers around &lt;code&gt;POST&lt;/code&gt; blocks that could do commit or rollback depending on whether the block exits normally. I&amp;rsquo;d like to call them &lt;code&gt;KEEP&lt;/code&gt; and &lt;code&gt;UNDO&lt;/code&gt;. &lt;code&gt;KEEP&lt;/code&gt; blocks would only be executed if the block succeeded. &lt;code&gt;UNDO&lt;/code&gt; blocks would only be executed if the block failed. One could even envision a syntax that ties the block to particular variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    UNDO $f { close $f }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After all, like the &lt;code&gt;CATCH&lt;/code&gt; block, all of these blocks are just fancy &lt;code&gt;BEGIN&lt;/code&gt; blocks that attach some meaning to some predefined property of the block.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s tempting to make the execution of &lt;code&gt;UNDO&lt;/code&gt; contingent upon whether the block itself was passed during execution, but I&amp;rsquo;m afraid that might leave a window in which a variable could already be set, but subsequent processing might raise an exception before enabling the rollback in question. So it&amp;rsquo;s probably better to tie it to a particular variable&amp;rsquo;s state more directly than just by placing the block at some point after the declaration. In fact, it could be associated directly with the variable in question at declaration time via a property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $f is undo { close $f } = open $file or die;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the block is truly a closure because it relies on the lexical scoping of &lt;code&gt;$f&lt;/code&gt;. (This form of lexical scoping works in Perl 6 because the name &lt;code&gt;$f&lt;/code&gt; is introduced immediately within the statement. This differs from the Perl 5 approach where the name is not introduced till the end of the current statement.)&lt;/p&gt;

&lt;p&gt;Actually, if the &lt;code&gt;close&lt;/code&gt; function defaults to &lt;code&gt;$_&lt;/code&gt;, we can say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $f is undo { close } = open $file;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;presuming the managing code is smart enough to pass &lt;code&gt;$f&lt;/code&gt; as a parameter to the closure. Likewise one could attach a &lt;code&gt;POST&lt;/code&gt; block to a variable with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $f is post { close } = open $file;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since properties can be combined, you can set multiple handlers on a variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $f is post { close } is undo { unlink $file } = open &amp;quot;&amp;gt;$file&amp;quot; or die;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There is, however, no &lt;code&gt;catch&lt;/code&gt; property to go with the &lt;code&gt;CATCH&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;I suppose we could allow a &lt;code&gt;pre&lt;/code&gt; property to set a &lt;code&gt;PRE&lt;/code&gt; block on a variable.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub attempt_closure_after_successful_candidate_file_open
    {
        my ($closure, @fileList) = @_; local (*F);
        foreach my $file (@fileList) {
            try { open F, $file; } catch { next; }
            try { &amp;amp;$closure(*F); } finally { close F; }
            return;
            }
        throw Exception &amp;quot;Can&#39;t open any file.&amp;quot;,
               debug =&amp;gt; @fileList . &amp;quot; tried.&amp;quot;;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub attempt_closure_after_successful_candidate_file_open
      (&amp;amp;closure, @fileList)
    {
        foreach my $file (@fileList) {
            my $f is post { close }
                = try { open $file or die; CATCH { next } }
            &amp;amp;closure($f);
            return;
        }
        throw Exception &amp;quot;Can&#39;t open any file.&amp;quot;,
               debug =&amp;gt; @fileList . &amp;quot; tried.&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the &lt;code&gt;next&lt;/code&gt; within the &lt;code&gt;CATCH&lt;/code&gt; refers to the loop, not the &lt;code&gt;CATCH&lt;/code&gt; block. It is legal to &lt;code&gt;next&lt;/code&gt; out of &lt;code&gt;CATCH&lt;/code&gt; blocks, since we won&amp;rsquo;t use &lt;code&gt;next&lt;/code&gt; to fall through switch cases.&lt;/p&gt;

&lt;p&gt;However, &lt;code&gt;X::Control&lt;/code&gt; exceptions (such as &lt;code&gt;X::NEXT&lt;/code&gt;) are a subset of &lt;code&gt;Exceptions&lt;/code&gt;, so&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when Exception { ... }   # catch any exception
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will stop returns and loop exits. This could be construed as a feature. When it&amp;rsquo;s considered a bug, you could maybe say something like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when X::Control { die }  # propagate control exceptions
        when Exception  { ... }  # catch all others
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to force such control exceptions to propagate outward. Actually, it would be nice to have a name for non-control exceptions. Then we could say (with a tip of the hat to Maxwell Smart):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CATCH {
        when X::Chaos   { ... }  # catch non-control exceptions
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And any control exceptions will then pass unimpeded (since by default uncaught exceptions are rethrown implicitly by the &lt;code&gt;CATCH&lt;/code&gt;). Fortunately or unfortunately, an explicit &lt;code&gt;default&lt;/code&gt; case will not automatically rethrow control exceptions.&lt;/p&gt;

&lt;p&gt;Following are some more examples of how the expression evaluation of &lt;code&gt;when&lt;/code&gt; can be used. The RFC versions sometimes look more concise, but recall that the &amp;ldquo;try&amp;rdquo; is any block in Perl 6, whereas in the RFC form there would have to be an extra, explicit &lt;code&gt;try&lt;/code&gt; block inside many subroutines, for instance. I&amp;rsquo;d rather establish a culture in which it is expected that subroutines handle their own exceptions.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... } catch $@-&amp;gt;{message} =~ /.../ =&amp;gt; { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        ...
        CATCH {
            when $!.message =~ /.../ { ... }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works because =~ is considered a boolean operator.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    catch not &amp;amp;TooSevere =&amp;gt; { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    when not &amp;amp;TooSevere { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The unary &lt;code&gt;not&lt;/code&gt; is also a boolean operator.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... } catch ref $@ =~ /.../ =&amp;gt; { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... CATCH { when $!.ref =~ /.../ { ... } } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { ... } catch grep { $_-&amp;gt;isa(&amp;quot;Foo&amp;quot;) } @@ =&amp;gt; { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        ...
        CATCH {
            when grep { $_.isa(Foo) } @$! { ... }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I suppose we could also assume grep to be a boolean operator in a scalar context. But that&amp;rsquo;s kind of klunky. If we accept Damian&amp;rsquo;s superposition RFC, it could be written this way:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        ...
        CATCH {
            when true any(@$!).isa(Foo) { ... }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, by the &amp;ldquo;any&amp;rdquo; rules of the &lt;code&gt;=~&lt;/code&gt; table, we can just say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        ...
        CATCH {
            when @$! =~ Foo { ... }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The RFC proposes the following syntax for finalization:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try { my $p = P-&amp;gt;new; my $q = Q-&amp;gt;new; ... }
    finally { $p and $p-&amp;gt;Done; }
    finally { $q and $q-&amp;gt;Done; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A world of hurt is covered over by that &amp;ldquo;&lt;code&gt;...&lt;/code&gt;&amp;rdquo;, which could move the &lt;code&gt;finally&lt;/code&gt; clauses far, far away from what they&amp;rsquo;re trying to clean up after. I think the intent is much clearer with &lt;code&gt;POST&lt;/code&gt;. And note also that we avoid the &amp;ldquo;lexical tunneling&amp;rdquo; perpetrated by &lt;code&gt;finally&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        my $p = P.new;   POST { $p and $p.Done; }
        my $q = Q.new;   POST { $q and $q.Done; }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More concisely, we can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        my $p is post { .Done } = P.new;
        my $q is post { .Done } = Q.new;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try     { TryToFoo; }
    catch   { TryToHandle; }
    finally { TryToCleanUp; }
    catch   { throw Exception &amp;quot;Can&#39;t cleanly Foo.&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How I&amp;rsquo;d write that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try {
        try {
            TryToFoo;
            POST    { TryToCleanUp; }
            CATCH   { TryToHandle; }
        }
        CATCH   { throw Exception &amp;quot;Can&#39;t cleanly Foo.&amp;quot;; }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That also more clearly indicates to the reader that the final &lt;code&gt;CATCH&lt;/code&gt; governs the inner try completely, rather than just relying on ordering.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Instances of the actual (non-subclassed) &lt;code&gt;Exception&lt;/code&gt; class itself are used for simple exceptions, for those cases in which one more or less just wants to say &lt;code&gt;throw Exception &amp;quot;My message.&amp;quot;&lt;/code&gt;, without a lot of extra tokens, and without getting into higher levels of the taxonomy of exceptions.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;die &amp;quot;My message.&amp;quot;&lt;/code&gt; has much the same effect. I think &lt;code&gt;fail &amp;quot;My message.&amp;quot;&lt;/code&gt;  will also default similarly, though with return-or-throw semantics that depend on the caller&amp;rsquo;s &lt;code&gt;use fatal&lt;/code&gt; settings.&lt;/p&gt;

&lt;p&gt;RFC (regarding &lt;code&gt;on_raise&lt;/code&gt;):&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Derived classes may override this method to attempt to &amp;ldquo;handle&amp;rdquo; an exception or otherwise manipulate it, just before it is raised. If &lt;code&gt;on_raise&lt;/code&gt; throws or returns true the exception is raised, otherwise it is not. An exception can be manipulated or replaced and then propagated in modified form simply by re-raising it in &lt;code&gt;on_raise&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Offhand, I don&amp;rsquo;t see this one. Not only does it seem to be making the &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; mistake all over again, it also makes little sense to me to use &amp;ldquo;throw&amp;rdquo; to do something that doesn&amp;rsquo;t throw. A throw should guarantee termination of control, or you&amp;rsquo;re just going to run user code that wasn&amp;rsquo;t expected to be run. It&amp;rsquo;d be like &lt;code&gt;return&lt;/code&gt; suddenly not returning! Let&amp;rsquo;s please use a different method to generate an unthrown exception. I think a &lt;code&gt;fail&lt;/code&gt; method is the right approach&amp;ndash;it terminates the control flow one way or another, even if just returning the exception as a funny-looking undef.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;on_catch&lt;/code&gt; might be a bit more useful.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;&amp;hellip;because the authors are of the opinion that overloading &lt;code&gt;else&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; with unwind semantics not traditionally associated with &lt;code&gt;else&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; can be confusing, especially when intermixed with local flow-control forms of &lt;code&gt;else&lt;/code&gt; and &lt;code&gt;continue&lt;/code&gt; (which may be present in any &lt;code&gt;{ ... }&lt;/code&gt; block), or when an &lt;code&gt;else die $@&lt;/code&gt; is forgotten on a &lt;code&gt;switch&lt;/code&gt; that needs to re-throw.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;CATCH&lt;/code&gt; will rethrow by default (unless there is a user-specified default).&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Some perl6-language-error discussions have suggested leaving out the try altogether, as in simply writing &lt;code&gt;{ } else { }&lt;/code&gt; to indicate non-local flow-control at work. Yikes!&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The &lt;code&gt;try&lt;/code&gt; is not for Perl&amp;rsquo;s sake. It&amp;rsquo;s for the developer&amp;rsquo;s sake. It says, watch out, some sort of non-local flow control is going on here. It signals intent to deal with action at a distance (unwinding semantics). It satisfies the first requirement listed under MOTIVATION.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;try {}&lt;/code&gt; is the new spelling of &lt;code&gt;eval {}&lt;/code&gt;, so it can still be used when self-documentation is desired. It&amp;rsquo;s often redundant, however, since I think the all-caps &lt;code&gt;CATCH&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; also serve the purpose of telling the developer to &amp;ldquo;watch out&amp;rdquo;. I expect that developers will get used to the notion that many subroutines will end with a &lt;code&gt;CATCH&lt;/code&gt; block. And I&amp;rsquo;m always in favor of reducing the bracket count of ordinary code where practical. (That&amp;rsquo;s why the &lt;code&gt;package&lt;/code&gt; declaration has always had a bracketless syntax. I hope to do the same for classes and modules in Perl 6.)&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The comma or &lt;code&gt;=&lt;/code&gt;``&lt;/em&gt; &lt;em&gt;in a conditional catch clause is required so the expression can be parsed from the block, in the fashion of Perl 5&amp;rsquo;s parsing of: &lt;code&gt;map&lt;/code&gt;&lt;code&gt;&amp;lt;expression&lt;/code&gt;``&lt;/em&gt;&lt;code&gt;, &amp;lt;list&lt;/code&gt;`&lt;code&gt;&amp;amp;gt;; Without the comma, the form&lt;/code&gt;catch $foo { &amp;hellip; }&lt;code&gt;could be a test for&lt;/code&gt;$foo&lt;code&gt;or a test for&lt;/code&gt;$foo{&amp;hellip;}` (the hash element).&amp;gt;&lt;/p&gt;

&lt;p&gt;We now require whitespace before non-subscript block, so this is not much of a problem.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How can we subclass &lt;code&gt;Exception&lt;/code&gt; and control the class namespace? For example, if the core can use any &lt;code&gt;Exception::Foo&lt;/code&gt;, where does one connect non-core &lt;code&gt;Exception&lt;/code&gt;s into the taxonomy? Possibly the core exceptions can derive from &lt;code&gt;Exception::CORE&lt;/code&gt;, and everyone else can use the &lt;code&gt;Exception::MyPackage&lt;/code&gt; convention.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think defining things as core vs non-core is very useful&amp;ndash;&amp;ldquo;core&amp;rdquo; is not a fundamental type of exception. I do think the standard exception taxonomy should be extensible, so that non-standard exceptions can migrate toward being standard over time. I also think that modules and classes should have their own subpackage in which to store exceptions.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How can we add new instance variables and methods to classes derived from &lt;code&gt;Exception&lt;/code&gt; and control those namespaces? Perhaps this will be covered by some new Perl 6 object technology. Otherwise, we will need yet another naming scheme convention.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Instance variables and methods in a derived class will not interfere with base classes (except by normal hiding of duplicate method names).&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;What should the default values be for &lt;code&gt;Exception&lt;/code&gt; object instance variables not specified to the constructor? For example, &lt;code&gt;tag&lt;/code&gt; could default to file + line number.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Depends on the constructor, I suspect.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;What assertions should be placed on the instance variables, if any?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Probably depends on the class.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;What should stringification return?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I lean towards just the message, with a different method for more info. But this is somewhat dependent on which representational methods we define for all Objects. And that has not been entirely thunk through.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mixed Flow Control&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Some of the reference texts, when discussing exception handling, refer to the matter that it may be difficult to implement a &lt;code&gt;go to&lt;/code&gt; across an unwinding semantics block, as in:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        try { open F, $f } catch { next; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;This matter will have to be referred to the internals experts. It&amp;rsquo;s ok if this functionality is not possible, it can always be simulated with lexical state variables instead.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;However, the authors would very much prefer that &lt;code&gt;goto&lt;/code&gt;s across unwinding boundaries would dwim. If that is not possible, hopefully some sort of compile-time warning could be produced.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;We can do this with special control exceptions that aren&amp;rsquo;t caught until it makes sense to catch them. (Where exactly control exceptions fit in the class hierarchy is still open to debate.) In any event, there&amp;rsquo;s no problem throwing a control exception from a &lt;code&gt;CATCH&lt;/code&gt;, since any exception thrown in a &lt;code&gt;CATCH&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt; would propagate outside the current try block in any event.&lt;/p&gt;

&lt;p&gt;Ordinary &lt;code&gt;goto&lt;/code&gt; should work as long as it&amp;rsquo;s leaving the current try scope. Reentering the try somewhere in the middle via &lt;code&gt;goto&lt;/code&gt; is likely not possible, or even desirable. A failed try should be re-entered from the top, once things have been cleared up. (If the try is a loop block, going to the next iteration out of its &lt;code&gt;CATCH&lt;/code&gt; will probably be considered safe, just as if there had been an explicit &lt;code&gt;try&lt;/code&gt; block within the loop. But I could be wrong on that.)&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Use &lt;code&gt;%@&lt;/code&gt; for Errors from Builtins&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;*RFC 151 proposes a mechanism for consolidating the information provided by of &lt;code&gt;$@&lt;/code&gt;, &lt;code&gt;$!&lt;/code&gt;, &lt;code&gt;$?&lt;/code&gt;, and &lt;code&gt;$^E&lt;/code&gt;. In the opinion of the author of RFC 88, merging &lt;code&gt;$@&lt;/code&gt; and &lt;code&gt;$!&lt;/code&gt; should not be undertaken, because &lt;code&gt;$@&lt;/code&gt; should &lt;em&gt;only&lt;/em&gt; be set if an exception is raised.*&lt;/p&gt;

&lt;p&gt;The RFC appears to give no justification for this last assertion. If we unify the error variables, &lt;code&gt;die&lt;/code&gt; with no arguments can simply raise the current value of &lt;code&gt;$!&lt;/code&gt;, and we stay object oriented all the way down. Then &lt;code&gt;$!&lt;/code&gt; indicates the current error whether or not it&amp;rsquo;s being thrown. It keeps track of its own state, as to whether it is currently in an &amp;ldquo;unclean&amp;rdquo; state, and refuses to throw away information unless it&amp;rsquo;s clean.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;%@&lt;/code&gt; &lt;em&gt;should be used to hold this fault-hash, based on the following arguments for symmetry.&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $@    current exception
        @@    current exception stack
        %@    current core fault information

        $@[0]        same as $@

        $@{type}     &amp;quot;IO::File::NotFound&amp;quot;
        $@{message}  &amp;quot;can&#39;t find file&amp;quot;
        $@{param}    &amp;quot;/foo/bar/baz.dat&amp;quot;
        $@{child}    $?
        $@{errno}    $!
        $@{os_err}   $^E
        $@{chunk}    That chunk thingy in some msgs.
        $@{file}     Source file name of caller.
        $@{line}     Source line number of caller.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;%@&lt;/code&gt; &lt;em&gt;should not contain a severity or fatality classification.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Every call to a core API function should clear &lt;code&gt;%@&lt;/code&gt; if it returns successfully.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Internally, Perl can use a simple structured data type to hold the whole canonical &lt;code&gt;%@&lt;/code&gt;. The code that handles reading from &lt;code&gt;%@&lt;/code&gt; will construct it out of the internal data on the fly.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;If &lt;code&gt;use fatal;&lt;/code&gt; is in scope, then just before returning, each core API function should do something like: &lt;code&gt;%@ and internal_die %@;&lt;/code&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The &lt;code&gt;internal_die&lt;/code&gt; becomes the one place where a canonical &lt;code&gt;Exception&lt;/code&gt; can be generated to encapsulate &lt;code&gt;%@&lt;/code&gt; just before raising an exception, whether or not the use of such canonical &lt;code&gt;Exception&lt;/code&gt;s is controlled by a pragma such as&lt;/em&gt; &lt;code&gt;use exceptions;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This &lt;code&gt;%@&lt;/code&gt; proposal just looks like a bunch of unnecessary complication to me. A proto-exception object with methods can be just as easily (and lazily) constructed, and will map straight into a real exception, unlike this hash. And an object can always be used as a hash to access parameterless methods such as instance variable accessors.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;eval&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The semantics of &lt;code&gt;eval&lt;/code&gt; are, &amp;ldquo;clear &lt;code&gt;$@&lt;/code&gt; and don&amp;rsquo;t unwind unless the user re-dies after the &lt;code&gt;eval&lt;/code&gt;&amp;rdquo;. The semantics of &lt;code&gt;try&lt;/code&gt; are &amp;ldquo;unwind after &lt;code&gt;try&lt;/code&gt;, unless any raised exception was cleanly and completely handled, in which case clear &lt;code&gt;$@&lt;/code&gt;&amp;rdquo;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In the author&amp;rsquo;s opinion, both &lt;code&gt;eval&lt;/code&gt; and &lt;code&gt;try&lt;/code&gt; should exist in Perl 6. This would also mean that the legacy of examples of how to use &lt;code&gt;eval&lt;/code&gt; in Perl will still work.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;And, of course, we still need &lt;code&gt;eval $string&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Discussions on perl6-language-errors have shown that some would prefer the &lt;code&gt;eval { ... }&lt;/code&gt; form to be removed from Perl 6, because having two exception handling methods in Perl could be confusing to developers. This would in fact be possible, since the same effect can be achieved with:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        try { } catch { } # Clears $@.

        my $e;

        try { ... } catch { $e = $@; }

        # now process $e instead of $@
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;On the other hand, &lt;code&gt;eval&lt;/code&gt; is a convenient synonym for all that, given that it already works that way.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think the exact semantics of &lt;code&gt;eval {...}&lt;/code&gt; are worth preserving. I think having bare &lt;code&gt;try {...}&lt;/code&gt; assume a &lt;code&gt;CATCH { default {} }&lt;/code&gt; will be close enough. Very few Perl 5 programs actually care whether &lt;code&gt;$@&lt;/code&gt; is set within the eval. Given that and the way we&amp;rsquo;ve defined &lt;code&gt;$!&lt;/code&gt;, the translation from Perl 5 to Perl 6 involves simply changing &lt;code&gt;eval {...}&lt;/code&gt; to &lt;code&gt;try {...}&lt;/code&gt; and &lt;code&gt;$@&lt;/code&gt; to &lt;code&gt;$!&lt;/code&gt; (which lives on as a &amp;ldquo;clean&amp;rdquo; exception after being caught by the &lt;code&gt;try&lt;/code&gt;). Perhaps some attempt can be made to pull an external handler into an internal &lt;code&gt;CATCH&lt;/code&gt; block.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;code&gt;catch v/s else + switch&lt;/code&gt;&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Some participants in discussions on perl6-language-errors have expressed the opinion that not only should &lt;code&gt;eval&lt;/code&gt; be used instead of &lt;code&gt;try&lt;/code&gt;, but &lt;code&gt;else&lt;/code&gt; should be used instead of multiple &lt;code&gt;catch&lt;/code&gt; blocks. They are of the opinion that an&lt;/em&gt; &lt;code&gt;else { switch ... }&lt;/code&gt; &lt;em&gt;should be used to handle multiple catch clauses, as in:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        eval { ... }
        else {
            switch ($@) {
                case $@-&amp;gt;isa(&amp;quot;Exception::IO&amp;quot;) { ... }
                case $@-&amp;gt;my_method { ... }
                }
            }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;This problem with&lt;/em&gt; &lt;code&gt;else { switch ... }&lt;/code&gt; &lt;em&gt;is: how should the code implicitly rethrow uncaught exceptions? Many proponents of this model think that uncaught exceptions should not be implicitly rethrown; one suggests that the programmer should &lt;code&gt;undef $@&lt;/code&gt; at the end of *every* successful case block, so that Perl re-raises any &lt;code&gt;$@&lt;/code&gt; still extant at the end of the &lt;code&gt;else&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;This RFC allows a &lt;code&gt;switch&lt;/code&gt; to be used in a&lt;/em&gt; &lt;code&gt;catch { ... }&lt;/code&gt; &lt;em&gt;clause, for cases where that approach would minimize redundant code in&lt;/em&gt; &lt;code&gt;catch&lt;/code&gt; &lt;code&gt;&amp;lt;expr&lt;/code&gt;`&lt;code&gt;&amp;amp;gt;&lt;/code&gt;{ &amp;hellip; }` &lt;em&gt;clauses, but with the mechanism proposed in this RFC, the switch functionality shown above can be written like this, while still maintaining the automatic exception propagation when no cases match:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        try { ... }
        catch Exception::IO =&amp;gt; { ... }
        catch $@-&amp;gt;my_method =&amp;gt; { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The switch construct works fine, because the implied &lt;code&gt;break&lt;/code&gt; of each handled case jumps over the default rethrow supplied by the &lt;code&gt;CATCH&lt;/code&gt;. There&amp;rsquo;s no reason to invent a parallel mechanism, and lots of reason not to.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mechanism Hooks&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In the name of extensibility and debugging, there should be hooks for callbacks to be invoked when a &lt;code&gt;try&lt;/code&gt;, &lt;code&gt;catch&lt;/code&gt;, or &lt;code&gt;finally&lt;/code&gt; block is entered or exited, and when a conditional &lt;code&gt;catch&lt;/code&gt; is evaluated. The callbacks would be passed information about what is happening in the context they are being called from.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;In order to scope the effect of the callbacks (rather than making them global), it is proposed that the callbacks be specified as options to the try statement, something like this:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    try on_catch_enter =&amp;gt; sub { ... },
        on_catch_exit  =&amp;gt; sub { ... },
    {
        ...
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;The (dynamic, not lexical) scope of these callbacks is from their try down through all trys nested under it (until overridden at a lower level). Nested callbacks should have a way of chaining to callbacks that were in scope when they come into scope, perhaps by including a reference to the outer-scope callback as a parameter to the callback. Basically, they could be kept in &amp;ldquo;global&amp;rdquo; variables overridden with &lt;code&gt;local&lt;/code&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yuck. I dislike cluttering up the &lt;code&gt;try&lt;/code&gt; syntax with what are essentially &lt;code&gt;temp&lt;/code&gt; assignments to dynamically scoped globals. It should be sufficient to say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        temp &amp;amp;*on_catch_enter = sub { ... };
        temp &amp;amp;*on_catch_exit  = sub { ... };
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;provided, of course, the implementation is smart enough to look for those hooks when it needs them.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Mixed-Mode Modules&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Authors of modules who wish to provide a public API that respects the current state of &lt;code&gt;use fatal;&lt;/code&gt; if such a mechanism is available, can do so as follows.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Internal to their modules, authors can use lexically scoped &lt;code&gt;use fatal;&lt;/code&gt; to explicitly control whether or not they want builtins to raise exceptions to signal errors.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Then, if and only if they want to support the other style, and only for public API subroutines, they do something like one of these:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Use return internally, now add support for throw at API:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     sub Foo
     {
        my $err_code = ... ; # real code goes here

        # Replace the old return $err_code with this:

        return $err_code unless $FATAL_MODE &amp;amp;&amp;amp; $error_code != $ok;

        throw Error::Code &amp;quot;Couldn&#39;t Foo.&amp;quot;, code =&amp;gt; $err_code;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Use throw internally, add support for return at API:&lt;/em&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     sub Foo
     {
        try {
            # real code goes here, may execute:

            throw Exception &amp;quot;Couldn&#39;t foo.&amp;quot;, code =&amp;gt; $err_code;
            }
        catch !$FATAL_MODE =&amp;gt; { return $@-&amp;gt;{code}; }

        return $ok;
        }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Yow. Too much mechanism. Why not just:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    return proto Exception &amp;quot;Couldn&#39;t foo.&amp;quot;, code =&amp;gt; $err_code;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;proto&lt;/code&gt; method can implement the standard &lt;code&gt;use fatal&lt;/code&gt; semantics when that is desired by the calling module, and otherwise set things up so that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Foo() or die;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ends up throwing the proto-exception. (The current proto-exception can be kept in &lt;code&gt;$!&lt;/code&gt; for use in messages, provided it&amp;rsquo;s in thread-local storage.)&lt;/p&gt;

&lt;p&gt;Actually, this is really important to make simple. I&amp;rsquo;d be in favor of a built-in that clearly says what&amp;rsquo;s going on, regardless of whether it ends in a throw or a return of undef:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    fail &amp;quot;Couldn&#39;t foo&amp;quot;, errno =&amp;gt; 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just as an aside, it could be argued that all such &amp;ldquo;built-ins&amp;rdquo; are really methods on an implicit class or object. In this case, the &lt;code&gt;Exception&lt;/code&gt; class&amp;hellip;&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;$SIG{__DIE__}&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The try, catch, and finally clauses localize and undef &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; before entering their blocks. This behavior can be removed if &lt;code&gt;$SIG{__DIE__}&lt;/code&gt; is removed.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;code&gt;$SIG{__DIE__}&lt;/code&gt; must die. At least, that name must die&amp;ndash;we may install a similar global hook for debugging purposes.&lt;/p&gt;

&lt;p&gt;RFC:&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Legacy&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The only changes in respect of Perl 5 behaviour implied by this RFC are that (1) &lt;code&gt;$@&lt;/code&gt; is now always an &lt;code&gt;Exception&lt;/code&gt; object (which stringifies reasonably), it is now read-only, and it can only be set via &lt;code&gt;die&lt;/code&gt;, and (2) the &lt;code&gt;@@&lt;/code&gt; array is now special, and it is now read-only too.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Perhaps &lt;code&gt;$!&lt;/code&gt; could be implicitly declared to have a type of &lt;code&gt;Exception&lt;/code&gt;. But I see little reason to make &lt;code&gt;$!&lt;/code&gt; readonly by default. All that does is prevent clever people from doing clever things that we haven&amp;rsquo;t thought of yet. And it won&amp;rsquo;t stop stupid people from doing stupid things. In any event, &lt;code&gt;$!&lt;/code&gt; is just a reference to an object, and access to the object will controlled by the class, not by Perl.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-199-html-id-rfc-199-shortcircuiting-builtin-functions-and-userdefined-subroutines-rfc-199-short-circuiting-built-in-functions-and-user-defined-subroutines-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/199.html&#34; id=&#34;rfc 199: shortcircuiting builtin functions and userdefined subroutines&#34;&gt;RFC 199: Short-circuiting built-in functions and user-defined subroutines&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;First I should note in passing that it is likely that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($found) = grep { $_ == 1 } (1..1_000_000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will be smart enough to stop on the first one without additional hints, since the left side will only demand one value of the right side.&lt;/p&gt;

&lt;p&gt;However, we do need to unify the behaviors of built-ins with user-defined control structures. From an internal point of view, all of these various ways of exiting a block will be unified as exceptions.&lt;/p&gt;

&lt;p&gt;It will be easy enough for a user-defined subroutine to catch the appropriate exceptions and do the right thing. For instance, to implement a loop wrapper (ignoring parser issues), you might write something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub mywhile ($keyword, &amp;amp;condition, &amp;amp;block) {
        my $l = $keyword.label;
        while (&amp;amp;condition()) {
            &amp;amp;block();
            CATCH {
                my $t = $!.tag;
                when X::Control::next { die if $t &amp;amp;&amp;amp; $t ne $l); next }
                when X::Control::last { die if $t &amp;amp;&amp;amp; $t ne $l); last }
                when X::Control::redo { die if $t &amp;amp;&amp;amp; $t ne $l); redo }
            }
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that those &lt;code&gt;die&lt;/code&gt; calls are just rethrows of the current exception to get past the current try scope (the &lt;code&gt;while&lt;/code&gt; in this case).&lt;/p&gt;

&lt;p&gt;How a block gets a label in general is an interesting question. It&amp;rsquo;s all very well to say that the keyword is the label, but that doesn&amp;rsquo;t help if you have two nested constructs with the same name. In Perl 5, labels are restricted to being at the beginning of the statement, but then how do you label a &lt;code&gt;grep&lt;/code&gt;? Should there be some way of specifying a label on a keyword rather than on a statement? We could end up with something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $found = grep:NUM { $_ == 1 and last NUM: $_ } (1..1_000_000);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, considering how often this feature is (not) going to used, I think we can stick with the tried-and-true statement label:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $found = do { NUM: grep { $_ == 1 and last NUM: $_ } (1..1_000_000) };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This has the advantage of matching the label syntax with a colon on the end in both places. I like that.&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think every block should implicitly have a way to return, or we&amp;rsquo;ll have difficulty optimizing away blocks that don&amp;rsquo;t do anything blockish. That&amp;rsquo;s because setting up a try environment is always a bit blockish, and does in fact impose some overhead that we&amp;rsquo;d just as soon avoid when it&amp;rsquo;s unnecessary.&lt;/p&gt;

&lt;p&gt;However, it&amp;rsquo;s probably okay if certain constructs that would know how to deal with a label are implicitly labelled by their keyword name when they don&amp;rsquo;t happen to have an explicit label. So I think we can allow something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    last grep: $_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Despite its appearance, that is not a method call, because &lt;code&gt;grep&lt;/code&gt; is not a predefined class. What we have is a unary operator &lt;code&gt;last&lt;/code&gt; that is taking an adverbial modifier specifying what to return from the loop.&lt;/p&gt;

&lt;p&gt;The interesting policy question as we go on will be whether a given construct responds to a given exception or not. Some exceptions will have to be restricted in their use. For instance, we should probably say that only explicit &lt;code&gt;sub&lt;/code&gt; declarations may respond to a &lt;code&gt;return&lt;/code&gt;. People will expect &lt;code&gt;return&lt;/code&gt; to exit the subroutine they think they&amp;rsquo;re in, even if there are blocks floating around that are actually closures being interpreted elsewhere. It might be considered antisocial for closure interpreters like &lt;code&gt;grep&lt;/code&gt; or &lt;code&gt;map&lt;/code&gt; or &lt;code&gt;sort&lt;/code&gt; to trap X::Control::return sooner than the user expects.&lt;/p&gt;

&lt;p&gt;As for using numbers instead of labels to indicate how many levels to break out of, that would be fine, except that I don&amp;rsquo;t believe in breaking out by levels. If the problem is complex enough that you need to break out more than one level, you need a name, not a number. Then it doesn&amp;rsquo;t matter if you refactor your code to have more block levels or less. I find I frequently have to refactor my code that way.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s possible to get carried away and retrofit &lt;code&gt;grep&lt;/code&gt; and &lt;code&gt;map&lt;/code&gt; with every conceivable variety of abort, retry, accept, reject, reduce, reuse, recycle, or whatever exception. I don&amp;rsquo;t think that&amp;rsquo;s necessary. There has to be some reason for writing your own code occasionally. If we get rid of all the reasons for writing user-defined subroutines, we might as well pack our bags and go home. But it&amp;rsquo;s okay at minimum to treat a looping construct like a loop.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-6-html-id-rfc-006-lexical-variables-made-default-rfc-006-lexical-variables-made-default-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/6.html&#34; id=&#34;rfc 006: lexical variables made default&#34;&gt;RFC 006: Lexical variables made default&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC proposes that &lt;code&gt;strict vars&lt;/code&gt; should be on by default. This is motivated by the desire that Perl better support (or cajole, in this case) the disciplines that enable successful programming in the large. This goal is laudable.&lt;/p&gt;

&lt;p&gt;However, the programming-in-the-small advocates also have a valid point: they don&amp;rsquo;t want to have to go to all the trouble of turning off strictures merely to write a succinct one-liner, since keystrokes are at a premium in such programming, and in fact the very strictures that increase clarity in large programs tend to decrease clarity in small programs.&lt;/p&gt;

&lt;p&gt;So this is one of those areas where we desire to have it both ways, and in fact, we pretty much can. The only question is where to draw the line. Some discussion suggested that only programs specified on the command line via the &lt;code&gt;-e&lt;/code&gt; switch should be exempt from stricture. But I don&amp;rsquo;t want to force every little file-based script into the large model of programming. And we don&amp;rsquo;t need to.&lt;/p&gt;

&lt;p&gt;Large programming requires the definition of modules and classes. The typical large program will (or should) consist mostly of modules and classes. So modules and classes will assume &lt;code&gt;strict vars&lt;/code&gt;. Small programming does not generally require the definition of modules and classes, though it may depend on existing modules and classes. But even small programs that use a lot of external modules and classes may be considered throw-away code. The very fact that the main code of a program is not typically reused (in the sense that modules and classes are reused) means that there is where we should draw the line. So in Perl 6, the main program will not assume &lt;code&gt;strict vars&lt;/code&gt;, unless you explicitly do something to turn it on, such as to declare &amp;ldquo;class Main&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-330-html-id-rfc-330-global-dynamic-variables-should-remain-the-default-rfc-330-global-dynamic-variables-should-remain-the-default-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/330.html&#34; id=&#34;rfc 330: global dynamic variables should remain the default&#34;&gt;RFC 330: Global dynamic variables should remain the default&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This is fine for the main program, but modules and classes should be held to the higher standard of &lt;code&gt;use strict&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-83-html-id-rfc-083-make-constants-look-like-variables-rfc-083-make-constants-look-like-variables-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/83.html&#34; id=&#34;rfc 083: make constants look like variables&#34;&gt;RFC 083: Make constants look like variables&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s important to keep in mind the distinction between variables and values. In a pure OO environment, variables are merely references to values, and have no properties of their own&amp;ndash;only the value itself would be able to say whether it is constant. Some values are naturally constant, such as a literal string, while other values could be marked constant, or created without methods that can modify the object, or some such mechanism. In such an environment, there is little use for properties on variables. Any time you put a property on a variable, it&amp;rsquo;s potentially lying about its value.&lt;/p&gt;

&lt;p&gt;However, Perl does not aspire to be a pure OO environment. In Perl-think, a variable is not merely a container for a value. Rather, a variable provides a &amp;ldquo;view&amp;rdquo; of a value. Sometimes that view could even be construed as a lie. That&amp;rsquo;s okay. Lying to yourself is a useful survival skill (except when it&amp;rsquo;s not). We find it necessary to repeat &amp;ldquo;I think I can&amp;rdquo; to ourselves precisely when we think we can&amp;rsquo;t. Conversely, it&amp;rsquo;s often valuable psychologically to treat possible activities as forbidden. Abstinence is easier to practice if you don&amp;rsquo;t have to decide anew every time there&amp;rsquo;s a possible assignation, er, I mean, assignment.&lt;/p&gt;

&lt;p&gt;Constant declarations on variables fall into this category. The value itself may or may not naturally be constant, but we will pretend that it is. We could in theory go farther than that. We could check the associated object to make sure that it is constant, and blow up if it&amp;rsquo;s not, but that&amp;rsquo;s not necessary in this case for consistent semantics. Other properties may be stricter about this. If you have a variable property that asserts a particular shape of multidimensional array, for instance, the object in question had better be able to supply semantics consistent with that view, and it&amp;rsquo;s probably a good idea to blow up sooner rather than later if it can&amp;rsquo;t. This is something like strong typing, except that it&amp;rsquo;s optional, because the variable property itself is optional.&lt;/p&gt;

&lt;p&gt;Nevertheless, the purpose of these variable properties is to allow the compiler to deduce things about the program that it could not otherwise deduce, and based on those deductions, produce both a more robust and more efficient compile-time interpretation of the semantics of the program. That is to say, you can do more optimizations without compromising safety. This is obviously true in the case of inlining constants, but the principle extends to other variable properties as well.&lt;/p&gt;

&lt;p&gt;The proposed syntax is fine, except that we&amp;rsquo;ll be using &lt;code&gt;is&lt;/code&gt; instead of &lt;code&gt;:&lt;/code&gt; for properties, as discussed in Apocalypse 2. (And it&amp;rsquo;s &lt;code&gt;constant&lt;/code&gt;, not &lt;code&gt;const&lt;/code&gt;.)&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-337-html-id-rfc-337-common-attribute-system-to-allow-userdefined-extensible-attributes-rfc-337-common-attribute-system-to-allow-user-defined-extensible-attributes-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/337.html&#34; id=&#34;rfc 337: common attribute system to allow userdefined, extensible attributes&#34;&gt;RFC 337: Common attribute system to allow user-defined, extensible attributes&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;As already revealed in Apocalypse 2, attributes will be known as &amp;ldquo;properties&amp;rdquo; in Perl 6, to avoid confusion with existing OO nomenclature for instance variables. Also, we&amp;rsquo;ll use the &lt;code&gt;is&lt;/code&gt; keyword instead of the colon.&lt;/p&gt;

&lt;p&gt;Setting properties on array and hash elements bothers me, particularly when those properties have names like &amp;ldquo;public&amp;rdquo; and &amp;ldquo;private&amp;rdquo;. This seems to me to be an attempt to paper over the gap of some missing OO functionality. So instead, I&amp;rsquo;d rather keep arrays and hashes mostly for homogenous data structures, and encourage people to use objects to store data of differing types. Then public and private can be properties of object attributes, which will look more like real variables in how they are declared. And we won&amp;rsquo;t have to worry about the meaning of &lt;code&gt;my @foo[2]&lt;/code&gt;, because that still won&amp;rsquo;t be allowed.&lt;/p&gt;

&lt;p&gt;Again, we need to be very clear that the object representing the variable is different than any objects contained by the variable. When we say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog @dogpound is loud;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we mean that the individual elements of &lt;code&gt;@dogpound&lt;/code&gt; are of type &lt;code&gt;Dog&lt;/code&gt;, not that the array variable is of type &lt;code&gt;Dog&lt;/code&gt;. But the &lt;code&gt;loud&lt;/code&gt; property applies to the array, not to the dogs in the array. If the array variable needs to have a type, it can be supplied as if it were a property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog @dogpound is DogPound is loud;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, if a property is the name of a known package/class, it is taken to be a kind of &lt;code&gt;tie&lt;/code&gt;. Given the declaration above, the following is always true:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @dogpound.is.loud
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;since the &lt;code&gt;loud&lt;/code&gt; is a property of the array object, even if it contains no dogs. It turns out that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @dogpound.is.DogPound
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is also true. This does not do an isa lookup. For that, say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @dogpound.isa(Pound)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you can use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @dogpound =~ Dog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to test the individual elements for Doghood.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-173-html-id-rfc-173-allow-multiple-loop-variables-in-foreach-statements-rfc-173-allow-multiple-loop-variables-in-foreach-statements-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/173.html&#34; id=&#34;rfc 173: allow multiple loop variables in foreach statements&#34;&gt;RFC 173: Allow multiple loop variables in foreach statements&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Unfortunately, the proposed syntax could also be interpreted as parallel traversal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  foreach ($a, $b) (@a, @b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Also the RFC assumes pairs will be passed as two elements, which is no longer necessarily the case. A hash by itself in list context will return a list of pair objects. We&amp;rsquo;ll need to say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %hash.kv
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to get a flattened list of keys alternating with values. (The same method on arrays produces alternating indices and values.)&lt;/p&gt;

&lt;p&gt;I like the idea of this RFC, but the proposed syntax is not what I&amp;rsquo;d like. There are various possible syntaxes that could also potentially fulfill the intent of RFC 120:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for [$i =&amp;gt; $elem] (@array) { }
    for {$i =&amp;gt; $elem} (@array) { }
    for ($i, $elem) = (@array.kv) { }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But I like the idea of something that feels like repeated binding. We could use the &lt;code&gt;:=&lt;/code&gt; binding operator, but since binding is actually the operation performed by formal parameters of subroutines, and since we&amp;rsquo;d like to keep the list near the &lt;code&gt;for&lt;/code&gt; and the formals near the closure, we&amp;rsquo;ll use a variant of subroutine declaration to declare &lt;code&gt;for&lt;/code&gt; loops:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @list -&amp;gt; $x { ... }         # one value at a time
    for @list -&amp;gt; $a, $b { ... }     # two values at a time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can un-interleave an array by saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @xyxyxy -&amp;gt; $x, $y { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Iterating over multiple lists in parallel needs a syntax much like a multi-dimensional slice. That is, something like a comma that binds looser than a comma. Since we&amp;rsquo;ll be using semicolon for that purpose to delimit the dimensions of multi-dimensional slices, we&amp;rsquo;ll use similar semicolons to delimit a parallel traversal of multiple lists: So parallel arrays could be stepped through like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @xxx; @yyy; @zzz -&amp;gt; $x; $y; $z { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there are semicolons on the right, there must be the same number as on the left.&lt;/p&gt;

&lt;p&gt;Each &amp;ldquo;stream&amp;rdquo; is considered separately, so you can traverse two arrays each two elements at a time like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @ababab; @cdcdcd -&amp;gt; $a, $b; $c, $d { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If there are no semicolons on the right, the values are taken sequentially across the streams. So you can say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @aaaa; @bbbb -&amp;gt; $a, $b { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and it ends up meaning the same thing as if the comma were a semicolon, but only because the number of variables on the right happens to be the same as the number of streams on the right. That doesn&amp;rsquo;t have to be the case. To get values one at a time across three streams, you can say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @a; @b; @c -&amp;gt; $x { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each semicolon delimited expression on the left is considered to be a list of generated values, so it&amp;rsquo;s perfectly legal to use commas or &amp;ldquo;infinite&amp;rdquo; ranges on the left. The following prints &amp;ldquo;a0&amp;rdquo;, &amp;ldquo;b2&amp;rdquo;, &amp;ldquo;c3&amp;rdquo;, and so on forever (or at least for a very long time):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for 0 .. Inf; &amp;quot;a&amp;quot; .. &amp;quot;z&amp;quot; x 1000 -&amp;gt; $i; $a {
        print &amp;quot;$a$i&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-19-html-id-rfc-019-rename-the-local-operator-rfc-019-rename-the-local-operator-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/19.html&#34; id=&#34;rfc 019: rename the local operator&#34;&gt;RFC 019: Rename the local operator&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ll go with &lt;code&gt;temp&lt;/code&gt; for the temporizing operator.&lt;/p&gt;

&lt;p&gt;In addition, we&amp;rsquo;re going to be storing more global state in objects (such as file objects). So it ought to be possible to temporize (that is, checkpoint/restore) an attribute of an object, or at least any attributes that can be treated as an lvalue.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-64-html-id-rfc-064-new-pragma-39-scope-39-to-change-perl-39-s-default-scoping-rfc-064-new-pragma-scope-to-change-perl-s-default-scoping-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/64.html&#34; id=&#34;rfc 064: new pragma &amp;#39;scope&amp;#39; to change perl&amp;#39;s default scoping&#34;&gt;RFC 064: New pragma &amp;lsquo;scope&amp;rsquo; to change Perl&amp;rsquo;s default scoping&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I can&amp;rsquo;t stop people from experimenting, but I&amp;rsquo;m not terribly interested in performing this experiment myself. I made &lt;code&gt;my&lt;/code&gt; short for a reason. So I&amp;rsquo;m accepting this RFC in principle, but only in principle. Standard Perl declarations will be plainly marked with &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;our&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;span-id-rejected-rfcs-rejected-rfcs-span&#34;&gt;&lt;span id=&#34;rejected rfcs&#34;&gt;Rejected RFCs&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Just because I&amp;rsquo;ve rejected these RFCs doesn&amp;rsquo;t mean that they weren&amp;rsquo;t addressing at a valid need. Usually an RFC gets rejected simply because I think there&amp;rsquo;s a better way to do it. Often there&amp;rsquo;s little difference between a rejected RFC that I&amp;rsquo;ve borrowed ideas from and an RFC accepted with major caveats.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re already running long, so these descriptions will be terse. Please read the RFC if you don&amp;rsquo;t understand the commentary.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-89-html-id-rfc-089-controllable-data-typing-rfc-089-controllable-data-typing-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/89.html&#34; id=&#34;rfc 089: controllable data typing&#34;&gt;RFC 089: Controllable Data Typing&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This is pretty close to what we&amp;rsquo;ve been planning for Perl for a long time. However, a number of the specifics are suboptimal.&lt;/p&gt;

&lt;p&gt;If you declare a constant, it&amp;rsquo;s a constant. There&amp;rsquo;s no point in allowing warnings on that by default. It should be fatal to modify a constant. Otherwise you lose all your optimization possibilities.&lt;/p&gt;

&lt;p&gt;For historical reasons, the assignment in&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     my ($a, $b) = new Foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will not distribute automatically over &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt;. If you want that, use the &lt;code&gt;^=&lt;/code&gt; hyperassignment instead, maybe.&lt;/p&gt;

&lt;p&gt;Constraint lists are vaguely interesting, but seem to be too much mechanism for the possible benefits. If you really want a data type that can be polymorphic, why not just define a polymorphic type?&lt;/p&gt;

&lt;p&gt;In general, there seems to be a lot of confusion in this RFC between constraints on variables and constraints on values. For constraints to be useful to the compiler, they have to be on the variable, and you can&amp;rsquo;t be &amp;ldquo;pushing&amp;rdquo; constraints at runtime.&lt;/p&gt;

&lt;p&gt;On aliasing via subroutine calls, note that declared parameters will be constant by default.&lt;/p&gt;

&lt;p&gt;So anyway, although I&amp;rsquo;m rejecting this RFC, we&amp;rsquo;ll certainly have a declaration syntax resembling some of the tables in the RFC.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-106-html-id-rfc-106-yet-another-lexical-variable-proposal-lexical-variables-made-default-rfc-106-yet-another-lexical-variable-proposal-lexical-variables-made-default-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/106.html&#34; id=&#34;rfc 106: yet another lexical variable proposal: lexical variables made default&#34;&gt;RFC 106: Yet another lexical variable proposal: lexical variables made default&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Yes, it&amp;rsquo;s true that other widely-admired languages like Ruby do implicit declaration of lexicals, but I think it&amp;rsquo;s a mistake, the results of which don&amp;rsquo;t show up until things start getting complicated. (It&amp;rsquo;s a sign of this weakness that in Ruby you see the workaround of faking up an assignment to force declaration of a variable.)&lt;/p&gt;

&lt;p&gt;I dislike the implicit declaration of lexicals because it tends to defeat the primary use of them, namely, catching typos. It&amp;rsquo;s just too easy to declare additional variable names by accident. It&amp;rsquo;s also too easy to broaden the scope of a variable by accident. You might have a bunch of separate subroutines each with their own lexical, and suddenly find that they&amp;rsquo;re all the same variable because you accidentally used the same variable name in the module initialization code.&lt;/p&gt;

&lt;p&gt;When you think about it, requiring &lt;code&gt;my&lt;/code&gt; on declaration is a form of orthogonality. Otherwise you find your default scoping rules arbitrarily tied to an inner scope, or an outer scope, or a subroutine scope. All of these are suboptimal choices. And I don&amp;rsquo;t buy the notion of using &lt;code&gt;my&lt;/code&gt; optionally to disambiguate when you feel like it. Perl gives you a lot of rope to hang yourself with, but this is the wrong kind of rope, because it obscures a needful visual distinction. Declarations should look like declarations, not just to the programmer, but also to whoever has to read the program after them, whether carbon-based or silicon-based.&lt;/p&gt;

&lt;p&gt;And when it comes down to it, I believe that declarations with &lt;code&gt;my&lt;/code&gt; are properly Huffman encoded. Declaring a lexical ought to be harder than assigning to one. And declaring a global ought to be harder than declaring a lexical (at least within classes and modules).&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-119-html-id-rfc-119-object-neutral-error-handling-via-exceptions-rfc-119-object-neutral-error-handling-via-exceptions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/119.html&#34; id=&#34;rfc 119: object neutral error handling via exceptions&#34;&gt;RFC 119: Object neutral error handling via exceptions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Good goals, but I don&amp;rsquo;t want yet another independent system of exception handling. Simplicity comes through unification. Also, the proposed syntax is all just a little too intertwingled for my tastes. Let&amp;rsquo;s see, how can I explain what I mean?&lt;/p&gt;

&lt;p&gt;The out-of-band stuff doesn&amp;rsquo;t stand out visually enough to me, and I don&amp;rsquo;t like thinking about it as control flow. Nevertheless, I think that what we&amp;rsquo;ve ended up with solves a number of the problems pointed out in this RFC. The RFC essentially asks for the functionality of &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;KEEP&lt;/code&gt; and &lt;code&gt;UNDO&lt;/code&gt; at a statement level. Although &lt;code&gt;POST&lt;/code&gt;, &lt;code&gt;KEEP&lt;/code&gt;, and &lt;code&gt;UNDO&lt;/code&gt; blocks cannot be attached to any statement, I believe that allowing &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;keep&lt;/code&gt;, and &lt;code&gt;undo&lt;/code&gt; properties in scoped declarations is powerful enough, and gives the compiler something tangible to attach the actions to. There is a kind of precision in attaching these actions to a specific variable&amp;ndash;the state is bound to the variable in a transactionally instantaneous way. I&amp;rsquo;m afraid if we attach transactional actions to statements as the RFC proposes, it won&amp;rsquo;t be clear exactly when the statement&amp;rsquo;s state change is to be considered successful, since the transaction can&amp;rsquo;t &amp;ldquo;know&amp;rdquo; which operation is the crucial one.&lt;/p&gt;

&lt;p&gt;Nonetheless, some ideas from this RFC will live on in the &lt;code&gt;post&lt;/code&gt;, &lt;code&gt;keep&lt;/code&gt;, and &lt;code&gt;undo&lt;/code&gt; property blocks.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-120-html-id-rfc-120-implicit-counter-in-for-statements-possibly-rfc-120-implicit-counter-in-for-statements-possibly-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/120.html&#34; id=&#34;rfc 120: implicit counter in for statements, possibly $#.&#34;&gt;RFC 120: Implicit counter in for statements, possibly $#.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I am prejudiced against this one, simply because I&amp;rsquo;ve been burned too many times by implicit variables that mandate implicit overhead. I think if you need an index, you should declare one, so that if you don&amp;rsquo;t declare one, the compiler knows not to bother setting up for it.&lt;/p&gt;

&lt;p&gt;Another problem is that people will keep asking what&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (@foo,@bar) { print $# }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is supposed to mean.&lt;/p&gt;

&lt;p&gt;I expect that we&amp;rsquo;ll end up with something more like what we discussed earlier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @array.kv -&amp;gt; $i, $elem { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-262-html-id-rfc-262-index-attribute-rfc-262-index-attribute-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/262.html&#34; id=&#34;rfc 262: index attribute&#34;&gt;RFC 262: Index Attribute&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Everyone has a use for &lt;code&gt;:&lt;/code&gt; these days&amp;hellip;&lt;/p&gt;

&lt;p&gt;This one seems not to be of very high utility, suffering from similar problems as the RFC 120 proposal. I don&amp;rsquo;t think it&amp;rsquo;s possible to efficiently track the container of a value within each contained object unless we know at compile time what a looping construct is, which is problematic with user-defined control structures.&lt;/p&gt;

&lt;p&gt;And what if an item is a member of more than one list?&lt;/p&gt;

&lt;p&gt;Again, I&amp;rsquo;d rather have something declared so we know whether to take the overhead. Then we don&amp;rsquo;t have to pessimize whenever we can&amp;rsquo;t do a complete static analysis.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-167-html-id-rfc-167-simplify-do-block-syntax-rfc-167-simplify-do-block-syntax-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/167.html&#34; id=&#34;rfc 167: simplify do block syntax&#34;&gt;RFC 167: Simplify do BLOCK Syntax&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I think the &amp;ldquo;do&amp;rdquo; on a &lt;code&gt;do&lt;/code&gt; block is useful to emphasize that the closure in the braces is to be executed immediately. Otherwise Perl (or the user (or both)) might be confused as to whether someone was trying to write a closure that is to be executed later, particularly if the block is the last item in a subroutine that might be wanting to return a closure. In fact, we&amp;rsquo;ll probably outlaw bare blocks at the statement level as too ambiguous. Use &lt;code&gt;for 1 {}&lt;/code&gt; or some such when you want a one-time loop, and use &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;sub&lt;/code&gt; when you want to return a closure.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll solve the &lt;code&gt;;&lt;/code&gt; problem by jiggering the definition of &lt;code&gt;{...}&lt;/code&gt;, not by fiddling with &lt;code&gt;do&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-209-html-id-rfc-209-fuller-integer-support-in-perl-rfc-209-fuller-integer-support-in-perl-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/209.html&#34; id=&#34;rfc 209: fuller integer support in perl.&#34;&gt;RFC 209: Fuller integer support in Perl.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;The old &lt;code&gt;use integer&lt;/code&gt; pragma was a hack. I think I&amp;rsquo;d rather use types and representation specs on individual declarations for compile-time selection, or alternate object constructors for run-time selection, particularly when infinite precision is desired. I&amp;rsquo;m not against using pragmas to alter the defaults, but I think it&amp;rsquo;s generally better to be more specific when you have the capability. You can force your programs to be lexically scoped with pragmas, but data wants to flow wherever it likes to go, so your lexically scoped module had better be able to deal rationally with any data thrown at it, even if it isn&amp;rsquo;t in the exact form that you prefer.&lt;/p&gt;

&lt;p&gt;By the way, the RFC is misleading when it asserts that 32-bit integer precision is lost when represented in floating point. That&amp;rsquo;s only true if you use 32-bit floats. Perl has always used 64-bit doubles, which give approximately 15 digits of integer precision. (The issue does arise with 64-bit integers, of course.)&lt;/p&gt;

&lt;p&gt;All that being said, Perl 6 will certainly have better support for integer types of various sorts. I just don&amp;rsquo;t think that a pragma redefining what an &amp;ldquo;integer&amp;rdquo; is will provide good documentation to whoever is trying to understand the program. Better to declare things of type MagicNum, or whatever.&lt;/p&gt;

&lt;p&gt;I could be wrong, of course. If so, write your pragma, and have the appropriate amount of fun.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-279-html-id-rfc-279-my-syntax-extensions-and-attribute-declarations-rfc-279-code-my-code-syntax-extensions-and-attribute-declarations-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/279.html&#34; id=&#34;rfc 279: my() syntax extensions and attribute declarations&#34;&gt;RFC 279: &lt;code&gt;my()&lt;/code&gt; syntax extensions and attribute declarations&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We already treated this in Apocalypse 2.&lt;/p&gt;

&lt;p&gt;The RFC assumes that the type always distributes over a &lt;code&gt;my&lt;/code&gt; list. This is not what is necessary for function signatures, which need individual types for each formal argument.&lt;/p&gt;

&lt;p&gt;And again, it doesn&amp;rsquo;t make much sense to me to put properties on a variable at run-time.&lt;/p&gt;

&lt;p&gt;It makes even less sense to me to be able to declare the type of an array element lexically. This is the province of objects, not arrays pretending to be structs.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-297-html-id-rfc-297-attributes-for-compiler-hints-rfc-297-attributes-for-compiler-hints-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/297.html&#34; id=&#34;rfc 297: attributes for compiler hints&#34;&gt;RFC 297: Attributes for compiler hints&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Sorry, we can&amp;rsquo;t have the semantics suddenly varying drastically merely because the user decided to run the program through a different translator. I think there&amp;rsquo;s a happy medium in there somewhere where we can have the same semantics for both interpreter and compiler.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-309-html-id-rfc-309-allow-keywords-in-sub-prototypes-rfc-309-allow-keywords-in-sub-prototypes-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/309.html&#34; id=&#34;rfc 309: allow keywords in sub prototypes&#34;&gt;RFC 309: Allow keywords in sub prototypes&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC is rejected only because it doesn&amp;rsquo;t go far enough. What we&amp;rsquo;ll eventually need is to allow a regex-ish syntax notation for parsing that may be separate from the argument declarations. (Then again, maybe not.) In any event, I think some kind of explicit regex notation is called for, not the promotion of identifiers to token matchers. We may want identifiers in signatures for something else later, so we&amp;rsquo;ll hold them in reserve.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-340-html-id-rfc-340-with-takes-a-context-rfc-340-with-takes-a-context-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/340.html&#34; id=&#34;rfc 340: with takes a context&#34;&gt;RFC 340: with takes a context&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This seems like a solution in search of a problem. Even if we end up with a context stack as explicit as Perl 5&amp;rsquo;s, I don&amp;rsquo;t think the amount we&amp;rsquo;ll deal with it warrants a keyword. (And I dislike &amp;ldquo;&lt;code&gt;return with;&lt;/code&gt;&amp;rdquo; as a needlessly opaque linguistic construct.)&lt;/p&gt;

&lt;p&gt;That being said, if someone implements (as user-defined code) the Pascalish &lt;code&gt;with&lt;/code&gt; as proposed in RFC 342 (and rejected), and if the &lt;code&gt;caller&lt;/code&gt; function (or something similar) returns sufficient information to build references to the lexical scope associated with the call frame in question, then something like this could also be implemented as user code. I can&amp;rsquo;t decide whether it&amp;rsquo;s not clear that this is a good idea, or it&amp;rsquo;s clear that this is not a good idea. In any event, I would warn anyone doing this that it&amp;rsquo;s likely to be extremely confusing, akin to goto-considered-harmful, and for similar reasons, though in this case by displacing scopes rather than control flow.&lt;/p&gt;

&lt;p&gt;Note that some mechanism resembling this will be necessary for modules to do exportation to a lexical scope (see &lt;code&gt;%MY&lt;/code&gt; in Apocalypse 2). However, lexical scope modification will be allowed only during the compile time of the lexical scope in question, since we need to be careful to preserve the encapsulation that lexical scoping provides. Turning lexical variables back into dynamic variables will tend to destroy that security.&lt;/p&gt;

&lt;p&gt;So I think we&amp;rsquo;ll stick with closures and continuations that don&amp;rsquo;t transport lexical scopes at runtime.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-342-html-id-rfc-342-pascallike-with-rfc-342-pascal-like-quot-with-quot-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/342.html&#34; id=&#34;rfc 342: pascallike with&#34;&gt;RFC 342: Pascal-like &amp;quot;with&amp;quot;&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I expect Perl&amp;rsquo;s parsing to be powerful enough that you could write a &amp;ldquo;with&amp;rdquo; if you wanted one.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S04.html&#34;&gt;Synopsis 04&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;span-id-withdrawn-rfcs-withdrawn-rfcs-span&#34;&gt;&lt;span id=&#34;withdrawn rfcs&#34;&gt;Withdrawn RFCs&lt;/span&gt;&lt;/h2&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-63-html-id-rfc-063-exception-handling-syntax-rfc-063-exception-handling-syntax-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/63.html&#34; id=&#34;rfc 063: exception handling syntax&#34;&gt;RFC 063: Exception handling syntax&lt;/a&gt;&lt;/h3&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-113-html-id-rfc-113-better-constants-and-constant-folding-rfc-113-better-constants-and-constant-folding-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/113.html&#34; id=&#34;rfc 113: better constants and constant folding&#34;&gt;RFC 113: Better constants and constant folding&lt;/a&gt;&lt;/h3&gt;

&lt;hr /&gt;

&lt;h1 id=&#34;span-id-other-decisions-other-decisions-span&#34;&gt;&lt;span id=&#34;other decisions&#34;&gt;Other decisions&lt;/span&gt;&lt;/h1&gt;

&lt;h3 id=&#34;span-id-cstyle-for-loop-c-style-for-loop-span&#34;&gt;&lt;span id=&#34;cstyle for loop&#34;&gt;C-style for loop&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Due to syntactic ambiguities with the new &lt;code&gt;for&lt;/code&gt; syntax of Perl 6, the generalized C-style &lt;code&gt;for&lt;/code&gt; loop is going to get its keyword changed to &lt;code&gt;loop&lt;/code&gt;. And &lt;code&gt;for&lt;/code&gt; will now always mean &amp;ldquo;foreach&amp;rdquo;. The expression &amp;ldquo;pill&amp;rdquo; is now optional, so instead of writing an infinite loop like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for (;;) {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you can now write it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    loop {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-cstyle-do-while-expr-no-longer-supported-c-style-do-while-expr-no-longer-supported-span&#34;&gt;&lt;span id=&#34;cstyle do {} while expr no longer supported&#34;&gt;C-style do {} while EXPR no longer supported&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In Perl 5, when you used a &lt;code&gt;while&lt;/code&gt; statement modifier on a statement consisting of nothing but a &lt;code&gt;do {}&lt;/code&gt;, something magical happened, and the block would be evaluated once before the condition was evaluated. This special-cased construct, seldom used and often misunderstood, will no longer be in Perl 6, and in fact will produce a compile-time error to prevent people from trying to use it. Where Perl 5 code has this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    do {
        ...
    } while CONDITION;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl 6 code will use a construct in which the control flow is more explicit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    loop {
        ...
        last unless CONDITION;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-bare-blocks-bare-blocks-span&#34;&gt;&lt;span id=&#34;bare blocks&#34;&gt;Bare blocks&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In Perl 5, bare blocks (blocks used as statements) are once-through loops. In Perl 6, blocks are closures. It would be possible to automatically execute any closure in void context, but unfortunately, when a closure is used as the final statement in an outer block, it&amp;rsquo;s ambiguous as to whether you wanted to return or execute the closure. Therefore the use of a closure at the statement level will be considered an error, whether or not it&amp;rsquo;s in a void context. Use &lt;code&gt;do {}&lt;/code&gt; for a &amp;ldquo;once&amp;rdquo; block, and an explicit &lt;code&gt;return&lt;/code&gt; or &lt;code&gt;sub&lt;/code&gt; when you want to return a reference to the closure.&lt;/p&gt;

&lt;h3 id=&#34;span-id-continue-block-continue-block-span&#34;&gt;&lt;span id=&#34;continue block&#34;&gt;continue block&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The &lt;code&gt;continue&lt;/code&gt; block changes its name to &lt;code&gt;NEXT&lt;/code&gt; and moves inside the block it modifies, to work like &lt;code&gt;POST&lt;/code&gt; blocks. Among other things, this allows &lt;code&gt;NEXT&lt;/code&gt; blocks to refer to lexical variables declared within the loop, provided the &lt;code&gt;NEXT&lt;/code&gt; block is place after them. The generalized loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    loop (EXPR1; EXPR2; EXPR3) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;can now be defined as equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    EXPR1;
    while EXPR2 {
        NEXT { EXPR3 }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(except that any variable declared in &lt;code&gt;EXPR3&lt;/code&gt; would have different lexical scope). The &lt;code&gt;NEXT&lt;/code&gt; block is called only before attempting the next iteration of the loop. It is not called when the loop is done and about to exit. Use a &lt;code&gt;POST&lt;/code&gt; for that.&lt;/p&gt;

&lt;p&gt;Well, that about wraps it up for now. You might be interesting to know that I&amp;rsquo;m posting this from the second sesquiannual Perl Whirl cruise, on board the Veendam, somewhere in the Carribean. If the ship disappears in the Bermuda Triangle, you won&amp;rsquo;t have to worry about the upcoming Exegesis, since Damian is also board. But for now, Perl 6 is cruising along, the weather&amp;rsquo;s wonderful, wish you were here.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apocalypse 3</title>
      <link>http://localhost:1313/pub/2001/10/02/apocalypse3.html/</link>
      <pubDate>Tue, 02 Oct 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/10/02/apocalypse3.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 03&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Table of Contents&lt;/p&gt;
&lt;p&gt;• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=2#rfc%20025:%20operators:%20multiway%20comparisons&#34;&gt;RFC 025: Operators: Multiway comparisons&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=2#rfc%20320:%20allow%20grouping%20of%20x%20file%20tests%20and%20add%20filetest%20builtin&#34;&gt;RFC 320: Allow grouping of -X file tests and add &lt;code&gt;filetest&lt;/code&gt; builtin&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=2#rfc%20290:%20better%20english%20names%20for%20x&#34;&gt;RFC 290: Better english names for -X&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=3#rfc%20283:%20tr///%20in%20array%20context%20should%20return%20a%20histogram&#34;&gt;RFC 283: &lt;code&gt;tr///&lt;/code&gt; in array context should return a histogram&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=3#rfc%20084:%20replace%20=%3E%20(stringifying%20comma)%20with%20=%3E%20(pair%20constructor)&#34;&gt;RFC 084: Replace &lt;code&gt;=&amp;gt;&lt;/code&gt; (stringifying comma) with &lt;code&gt;=&amp;gt;&lt;/code&gt; (pair constructor)&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=3#rfc%20081:%20lazily%20evaluated%20list%20generation%20functions&#34;&gt;RFC 081: Lazily evaluated list generation functions&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=4#rfc%20285:%20lazy%20input%20/%20contextsensitive%20input&#34;&gt;RFC 285: Lazy Input / Context-sensitive Input&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=4#rfc%20082:%20arrays:%20apply%20operators%20elementwise%20in%20a%20list%20context&#34;&gt;RFC 082: Arrays: Apply operators element-wise in a list context&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=4#rfc%20045:%20%7C%7C%20and%20&amp;amp;&amp;amp;%20should%20propagate%20result%20context%20to%20both%20sides&#34;&gt;RFC 045: &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; should propagate result context to both sides&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=5#rfc%20054:%20operators:%20polymorphic%20comparisons&#34;&gt;RFC 054: Operators: Polymorphic comparisons&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=5#rfc%20104:%20backtracking&#34;&gt;RFC 104: Backtracking&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=5#rfc%20143:%20case%20ignoring%20eq%20and%20cmp%20operators&#34;&gt;RFC 143: Case ignoring &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=5#rfc%20170:%20generalize%20=~%20to%20a%20special%20applyto%20assignment%20operator&#34;&gt;RFC 170: Generalize &lt;code&gt;=~&lt;/code&gt; to a special ``apply-to&#39;&#39; assignment operator&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#nonrfc%20considerations&#34;&gt;Non-RFC considerations&lt;/a&gt;&lt;/p&gt;
&lt;table&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt; &lt;/td&gt;
&lt;td&gt;&lt;span class=&#34;tiny&#34;&gt; • &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#binary%20.%20(dot)&#34;&gt;Binary &lt;code&gt;.&lt;/code&gt; (dot)&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#unary%20.%20(dot)&#34;&gt;Unary &lt;code&gt;.&lt;/code&gt; (dot)&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#binary%20_&#34;&gt;Binary &lt;code&gt;_&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#unary%20_&#34;&gt;Unary &lt;code&gt;_&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#unary%20+%20X&#34;&gt;Unary &lt;code&gt;+&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#binary%20:=%20Y&#34;&gt;Binary &lt;code&gt;:=&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#unary%20*%20XX&#34;&gt;Unary &lt;code&gt;*&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#list%20context&#34;&gt;List context&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#binary%20:%20YY&#34;&gt;Binary &lt;code&gt;:&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#trinary%20::&#34;&gt;Trinary &lt;code&gt;??::&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#binary%20//%20YYY&#34;&gt;Binary &lt;code&gt;//&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#binary%20;%20YYYY&#34;&gt;Binary &lt;code&gt;;&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#unary%20%5E%20XXX&#34;&gt;Unary &lt;code&gt;^&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#unary%20&#34;&gt;Unary &lt;code&gt;?&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#binary%20&#34;&gt;Binary &lt;code&gt;?&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#binary%20~%20YYYYY&#34;&gt;Binary &lt;code&gt;~&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#binary%20~~%20YYYYYY&#34;&gt;Binary &lt;code&gt;~~&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#user%20defined%20operators&#34;&gt;User defined operators&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#unicode%20operators&#34;&gt;Unicode operators&lt;/a&gt;&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/10/02/apocalypse3.html?page=6#precedence&#34;&gt;Precedence&lt;/a&gt;&lt;br /&gt;
&lt;/span&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;To me, one of the most agonizing aspects of language design is coming up with a useful system of operators. To other language designers, this may seem like a silly thing to agonize over. After all, you can view all operators as mere syntactic sugar &amp;ndash; operators are just funny looking function calls. Some languages make a feature of leveling all function calls into one syntax. As a result, the so-called functional languages tend to wear out your parenthesis keys, while OO languages tend to wear out your dot key.&lt;/p&gt;

&lt;p&gt;But while your computer really likes it when everything looks the same, most people don&amp;rsquo;t think like computers. People prefer different things to look different. They also prefer to have shortcuts for common tasks. (Even the mathematicians don&amp;rsquo;t go for complete orthogonality. Many of the shortcuts we typically use for operators were, in fact, invented by mathematicians in the first place.)&lt;/p&gt;

&lt;p&gt;So let me enumerate some of the principles that I weigh against each other when designing a system of operators.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Different classes of operators should look different. That&amp;rsquo;s why filetest operators look different from string or numeric operators.&lt;/li&gt;
&lt;li&gt;Similar classes of operators should look similar. That&amp;rsquo;s why the filetest operators look like each other.&lt;/li&gt;
&lt;li&gt;Common operations should be ``Huffman coded.&amp;rdquo; That is, frequently used operators should be shorter than infrequently used ones. For how often it&amp;rsquo;s used, the &lt;code&gt;scalar&lt;/code&gt; operator of Perl 5 is too long, in my estimation.&lt;/li&gt;
&lt;li&gt;Preserving your culture is important. So Perl borrowed many of its operators from other familiar languages. For instance, we used Fortran&amp;rsquo;s &lt;code&gt;**&lt;/code&gt; operator for exponentiation. As we go on to Perl 6, most of the operators will be ``borrowed&amp;rdquo; directly from Perl 5.&lt;/li&gt;
&lt;li&gt;Breaking out of your culture is also important, because that is how we understand other cultures. As an explicitly multicultural language, Perl has generally done OK in this area, though we can always do better. Examples of cross-cultural exchange among computer cultures include XML and Unicode. (Not surprisingly, these features also enable better cross-cultural exchange among human cultures &amp;ndash; we sincerely hope.)&lt;/li&gt;
&lt;li&gt;Sometimes operators should respond to their context. Perl has many operators that do different but related things in scalar versus list context.&lt;/li&gt;
&lt;li&gt;Sometimes operators should propagate context to their arguments. The &lt;code&gt;x&lt;/code&gt; operator currently does this for its left argument, while the short-circuit operators do this for their right argument.&lt;/li&gt;
&lt;li&gt;Sometimes operators should force context on their arguments. Historically, the scalar mathematical operators of Perl have forced scalar context on their arguments. One of the RFCs discussed below proposes to revise this.&lt;/li&gt;
&lt;li&gt;Sometimes operators should respond polymorphically to the types of their arguments. Method calls and overloading work this way.&lt;/li&gt;
&lt;li&gt;Operator precedence should be designed to minimize the need for parentheses. You can think of the precedence of operators as a partial ordering of the operators such that it minimizes the number of ``unnatural&amp;rdquo; pairings that require parentheses in typical code.&lt;/li&gt;
&lt;li&gt;Operator precedence should be as simple as possible. Perl&amp;rsquo;s precedence table currently has 24 levels in it. This might or might not be too many. We could probably reduce it to about 18 levels, if we abandon strict C compatibility of the C-like operators.&lt;/li&gt;
&lt;li&gt;People don&amp;rsquo;t actually want to think about precedence much, so precedence should be designed to match expectations. Unfortunately, the expectations of someone who knows the precedence table won&amp;rsquo;t match the expectations of someone who doesn&amp;rsquo;t. And Perl has always catered to the expectations of C programmers, at least up till now. There&amp;rsquo;s not much one can do up front about differing cultural expectations.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It would be easy to drive any one of these principles into the ground, at the expense of other principles. In fact, various languages have done precisely that.&lt;/p&gt;

&lt;p&gt;My overriding design principle has always been that the complexity of the solution space should map well onto the complexity of the problem space. Simplification good! Oversimplification bad! Placing artificial constraints on the solution space produces an impedence mismatch with the problem space, with the result that using a language that is artificially simple induces artificial complexity in all solutions written in that language.&lt;/p&gt;

&lt;p&gt;One artificial constraint that all computer languages must deal with is the number of symbols available on the keyboard, corresponding roughly to the number of symbols in ASCII. Most computer languages have compensated by defining systems of operators that include digraphs, trigraphs, and worse. This works pretty well, up to a point. But it means that certain common unary operators cannot be used as the end of a digraph operator. Early versions of C had assignment operators in the wrong order. For instance, there used to be a &lt;code&gt;=-&lt;/code&gt; operator. Nowadays that&amp;rsquo;s spelled &lt;code&gt;-=&lt;/code&gt;, to avoid conflict with unary minus.&lt;/p&gt;

&lt;p&gt;By the same token (no pun intended), you can&amp;rsquo;t easily define a unary &lt;code&gt;=&lt;/code&gt; operator without requiring a space before it most of the time, since so many binary operators end with the &lt;code&gt;=&lt;/code&gt; character.&lt;/p&gt;

&lt;p&gt;Perl gets around some of these problems by keeping track of whether it is expecting an operator or a term. As it happens, a unary operator is simply one that occurs when Perl is expecting a term. So Perl could keep track of a unary &lt;code&gt;=&lt;/code&gt; operator, even if the human programmer might be confused. So I&amp;rsquo;d place a unary &lt;code&gt;=&lt;/code&gt; operator in the category of ``OK, but don&amp;rsquo;t use it for anything that will cause widespread confusion.&amp;rdquo; Mind you, I&amp;rsquo;m not proposing a specific use for a unary &lt;code&gt;=&lt;/code&gt; at this point. I&amp;rsquo;m just telling you how I think. If we ever do get a unary &lt;code&gt;=&lt;/code&gt; operator, we will hopefully have taken these issues into account.&lt;/p&gt;

&lt;p&gt;While we can disambiguate operators based on whether an operator or a term is expected, this implies some syntactic constraints as well. For instance, you can&amp;rsquo;t use the same symbol for both a postfix operator and a binary operator. So you&amp;rsquo;ll never see a binary &lt;code&gt;++&lt;/code&gt; operator in Perl, because Perl wouldn&amp;rsquo;t know whether to expect a term or operator after that. It also implies that we can&amp;rsquo;t use the ``juxtaposition&amp;rdquo; operator. That is, you can&amp;rsquo;t just put two terms next to each other, and expect something to happen (such as string concatenation, as in &lt;em&gt;awk&lt;/em&gt;). What if the second term started with something looked like an operator? It would be misconstrued as a binary operator.&lt;/p&gt;

&lt;p&gt;Well, enough of these vague generalities. On to the vague specifics.&lt;/p&gt;

&lt;p&gt;The RFCs for this apocalypse are (as usual) all over the map, but don&amp;rsquo;t cover the map. I&amp;rsquo;ll talk first about what the RFCs do cover, and then about what they don&amp;rsquo;t. Here are the RFCs that happened to get themselves classified into chapter 3:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RFC   PSA    Title
    ---   ---    -----
    024   rr     Data types: Semi-finite (lazy) lists
    025   dba    Operators: Multiway comparisons
    039   rr     Perl should have a print operator 
    045   bbb    C&amp;lt;||&amp;gt; and C&amp;lt;&amp;amp;&amp;amp;&amp;gt; should propagate result context to both sides
    054   cdr    Operators: Polymorphic comparisons
    081   abc    Lazily evaluated list generation functions
    082   abc    Arrays: Apply operators element-wise in a list context
    084   abb    Replace =&amp;gt; (stringifying comma) with =&amp;gt; (pair constructor)
    104   ccr    Backtracking
    138   rr     Eliminate =~ operator.
    143   dcr    Case ignoring eq and cmp operators
    170   ccr    Generalize =~ to a special &amp;quot;apply-to&amp;quot; assignment operator
    283   ccc    C&amp;lt;tr///&amp;gt; in array context should return a histogram
    285   acb    Lazy Input / Context-sensitive Input
    290   bbc    Better english names for -X
    320   ccc    Allow grouping of -X file tests and add C&amp;lt;filetest&amp;gt; builtin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you can click on the following RFC titles to view a copy of the RFC in question. The discussion sometimes assumes that you&amp;rsquo;ve read the RFC.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 03&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-25-html-id-rfc-025-operators-multiway-comparisons-rfc-025-operators-multiway-comparisons-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/25.html&#34; id=&#34;rfc 025: operators: multiway comparisons&#34;&gt;RFC 025: Operators: Multiway comparisons&lt;/a&gt;&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;Previous Apocalypses&lt;/p&gt;
&lt;p&gt;• &lt;a href=&#34;http://localhost:1313/pub/2001/04/02/wall.html&#34;&gt;Apocalypse 1&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
• &lt;a href=&#34;http://localhost:1313/pub/2001/05/03/wall.html&#34;&gt;Apocalypse 2&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;This RFC proposes that expressions involving multiple chained comparisons should act like mathematician would expect. That is, if you say this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 &amp;lt;= $x &amp;lt; 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it really means something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 &amp;lt;= $x &amp;amp;&amp;amp; $x &amp;lt; 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$x&lt;/code&gt; would only be evaluated once, however. (This is very much like the rewrite rule we use to explain assignment operators such as &lt;code&gt;$x += 3&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;I started with this RFC simply because it&amp;rsquo;s not of any earthshaking importance whether I accept it or not. The tradeoff is whether to put some slight complexity into the grammar in order to save some slight complexity in some Perl programs. The complexity in the grammar is not much of a problem here, since it&amp;rsquo;s amortized over all possible uses of it, and it already matches the known psychology of a great number of people.&lt;/p&gt;

&lt;p&gt;There is a potential interaction with precedence levels, however. If we choose to allow an expression like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    0 &amp;lt;= $x == $y &amp;lt; 20
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then we&amp;rsquo;ll have to unify the precedence levels of the comparison operators with the equality operators. I don&amp;rsquo;t see a great problem with this, since the main reason for having them different was (I believe) so that you could write an exclusive of two comparisons, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $x &amp;lt; 10 != $y &amp;lt; 10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, Perl has a built-in &lt;code&gt;xor&lt;/code&gt; operator, so this isn&amp;rsquo;t really much of an issue. And there&amp;rsquo;s a lot to be said for forcing parentheses in that last expression anyway, just for clarity. So unless anyone comes up with a large objection that I&amp;rsquo;m not seeing, this RFC is accepted.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-320-html-id-rfc-320-allow-grouping-of-x-file-tests-and-add-filetest-builtin-rfc-320-allow-grouping-of-x-file-tests-and-add-code-filetest-code-builtin-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/320.html&#34; id=&#34;rfc 320: allow grouping of x file tests and add filetest builtin&#34;&gt;RFC 320: Allow grouping of -X file tests and add &lt;code&gt;filetest&lt;/code&gt; builtin&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC proposes to allow clustering of file test operators much like some Unix utilities allow bundling of single character switches. That is, if you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -drwx $file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it really means something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -d $file &amp;amp;&amp;amp; -r $file &amp;amp;&amp;amp; -w $file &amp;amp;&amp;amp; -x $file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, as proposed, this syntax will simply be too confusing. We have to be able to negate named operators and subroutines. The proposed workaround of putting a space after a unary minus is much too onerous and counterintuitive, or at least countercultural.&lt;/p&gt;

&lt;p&gt;The only way to rescue the proposal would be to say that such operators are autoloaded in some fashion; any negated but &lt;em&gt;unrecognized&lt;/em&gt; operator would then be assumed to be a clustered filetest. This would be risky in that it would prevent Perl from catching misspelled subroutine names at compile time when negated, and the error might well not get caught at run time either, if all the characters in the name are valid filetests, and if the argument can be interpreted as a filename or filehandle (which is usually). Perhaps it would be naturally disallowed under &lt;code&gt;use strict&lt;/code&gt;, since we&amp;rsquo;d basically be treating &lt;code&gt;-xyz&lt;/code&gt; as a bareword. On the other hand, in Perl 5, &lt;em&gt;all&lt;/em&gt; method names are essentially in the unrecognized category until run time, so it would be impossible to tell whether to parse the minus sign as a real negation. Optional type declarations in Perl 6 would only help the compiler with variables that are actually declared to have a type. Fortunately, a negated 1 is still true, so even if we parsed the negation as a real negation, it might still end up doing the right thing. But it&amp;rsquo;s all very tacky.&lt;/p&gt;

&lt;p&gt;So I&amp;rsquo;m thinking of a different tack. Instead of bundling the letters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -drwx $file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;let&amp;rsquo;s think about the trick of returning the value of &lt;code&gt;$file&lt;/code&gt; for a true value. Then we&amp;rsquo;d write nested unary operators like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -d -r -w -x $file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;One tricky thing about that is that the operators are applied right to left. And they don&amp;rsquo;t really short circuit the way stacked &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; would (though the optimizer could probably fix that). So I expect we could do this for the default, and if you want the &lt;code&gt;-drwx&lt;/code&gt; as an autoloaded backstop, you can explicitly declare that.&lt;/p&gt;

&lt;p&gt;In any event, the proposed &lt;code&gt;filetest&lt;/code&gt; built-in need not be built in. It can just be a universal method. (Or maybe just common to strings and filehandles?)&lt;/p&gt;

&lt;p&gt;My one hesitation in making cascading operators work like that is that people might be tempted to get cute with the returned filename:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $handle = open -r -w -x $file or die;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That might be terribly confusing to a lot of people. The solution to this conundrum is presented at the end of the next section.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-290-html-id-rfc-290-better-english-names-for-x-rfc-290-better-english-names-for-x-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/290.html&#34; id=&#34;rfc 290: better english names for x&#34;&gt;RFC 290: Better english names for -X&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC proposes long names as aliases for the various filetest operators, so that instead of saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -r $file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you might say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use english;
    freadable($file)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, there&amp;rsquo;s no need for the &lt;code&gt;use english&lt;/code&gt;, I expect. These names could merely universal (or nearly universal) methods. In any case, we should start getting used to the idea that &lt;code&gt;mumble($foo)&lt;/code&gt; is equivalent to &lt;code&gt;$foo.mumble()&lt;/code&gt;, at least in the absence of a local subroutine definition to the contrary. So I expect that we&amp;rsquo;ll see both:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    is_readable($file)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $file.is_readable
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similar to the cascaded filetest ops in the previous section, one approach might be that the boolean methods return the object in question for success so that method calls could be stacked without repeating the object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ($file.is_dir
             .is_readable
             .is_writable
             .is_executable) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But &lt;code&gt;-drwx $file&lt;/code&gt; could still be construed as more readable, for some definition of readability. And cascading methods aren&amp;rsquo;t really short-circuited. Plus, the value returned would have to be something like ``$file is true,&amp;rdquo; to prevent confusion over filename ``0.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;There is also the question of whether this really saves us anything other than a little notational convenience. If each of those methods has to do a &lt;em&gt;stat&lt;/em&gt; on the filename, it will be rather slow. To fix that, what we&amp;rsquo;d actually have to return would be not the filename, but some object containing the stat buffer (represented in Perl 5 by the &lt;code&gt;_&lt;/code&gt; character). If we did that, we wouldn&amp;rsquo;t have to play &lt;code&gt;$file is true&lt;/code&gt; games, because a valid stat buffer object would (presumably) always be true (at least until it&amp;rsquo;s false).&lt;/p&gt;

&lt;p&gt;The same argument would apply to cascaded filetest operators we talked about earlier. An autoloaded &lt;code&gt;-drwx&lt;/code&gt; handler would presumably be smart enough to do a single stat. But we&amp;rsquo;d likely lose the speed gain by invoking the autoload mechanism. So cascaded operators (either &lt;code&gt;-X&lt;/code&gt; style or &lt;code&gt;.is_XXX&lt;/code&gt; style) are the way to go. They just return objects that know how to be either boolean or stat buffer objects in context. This implies you could even say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $statbuf = -f $file or die &amp;quot;Not a regular file: $file&amp;quot;;
    if (-r -w $statbuf) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This allows us to simplify the special case in Perl 5 represented by the &lt;code&gt;_&lt;/code&gt; token, which was always rather difficult to explain. And returning a stat buffer instead of &lt;code&gt;$file&lt;/code&gt; prevents the confusing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $handle = open -r -w -x $file or die;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unless, of course, we decide to make a stat buffer object return the filename in a string context. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 03&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-283-html-id-rfc-283-tr-in-array-context-should-return-a-histogram-rfc-283-code-tr-code-in-array-context-should-return-a-histogram-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/283.html&#34; id=&#34;rfc 283: tr/// in array context should return a histogram&#34;&gt;RFC 283: &lt;code&gt;tr///&lt;/code&gt; in array context should return a histogram&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Yes, but &amp;hellip;&lt;/p&gt;

&lt;p&gt;While it&amp;rsquo;s true that I put that item into the Todo list ages ago, I think that histograms should probably have their own interface, since the histogram should probably be returned as a complete hash in scalar context, but we can&amp;rsquo;t guess that they&amp;rsquo;ll want a histogram for an ordinary scalar &lt;code&gt;tr///&lt;/code&gt;. On the other hand, it could just be a &lt;code&gt;/h&lt;/code&gt; modifier. But we&amp;rsquo;ve already done violence to &lt;code&gt;tr///&lt;/code&gt; to make it do character counting without transliterating, so maybe this isn&amp;rsquo;t so far fetched.&lt;/p&gt;

&lt;p&gt;One problem with this RFC is that it does the histogram over the input rather than the output string. The original Todo entry did not specify this, but it was what I had intended. But it&amp;rsquo;s more useful to do it on the resulting characters because then you can use the &lt;code&gt;tr///&lt;/code&gt; itself to categorize characters into, say, vowels and consonants, and then count the resulting V&amp;rsquo;s and C&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;On the other hand, I&amp;rsquo;m thinking that the &lt;code&gt;tr///&lt;/code&gt; interface is really rather lousy, and getting lousier every day. The whole &lt;code&gt;tr///&lt;/code&gt; interface is kind of sucky for any sort of dynamically generated data. But even without dynamic data, there are serious problems. It was bad enough when the character set was just ASCII. The basic problem is that the notation is inside out from what it should be, in the sense that it doesn&amp;rsquo;t actually show which characters correspond, so you have to count characters. We made some progress on that in Perl 5 when, instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    tr/abcdefghijklmnopqrstuvwxyz/VCCCVCCCVCCCCCVCCCCCVCCCCC/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we allowed you to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    tr[abcdefghijklmnopqrstuvwxyz]
      [VCCCVCCCVCCCCCVCCCCCVCCCCC]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are also shenanigans you can play if you know that duplicates on the left side prefer the first mention to subsequent mentions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    tr/aeioua-z/VVVVVC/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But you&amp;rsquo;re still working against the notation. We need a more explicit way to put character classes into correspondence.&lt;/p&gt;

&lt;p&gt;More problems show up when we extend the character set beyond ASCII. The use of &lt;code&gt;tr///&lt;/code&gt; for case translations has long been semi-deprecated, because a range like &lt;code&gt;tr/a-z/A-Z/&lt;/code&gt; leaves out characters with diacritics. And now with Unicode, the whole notion of what is a character is becoming more susceptible to interpretation, and the &lt;code&gt;tr///&lt;/code&gt; interface doesn&amp;rsquo;t tell Perl whether to treat character modifiers as part of the base character. For some of the double-wide characters it&amp;rsquo;s even hard to just &lt;em&gt;look&lt;/em&gt; at the character and tell if it&amp;rsquo;s one character or two. Counted character lists are about as modern as hollerith strings in Fortran.&lt;/p&gt;

&lt;p&gt;So I suspect the &lt;code&gt;tr///&lt;/code&gt; syntax will be relegated to being just one quote-like interface to the actual transliteration module, whose main interface will be specified in terms of translation pairs, the left side of which will give a pattern to match (typically a character class), and the right side will say what to translation anything matching to. Think of it as a series of coordinated parallel &lt;code&gt;s///&lt;/code&gt; operations. Syntax is still open for negotiation till apocalypse 5.&lt;/p&gt;

&lt;p&gt;But there can certainly be a histogram option in there somewhere.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-84-html-id-rfc-084-replace-gt-stringifying-comma-with-gt-pair-constructor-rfc-084-replace-code-gt-code-stringifying-comma-with-code-gt-code-pair-constructor-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/84.html&#34; id=&#34;rfc 084: replace =&amp;gt; (stringifying comma) with =&amp;gt; (pair constructor)&#34;&gt;RFC 084: Replace &lt;code&gt;=&amp;gt;&lt;/code&gt; (stringifying comma) with &lt;code&gt;=&amp;gt;&lt;/code&gt; (pair constructor)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I like the basic idea of pairs because it generalizes to more than just hash values. Named parameters will almost certainly be implemented using pairs as well.&lt;/p&gt;

&lt;p&gt;I do have some quibbles with the RFC. The proposed &lt;code&gt;key&lt;/code&gt; and &lt;code&gt;value&lt;/code&gt; built-ins should simply be lvalue methods on pair objects. And if we use pair objects to implement entries in hashes, the key must be immutable, or there must be some way of re-hashing the key if it changes.&lt;/p&gt;

&lt;p&gt;The stuff about using pairs for mumble-but-false is bogus. We&amp;rsquo;ll use properties for that sort of chicanery. (And multiway comparisons won&amp;rsquo;t rely on such chicanery in any event. See above.)&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-81-html-id-rfc-081-lazily-evaluated-list-generation-functions-rfc-081-lazily-evaluated-list-generation-functions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/81.html&#34; id=&#34;rfc 081: lazily evaluated list generation functions&#34;&gt;RFC 081: Lazily evaluated list generation functions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Sorry, you can&amp;rsquo;t have the colon&amp;ndash;at least, not without sharing it. Colon will be a kind of ``supercomma&amp;rdquo; that supplies an adverbial list to some previous operator, which in this case would be the prior colon or dotdot.&lt;/p&gt;

&lt;p&gt;(We can&amp;rsquo;t quite implement &lt;code&gt;?:&lt;/code&gt; as a &lt;code&gt;:&lt;/code&gt; modifier on &lt;code&gt;?&lt;/code&gt;, because the precedence would be screwey, unless we limit &lt;code&gt;:&lt;/code&gt; to a single argument, which would preclude its being used to disambiguate indirect objects. More on that later.)&lt;/p&gt;

&lt;p&gt;The RFCs proposal concerning &lt;code&gt;attributes::get(@a)&lt;/code&gt; stuff is superseded by value properties. So, &lt;code&gt;@a.method()&lt;/code&gt; should just pull out the variable&amp;rsquo;s properties directly, if the variable is of a type that supports the methods in question. A lazy list object should certainly have such methods.&lt;/p&gt;

&lt;p&gt;Assignment of a lazy list to a tied array is a problem unless the tie implementation handles laziness. By default a tied array is likely to enforce immediate list evaluation. Immediate list evaluation doesn&amp;rsquo;t work on infinite lists. That means it&amp;rsquo;s gonna fill up your disk drive if you try to say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @my_tied_file = 1..Inf;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Laziness should be possible, but not necessarily the norm. It&amp;rsquo;s all very well to delay the evaluation of ``pure&amp;rdquo; functions in the realm of math, since presumably you get the same result no matter when you evaluate. But a lot of Perl programming is done with real world data that changes over time. Saying &lt;code&gt;somefunc($a .. $b)&lt;/code&gt; can get terribly fouled up if &lt;code&gt;$b&lt;/code&gt; can change, and the lazy function still refers to the variable rather than its instantaneous value. On the other hand, there is overhead in taking snapshots of the current state.&lt;/p&gt;

&lt;p&gt;On the gripping hand, the lazy list object &lt;em&gt;is&lt;/em&gt; the snapshot of the values, that&amp;rsquo;s not a problem in this case. Forget I mentioned it.&lt;/p&gt;

&lt;p&gt;The tricky thing about lazy lists is not the lazy lists themselves, but how they interact with the rest of the language. For instance, what happens if you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @lazy = 1..Inf;
    @lazy[5] = 42;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Is &lt;code&gt;@lazy&lt;/code&gt; still lazy after it is modified? Do we remember the &lt;code&gt;@lazy[5]&lt;/code&gt; is an ``exception&amp;rdquo;, and continue to generate the rest of the values by the original rule? What if &lt;code&gt;@lazy&lt;/code&gt; is going to be generated by a recursive function? Does it matter whether we&amp;rsquo;ve already generated &lt;code&gt;@lazy[5]&lt;/code&gt;?&lt;/p&gt;

&lt;p&gt;And how do we explain this simply to people so that they can understand? We will have to be very clear about the distinction between the abstraction and the concrete value. I&amp;rsquo;m of the opinion that a lazy list is a definition of the &lt;em&gt;default&lt;/em&gt; values of an array, and that the actual values of the array override any default values. Assigning to a previously memoized element overrides the memoized value.&lt;/p&gt;

&lt;p&gt;It would help the optimizer to have a way to declare ``pure&amp;rdquo; array definitions that can&amp;rsquo;t be overridden.&lt;/p&gt;

&lt;p&gt;Also consider this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @array = (1..100, 100..10000:100);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A single flat array can have multiple lazy lists as part of it&amp;rsquo;s default definition. We&amp;rsquo;ll have to keep track of that, which could get especially tricky if the definitions start overlapping via slice definitions.&lt;/p&gt;

&lt;p&gt;In practice, people will treat the default values as real values. If you pass a lazy list into a function as an array argument, the function will probably not know or care whether the values it&amp;rsquo;s getting from the array are being generated on the fly or were there in the first place.&lt;/p&gt;

&lt;p&gt;I can think of other cans of worms this opens, and I&amp;rsquo;m quite certain I&amp;rsquo;m too stupid to think of them all. Nevertheless, my gut feeling is that we can make things work more like people expect rather than less. And I was always a little bit jealous that REXX could have arrays with default values. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 03&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-285-html-id-rfc-285-lazy-input-contextsensitive-input-rfc-285-lazy-input-context-sensitive-input-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/285.html&#34; id=&#34;rfc 285: lazy input / contextsensitive input&#34;&gt;RFC 285: Lazy Input / Context-sensitive Input&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Solving this with &lt;code&gt;want()&lt;/code&gt; is the wrong approach, but I think the basic idea is sound because it&amp;rsquo;s what people expect. And the &lt;code&gt;want()&lt;/code&gt; should in fact be unnecessary. Essentially, if the right side of a list assignment produces a lazy list, and the left side requests a finite number of elements, the list generator will only produce enough to satisy the demand. It doesn&amp;rsquo;t need to know how many in advance. It just produces another scalar value when requested. The generator doesn&amp;rsquo;t have to be smart about its context. The motto of a lazy list generator should be, ``Ours is not to question why, ours is but to do (the next one) or die.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;It will be tricky to make this one work right:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ($first, @rest) = 1 .. Inf;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-82-html-id-rfc-082-arrays-apply-operators-elementwise-in-a-list-context-rfc-082-arrays-apply-operators-element-wise-in-a-list-context-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/82.html&#34; id=&#34;rfc 082: arrays: apply operators elementwise in a list context&#34;&gt;RFC 082: Arrays: Apply operators element-wise in a list context&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;APL, here we come&amp;hellip; :-)&lt;/p&gt;

&lt;p&gt;This is by far the most difficult of these RFCs to decide, so I&amp;rsquo;m going to be doing a lot of thinking out loud here. This is research&amp;ndash;or at least, a search. Please bear with me.&lt;/p&gt;

&lt;p&gt;I expect that there are two classes of Perl programmers&amp;ndash;those that would find these ``hyper&amp;rdquo; operators natural, and those that wouldn&amp;rsquo;t. Turning this feature on by default would cause a lot of heartburn for people who (from Perl 5 experience) expect arrays to always return their length under scalar operators even in list context. It can reasonably be argued that we need to make the scalar operators default, but make it easy to turn on hyper operators within a lexical scope. In any event, both sets of operators need to be visible from anywhere&amp;ndash;we&amp;rsquo;re just arguing over who gets the short, traditional names. All operators will presumably have longer names for use as function calls anyway. Instead of just naming an operator with long names like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    operator:+
    operator:/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the longer names could distinguish ``hyperness&amp;rdquo; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a scalar:+ @b
    @a list:/ @b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That implies they could also be called like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    scalar:+(@a, @b)
    list:/(@a, @b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We might find some short prefix character stands in for ``list&amp;rdquo; or ``scalar&amp;rdquo;. The obvious candidates are &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a $+ @b
    @a @/ @b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, in this case, ``obvious&amp;rdquo; is synonymous with ``wrong&amp;rdquo;. These operators would be completely confusing from a visual point of view. If the main psychological point of putting noun markers on the nouns is so that they stand out from the verbs, then you don&amp;rsquo;t want to put the same markers on the verbs. It would be like the Germans starting to capitalize all their words instead of just their nouns.&lt;/p&gt;

&lt;p&gt;Instead, we could borrow a singular/plural memelet from shell globbing, where &lt;code&gt;*&lt;/code&gt; means multiple characters, and &lt;code&gt;?&lt;/code&gt; means one character:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a ?+ @b
    @a */ @b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that has a bad ambiguity. How do you tell whether &lt;code&gt;**&lt;/code&gt; is an exponentiation or a list multiplication? So if we went that route, we&amp;rsquo;d probably have to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a ?:+ @b
    @a *:/ @b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or some such. But if we&amp;rsquo;re going that far in the direction of gobbledygook, perhaps there are prefix characters that wouldn&amp;rsquo;t be so ambiguous. The colon and the dot also have a visual singular/plural value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a .+ @b
    @a :/ @b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;re already changing the old meaning of dot (and I&amp;rsquo;m planning to rescue colon from the &lt;code&gt;?:&lt;/code&gt; operator), so perhaps that could be made to work. You could almost think of dot and colon as complementary method calls, where you could say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $len = @a.length;   # length as a scalar operator
    @len = @a:length;   # length as a list operator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that would interfere with other desirable uses of colon. Plus, it&amp;rsquo;s actually going to be confusing to think of these as singular and plural operators because, while we&amp;rsquo;re specifying that we want a ``plural&amp;rdquo; operator, we&amp;rsquo;re not specifying how to treat the plurality. Consider this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @len = list:length(@a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anyone would naively think that returns the length of the list, not the length of each element of the list. To make it work in English, we&amp;rsquo;d actually have to say something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @len = each:length(@a);
    $len = the:length(@a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That would be equivalent to the method calls:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @len = @a.each:length;
    $len = @a.the:length;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But does this really mean that there are two array methods with those weird names? I don&amp;rsquo;t think so. We&amp;rsquo;ve reached a result here that is spectacularly close to a &lt;em&gt;reductio ad absurdum&lt;/em&gt;. It seems to me that the whole point of this RFC is that the ``eachness&amp;rdquo; is most simply specified by the list context, together with the knowledge that &lt;code&gt;length()&lt;/code&gt; is a function/method that maps one scalar value to another. The distribution of that function over an array value is not something the scalar function should be concerned with, except insofar as it must make sure its type signature is correct.&lt;/p&gt;

&lt;p&gt;And there&amp;rsquo;s the rub. We&amp;rsquo;re really talking about enforced strong typing for this to work right. When we say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo = @bar.mumble
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How do we know whether &lt;code&gt;mumble&lt;/code&gt; has the type signature that magically enables iteration over &lt;code&gt;@bar&lt;/code&gt;? That definition is off in some other file that we may not have memorized quite yet. We need some more explicit syntax that says that auto-interation is expected, regardless of whether the definition of the operator is well specified. Magical auto-iteration is not going to work well in a language with optional typing.&lt;/p&gt;

&lt;p&gt;So the resolution of this is that the unmarked forms of operators will force scalar context as they do in Perl 5, and we&amp;rsquo;ll need a special marker that says an operator is to be auto-iterated. That special marker turns out to be an uparrow, with a tip o&amp;rsquo; the hat to higher-order functions. That is, the hyper-operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a ^* @b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    parallel { $^a * $^b } @a, @b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(where &lt;code&gt;parallel&lt;/code&gt; is a hypothetical function that iterates through multiple arrays in parallel.)&lt;/p&gt;

&lt;p&gt;Hyper operators will also intuit where a dimension is missing from one of its arguments, and replicate a scalar value to a list value in that dimension. That means you can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a ^+ 1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to get a value with one added to each element of &lt;code&gt;@a&lt;/code&gt;. (&lt;code&gt;@a&lt;/code&gt; is unchanged.)&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t believe there are any insurmountable ambiguities with the uparrow notation. There is currently an uparrow operator meaning exclusive-or, but that is rarely used in practice, and is not typically followed by other operators when it is used. We can represent exclusive-or with &lt;code&gt;~&lt;/code&gt; instead. (I like that idea anyway, because the unary &lt;code&gt;~&lt;/code&gt; is a 1&amp;rsquo;s complement, and the binary &lt;code&gt;~&lt;/code&gt; would simply be doing a 1&amp;rsquo;s complement on the second argument of the set bits in the first argument. On the other hand, there&amp;rsquo;s destructive interference with other cultural meanings of tilde, so it&amp;rsquo;s not completely obvious that it&amp;rsquo;s the right thing to do. Nevertheless, that&amp;rsquo;s what we&amp;rsquo;re doing.)&lt;/p&gt;

&lt;p&gt;Anyway, in essence, I&amp;rsquo;m rejecting the underlying premise of this RFC, that we&amp;rsquo;ll have strong enough typing to intuit the right behavior without confusing people. Nevertheless, we&amp;rsquo;ll still have easy-to-use (and more importantly, easy-to-recognize) hyper-operators.&lt;/p&gt;

&lt;p&gt;This RFC also asks about how return values for functions like &lt;code&gt;abs()&lt;/code&gt; might be specified. I expect sub declarations to (optionally) include a return type, so this would be sufficient to figure out which functions would know how to map a scalar to a scalar. And we should point out again that even though the base language will not try to intuit which operators should be hyperoperators, there&amp;rsquo;s no reason in principle that someone couldn&amp;rsquo;t invent a dialect that does. All is fair if you predeclare.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-45-html-id-rfc-045-and-amp-amp-should-propagate-result-context-to-both-sides-rfc-045-code-code-and-code-amp-amp-code-should-propagate-result-context-to-both-sides-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/45.html&#34; id=&#34;rfc 045: || and &amp;amp;&amp;amp; should propagate result context to both sides&#34;&gt;RFC 045: &lt;code&gt;||&lt;/code&gt; and &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; should propagate result context to both sides&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Yes. The thing that makes this work in Perl 6, where it was almost impossible in Perl 5, is that in Perl 6, list context doesn&amp;rsquo;t imply immediate list flattening. More precisely, it specifies immediate list flattening in a notional sense, but the implementation is free to delay that flattening until it&amp;rsquo;s actually required. Internally, a flattened list is still an object. So when &lt;code&gt;@a || @b&lt;/code&gt; evaluates the arrays, they&amp;rsquo;re evaluated as objects that can return either a boolean value or a list, depending on the context. And it will be possible to apply both contexts to the first argument simultaneously. (Of course, the computer actually looks at it in the boolean context first.)&lt;/p&gt;

&lt;p&gt;There is no conflict with RFC 81 because the hyper versions of these operators will be spelled:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a ^|| @b
    @a ^&amp;amp;&amp;amp; @b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 03&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-54-html-id-rfc-054-operators-polymorphic-comparisons-rfc-054-operators-polymorphic-comparisons-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/54.html&#34; id=&#34;rfc 054: operators: polymorphic comparisons&#34;&gt;RFC 054: Operators: Polymorphic comparisons&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m not sure of the performance hit of backstopping numeric equality with string equality. Maybe vtables help with this. But I think this RFC is proposing something that is too specific. The more general problem is how you allow variants of built-ins, not just for &lt;code&gt;==&lt;/code&gt;, but for other operators like &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt;, not to mention all the other operators that have scalar and list variants.&lt;/p&gt;

&lt;p&gt;A generic equality operator could potentially be supplied by operator definition. I expect that a similar mechanism would allow us to define how abstract a comparison &lt;code&gt;cmp&lt;/code&gt; would do, so we could sort and collate according to the various defined levels of Unicode.&lt;/p&gt;

&lt;p&gt;The argument that you can&amp;rsquo;t do generic programming is somewhat specious. The problem in Perl 5 is that you can&amp;rsquo;t name operators, so you couldn&amp;rsquo;t pass in a generic operator in place of a specific one even if you wanted to. I think it&amp;rsquo;s more important to make sure all operators have real function names in Perl 6:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    operator:+($a, $b);     # $a + $b
    operator:^+(@a, @b);    # @a ^+ @b

    my sub operator:&amp;lt;?&amp;gt; ($a, $b) { ... }
    if ($a &amp;lt;?&amp;gt; $b) { ... }
    @sorted = collate \&amp;amp;operator:&amp;lt;?&amp;gt;, @unicode;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-104-html-id-rfc-104-backtracking-rfc-104-backtracking-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/104.html&#34; id=&#34;rfc 104: backtracking&#34;&gt;RFC 104: Backtracking&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;As proposed, this can easily be done with an operator definition to call a sequence of closures. I wonder whether the proposal is complete, however. There should probably be more make-it-didn&amp;rsquo;t-happen semantics to a backtracking engine. If Prolog unification is emulated with an assignment, how do you later unassign a variable if you backtrack past it?&lt;/p&gt;

&lt;p&gt;Ordinarily, temporary values are scoped to a block, but we&amp;rsquo;re using blocks differently here, much like parens are used in a regex. Later parens don&amp;rsquo;t undo the ``unifications&amp;rdquo; of earlier parens.&lt;/p&gt;

&lt;p&gt;In normal imperative programming these temporary determinations are remembered in ordinary scoped variables and the current hypothesis is extended via recursion. An &lt;code&gt;andthen&lt;/code&gt; operator would need to have a way of keeping BLOCK1&amp;rsquo;s scope around until BLOCK2 succeeds or fails. That is, in terms of lexical scoping:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {BLOCK1} andthen {BLOCK2}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;needs to work more like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {BLOCK1 andthen {BLOCK2}}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This might be difficult to arrange as a mere module. However, with rewriting rules it might be possible to install the requisite scoping semantics within BLOCK1 to make it work like that. So I don&amp;rsquo;t think this is a primitive in the same sense that continuations would be. For now let&amp;rsquo;s assume we can build backtracking operators from continuations. Those will be covered in a future apocalypse.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-143-html-id-rfc-143-case-ignoring-eq-and-cmp-operators-rfc-143-case-ignoring-code-eq-code-and-code-cmp-code-operators-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/143.html&#34; id=&#34;rfc 143: case ignoring eq and cmp operators&#34;&gt;RFC 143: Case ignoring &lt;code&gt;eq&lt;/code&gt; and &lt;code&gt;cmp&lt;/code&gt; operators&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This is another RFC that proposes a specific feature that can be handled by a more generic feature, in this case, an operator definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub operator:EQ { lc($^a) eq lc($^b) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Incidentally, I notice that the RFC normalizes to uppercase. I suspect it&amp;rsquo;s better these days to normalize to lowercase, because Unicode distinguishes titlecase from uppercase, and provides mappings for both to lowercase.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-170-html-id-rfc-170-generalize-to-a-special-applyto-assignment-operator-rfc-170-generalize-code-code-to-a-special-apply-to-assignment-operator-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/170.html&#34; id=&#34;rfc 170: generalize =~ to a special applyto assignment operator&#34;&gt;RFC 170: Generalize &lt;code&gt;=~&lt;/code&gt; to a special ``apply-to&amp;rdquo; assignment operator&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I don&amp;rsquo;t think the argument should come in on the right. I think it would be more natural to treat it as an object, since all Perl variables will essentially be objects anyway, if you scratch them right. Er, left.&lt;/p&gt;

&lt;p&gt;I do wonder whether we could generalize &lt;code&gt;=~&lt;/code&gt; to a list operator that calls a given method on multiple objects, so that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ($a, $b) =~ s/foo/bar/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would be equivalent to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for ($a, $b) { s/foo/bar/ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But then maybe it&amp;rsquo;s redundant, except that you could say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo =~ s/foo/bar/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in the middle of an expression. But by and large, I think I&amp;rsquo;d rather see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo.grep {!m/\s/}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;instead of using &lt;code&gt;=~&lt;/code&gt; for what is essentially a method call. In line with what we discussed before, the list version could be a hyperoperator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo . ^s/foo/bar/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or possibly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo ^. s/foo/bar/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that in the general case this all implies that there is some interplay between how you declare method calls and how you declare quote-like operators. It seems as though it would be dangerous to let a quote-like declaration out of a lexical scope, but then it&amp;rsquo;s also not clear how a method call declaration could be lexically scoped. So we probably can&amp;rsquo;t do away with &lt;code&gt;=~&lt;/code&gt; as an explicit marker that the thing on the left is a string, and the thing on the right is a quoted construct. That means that a hypersubstitution is really spelled:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo ^=~ s/foo/bar/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Admittedly, that&amp;rsquo;s not the prettiest thing in the world.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S03.html&#34;&gt;Synopsis 03&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-nonrfc-considerations-non-rfc-considerations-span&#34;&gt;&lt;span id=&#34;nonrfc considerations&#34;&gt;Non-RFC considerations&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The RFCs propose various specific features, but don&amp;rsquo;t give a systematic view of the operators as a whole. In this section I&amp;rsquo;ll try to give a more cohesive picture of where I see things going.&lt;/p&gt;

&lt;h4 id=&#34;span-id-binary-dot-binary-dot-span&#34;&gt;&lt;span id=&#34;binary . (dot)&#34;&gt;Binary &lt;code&gt;.&lt;/code&gt; (dot)&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This is now the method call operator, in line with industry-wide practice. It also has ramifications for how we declare object attribute variables. I&amp;rsquo;m anticipating that, within a class module, saying&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my int $.counter;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would declare both a &lt;code&gt;$.counter&lt;/code&gt; instance variable and a &lt;code&gt;counter&lt;/code&gt; accessor method for use within the class. (If marked as public, it would also declare a &lt;code&gt;counter&lt;/code&gt; accessor method for use outside the class.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-unary-dot-unary-dot-span&#34;&gt;&lt;span id=&#34;unary . (dot)&#34;&gt;Unary &lt;code&gt;.&lt;/code&gt; (dot)&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;It&amp;rsquo;s possible that a unary &lt;code&gt;.&lt;/code&gt; would call a method on the current object within a class. That is, it would be the same as a binary &lt;code&gt;.&lt;/code&gt; with &lt;code&gt;$self&lt;/code&gt; (or equivalent) on the left:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method foowrapper ($a, $b) {
        .reallyfoo($a, $b, $c)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, it might be considered better style to be explicit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method foowrapper ($self: $a, $b) {
        $self.reallyfoo($a, $b, $c)
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Don&amp;rsquo;t take that declaration syntax as final just yet, however.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-binary-binary-span&#34;&gt;&lt;span id=&#34;binary _&#34;&gt;Binary &lt;code&gt;_&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Since &lt;code&gt;.&lt;/code&gt; is taken for method calls, we need a new way to concatenate strings. We&amp;rsquo;ll use a solitary underscore for that. So, instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a . $b . $c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;ll say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a _ $b _ $c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only downside to that is the space between a variable name and the operator is required. This is to be construed as a feature.&lt;/p&gt;

&lt;h4 id=&#34;span-id-unary-unary-span&#34;&gt;&lt;span id=&#34;unary _&#34;&gt;Unary &lt;code&gt;_&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Since the &lt;code&gt;_&lt;/code&gt; token indicating stat buffer is going away, a unary underscore operator will force stringification, just as interpolation does, only without the quotes.&lt;/p&gt;

&lt;h4 id=&#34;span-id-unary-x-unary-span&#34;&gt;&lt;span id=&#34;unary + X&#34;&gt;Unary &lt;code&gt;+&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Similarly, a unary &lt;code&gt;+&lt;/code&gt; will force numification in Perl 6, unlike in Perl 5. If that fails, NaN (not a number) is returned.&lt;/p&gt;

&lt;h4 id=&#34;span-id-binary-y-binary-span&#34;&gt;&lt;span id=&#34;binary := Y&#34;&gt;Binary &lt;code&gt;:=&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;We need to distinguish two different forms of assignment. The standard assignment operator, &lt;code&gt;=&lt;/code&gt;, works just as it does Perl 5, as much as possible. That is, it tries to make it look like a value assignment. This is our cultural heritage.&lt;/p&gt;

&lt;p&gt;But we also need an operator that works like assignment but is more definitional. If you&amp;rsquo;re familiar with Prolog, you can think of it as a sort of unification operator (though without the implicit backtracking semantics). In human terms, it treats the left side as a set of formal arguments exactly as if they were in the declaration of a function, and binds a set of arguments on the right hand side as though they were being passed to a function. This is what the new &lt;code&gt;:=&lt;/code&gt; operator does. More below.&lt;/p&gt;

&lt;h4 id=&#34;span-id-unary-xx-unary-span&#34;&gt;&lt;span id=&#34;unary * XX&#34;&gt;Unary &lt;code&gt;*&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Unary &lt;code&gt;*&lt;/code&gt; is the list flattening operator. (See Ruby for prior art.) When used on an rvalue, it turns off function signature matching for the rest of the arguments, so that, for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = (\@foo, @bar);
    push *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would be equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push @foo, @bar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this respect, it serves as a replacement for the prototype-disabling &lt;code&gt;&amp;amp;foo(@bar)&lt;/code&gt; syntax of Perl 5. That would be translated to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    foo(*@bar)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In an lvalue, the unary &lt;code&gt;*&lt;/code&gt; indicates that subsequent array names slurp all the rest of the values. So this would swap two arrays:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (@a, @b) := (@b, @a);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;whereas this would assign all the array elements of &lt;code&gt;@c&lt;/code&gt; and &lt;code&gt;@d&lt;/code&gt; to &lt;code&gt;@a&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (*@a, @b) := (@c, @d);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;An ordinary flattening list assignment:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a = (@b, @c);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    *@a := (@b, @c);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s not the same as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a := *(@b, @c);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which would take the first element of &lt;code&gt;@b&lt;/code&gt; as the new definition of &lt;code&gt;@a&lt;/code&gt;, and throw away the rest, exactly as if you passed too many arguments to a function. It could optionally be made to blow up at run time. (It can&amp;rsquo;t be made to blow up at compile time, since we don&amp;rsquo;t know how many elements are in &lt;code&gt;@b&lt;/code&gt; and &lt;code&gt;@c&lt;/code&gt; combined. There could be exactly one element, which is what the left side wants.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-list-context-list-context-span&#34;&gt;&lt;span id=&#34;list context&#34;&gt;List context&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The whole notion of list context is somewhat modified in Perl 6. Since lists can be lazy, the interpretation of list flattening is also by necessity lazy. This means that, in the absence of the &lt;code&gt;*&lt;/code&gt; list flattening operator (or an equivalent old-fashioned list assignment), lists in Perl 6 are object lists. That is to say, they are parsed as if they were a list of objects in scalar context. When you see a function call like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    foo @a, @b, @c;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you should generally assume that three discrete arrays are being passed to the function, unless you happen to know that the signature of &lt;code&gt;foo&lt;/code&gt; includes a list flattening &lt;code&gt;*&lt;/code&gt;. (If a subroutine doesn&amp;rsquo;t have a signature, it is assumed to have a signature of &lt;code&gt;(*@_)&lt;/code&gt; for old times&amp;rsquo; sake.) Note that this is really nothing new to Perl, which has always made this distinction for builtins, and extended it to user-defined functions in Perl 5 via prototypes like &lt;code&gt;\@&lt;/code&gt; and &lt;code&gt;\%&lt;/code&gt;. We&amp;rsquo;re just changing the syntax in Perl 6 so that the unmarked form of formal argument expects a scalar value, and you optionally declare the final formal argument to expect a list. It&amp;rsquo;s a matter of Huffman coding again, not to mention saving wear and tear on the backslash key.&lt;/p&gt;

&lt;h4 id=&#34;span-id-binary-yy-binary-span&#34;&gt;&lt;span id=&#34;binary : YY&#34;&gt;Binary &lt;code&gt;:&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As I pointed out in an earlier apocalypse, the first rule of computer language design is that everybody wants the colon. I think that means that we should do our best to give the colon to as many features as possible.&lt;/p&gt;

&lt;p&gt;Hence, this operator modifies a preceding operator adverbially. That is, it can turn any operator into a trinary operator (provided a suitable definition is declared). It can be used to supply a ``step&amp;rdquo; to a range operator, for instance. It can also be used as a kind of super-comma separating an indirect object from the subsequent argument list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print $handle[2]: @args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, this conflicts with the old definition of the &lt;code&gt;?:&lt;/code&gt; operator. See below.&lt;/p&gt;

&lt;p&gt;In a method type signature, this operator indicates that a previous argument (or arguments) is to be considered the ``self&amp;rdquo; of a method call. (Putting it after multiple arguments could indicate a desire for multimethod dispatch!)&lt;/p&gt;

&lt;h4 id=&#34;span-id-trinary-trinary-span&#34;&gt;&lt;span id=&#34;trinary ::&#34;&gt;Trinary &lt;code&gt;??::&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The old &lt;code&gt;?:&lt;/code&gt; operator is now spelled &lt;code&gt;??::&lt;/code&gt;. That is to say, since it&amp;rsquo;s really a kind of short-circuit operator, we just double both characters like the &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; and &lt;code&gt;||&lt;/code&gt; operator. This makes it easy to remember for C programmers. Just change:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a ? $b : $c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a ?? $b :: $c
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The basic problem is that the old &lt;code&gt;?:&lt;/code&gt; operator wastes two very useful single characters for an operator that is not used often enough to justify the waste of two characters. It&amp;rsquo;s bad Huffman coding, in other words. Every proposed use of colon in the RFCs conflicted with the &lt;code&gt;?:&lt;/code&gt; operator. I think that says something.&lt;/p&gt;

&lt;p&gt;I can&amp;rsquo;t list here all the possible spellings of &lt;code&gt;?:&lt;/code&gt; that I considered. I just think &lt;code&gt;??::&lt;/code&gt; is the most visually appealing and mnemonic of the lot of them.&lt;/p&gt;

&lt;h4 id=&#34;span-id-binary-yyy-binary-span&#34;&gt;&lt;span id=&#34;binary // YYY&#34;&gt;Binary &lt;code&gt;//&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A binary &lt;code&gt;//&lt;/code&gt; operator is the defaulting operator. That is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a // $b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is short for:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    defined($a) ?? $a :: $b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;except that the left side is evaluated only once. It will work on arrays and hashes as well as scalars. It also has a corresponding assignment operator, which only does the assignment if the left side is undefined:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $pi //= 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-binary-yyyy-binary-span&#34;&gt;&lt;span id=&#34;binary ; YYYY&#34;&gt;Binary &lt;code&gt;;&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The binary &lt;code&gt;;&lt;/code&gt; operator separates two expressions in a list, much like the expressions within a C-style &lt;code&gt;for&lt;/code&gt; loop. Obviously the expressions need to be in some kind of bracketing structure to avoid ambiguity with the end of the statement. Depending on the context, these expressions may be interpreted as arguments to a &lt;code&gt;for&lt;/code&gt; loop, or slices of a multi-dimensional array, or whatever. In the absence of other context, the default is simply to make a list of lists. That is,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [1,2,3;4,5,6]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is a shorthand for:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [[1,2,3],[4,5,6]]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But usually there will be other context, such as a multidimension array that wants to be sliced, or a syntactic construct that wants to emulate some kind of control structure. A construct emulating a 3-argument &lt;code&gt;for&lt;/code&gt; loop might force all the expressions to be closures, for instance, so that they can be evaluated each time through the loop. User-defined syntax will discussed in apocalypse 18, if not sooner.&lt;/p&gt;

&lt;h4 id=&#34;span-id-unary-xxx-unary-span&#34;&gt;&lt;span id=&#34;unary ^ XXX&#34;&gt;Unary &lt;code&gt;^&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Unary ^ is now reserved for hyper operators. Note that it works on assignment operators as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a ^+= 1;    # increment all elements of @a
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-unary-unary-span-1&#34;&gt;&lt;span id=&#34;unary &#34;&gt;Unary &lt;code&gt;?&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Reserved for future use.&lt;/p&gt;

&lt;h4 id=&#34;span-id-binary-binary-span-1&#34;&gt;&lt;span id=&#34;binary &#34;&gt;Binary &lt;code&gt;?&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Reserved for future use.&lt;/p&gt;

&lt;h4 id=&#34;span-id-binary-yyyyy-binary-span&#34;&gt;&lt;span id=&#34;binary ~ YYYYY&#34;&gt;Binary &lt;code&gt;~&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This is now the bitwise XOR operator. Recall that unary &lt;code&gt;~&lt;/code&gt; (1&amp;rsquo;s complement) is simply an XOR with a value containing all 1 bits.&lt;/p&gt;

&lt;h4 id=&#34;span-id-binary-yyyyyy-binary-span&#34;&gt;&lt;span id=&#34;binary ~~ YYYYYY&#34;&gt;Binary &lt;code&gt;~~&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This is a logical XOR operator. It&amp;rsquo;s a high precedence version of the low precedence &lt;code&gt;xor&lt;/code&gt; operator.&lt;/p&gt;

&lt;h4 id=&#34;span-id-user-defined-operators-user-defined-operators-span&#34;&gt;&lt;span id=&#34;user defined operators&#34;&gt;User defined operators&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The declaration syntax of user-defined operators is still up for grabs, but we can say a few things about it. First, we can differentiate unary from binary declarations simply by the number of arguments. (Declaration of a return type may also be useful for disambiguating subsequent parsing. One place it won&amp;rsquo;t be needed is for operators wanting to know whether they should behave as hyperoperators. The pressure to do that is relieved by the explicit &lt;code&gt;^&lt;/code&gt; hypermarker.)&lt;/p&gt;

&lt;p&gt;We also need to think how these operator definitions relate to overloading. We can treat an operator as a method on the first object, but sometimes it&amp;rsquo;s the second object that should control the action. (Or with multimethod dispatch, both objects.) These will have to be thrashed out under ordinary method dispatch policy. The important thing is to realize that an operator is just a funny looking method call. When you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $man bites $dog
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The infrastruture will need to untangle whether the man is biting the dog or the dog is getting bitten by the man. The actual biting could be implement in either the &lt;code&gt;Man&lt;/code&gt; class or the &lt;code&gt;Dog&lt;/code&gt; class, or even somewhere else, in the case of multimethods.&lt;/p&gt;

&lt;h4 id=&#34;span-id-unicode-operators-unicode-operators-span&#34;&gt;&lt;span id=&#34;unicode operators&#34;&gt;Unicode operators&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Rather than using longer and longer strings of ASCII characters to represent user-defined operators, it will be much more readable to allow the (judicious) use of Unicode operators.&lt;/p&gt;

&lt;p&gt;In the short term, we won&amp;rsquo;t see much of this. As screen resolutions increase over the next 20 years, we&amp;rsquo;ll all become much more comfortable with the richer symbol set. I see no reason (other than fear of obfuscation (and fear of fear of obfuscation))) why Unicode operators should not be allowed.&lt;/p&gt;

&lt;p&gt;Note that, unlike APL, we won&amp;rsquo;t be hardware dependent, in the sense that any Perl implementation will always be able to parse Unicode, even if you can&amp;rsquo;t display it very well. (But note that Vim 6.0 just came out with Unicode support.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-precedence-precedence-span&#34;&gt;&lt;span id=&#34;precedence&#34;&gt;Precedence&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;We will at least unify the precedence levels of the equality and relational operators. Other unifications are possible. For instance, the &lt;code&gt;not&lt;/code&gt; logical operator could be combined with list operators in precedence. There&amp;rsquo;s only so much simplification that you can do, however, since you can&amp;rsquo;t mix right association with left association. By and large, the precedence table will be what you expect, if you expect it to remain largely the same.&lt;/p&gt;

&lt;p&gt;And that still goes for Perl 6 in general. We talk a lot here about what we&amp;rsquo;re changing, but there&amp;rsquo;s a lot more that we&amp;rsquo;re not changing. Perl 5 does a lot of things right, and we&amp;rsquo;re not terribly interested in ``fixing&amp;rdquo; that.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Larry Wall: Apocalypse Two</title>
      <link>http://localhost:1313/pub/2001/05/03/wall.html/</link>
      <pubDate>Thu, 03 May 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/05/03/wall.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historical reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S02.html&#34;&gt;Synopsis 02&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Perl 6 Apocalypse&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;The rest of the &amp;quot;Apocalypse&amp;quot; series is available on &lt;a href=&#34;http://localhost:1313/authors/larry-wall&#34;&gt;Larry Wall&#39;s author page&lt;/a&gt;.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;table-of-contents&#34;&gt;Table Of Contents&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#atoms&#34;&gt;Atoms&lt;/a&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#molecules&#34;&gt;Molecules&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rfc005&#34;&gt;RFC 005: Multiline Comments for Perl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfc102&#34;&gt;RFC 102: Inline Comments for Perl&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#builtindatatypes&#34;&gt;Built-in Data Types&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rfc161&#34;&gt;RFC 161: Everything in Perl Becomes an Object.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfc038&#34;&gt;RFC 038 : Standardise Handling of Abnormal Numbers Like Infinities and NaNs&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfc043&#34;&gt;RF C 043: Integrate BigInts (and BigRats) Support Tightly With the Basic Scalars&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfc192&#34;&gt;RFC 192: Undef Values ne Value&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfc212&#34;&gt;RFC 212: Make &lt;code&gt;length(@array)&lt;/code&gt; work&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfc218&#34;&gt;RFC 218: &lt;code&gt;my Dog $spot&lt;/code&gt; Is Just an Assertion&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#otherdecisionsabouttypes&#34;&gt;Other Decisions About Types&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#variables&#34;&gt;Variables&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rfc071&#34;&gt;RFC 071: Legacy Perl $pkg&amp;rsquo;var Should Die&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfc009&#34;&gt;RFC 009: Highlander Variable Types&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfc133&#34;&gt;RFC 133: Alternate Syntax for Variabl e Names&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfc134&#34;&gt;RFC 134: Alternative Array and Hash Slicing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfc196&#34;&gt;RFC 196: More Direct Syntax for Hashes&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfc201&#34;&gt;RFC 201: Hash Slicing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#otherdecisionsaboutvariables&#34;&gt;Other Decisions About Variables&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#names&#34;&gt;Names&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#literals&#34;&gt;Literals&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#underscoresinnumericliterals&#34;&gt;Underscores in Numeric Literals&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#rfc105&#34;&gt;RFC 105: Remove ``In string @ m ust be \@&amp;rdquo; Fatal Error&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#rfc111&#34;&gt;RFC 111: Here Docs Terminators (Was Whitespace and Here Docs)&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#rfc162&#34;&gt;RFC 162: Heredoc Contents&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#rfc139&#34;&gt;RFC 139: Allow Calling Any Function With a Syntax Like s///&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#rfc222&#34;&gt;RFC 222: Interpolation of Object Met hod Calls&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#rfc226&#34;&gt;RFC 226: Selective Int erpolation in Single Quotish Context.&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#rfc237&#34;&gt;RFC 237: Hashes Should Interpolate in Double-Quoted Strings&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#rfc251&#34;&gt;RFC 251: Interpolation of Class Metho d Calls&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#rfc252&#34;&gt;RFC 252: Interpolation of Cubroutines&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#rfc327&#34;&gt;RFC 327: &lt;code&gt;\v&lt;/code&gt; for Vertical Tab&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;[RFC 328: Single Quotes Don&amp;rsquo;t Interpolate \&amp;rsquo; and \\](#rfc328)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#otherdecisionsaboutliterals&#34;&gt;Other Decisions About Literals&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#scopingofletal&#34;&gt;Scoping of \L et al.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#barewordpolicy&#34;&gt;Bareword Policy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#weirdbrackets&#34;&gt;Weird Brackets&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#specialtokens&#34;&gt;Special Tokens&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#heredocsyntax&#34;&gt;Heredoc Syntax&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#context&#34;&gt;Context&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#referencesarenowtransparenttobooleancontext&#34;&gt;References Are Now Transparent t o Boolean Context&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#lists&#34;&gt;Lists&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rfc175&#34;&gt;RFC 175: Add &lt;code&gt;list&lt;/code&gt; Keyword to Force List Context (like &lt;code&gt;scalar&lt;/code&gt;)&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#otherdecisionsaboutlists&#34;&gt;Other Decisions About Lists&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#files&#34;&gt;Files&lt;/a&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;#rfc034&#34;&gt;RFC 034: Angle Brackets Should Not Be Used for File Globbing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#rfc051&#34;&gt;RFC 051: Angle Brackets Should Accept Filenames and Lists&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;a href=&#34;#properties&#34;&gt;Properties&lt;/a&gt;&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Larry Wall will give his annual entertaining talk on the state of the Perl world, covering both Perl 5 and Perl 6 at this Year&amp;rsquo;s &lt;a href=&#34;http://conferences.oreilly.com/perl/&#34;&gt;Open Source Convention&lt;/a&gt;. Don&amp;rsquo;t miss this rare opportunity to hear the creator of Perl, patch, and run share his insights.&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Here&amp;rsquo;s Apocalypse 2, meant to be read in conjunction with Chapter 2 of the Camel Book. The basic assumption is that if Chapter 2 talks about something that I don&amp;rsquo;t discuss here, it doesn&amp;rsquo;t change in Perl 6. (Of course, it could always just be an oversight. One might say that people who oversee things have a gift of oversight.)&lt;/p&gt;

&lt;p&gt;Before I go further, I would like to thank all the victims, er, participants in the RFC process. (I beg special forgiveness from those whose brains I haven&amp;rsquo;t been able to get inside well enough to incorporate their ideas). I would also like to particularly thank Damian Conway, who will recognize many of his systematic ideas here, including some that have been less than improved by my meddling.&lt;/p&gt;

&lt;p&gt;Here are the RFCs covered:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RFC  PSA  Title
    ---  ---  -----
      Textual
    005  cdr  Multiline Comments for Perl
    102  dcr  Inline Comments for Perl

      Types
    161  adb  Everything in Perl Becomes an Object
    038  bdb  Standardise Handling of Abnormal Numbers Like Infinities and NaNs
    043  bcb  Integrate BigInts (and BigRats) Support Tightly With the Basic Scalars
    192  ddr  Undef Values ne Value
    212  rrb  Make Length(@array) Work
    218  bcc  C&amp;lt;my Dog $spot&amp;gt; Is Just an Assertion

      Variables
    071  aaa  Legacy Perl $pkg&#39;var Should Die
    009  bfr  Highlander Variable Types
    133  bcr  Alternate Syntax for Variable Names
    134  bcc  Alternative Array and Hash Slicing
    196  bcb  More Direct Syntax for Hashes
    201  bcr  Hash Slicing

      Strings
    105  aaa  Remove &amp;quot;In string @ must be \@&amp;quot; Fatal Error
    111  aaa  Here Docs Terminators (Was Whitespace and Here Docs)
    162  abb  Heredoc Contents
    139  cfr  Allow Calling Any Function With a Syntax Like s///
    222  abb  Interpolation of Object Method Calls
    226  acr  Selective Interpolation in Single Quotish Context
    237  adc  Hashes Should Interpolate in Double-Quoted Strings
    251  acr  Interpolation of Class Method Calls
    252  abb  Interpolation of Subroutines
    327  dbr  C&amp;lt;\v&amp;gt; for Vertical Tab
    328  bcr  Single Quotes Don&#39;t Interpolate \&#39; and \\

      Files
    034  aaa  Angle Brackets Should Not Be Used for File Globbing
    051  ccr  Angle Brackets Should Accept Filenames and Lists

      Lists
    175  rrb  Add C&amp;lt;list&amp;gt; Keyword to Force List Context (like C&amp;lt;scalar&amp;gt;)

      Retracted
    010  rr  Filehandles Should Use C&amp;lt;*&amp;gt; as a Type Prefix If Typeglobs Are Eliminated
    103  rr  Fix C&amp;lt;$pkg::$var&amp;gt; Precedence Issues With Parsing of C&amp;lt;::&amp;gt;
    109  rr  Less Line Noise - Let&#39;s Get Rid of @%
    245  rr  Add New C&amp;lt;empty&amp;gt; Keyword to DWIM for Clearing Values
    263  rr  Add Null() Keyword and Fundamental Data Type
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-atoms-atoms-span&#34;&gt;&lt;span id=&#34;atoms&#34;&gt;Atoms&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl 6 programs are notionally written in Unicode, and assume Unicode semantics by default even when they happen to be processing other character sets behind the scenes. Note that when we say that Perl is written in Unicode, we&amp;rsquo;re speaking of an abstract character set, not any particular encoding. (The typical program will likely be written in UTF-8 in the West, and in some 16-bit character set in the East.)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-molecules-molecules-span&#34;&gt;&lt;span id=&#34;molecules&#34;&gt;Molecules&lt;/span&gt;&lt;/h3&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-5-html-id-rfc005-rfc-005-m-ultiline-comments-for-perl-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/5.html&#34; id=&#34;rfc005&#34;&gt;RFC 005: M ultiline Comments for Perl&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I admit to being prejudiced on this one &amp;ndash; I was unduly influenced at a tender age by the rationale for the design of Ada, which made a good case, I thought, for leaving multiline comments out of the language.&lt;/p&gt;

&lt;p&gt;But even if I weren&amp;rsquo;t blindly prejudiced, I suspect I&amp;rsquo;d look at the psychology of the thing, and notice that much of the time, even in languages that have multiline comments, people nevertheless tend to use them like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    /*
     *  Natter, natter, natter.
     *  Gromish, gromish, gromish.
     */
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The counterargument to that is, of course, that people don&amp;rsquo;t &lt;em&gt;always&lt;/em&gt; do that in C, so why should they have to do it in Perl? And if there were no other way to do multiline comments in Perl, they&amp;rsquo;d have a stronger case. But there already is another way, albeit one rejected by this RFC as ``a workaround.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;But it seems to me that, rather than adding another kind of comment or trying to make something that looks like code behave like a comment, the solution is simply to fix whatever is wrong with POD so that its use for commenting can no longer be considered a workaround. Actual design of POD can be put off till Apocalypse 26, but we can speculate at this point that the rules for switching back and forth between POD and Perl are suboptimal for use in comments. If so, then it&amp;rsquo;s likely that in Perl 6 we&amp;rsquo;ll have a rule like this: If a &lt;code&gt;=begin MUMBLE&lt;/code&gt; transitions from Perl to POD mode then the corresponding &lt;code&gt;=end MUMBLE&lt;/code&gt; should transition back (without a &lt;code&gt;=cut&lt;/code&gt; directive).&lt;/p&gt;

&lt;p&gt;Note that we haven&amp;rsquo;t defined our &lt;code&gt;MUMBLE&lt;/code&gt;s yet, but they can be set up to let our program have any sort of programmatic access to the data that we desire. For instance, it is likely that comments of this kind could be tied in with some sort of literate (or at least, semiliterate) programming framework.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-102-html-id-rfc102-rfc-102-inline-comments-for-perl-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/102.html&#34; id=&#34;rfc102&#34;&gt;RFC 102: Inline Comments for Perl&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I have never much liked inline comments &amp;ndash; as commonly practiced they tend to obfuscate the code as much as they clarify it. That being said, ``All is fair if you predeclare.&amp;rdquo; So there should be nothing preventing someone from writing a lexer regex that handles them, provided we make the lexer sufficiently mutable. Which we will. (As it happens, the character sequence ``&lt;code&gt;/*&lt;/code&gt;&amp;rdquo; will be unlikely to occur in standard Perl 6. Which I guess means it &lt;em&gt;is&lt;/em&gt; likely to occur in nonstandard Perl 6. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;A pragma declaring nonstandard commenting would also allow people to use &lt;code&gt;/* */&lt;/code&gt; for multiline comments, if they like. (But I still think it&amp;rsquo;d be better to use POD directives for that, just to keep the text accessible to the program.)&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-builtindatatypes-built-in-data-types-span&#34;&gt;&lt;span id=&#34;builtindatatypes&#34;&gt;Built-In Data Types&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The basic change here is that, rather than just supporting scalars, arrays and hashes, Perl 6 supports opaque objects as a fourth fundamental data type. (You might think of them as pseudo-hashes done right.) While a class can access its object attributes any way it likes, all external access to opaque objects occurs through methods, even for attributes. (This guarantees that attribute inheritance works correctly.)&lt;/p&gt;

&lt;p&gt;While Perl 6 still defaults to typeless scalars, Perl will be able to give you more performance and safety as you give it more type information to work with. The basic assumption is that homogenous data structures will be in arrays and hashes, so you can declare the type of the scalars held in an array or hash. Heterogenous structures can still be put into typeless arrays and hashes, but in general Perl 6 will encourage you to use classes for such data, much as C encourages you to use structs rather than arrays for such data.&lt;/p&gt;

&lt;p&gt;One thing we&amp;rsquo;ll be mentioning before we discuss it in detail is the notion of ``properties.&amp;rdquo; (In Perl 5, we called these ``attributes,&amp;rdquo; but we&amp;rsquo;re reserving that term for actual object attributes these days, so we&amp;rsquo;ll call these things ``properties.&amp;ldquo;) Variables and values can have additional data associated with them that is ``out of band&amp;rdquo; with respect to the ordinary typology of the variable or value. For now, just think of properties as a way of adding ad hoc attributes to a class that doesn&amp;rsquo;t support them. You could also think of it as a form of class derivation at the granularity of the individual object, without having to declare a complete new class.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-161-html-id-rfc161-rfc-161-everything-in-perl-becomes-an-object-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/161.html&#34; id=&#34;rfc161&#34;&gt;RFC 161: Everything in Perl Becomes an Object.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This is essentially a philosophical RFC that is rather short on detail. Nonetheless, I agree with the premise that all Perl objects should act like objects if you choose to treat them that way. If you choose not to treat them as objects, then Perl will try to go along with that, too. (You may use hash subscripting and slicing syntax to call attribute accessors, for instance, even if the attributes themselves are not stored in a hash.) Just because Perl 6 is more object-oriented internally, does not mean you&amp;rsquo;ll be forced to think in object-oriented terms when you don&amp;rsquo;t want to. (By and large, there will be a few places where OO-think is more required in Perl 6 than in Perl 5. Filehandles are more object-oriented in Perl 6, for instance, and the special variables that used to be magically associated with the currently selected output handle are better specified by association with a specific filehandle.)&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-38-html-id-rfc038-rfc-038-standardise-handling-of-abnormal-numbers-like-infinities-and-nans-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/38.html&#34; id=&#34;rfc038&#34;&gt;RFC 038: Standardise Handling Of Abnormal Numbers Like Infinities and NaNs&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This is likely to slow down numeric processing in some locations. Perhaps it could be turned off when desirable. We need to be careful not to invent something that is guaranteed to run slower than IEEE floating point. We should also try to avoid defining a type system that makes translation of numeric types to Java or C# types problematic.&lt;/p&gt;

&lt;p&gt;That being said, standard semantics are a good thing, and should be the default behavior.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-43-html-id-rfc043-rfc-043-integrate-bigints-and-bigrats-support-tightly-with-the-basic-scalars-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/43.html&#34; id=&#34;rfc043&#34;&gt;RFC 043: Integrate BigInts (and BigRats) Support Tightly With the Basic Scalars&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC suggests that a pragma enables the feature, but I think it should probably be tied to the run-time type system, which means it&amp;rsquo;s driven more by how the data is created than by where it happens to be stored or processed. I don&amp;rsquo;t see how we can make it a pragma, except perhaps to influence the meaning of ``int&amp;rdquo; and ``num&amp;rdquo; in actual declarations further on in the lexical scope:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use bigint;
    my int $i;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;might really mean&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my bigint $i;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or maybe just&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my int $i is bigint;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;since representation specifications might just be considered part of the ``fine print.&amp;rdquo; But the whole subject of lexically scoped variable properties specifying the nature of the objects they contain is a bit problematic. A variable is a sort of mini-interface, a contract if you will, between the program and the object in question. Properties that merely influence how the program sees the object are not a problem &amp;ndash; when you declare a variable to be constant, you&amp;rsquo;re promising not to modify the object through that variable, rather than saying something intrinsically true about the object. (Not that there aren&amp;rsquo;t objects that are intrinsically constant.)&lt;/p&gt;

&lt;p&gt;Other property declarations might need to have some say in how constructors are called in order to guarantee consistency between the variable&amp;rsquo;s view of the object, and the nature of the object itself. In the worst case we could try to enforce consistency at run time, but that&amp;rsquo;s apt to be slow. If every assignment of a &lt;code&gt;Dog&lt;/code&gt; object to a &lt;code&gt;Mammal&lt;/code&gt; variable has to check to see whether &lt;code&gt;Dog&lt;/code&gt; is a &lt;code&gt;Mammal&lt;/code&gt;, then the assignment is going to be a dog.&lt;/p&gt;

&lt;p&gt;So we&amp;rsquo;ll have to revisit this when we&amp;rsquo;re defining the relationship between variable declarations and constructors. In any event, if we don&amp;rsquo;t make Perl&amp;rsquo;s numeric types automatically promote to big representations, we should at least make it easy to specify it when you &lt;em&gt;want&lt;/em&gt; that to happen.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-192-html-id-rfc192-rfc-192-undef-values-ne-value-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/192.html&#34; id=&#34;rfc192&#34;&gt;RFC 192: Undef Values ne Value&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve rejected this one, because I think something that&amp;rsquo;s undefined should be considered just that, undefined. I think the standard semantics are useful for catching many kinds of errors.&lt;/p&gt;

&lt;p&gt;That being said, it&amp;rsquo;ll hopefully be easy to modify the standard operators within a particular scope, so I don&amp;rsquo;t think we need to think that our way to think is the only way to think, I think.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-212-html-id-rfc212-rfc-212-make-code-length-array-code-work-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/212.html&#34; id=&#34;rfc212&#34;&gt;RFC 212: Make &lt;code&gt;length(@array)&lt;/code&gt; Work&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s an oddity, an RFC that the author retracted, but that I accept, more or less. I think &lt;code&gt;length(@array)&lt;/code&gt; should be equivalent to &lt;code&gt;@array.length()&lt;/code&gt;, so if there&amp;rsquo;s a &lt;code&gt;length&lt;/code&gt; method available, it should be called.&lt;/p&gt;

&lt;p&gt;The question is whether there should be a &lt;code&gt;length&lt;/code&gt; method at all, for strings or arrays. It almost makes more sense for arrays than it does for strings these days, because when you talk about the length of a string, you need to know whether you&amp;rsquo;re talking about byte length or character length. So we may split up the traditional length function into two, in which case we might end up with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $foo.chars
    $foo.bytes
    @foo.elems
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or some such. Whatever the method names we choose, differentiating them would be more powerful in supplying context. For instance, one could envision calling &lt;code&gt;@foo.bytes&lt;/code&gt; to return the byte length of all the strings. That wouldn&amp;rsquo;t fly if we overloaded the method name.&lt;/p&gt;

&lt;p&gt;Even &lt;code&gt;chars($foo)&lt;/code&gt; might not be sufficiently precise, since, depending on how you&amp;rsquo;re processing Unicode, you might want to know how long the string is in actual characters, not counting combining characters that don&amp;rsquo;t take extra space. But that&amp;rsquo;s a topic for later.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-218-html-id-rfc218-rf-c-218-code-my-dog-spot-code-is-just-an-assertion-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/218.html&#34; id=&#34;rfc218&#34;&gt;RF C 218: &lt;code&gt;my Dog $spot&lt;/code&gt; Is Just an Assertion&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I expect that a declaration of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Dog $spot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is merely an assertion that you will not use &lt;code&gt;$spot&lt;/code&gt; inconsistently with it being a &lt;code&gt;Dog&lt;/code&gt;. (But I mean something different by ``assertion&amp;rdquo; than this RFC does.) This assertion may or may not be tested at every assignment to &lt;code&gt;$spot&lt;/code&gt;, depending on pragmatic context. This bare declaration does not call a constructor; however, there may be forms of declaration that do. This may be necessary so that the variable and the object can pass properties back and forth, and in general, make sure they&amp;rsquo;re consistent with each other. For example, you might declare an array with a multidimensional shape, and this shape property needs to be visible to the constructor, if we don&amp;rsquo;t want to have to specify it redundantly.&lt;/p&gt;

&lt;p&gt;On the other hand, we might be able to get assignment sufficiently overloaded to accomplish the same goal, so I&amp;rsquo;m deferring judgment on that. All I&amp;rsquo;m deciding here is that a bare declaration without arguments as above does not invoke a constructor, but merely tells the compiler something.&lt;/p&gt;

&lt;h3 id=&#34;span-id-otherdecisionsabouttypes-other-decisions-about-types-span&#34;&gt;&lt;span id=&#34;otherdecisionsabouttypes&#34;&gt;Other Decisions About Types&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Built-in object types will be in all uppercase: &lt;code&gt;INTEGER&lt;/code&gt;, &lt;code&gt;NUMBER&lt;/code&gt;, &lt;code&gt;STRING&lt;/code&gt;, &lt;code&gt;REF&lt;/code&gt;, &lt;code&gt;SCALAR&lt;/code&gt;, &lt;code&gt;ARRAY&lt;/code&gt;, &lt;code&gt;HASH&lt;/code&gt;, &lt;code&gt;REGEX&lt;/code&gt; and &lt;code&gt;CODE&lt;/code&gt;. Corresponding to at least some of these, there will also be lowercase intrinsic types, such as &lt;code&gt;int&lt;/code&gt;, &lt;code&gt;num&lt;/code&gt;, &lt;code&gt;str&lt;/code&gt; and &lt;code&gt;ref&lt;/code&gt;. Use of the lowercase typename implies you aren&amp;rsquo;t intending to do anything fancy OO-wise with the values, or store any run-time properties, and thus Perl should feel free to store them compactly. (As a limiting case, objects of type &lt;code&gt;bit&lt;/code&gt; can be stored in one bit.) This distinction corresponds roughly to the boxed/unboxed distinction of other computer languages, but it is likely that Perl 6 will attempt to erase the distinction for you to the extent possible. So, for instance, an &lt;code&gt;int&lt;/code&gt; may still be used in a string context, and Perl will convert it for you, but it won&amp;rsquo;t cache it, so the next time you use it as a string, it will have to convert again.&lt;/p&gt;

&lt;p&gt;The declared type of an array or hash specifies the type of each element, not the type of an array or hash as a whole. This is justified by the notion that an array or hash is really just a strange kind of function that (typically) takes a subscript as an argument and returns a value of a particular type. If you wish to associate a type with the array or hash as a whole, that involves setting a &lt;code&gt;tie&lt;/code&gt; property. If you find yourself wishing to declare different types on different elements, it probably means that you should either be using a class for the whole heterogenous thing, or at least declare the type of array or hash that will be a base class of all the objects it will contain.&lt;/p&gt;

&lt;p&gt;Of course, untyped arrays and hashes will be just as acceptable as they are currently. But a language can only run so fast when you force it to defer all type checking and method lookup till run time.&lt;/p&gt;

&lt;p&gt;The intent is to make use of type information where it&amp;rsquo;s useful, and not require it where it&amp;rsquo;s not. Besides performance and safety, one other place where type information is useful is in writing interfaces to other languages. It is postulated that Perl 6 will provide enough optional type declaration syntax that it will be unnecessary to write XS-style glue in most cases.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-variables-variables-span&#34;&gt;&lt;span id=&#34;variables&#34;&gt;Variables&lt;/span&gt;&lt;/h3&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-71-html-id-rfc071-rfc-0-71-legacy-perl-pkg-var-should-die-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/71.html&#34; id=&#34;rfc071&#34;&gt;RFC 0 71: Legacy Perl $pkg&amp;rsquo;var Should Die&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I agree. I was unduly influenced by Ada syntax here, and it was a mistake. And although we&amp;rsquo;re adding a properties feature into Perl 6 that is much like Ada&amp;rsquo;s attribute feature, we won&amp;rsquo;t make the mistake of reintroducing a syntax that drives highlighting editors nuts. We&amp;rsquo;ll try to make different mistakes this time.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-9-html-id-rfc009-rfc-009-hig-hlander-variable-types-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/9.html&#34; id=&#34;rfc009&#34;&gt;RFC 009: Hig hlander Variable Types&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I basically agree with the problem this RFC is trying to solve, but I disagree with the proposed solution. The basic problem is that, while the idiomatic association of &lt;code&gt;$foo[$bar]&lt;/code&gt; with &lt;code&gt;@foo&lt;/code&gt; rather than &lt;code&gt;$foo&lt;/code&gt; worked fine in Perl 4, when we added recursive data structures to Perl 5, it started getting in the way notationally, so that initial funny character was trying to do too much in both introducing the ``root&amp;rdquo; of the reference, as well as the context to apply to the final subscript. This necessitated odd looking constructions like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $foo-&amp;gt;[1][2][3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This RFC proposes to solve the dilemma by unifying scalar variables with arrays and hashes at the name level. But I think people like to think of &lt;code&gt;$foo&lt;/code&gt;, &lt;code&gt;@foo&lt;/code&gt; and &lt;code&gt;%foo&lt;/code&gt; as separate variables, so I don&amp;rsquo;t want to break that. Plus, the RFC doesn&amp;rsquo;t unify &lt;code&gt;&amp;amp;foo&lt;/code&gt;, while it&amp;rsquo;s perfectly possible to have a reference to a function as well as a reference to the more ordinary data structures.&lt;/p&gt;

&lt;p&gt;So rather than unifying the names, I believe all we have to do is unify the treatment of variables with respect to references. That is, all variables may be thought of as references, not just scalars. And in that case, subscripts always dereference the reference implicit in the array or hash named on the left.&lt;/p&gt;

&lt;p&gt;This has two major implications, however. It means that Perl programmers must learn to write &lt;code&gt;@foo[1]&lt;/code&gt; where they used to write &lt;code&gt;$foo[1]&lt;/code&gt;. I think most Perl 5 people will be able to get used to this, since many of them found the current syntax a bit weird in the first place.&lt;/p&gt;

&lt;p&gt;The second implication is that slicing needs a new notation, because subscripts no longer have their scalar/list context controlled by the initial funny character. Instead, the context of the subscript will need to be controlled by some combination of:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Context of the entire term.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Appearance of known list operators in the subscript, such as comma or range.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Explicit syntax casting the inside of the subscript to list or scalar context.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Explicit declaration of default behavior.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;One thing that probably shouldn&amp;rsquo;t enter into it is the run-time type of the array object, because context really needs to be calculated at compile time if at all possible.&lt;/p&gt;

&lt;p&gt;In any event, it&amp;rsquo;s likely that some people will want subscripts to default to scalars, and other people will want them to default to lists. There are good arguments for either default, depending on whether you think more like an APL programmer or a mere mortal.&lt;/p&gt;

&lt;p&gt;There are other larger implications. If composite variables are thought of as scalar references, then the names &lt;code&gt;@foo&lt;/code&gt; and &lt;code&gt;%foo&lt;/code&gt; are really scalar variables unless explicitly dereferenced. That means that when you mention them in a scalar context, you get the equivalent of Perl 5&amp;rsquo;s &lt;code&gt;\@foo&lt;/code&gt; and &lt;code&gt;\%foo&lt;/code&gt;. This simplifies the prototyping system greatly, in that an operator like &lt;code&gt;push&lt;/code&gt; no longer needs to specify some kind of special reference context for its first argument &amp;ndash; it can merely specify a scalar context, and that&amp;rsquo;s good enough to assume the reference generation on its first argument. (Of course, the function signature can always be more specific if it wants to. More about that in future installments.)&lt;/p&gt;

&lt;p&gt;There are also implications for the assignment operator, in that it has to be possible to assign array references to array variables without accidentally invoking list context and copying the list instead of the reference to the list. We could invent another assignment operator to distinguish the two cases, but at the moment it looks as though bare variables and slices will behave as lvalues just as they do in Perl 5, while lists in parentheses will change to a binding of the right-hand arguments more closely resembling the way Perl 6 will bind formal arguments to actual arguments for function calls. That is to say,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo = (1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will supply an unbounded list context to the right side, but&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (@foo, @bar) = (@bar, @foo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will supply a context to the right side that requests two scalar values that are array references. This will be the default for unmarked variables in an lvalue list, but there will be an easy way to mark formal array and hash parameters to slurp the rest of the arguments with list context, as they do by default in Perl 5.&lt;/p&gt;

&lt;p&gt;(Alternately, we might end up leaving the ordinary list assignment operator with Perl 5 semantics, and define a new assignment operator such as &lt;code&gt;:=&lt;/code&gt; that does signatured assignment. I can argue that one both ways.)&lt;/p&gt;

&lt;p&gt;Just as arrays and hashes are explicitly dereferenced via subscripting (or implicitly dereferenced in list context), so too functions are merely named but not called by &lt;code&gt;&amp;amp;foo&lt;/code&gt;, and explicitly dereferenced with parentheses (or by use as a bare name without the ampersand (or both)). The Perl 5 meanings of the ampersand are no longer in effect, in that ampersand will no longer imply that signature matching is suppressed &amp;ndash; there will be a different mechanism for that. And since &lt;code&gt;&amp;amp;foo&lt;/code&gt; without parens doesn&amp;rsquo;t do a call, it is no longer possible to use that syntax to automatically pass the &lt;code&gt;@_&lt;/code&gt; array &amp;ndash; you&amp;rsquo;ll have to do that explicitly now with &lt;code&gt;foo(@_)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Scalar variables are special, in that they may hold either references or actual ``native&amp;rdquo; values, and there is no special dereference syntax as there is for other types. Perl 6 will attempt to hide the distinction as much as possible. That is, if &lt;code&gt;$foo&lt;/code&gt; contains a native integer, calling the &lt;code&gt;$foo.bar&lt;/code&gt; method will call a method on the built-in type. But if &lt;code&gt;$foo&lt;/code&gt; contains a reference to some other object, it will call the method on that object. This is consistent with the way we think about overloading in Perl 5, so you shouldn&amp;rsquo;t find this behavior surprising. It may take special syntax to get at any methods of the reference variable itself in this case, but it&amp;rsquo;s OK if special cases are special.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-133-html-id-rfc133-rfc-133-alternate-syntax-for-variable-names-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/133.html&#34; id=&#34;rfc133&#34;&gt;RFC 133: Alternate Syntax for Variable Names&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC has a valid point, but in fact we&amp;rsquo;re going to do just the opposite of what it suggests. That is, we&amp;rsquo;ll consider the funny characters to be part of the name, and use the subscripts for context. This works out better, because there&amp;rsquo;s only one funny character, but many possible forms of dereferencing.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-134-html-id-rfc134-r-fc-134-alternative-array-and-hash-slicing-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/134.html&#34; id=&#34;rfc134&#34;&gt;R FC 134: Alternative Array and Hash Slicing&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;re definitely killing Perl 5&amp;rsquo;s slice syntax, at least as far as relying on the initial character to determine the context of the subscript. There are many ways we could reintroduce a slicing syntax, some of which are mentioned in this RFC, but we&amp;rsquo;ll defer the decision on that till Apocalypse 9 on Data Structures, since the interesting parts of designing slice syntax will be driven by the need to slice multidimensional arrays.&lt;/p&gt;

&lt;p&gt;For now we&amp;rsquo;ll just say that arrays can have subscript signatures much like functions have parameter signatures. Ordinary one-dimensional arrays (and hashes) can then support some kind of simple slicing syntax that can be extended for more complicated arrays, while allowing multidimensional arrays to distinguish between simple slicing and complicated mappings of lists and functions onto subscripts in a manner more conducive to numerical programming.&lt;/p&gt;

&lt;p&gt;On the subject of hash slices returning pairs rather than values, we could distinguish this with special slice syntax, or we could establish the notion of a hashlist context that tells the slice to return pairs rather than just values. (We may not need a special slice syntax for that if it&amp;rsquo;s possible to typecast back and forth between pair lists and ordinary lists.)&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-196-html-id-rfc196-rfc-19-6-more-direct-syntax-for-hashes-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/196.html&#34; id=&#34;rfc196&#34;&gt;RFC 19 6: More Direct Syntax for Hashes&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC makes three proposals, which we&amp;rsquo;ll consider separately.&lt;/p&gt;

&lt;p&gt;Proposal 1 is ``that a hash in scalar context evaluate to the number of keys in the hash.&amp;rdquo; (You can find that out now, but only by using the &lt;code&gt;keys()&lt;/code&gt; function in scalar context.) Proposal 1 is OK if we change ``scalar context&amp;rdquo; to ``numeric context,&amp;rdquo; since in scalar context a hash will produce a reference to the hash, which just happens to numify to the number of entries.&lt;/p&gt;

&lt;p&gt;We must also realize that some implementations of hash might have to go through and count all the entries to return the actual number. Fortunately, in boolean context, it suffices to find a single entry to determine whether the hash contains anything. However, on hashes that don&amp;rsquo;t keep track of the number of entries, finding even one entry might reset any active iterator on the hash, since some implementations of hash (in particular, the ones that don&amp;rsquo;t keep track of the number of entries) may only supply a single iterator.&lt;/p&gt;

&lt;p&gt;Proposal 2 is ``that the iterator in a hash be reset through an explicit call to the &lt;code&gt;reset()&lt;/code&gt; function.&amp;rdquo; That&amp;rsquo;s fine, with the proviso that it won&amp;rsquo;t be a function, but rather a &lt;em&gt;method&lt;/em&gt; on the HASH class.&lt;/p&gt;

&lt;p&gt;Proposal 3 is really about &lt;code&gt;sort&lt;/code&gt; recognizing pairs and doing the right thing. Defaulting to sorting on &lt;code&gt;$^a[0] cmp $^b[0]&lt;/code&gt; is likely to be reasonable, and that&amp;rsquo;s where a pair&amp;rsquo;s key would be found. However, it&amp;rsquo;s probable that the correct solution is simply to provide a default string method for anonymous lists that happens to produce a decent key to sort on when &lt;code&gt;cmp&lt;/code&gt; requests a string representation of either of its arguments. The &lt;code&gt;sort&lt;/code&gt; itself should probably just concentrate on memoizing the returned strings so they don&amp;rsquo;t have to be recalculated.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-201-html-id-rfc201-rfc-201-hash-slicing-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/201.html&#34; id=&#34;rfc201&#34;&gt;RFC 201: Hash Slicing&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This RFC proposes to use &lt;code&gt;%&lt;/code&gt; as a marker for special hash slicing in the subscript. Unfortunately, the &lt;code&gt;%&lt;/code&gt; funny character will not be available for this use, since all hash refs will start with &lt;code&gt;%&lt;/code&gt;. Concise list comprehensions will require some other syntax within the subscript, which will hopefully generalize to arrays as well.&lt;/p&gt;

&lt;h3 id=&#34;span-id-otherdecisionsaboutvariables-other-decisions-about-variables-span&#34;&gt;&lt;span id=&#34;otherdecisionsaboutvariables&#34;&gt;Other Decisions About Variables&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Various special punctuation variables are gone in Perl 6, including all the deprecated ones. (Non-deprecated variables will be replaced by some kind of similar functionality that is likely to be invoked through some kind of method call on the appropriate object. If there is no appropriate object, then a named global variable might provide similar functionality.)&lt;/p&gt;

&lt;p&gt;Freeing up the various bracketing characters allows us to use them for other purposes, such as interpolation of expressions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;$(expr)&amp;quot;           # interpolate a scalar expression
    &amp;quot;@(expr)&amp;quot;           # interpolate a list expression
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$#foo&lt;/code&gt; is gone. If you want the final subscript of an array, and &lt;code&gt;[-1]&lt;/code&gt; isn&amp;rsquo;t good enough, use &lt;code&gt;@foo.end&lt;/code&gt; instead.&lt;/p&gt;

&lt;p&gt;Other special variables (such as the regex variables) will change from dynamic scoping to lexical scoping. It is likely that even &lt;code&gt;$_&lt;/code&gt; and &lt;code&gt;@_&lt;/code&gt; will be lexically scoped in Perl 6.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-names-names-span&#34;&gt;&lt;span id=&#34;names&#34;&gt;Names&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In Perl 5, lexical scopes are unnamed and unnameable. In Perl 6, the current lexical scope will have a name that is visible within the lexical scope as the pseudo class &lt;code&gt;MY&lt;/code&gt;, so that such a scope can, if it so chooses, delegate management of its lexical scope to some other module at compile time. In normal terms, that means that when you use a module, you can let it import things lexically as well as packagely.&lt;/p&gt;

&lt;p&gt;Typeglobs are gone. Instead, you can get at a variable object through the symbol table hashes that are structured much like Perl 5&amp;rsquo;s. The variable object for &lt;code&gt;$MyPackage::foo&lt;/code&gt; is stored in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %MyPackage::{&#39;$foo&#39;}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the funny character is part of the name. There is no longer any structure in Perl that associates everything with the name ``&lt;code&gt;foo&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Perl&amp;rsquo;s special global names are stored in a special package named ``&lt;code&gt;*&lt;/code&gt;&amp;rdquo; because they&amp;rsquo;re logically in every scope that does not hide them. So the unambiguous name of the standard input filehandle is &lt;code&gt;$*STDIN&lt;/code&gt;, but a package may just refer to &lt;code&gt;$STDIN&lt;/code&gt;, and it will default to &lt;code&gt;$*STDIN&lt;/code&gt; if no package or lexical variable of that name has been declared.&lt;/p&gt;

&lt;p&gt;Some of these special variables may actually be cloned for each lexical scope or each thread, so just because a name is in the special global symbol table doesn&amp;rsquo;t mean it always behaves as a global across all modules. In particular, changes to the symbol table that affect how the parser works must be lexically scoped. Just because I install a special rule for my cool new hyperquoting construct doesn&amp;rsquo;t mean everyone else should have to put up with it. In the limiting case, just because I install a Python parser, it shouldn&amp;rsquo;t force other modules into a maze of twisty little whitespace, all alike.&lt;/p&gt;

&lt;p&gt;Another way to look at it is that all names in the ``&lt;code&gt;*&lt;/code&gt;&amp;rdquo; package are automatically exported to every package and/or outer lexical scope.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-literals-literals-span&#34;&gt;&lt;span id=&#34;literals&#34;&gt;Literals&lt;/span&gt;&lt;/h3&gt;

&lt;h3 id=&#34;span-id-underscoresinnumericliterals-underscores-in-numeric-literals-span&#34;&gt;&lt;span id=&#34;underscoresinnumericliterals&#34;&gt;Underscores in Numeric Literals&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Underscores will be allowed between any two digits within a number.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-105-html-id-rfc105-rfc-105-remove-in-string-must-be-fatal-error-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/105.html&#34; id=&#34;rfc105&#34;&gt;RFC 105: Remove ``In string @ must be \@&amp;rdquo; Fatal Error&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Fine.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-111-html-id-rfc111-rfc-111-here-docs-terminators-was-whitespace-and-here-docs-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/111.html&#34; id=&#34;rfc111&#34;&gt;RFC 111: Here Docs Terminators (Was Whitespace and Here Docs)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Fine.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-162-html-id-rfc162-rfc-162-heredoc-co-ntents-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/162.html&#34; id=&#34;rfc162&#34;&gt;RFC 162: Heredoc co ntents&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I think I like option (e) the best: remove whitespace equivalent to the terminator.&lt;/p&gt;

&lt;p&gt;By default, if it has to dwim, it should dwim assuming that hard tabs are 8 spaces wide. This should not generally pose a problem, since most of the time the tabbing will be consistent throughout anyway, and no dwimming will be necessary. This puts the onus on people using nonstandard tabs to make sure they&amp;rsquo;re consistent so that Perl doesn&amp;rsquo;t have to guess.&lt;/p&gt;

&lt;p&gt;Any additional mangling can easily be accomplished by a user-defined operator.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-139-html-id-rfc139-rfc-139-allow-calling-any-function-with-a-syntax-like-s-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/139.html&#34; id=&#34;rfc139&#34;&gt;RFC 139: Allow Calling Any Function With a Syntax Like s///&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Creative quoting will be allowed with lexical mutataion, but we can&amp;rsquo;t parse &lt;code&gt;foo(bar)&lt;/code&gt; two different ways simultaneously, and I&amp;rsquo;m unwilling to prevent people from using parens as quote characters. I don&amp;rsquo;t see how we can reasonably have new quote operators without explicit declaration. And if the utility of a quote-like operator is sufficient, there should be little relative burden in requiring such a declaration.&lt;/p&gt;

&lt;p&gt;The form of such a declaration is left to the reader as an exercise in function property definition. We may revisit the question later in this series. It&amp;rsquo;s also possible that a quote operator such as &lt;code&gt;qx//&lt;/code&gt; could have a corresponding function name like &lt;code&gt;quote:qx&lt;/code&gt; that could be invoked as a function.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-222-html-id-rfc222-rfc-222-interpolation-of-object-method-calls-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/222.html&#34; id=&#34;rfc222&#34;&gt;RFC 222: Interpolation of Object Method Calls&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve been hankering for methods to interpolate for a long time, so I&amp;rsquo;m in favor of this RFC. And it&amp;rsquo;ll become doubly important as we move toward encouraging people to use accessor methods to refer to object attributes outside the class itself.&lt;/p&gt;

&lt;p&gt;I have one ``but,&amp;rdquo; however. Since we&amp;rsquo;ll switch to using &lt;code&gt;.&lt;/code&gt; instead of &lt;code&gt;-&amp;gt;&lt;/code&gt;, I think for sanity&amp;rsquo;s sake we may have to require the parentheses, or ``&lt;code&gt;$file.$ext&lt;/code&gt;&amp;rdquo; is going to give people fits. Not to mention ``&lt;code&gt;$file.ext&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-226-html-id-rfc226-rfc-226-selective-interpolation-in-single-quotish-context-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/226.html&#34; id=&#34;rfc226&#34;&gt;RFC 226: Selective Interpolation in Single Quotish Context.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;This proposal has much going for it, but there are also difficulties, and I&amp;rsquo;ve come close to rejecting it outright simply because the single-quoting policy of Perl 5 has been successful. And I think the proposal in this RFC for &lt;code&gt;\I&lt;/code&gt;&amp;hellip;&lt;code&gt;\E&lt;/code&gt; is ugly. (And I&amp;rsquo;d like to kill &lt;code&gt;\E&lt;/code&gt; anyway, and use bracketed scopings.)&lt;/p&gt;

&lt;p&gt;However, I think there is a major ``can&amp;rsquo;t get there from here&amp;rdquo; that we could solve by treating interpolation into single quotes as something hard, not something easy. The basic problem is that it&amp;rsquo;s too easy to run into a &lt;code&gt;\$&lt;/code&gt; or &lt;code&gt;\@&lt;/code&gt; (or a &lt;code&gt;\I&lt;/code&gt; for that matter) that wants to be taken literally. I think we could allow the interpolation of arbitrary expressions into single-quoted strings, but only if we limit it to an unlikely sequence where three or more characters are necessary for recognition. The most efficient mental model would seem to be the idea of embedding one kind of quote in another, so I think this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    \q{stuff}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will embed single-quoted stuff, while this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    \qq{stuff}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will embed double-quoted stuff. A variable could then be interpolated into a single-quoted string by saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    \qq{$foo}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-237-html-id-rfc237-rfc-237-hashes-should-interpolate-in-double-quoted-strings-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/237.html&#34; id=&#34;rfc237&#34;&gt;RFC 237: Hashes Should Interpolate in Double-Quoted Strings&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I agree with this RFC in principle, but we can&amp;rsquo;t define the default hash stringifier in terms of variables that are going away in Perl 6, so the RFC&amp;rsquo;s proposal of using &lt;code&gt;$&amp;quot;&lt;/code&gt; is right out.&lt;/p&gt;

&lt;p&gt;All objects should have a method by which they produce readable output. How this may be overridden by user preference is open to debate. Certainly, dynamic scoping has its problems. But lexical override of an object&amp;rsquo;s preferences is also problematic. Individual object properties appear to give a decent way out of this. More on that below.&lt;/p&gt;

&lt;p&gt;On &lt;code&gt;printf&lt;/code&gt; formats, I don&amp;rsquo;t see any way to dwim that &lt;code&gt;%d&lt;/code&gt; isn&amp;rsquo;t an array, so we&amp;rsquo;ll just have to put formats into single quotes in general. Those format strings that also interpolate variables will be able to use the new &lt;code&gt;\qq{$var}&lt;/code&gt; feature.&lt;/p&gt;

&lt;p&gt;Note for those who are thinking we should just stick with Perl 5 interpolation rules: We have to allow &lt;code&gt;%&lt;/code&gt; to introduce interpolation now because individual hash values are no longer named with &lt;code&gt;$foo{$bar}&lt;/code&gt;, but rather &lt;code&gt;%foo{$bar}&lt;/code&gt;. So we might as well allow interpolation of complete hashes.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-251-html-id-rfc251-rfc-251-interpolation-of-class-method-calls-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/251.html&#34; id=&#34;rfc251&#34;&gt;RFC 251: Interpolation of Class Method Calls&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Class method calls are relatively rare (except for constructors, which will be rarely interpolated). So rather than scanning for identifiers that might introduce a class, I think we should just depend on expression interpolation instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;There are $(Dog.numdogs) dogs.&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-252-html-id-rfc252-rfc-252-interpolation-of-subroutines-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/252.html&#34; id=&#34;rfc252&#34;&gt;RFC 252 : Interpolation of Subroutines&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I think subroutines should interpolate, provided they&amp;rsquo;re introduced with the funny character. (On the other hand, how hard is &lt;code&gt;$(sunset $date)&lt;/code&gt; or &lt;code&gt;@(sunset $date)&lt;/code&gt;? On the gripping hand, I like the consistency of &lt;code&gt;&amp;amp;&lt;/code&gt; with &lt;code&gt;$&lt;/code&gt;, &lt;code&gt;@&lt;/code&gt; and &lt;code&gt;%&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;I think the parens are required, since in Perl 6, scalar &lt;code&gt;&amp;amp;sub&lt;/code&gt; will just return a reference, and require parens if you really want to deref the sub ref. (It&amp;rsquo;s true that a subroutine can be called without parens when used as a list operator, but you can&amp;rsquo;t interpolate those without a funny character.)&lt;/p&gt;

&lt;p&gt;For those worried about the use of &lt;code&gt;&amp;amp;&lt;/code&gt; for signature checking suppression, we should point out that &lt;code&gt;&amp;amp;&lt;/code&gt; will no longer be the way to suppress signature checking in Perl 6, so it doesn&amp;rsquo;t matter.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-327-html-id-rfc327-rfc-327-code-v-code-for-vertical-tab-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/327.html&#34; id=&#34;rfc327&#34;&gt;RFC 327: &lt;code&gt;\ v&lt;/code&gt; for Vertical Tab&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I think the opportunity cost of not reserving &lt;code&gt;\v&lt;/code&gt; for future use is too high to justify the small utility of retaining compatibility with a feature virtually nobody uses anymore. For instance, I almost used &lt;code&gt;\v&lt;/code&gt; and &lt;code&gt;\V&lt;/code&gt; for switching into and out of verbatim (single-quote) mode, until I decided to unify that with quoting syntax and use &lt;code&gt;\qq{}&lt;/code&gt; and &lt;code&gt;\q{}&lt;/code&gt; instead.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-328-html-id-rfc328-rfc-328-single-quotes-don-t-interpolate-and-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/328.html&#34; id=&#34;rfc328&#34;&gt;RFC 328: Single quotes don&amp;rsquo;t interpolate \&amp;rsquo; and \&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I think hyperquotes will be possible with a declaration of your quoting rules, so we&amp;rsquo;re not going to change the basic single-quote rules (except for supporting &lt;code&gt;\q&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;span-id-otherdecisionsaboutliterals-other-decisions-about-literals-span&#34;&gt;&lt;span id=&#34;otherdecisionsaboutliterals&#34;&gt;Other Decisions About Literals&lt;/span&gt;&lt;/h3&gt;

&lt;h3 id=&#34;span-id-scopingofletal-scoping-of-l-et-al-span&#34;&gt;&lt;span id=&#34;scopingofletal&#34;&gt;Scoping of \L et al.&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;d like to get rid of the gratuitously ugly &lt;code&gt;\E&lt;/code&gt; as an end-of-scope marker. Instead, if any sequence such as &lt;code&gt;\L&lt;/code&gt;, &lt;code&gt;\U&lt;/code&gt; or &lt;code&gt;\Q&lt;/code&gt; wishes to impose a scope, then it must use curlies around that scope: &lt;code&gt;\L{&lt;/code&gt;&lt;em&gt;stuff&lt;/em&gt;&lt;code&gt;}&lt;/code&gt;, &lt;code&gt;\U{&lt;/code&gt;&lt;em&gt;stuff&lt;/em&gt;&lt;code&gt;}&lt;/code&gt; or &lt;code&gt;\Q{&lt;/code&gt;&lt;em&gt;stuff&lt;/em&gt;&lt;code&gt;}&lt;/code&gt;. Any literal curlies contained in &lt;em&gt;stuff&lt;/em&gt; must be backslashed. (Curlies as syntax (such as for subscripts) should nest correctly.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-barewordpolicy-bareword-policy-span&#34;&gt;&lt;span id=&#34;barewordpolicy&#34;&gt;Bareword Policy&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There will be no barewords in Perl 6. Any bare name that is a declared package name will be interpreted as a class object that happens to stringify to the package name. All other bare names will be interpreted as subroutine or method calls. For nonstrict applications, undefined subroutines will autodefine themselves to return their own name. Note that in &lt;code&gt;${name}&lt;/code&gt; and friends, the name is considered autoquoted, not a bareword.&lt;/p&gt;

&lt;h3 id=&#34;span-id-weirdbrackets-weird-brackets-span&#34;&gt;&lt;span id=&#34;weirdbrackets&#34;&gt;Weird brackets&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Use of brackets to disambiguate&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;${foo[bar]}&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;from&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;${foo}[bar]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;will no longer be supported. Instead, the expression parser will always grab as much as it can, and you can make it quit at a particular point by interpolating a null string, specified by &lt;code&gt;\Q&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;quot;$foo\Q[bar]&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-specialtokens-special-tokens-span&#34;&gt;&lt;span id=&#34;specialtokens&#34;&gt;Special tokens&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Special tokens will turn into either POD directives or lexically scoped OO methods under the &lt;code&gt;MY&lt;/code&gt; pseudo-package:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Old                 New
    ---                 ---
    __LINE__            MY.line
    __FILE__            MY.file
    __PACKAGE__         MY.package
    __END__             =begin END      (or remove)
    __DATA__            =begin DATA
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-heredocsyntax-heredoc-syntax-span&#34;&gt;&lt;span id=&#34;heredocsyntax&#34;&gt;Heredoc Syntax&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;I think heredocs will require quotes around any identifier, and we need to be sure to support &lt;code&gt;&amp;lt;&amp;lt; qq(END)&lt;/code&gt; style quotes. Space is now allowed before the (required) quoted token. Note that custom quoting is now possible, so if you define a fancy &lt;code&gt;qh&lt;/code&gt; operator for your fancy hyperquoting algorithm, then you could say &lt;code&gt;&amp;lt;&amp;lt;qh(END)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It is still the case that you can say &lt;code&gt;&amp;lt;&amp;lt;&amp;quot;&amp;quot;&lt;/code&gt; to grab everything up to the next blank line. However, Perl 6 will consider any line containing only spaces, tabs, etc., to be blank, not just the ones that immediately terminate with newline.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-context-context-span&#34;&gt;&lt;span id=&#34;context&#34;&gt;Context&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In Perl 5, a lot of contextual processing was done at run-time, and even then, a given function could only discover whether it was in void, scalar or list context. In Perl 6, we will extend the notion of context to be more amenable to both compile-time and run-time analysis. In particular, a function or method can know (theoretically even at compile time) when it is being called in:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Void context
    Scalar context
        Boolean context
        Integer context
        Numeric context
        String context
        Object context
    List context
        Flattening list context (true list context).
        Non-flattening list context (list of scalars/objects)
        Lazy list context (list of closures)
        Hash list context (list of pairs)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(This list isn&amp;rsquo;t necessarily exhaustive.)&lt;/p&gt;

&lt;p&gt;Each of these contexts (except maybe void) corresponds to a way in which you might declare the parameters of a function (or the left side of a list assignment) to supply context to the actual argument list (or right side of a list assignment). By default, parameters will supply object context, meaning individual parameters expect to be aliases to the actual parameters, and even arrays and hashes don&amp;rsquo;t do list context unless you explicitly declare them to. These aren&amp;rsquo;t cast in stone yet (or even Jello), but here are some ideas for possible parameter declarations corresponding to those contexts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Scalar context
        Boolean context                 bit $arg
        Integer context                 int $arg
        Numeric context                 num $arg
        String context                  str $arg
        Object context                  $scalar, %hash, Dog @canines, &amp;amp;foo
    List context
        Flattening list context         *@args
        Non-flattening list context     $@args
        Lazy list context               &amp;amp;@args
        Hash list context               *%args
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(I also expect unary * to force flattening of arrays in rvalue contexts. This is how we defeat the type signature in Perl 6, instead of relying on the initial ampersand. So instead of Perl 5&amp;rsquo;s &lt;code&gt;&amp;amp;push(@list)&lt;/code&gt;, you could just say &lt;code&gt;push *@list&lt;/code&gt;, and it wouldn&amp;rsquo;t matter what &lt;code&gt;push&lt;/code&gt;&amp;rsquo;s parameter signature said.)&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also possible to define properties to modify formal arguments, though that can get clunky pretty quickly, and I&amp;rsquo;d like to have a concise syntax for the common cases, such as the last parameter slurping a list in the customary fashion. So the signature for the built-in &lt;code&gt;push&lt;/code&gt; could be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub push (@array, *@pushees);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Actually, the signature might just be &lt;code&gt;(*@pushees)&lt;/code&gt;, if &lt;code&gt;push&lt;/code&gt; is really a method in the &lt;code&gt;ARRAY&lt;/code&gt; class, and the object is passed implicitly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    class ARRAY;
    sub .push (*@pushees);
    sub .pop (;int $numtopop);
    sub .splice (int $offset, int $len, *@repl);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But we&amp;rsquo;re getting ahead of ourselves.&lt;/p&gt;

&lt;p&gt;By the way, all function and method parameters (other than the object itself) will be considered read-only unless declared with the &lt;code&gt;rw&lt;/code&gt; property. (List assignments will default the other way.) This will prevent a great deal of the wasted motion current Perl implementations have to go through to make sure all function arguments are valid lvalues, when most of them are in fact never modified.&lt;/p&gt;

&lt;p&gt;Hmm, we&amp;rsquo;re still getting ahead of ourselves. Back to contexts.&lt;/p&gt;

&lt;h3 id=&#34;span-id-referencesarenowtransparenttobooleancontext-references-are-now-transparent-to-b-oolean-context-span&#34;&gt;&lt;span id=&#34;referencesarenowtransparenttobooleancontext&#34;&gt;References are now transparent to b oolean context&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;References are no longer considered to be ``always true&amp;rdquo; in Perl 6. Any type can overload its &lt;code&gt;bit()&lt;/code&gt; casting operator, and any type that hasn&amp;rsquo;t got a &lt;code&gt;bit()&lt;/code&gt; of its own inherits one from somewhere else, if only from class UNIVERSAL. The built-in bit methods have the expected boolean semantics for built-in types, so arrays are still true if they have something in them, strings are true if they aren&amp;rsquo;t &lt;code&gt;&amp;quot;&amp;quot;&lt;/code&gt; or &lt;code&gt;&amp;amp;qu ot;0&amp;quot;&lt;/code&gt;, etc.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-lists-lists-span&#34;&gt;&lt;span id=&#34;lists&#34;&gt;Lists&lt;/span&gt;&lt;/h3&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-175-html-id-rfc175-rfc-175-add-code-list-code-keyword-to-force-list-context-like-code-scalar-code-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/175.html&#34; id=&#34;rfc175&#34;&gt;RFC 175: Add &lt;code&gt;list&lt;/code&gt; keyword to force list context (like &lt;code&gt;scalar&lt;/code&gt;)&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Another RFC rescued from the compost pile. In Perl 6, type names will identify casting functions in general. (A casting function merely forces context &amp;ndash; it&amp;rsquo;s a no-op unless the actual context is different.) In Perl 6, a list used in a scalar context will automatically turn itself into a reference to the list rather than returning the last element. (A subscript of &lt;code&gt;[-1]&lt;/code&gt; can always be used to get the last element explicitly, if that&amp;rsquo;s actually desired. But that&amp;rsquo;s a rarity, in practice.) So it works out that the explicit list composer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [1,2,3]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is syntactic sugar for something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    scalar(list(1,2,3));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Depending on whether we continue to make a big deal of the list/array distinction, that might actually be spelled:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    scalar(array(1,2,3));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other casts might be words like &lt;code&gt;hash&lt;/code&gt; (supplying a pairlist context) and &lt;code&gt;objlist&lt;/code&gt; (supplying a scalar context to a list of expressions). Maybe even the optional &lt;code&gt;sub&lt;/code&gt; keyword could be considered a cast on a following block that might not otherwise be considered a closure in context. Perhaps &lt;code&gt;sub&lt;/code&gt; is really spelled &lt;code&gt;lazy&lt;/code&gt;. In which case, we might even have a &lt;code&gt;lazylist&lt;/code&gt; context to supply a lazy context to a list of expressions.&lt;/p&gt;

&lt;p&gt;And of course, you could use standard casts like &lt;code&gt;int()&lt;/code&gt;, &lt;code&gt;num()&lt;/code&gt;, and &lt;code&gt;str()&lt;/code&gt;, when you want to be explicit about such contexts at compile time. (Perl 5 already has these contexts, but only at run time.) Note also that, due to the relationship between unary functions and methods, &lt;code&gt;$foo.int&lt;/code&gt;, &lt;code&gt;$foo.num&lt;/code&gt;, and &lt;code&gt;$foo.str&lt;/code&gt; will be just a different way to write the same casts.&lt;/p&gt;

&lt;p&gt;Lest you worry that your code is going to be full of casts, I should point out that you won&amp;rsquo;t need to use these casts terribly often because each of these contexts will typically be implied by the signature of the function or method you&amp;rsquo;re calling. (And Perl will still be autoconverting for you whenever it makes sense.) More on that in Apocalypse 6, Subroutines. If not sooner.&lt;/p&gt;

&lt;p&gt;So, while boolean context might be explicitly specified by writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if (bit $foo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ($foo.bit)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;d usually just write it as in Perl 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ($foo)
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-otherdecisionsaboutlists-other-decisions-about-lists-span&#34;&gt;&lt;span id=&#34;otherdecisionsaboutlists&#34;&gt;Other Decisions about Lists&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Based on some of what we&amp;rsquo;ve said, you can see that we&amp;rsquo;ll have the ability to define various kinds of lazily generated lists. The specific design of these operators is left for subsequent Apocalypses, however. I will make one observation here, that I think some of the proposals for how array subscripts are generated should be generalized to work outside of subscripts as well. This may place some constraints on the general use of the &lt;code&gt;:&lt;/code&gt; character in places where an operator is expected, for instance.&lt;/p&gt;

&lt;p&gt;As mentioned above, we&amp;rsquo;ll be having several different kinds of list context. In particular, there will be a hash list context that assumes you&amp;rsquo;re feeding it pairs, and if you don&amp;rsquo;t feed it pairs, it will assume the value you feed it is a key, and supply a default value. There will likely be ways to get hashes to default to interesting values such as 0 or 1.&lt;/p&gt;

&lt;p&gt;In order to do this, the &lt;code&gt;=&amp;gt;&lt;/code&gt; operator has to at least mark its left operand as a key. More likely, it actually constructs a pair object in Perl 6. And the &lt;code&gt;{ foo =&amp;gt; $bar }&lt;/code&gt; list composer will be required to use &lt;code&gt;=&amp;gt;&lt;/code&gt; (or be in a hashlist context), or it will instead be interpreted as a closure without a &lt;code&gt;sub&lt;/code&gt;. (You can always use an explicit &lt;code&gt;sub&lt;/code&gt; or &lt;code&gt;hash&lt;/code&gt; to cast the brackets to the proper interpretation.)&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ve noticed how many programs use &lt;code&gt;qw()&lt;/code&gt; all over the place (much more frequently than the input operator, for instance), and I&amp;rsquo;ve always thought &lt;code&gt;qw()&lt;/code&gt; was kind of ugly, so I&amp;rsquo;d like to replace it with something prettier. Since the input operator is using up a pair of perfectly good bracketing characters for little syntactic gain, we&amp;rsquo;re going to steal those and make them into a qw-like list composer. In ordinary list context, the following would be identical:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @list = &amp;lt; foo $bar %baz blurch($x) &amp;gt;;
    @list = qw/ foo $bar %baz blurch($x) /;                     # same as this
    @list = (&#39;foo&#39;, &#39;$bar&#39;, &#39;%baz&#39;, &#39;blurch($x)&#39;);              # same as this
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But in hashlist context, it might be equivalent to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %list = &amp;lt; foo $bar %baz blurch($x) &amp;gt;;
    %list = (foo =&amp;gt; 1, &#39;$bar&#39; =&amp;gt; 1, &#39;%baz&#39; = 1, blurch =&amp;gt; $x);  # same as this
&lt;/code&gt;&lt;/pre&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-files-files-span&#34;&gt;&lt;span id=&#34;files&#34;&gt;Files&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Basically, file handles are just objects that can be used as iterators, and don&amp;rsquo;t belong in this chapter anymore.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-34-html-id-rfc034-rfc-034-angle-brackets-should-not-be-used-for-file-globbing-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/34.html&#34; id=&#34;rfc034&#34;&gt;RFC 034: Angle Brackets Should Not Be Used for File Globbing&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Indeed, they won&amp;rsquo;t be. In fact, angle brackets won&amp;rsquo;t be used for input at all, I suspect. See below. Er, above.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-51-html-id-rfc051-rfc-051-angle-brackets-should-accept-filenames-and-lists-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/51.html&#34; id=&#34;rfc051&#34;&gt;RFC 051: Angle Brackets Should Accept Filenames and Lists&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;There is likely to be no need for an explicit input operator in Perl 6, and I want the angles for something else. I/O handles are a subclass of iterators, and I think general iterator variables will serve the purpose formerly served by the input operator, particularly since they can be made to do the right Thing in context. For instance, to read from standard input, it will suffice to say&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while ($STDIN) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the iterator will know it should assign to &lt;code&gt;$_&lt;/code&gt;, because it&amp;rsquo;s in a Boolean context.&lt;/p&gt;

&lt;p&gt;I read this RFC more as requesting a generic way to initialize an iterator according to the type of the iterator. The trick in this case is to prevent the re-evaluation of the spec every time &amp;ndash; you don&amp;rsquo;t want to reopen the file every time you read a line from it, for instance. There will be standard ways to suppress evaluation in Perl 6, both from the standpoint of the caller and the callee. In any case, the model is that an anonymous subroutine is passed in, and called only when appropriate. So an iterator syntax might prototype its argument to be an anonymous sub, or the user might explicitly pass an anonymous sub, or both. In any event, the &lt;code&gt;sub&lt;/code&gt; keyword will be optional in Perl 6, so things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    while (file {LIST}) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;can be made to defer evaluation of LIST to the appropriate moment (or moments, if LIST is in turn generating itself on the fly). For appropriate parameter declarations I suppose even the brackets could be scrapped.&lt;/p&gt;

&lt;hr /&gt;

&lt;h3 id=&#34;span-id-properties-properties-span&#34;&gt;&lt;span id=&#34;properties&#34;&gt;Properties&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Variables and values of various types have various kinds of data attributes that are naturally associated with them by virtue of their type. You know a dog comes equipped with a wag, hopefully attached to a tail. That&amp;rsquo;s just part of doghood.&lt;/p&gt;

&lt;p&gt;Many times, however, you want the equivalent of a Post-It&amp;reg; note, so you can temporarily attach bits of arbitrary information to some unsuspecting appliance that (though it wasn&amp;rsquo;t designed for it) is nevertheless the right place to put the note. Similarly, variables and values in Perl 6 allow you to attach arbitrary pieces of information known as ``properties.&amp;rdquo; In essence, any object in Perl can have an associated hash containing these properties, which are named by the hash key.&lt;/p&gt;

&lt;p&gt;Some of these properties are known at compile time, and don&amp;rsquo;t actually need to be stored with the object in question, but can actually be stored instead in the symbol table entry for the variable in question. (Perl still makes it appear as though these values are attached to the object.) Compile-time properties can therefore be attached to variables of any type.&lt;/p&gt;

&lt;p&gt;Run-time properties really are associated with the object in question, which implies some amount of overhead. For that reason, intrinsic data types like &lt;code&gt;int&lt;/code&gt; and &lt;code&gt;num&lt;/code&gt; may or may not allow run-time properties. In cases where it is allowed, the intrinsic type must generally be promoted to its corresponding object type (or wrapped in an object that delegates back to the original intrinsic for the actual value). But you really don&amp;rsquo;t want to promote an array of a million bits to an array of a million objects just because you had the hankering to put a sticky note on one of those bits, so in those cases it&amp;rsquo;s likely to be disallowed, or the bit is likely to be cloned instead of referenced, or some such thing.&lt;/p&gt;

&lt;p&gt;Properties may also be attached to subroutines.&lt;/p&gt;

&lt;p&gt;In general, you don&amp;rsquo;t set or clear properties directly &amp;ndash; instead you call an accessor method to do it for you. If there is no method of that name, Perl will assume there was one that just sets or clears a property with the same name as the method. However, using accessor methods to set or clear properties allows us to define synthetic properties. For instance, there might be a real &lt;code&gt;constant&lt;/code&gt; property that you could attach to a variable. Certain variables (such as those in a function prototype) might have &lt;code&gt;constant&lt;/code&gt; set by default. In that case, setting a synthetic property such as &lt;code&gt;rw&lt;/code&gt; might clear the underlying &lt;code&gt;constant&lt;/code&gt; property.&lt;/p&gt;

&lt;p&gt;A property may be attached to the foregoing expression by means of the ``is&amp;rdquo; keyword. Here&amp;rsquo;s a compile-time property set on a variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my int $pi is constant = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a run-time property set on a return value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    return 0 is true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whether a property is applied to a variable at compile time or a value at run-time depends on whether it&amp;rsquo;s in lvalue or rvalue context. (Variable declarations are always in lvalue context even when you don&amp;rsquo;t assign anything to them.)&lt;/p&gt;

&lt;p&gt;The ``&lt;code&gt;is&lt;/code&gt;&amp;rdquo; works just like the ``&lt;code&gt;.&lt;/code&gt;&amp;rdquo; of a method call, except that the return value is the object on the left, not the return value of the method, which is discarded.&lt;/p&gt;

&lt;p&gt;As it happens, the ``&lt;code&gt;is&lt;/code&gt;&amp;rdquo; is optional in cases where an operator is already expected. So you might see things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my int $pi constant = 3;
    return 0 true;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, the methods are actually being parsed as postfix operators. (However, we may make it a stricture that you may omit the &lt;code&gt;is&lt;/code&gt; only for predeclared property methods.)&lt;/p&gt;

&lt;p&gt;Since these actually are method calls, you can pass arguments in addition to the object in question:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my int @table is dim(366,24,60);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our examples above are assuming an argument of &lt;code&gt;(1)&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my int $pi is constant(1) = 3;
    return 0 is true(1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the ``&lt;code&gt;is&lt;/code&gt;&amp;rdquo; is optional in the common cases, you can stack multiple properties without repeating the ``&lt;code&gt;is&lt;/code&gt;.&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my int $pi is shared locked constant optimize($optlevel) = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Note that these methods are called on the &lt;code&gt;$pi&lt;/code&gt; variable at compile time, so it behooves you to make sure everything you call is defined. For instance, &lt;code&gt;$optlevel&lt;/code&gt; needs to be known at compile-time.)&lt;/p&gt;

&lt;p&gt;Here are a list of property ideas stolen from Damian. (I guess that makes it intellectual property theft.) Some of the names have been changed to protect the (CS) innocent.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Subroutine attributes...
    sub name is rw { ... }                      # was lvalue

    my sub rank is same { ... }                 # was memoized

    $snum = sub is optimize(1) { ... };         # &amp;quot;is&amp;quot; required here

    # Variable attributes...
    our $age is constant = 21;                  # was const

    my %stats is private;
    my int @table is dim(366,24,60);

    $arrayref = [1..1000000] is computed Purpose(&#39;demo of anon var attrs&#39;);

    sub choose_rand (@list is lazy) { return $list[rand @list] }
                                                # &amp;amp;@list notation is likely

    $self = $class.bless( {name=&amp;gt;$name, age=&amp;gt;$age} is Initialized );

    # Reference attributes...
    $circular = \$head is weak;

    # Literal attributes...
    $name = &amp;quot;Damian&amp;quot; is Note(&amp;quot;test data only&amp;quot;);
    $iohandle = open $filename is dis(qw/para crlf uni/) or die;
    $default = 42 is Meaning(&amp;lt;&amp;lt;OfLife);
                             The Answer
                             OfLife

    package Pet is interface;

    class Dog inherits(&#39;Canine&#39;) { ... }

    print $data{key is NoteToSelf(&#39;gotta get a better name for this key&#39;)};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(I don&amp;rsquo;t agree with using properties for all of these things, but it&amp;rsquo;s pretty amazing how far into the ground you can drive it.)&lt;/p&gt;

&lt;p&gt;Property names should start with an identifier letter (which includes Unicode letters and ideographs). The parsing of the arguments (if any) is controlled by the signature of the method in question. Property method calls without a ``.&amp;rdquo; always modify their underlying property.&lt;/p&gt;

&lt;p&gt;If called as an ordinary method (with a ``.&amp;ldquo;), the property value is returned without being modified. That value could then be modified by a run-time property. For instance, &lt;code&gt;$pi.constant&lt;/code&gt; would return &lt;code&gt;1&lt;/code&gt; rather than the value of &lt;code&gt;$pi&lt;/code&gt;, so we get:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    return $pi.constant is false;       # &amp;quot;1 but false&amp;quot; (not possible in Perl 5)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, if you omit the dot, something else happens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    return $pi constant is false;       # 3 but false (and 3 is now very constant)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here are some more munged Damian examples:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if (&amp;amp;name.rw) { ... }

    $age++ unless $age.constant;

    $elements = return reduce $^ * $^, *@table.dim;

    last if ${self}.Initialized;

    print &amp;quot;$arrayref.Purpose() is not $default.Meaning()\n&amp;quot;;

    print %{$self.X};    # print hash referred to by X attribute of $self
    print %{$self}.X;    # print X attribute of hash referred to by $self
    print %$self.X;      # print X attribute of hash referred to by $self
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with the dotless form, if there is no actual method corresponding to the property, Perl pretends there&amp;rsquo;s a rudimentary one returning the actual property.&lt;/p&gt;

&lt;p&gt;Since these methods return the properties (except when overridden by dotless syntax), you can temporize a property just as you can any method, provided the method itself allows writing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    temp $self.X = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    temp $self is X = 0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would assign to 0 to &lt;code&gt;$self&lt;/code&gt; instead. (Whether it actually makes sense to set the compile-time X property at run time on the &lt;code&gt;$self&lt;/code&gt; variable is anybody&amp;rsquo;s guess.)&lt;/p&gt;

&lt;p&gt;Note that by virtue of their syntax, properties cannot be set by interpolation into a string. So, happily:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;My $variable is foobar\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;does not attempt to set the &lt;code&gt;foobar&lt;/code&gt; property on &lt;code&gt;$variable&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The ``&lt;code&gt;is&lt;/code&gt;&amp;rdquo; keyword binds with the same precedence as ``.&amp;ldquo;, even when it&amp;rsquo;s not actually there.&lt;/p&gt;

&lt;p&gt;Note that when you say &lt;code&gt;$foo.bar&lt;/code&gt;, you get &lt;code&gt;$foo&lt;/code&gt;&amp;rsquo;s compile-time property if there is one (which is known at compile time, duh). Otherwise it&amp;rsquo;s an ordinary method call on the value (which looks for a run-time property only if a method can&amp;rsquo;t be found, so it shouldn&amp;rsquo;t impact ordinary method call overhead.)&lt;/p&gt;

&lt;p&gt;To get to the properties directly without going through the method interface, use the special &lt;code&gt;btw&lt;/code&gt; method, which returns a hash ref to the properties hash.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $foo.btw{constant}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that synthetic properties won&amp;rsquo;t show up there!&lt;/p&gt;

&lt;p&gt;None of the property names in this Apocalypse should be taken as final. We will decide on actual property names as we proceed through the series.&lt;/p&gt;

&lt;p&gt;Well, that&amp;rsquo;s it for Apocalypse 2. Doubtless there are some things I should have decided here that I didn&amp;rsquo;t yet, but at least we&amp;rsquo;re making progress. Well, at least we&amp;rsquo;re moving in some direction or other. Now it&amp;rsquo;s time for us to dance the Apocalypso, in honor of Jon Orwant and his new wife.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Apocalypse 1: The Ugly, the Bad, and the Good</title>
      <link>http://localhost:1313/pub/2001/04/02/wall.html/</link>
      <pubDate>Mon, 02 Apr 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/04/02/wall.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S01.html&#34;&gt;Synopsis 01&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;•&lt;a href=&#34;#rfc141&#34;&gt;RFC 141: This Is The Last Major Revision&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#rfc28&#34;&gt;RFC 28: Perl should stay Perl&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#rfc16&#34;&gt;RFC 16: Keep default Perl free of constraints such as warnings and strict&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#rfc73&#34;&gt;RFC 73: All Perl core functions should return objects&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#rfc26&#34;&gt;RFC 26: Named operators versus functions&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;People get scared when they hear the word Apocalypse, but here I mean it in the good sense: a Revealing. An Apocalypse is supposed to reveal good news to good people. (And if it also happens to reveal bad news to bad people, so be it. Just don&amp;rsquo;t be bad.)&lt;/p&gt;

&lt;p&gt;What I will be revealing in these columns will be the design of Perl 6. Or more accurately, the beginnings of that design, since the design process will certainly continue after I&amp;rsquo;ve had my initial say in the matter. I&amp;rsquo;m not omniscient, rumors to the contrary notwithstanding. This job of playing God is a little too big for me. Nevertheless, someone has to do it, so I&amp;rsquo;ll try my best to fake it. And I&amp;rsquo;ll expect all of you to help me out with the process of creating history. We all have to do our bit with free will.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;If you look at the history of Perl 6 up to this point, you will see why this column is subtitled The Ugly, the Bad, and the Good. The RFC process of last year was ugly, in a good sense. It was a brainstorming process, and that means it was deliberately ugly—not in the sense of incivility, since the RFC process was in fact surprisingly civil, but in the sense that there was little coherent design to the suggestions in the RFCs. Frankly, the RFCs are all over the map, without actually covering the map. There are contradictory RFCs, and there are missing RFCs. Many of the RFCs propose real problems but go off at funny angles in trying to propose solutions. Many of them patch symptoms without curing the underlying ailments.&lt;/p&gt;

&lt;table&gt;
&lt;thead&gt;
&lt;tr&gt;
&lt;th&gt;&lt;/th&gt;
&lt;/tr&gt;
&lt;/thead&gt;

&lt;tbody&gt;
&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;strong&gt;Larry Wall will give his annual entertaining talk on the state of the Perl world, covering both Perl 5 and Perl 6 at this Year&amp;rsquo;s &lt;a href=&#34;http://conferences.oreilly.com/perl/&#34;&gt;Open Source Convention&lt;/a&gt;. Don&amp;rsquo;t miss this rare opportunity to hear the creator of Perl, patch, and run share his insights.&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;

&lt;tr&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;I also discovered Larry&amp;rsquo;s First Law of Language Redesign: Everyone wants the colon.&lt;/p&gt;

&lt;p&gt;That was the Ugly part. The Bad part was that I was supposed to take these RFCs and produce a coherent design in two weeks. I starting out thinking I could just classify the RFCs into the good, bad, and ugly categories, but somehow most of them ended up in the ugly category, because the good ones typically had something wrong with them, and the even the bad ones typically indicated a problem that could use some thought, even if the solution was totally bogus.&lt;/p&gt;

&lt;p&gt;It is now five months later, and I&amp;rsquo;ve been mulling over coherence the whole time, for some definition of mulling. Many of you know what happens when the size of your Perl process exceeds the size of your physical memory—you start thrashing. Well, that&amp;rsquo;s basically what happened to me. I couldn&amp;rsquo;t get enough of the problem into my head at once to make good progress, and I&amp;rsquo;m not actually very good at subdividing problems. My forte is synthesis, not analysis. It didn&amp;rsquo;t help that I had a number of distractions in my life, some of them self-inflicted, and some of them not. I won&amp;rsquo;t go into all that. Save it for my unauthorized autobiography.&lt;/p&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;
&lt;p&gt;&lt;a href=&#34;http://www.oreilly.com/catalog/pperl3/&#34; class=&#34;tiny&#34;&gt;&lt;strong&gt;Programming Perl, 3rd Edition&lt;/strong&gt;&lt;/a&gt;&lt;br /&gt;
Larry Wall, Tom Christiansen &amp;amp; Jon Orwant&lt;br /&gt;
3rd Edition July 2000&lt;br /&gt;
0-596-00027-8, Order Number: 0278&lt;br /&gt;
1092 pages, $49.95&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;But now we come to the Good part. (I hope.) After thinking lots and lots about many of the individual RFCs, and not knowing how to start thinking about them as a whole, it occurred to me (finally!) that the proper order to think about things was, more or less, the order of the chapters in the Camel Book. That is, the Camel Book&amp;rsquo;s order is designed to minimize forward references in the explanation of Perl, so considering Perl 6 in roughly the same order will tend to reduce the number of things that I have to decide before I&amp;rsquo;ve decided them.&lt;/p&gt;

&lt;p&gt;So I&amp;rsquo;ve merrily classified all the RFCs by chapter number, and they look much more manageable now. (I also restructured my email so that I can look at a slice of all the messages that ever talked about a particular RFC, regardless of which mailing list the message was on. That&amp;rsquo;s also a big help.) I intend to produce one Apocalypse for each Chapter, so Apocalypse 1 corresponds to Chapter 1: An Overview of Perl. (Of course, in the book, the Overview is more like a small tutorial, not really a complete analysis of the philosophical underpinnings of Perl. Nevertheless, it was a convenient place to classify those RFCs that talk about Perl 6 on that level.)&lt;/p&gt;

&lt;p&gt;So today I&amp;rsquo;m talking about the following RFCs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RFC  PSA  Title
    ---  ---  -----
     16  bdb  Keep default Perl free of constraints such as warnings and
strict.
     26  ccb  Named operators versus functions
     28  acc  Perl should stay Perl.
     73  adb  All Perl core functions should return objects
    141  abr  This Is The Last Major Revision
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The PSA rating stands for ``Problem, Solution, Acceptance&amp;rdquo;. The problem and solution are graded on an a-f scale, and very often you&amp;rsquo;ll find I grade the problem higher than the solution. The acceptance rating is one of&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    a  Accepted wholeheartedly
    b  Accepted with a few &amp;quot;buts&amp;quot;
    c  Accepted with some major caveats
    r  Rejected
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I might at some point add a ``d&amp;rdquo; for Deferred, if I really think it&amp;rsquo;s too soon to decide something.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-141-html-id-rfc141-rfc-141-this-is-the-last-major-revision-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/141.html&#34; id=&#34;rfc141&#34;&gt;RFC 141: This Is The Last Major Revision&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I was initially inclined to accept this RFC, but decided to reject it on theological grounds. In apocalyptic literature, 7 is the number representing perfection, while 6 is the number representing imperfection. In fact, we probably wouldn&amp;rsquo;t end up converging on a version number of &lt;code&gt;2*PI&lt;/code&gt; as the RFC suggests, but rather on &lt;code&gt;6.6.6&lt;/code&gt;, which would be rather unfortunate.&lt;/p&gt;

&lt;p&gt;So Perl 7 will be the last major revision. In fact, Perl 7 will be so perfect, it will need no revision at all. Perl 6 is merely the prototype for Perl 7. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Actually, I agree with the underlying sentiment of the RFC—I only rejected it for the entertainment value. I want Perl to be a language that can continue to evolve to better fit the problems people want to solve with it. To that end, I have several design goals that will tend to be obscured if you just peruse the RFCs.&lt;/p&gt;

&lt;p&gt;First, Perl will support multiple syntaxes that map onto a single semantic model. Second, that single semantic model will in turn map to multiple platforms.&lt;/p&gt;

&lt;p&gt;Multiple syntaxes sound like an evil thing, but they&amp;rsquo;re really necessary for the evolution of the language. To some extent we already have a multi-syntax model in Perl 5; every time you use a pragma or module, you are warping the language you&amp;rsquo;re using. As long as it&amp;rsquo;s clear from the declarations at the top of the module which version of the language you&amp;rsquo;re using, this causes little problem.&lt;/p&gt;

&lt;p&gt;A particularly strong example of how support of multiple syntaxes will allow continued evolution is the migration from Perl 5 to Perl 6 itself. See the discussion of RFC 16 below.&lt;/p&gt;

&lt;p&gt;Multiple backends are a necessity of the world we live in today. Perl 6 must not be limited to running only on platforms that can be programmed in C. It must be able to run in other kinds of virtual machines, such as those supported by Java and C#.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-28-html-id-rfc28-rfc-28-perl-should-stay-perl-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/28.html&#34; id=&#34;rfc28&#34;&gt;RFC 28: Perl should stay Perl.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;It is my fond hope that those who are fond of Perl 5 will be fonder still of Perl 6. That being said, it&amp;rsquo;s also my hope that Perl will continue trying to be all things to all people, because that&amp;rsquo;s part of Perl too.&lt;/p&gt;

&lt;p&gt;While I accept the RFC in principle (that is, I don&amp;rsquo;t intend to go raving mad), I have some major caveats with it, because I think it is needlessly fearful that any of several programming paradigms will ``take over&amp;rdquo; the design. This is not going to happen. Part of what makes Perl Perl is that it is intentionally multi-paradigmatic. You might say that Perl allows you to be paradigmatic without being ``paradogmatic&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;The essence of Perl is really context sensitivity, not just to syntactic context, but also to semantic, pragmatic, and cultural context. This overall philosophy is not going to change in Perl 6, although specific context sensitivities may come and go. Some of the current context sensitivities actually prevent us from doing a better job of it in other areas. By intentionally breaking a few things, we can make Perl understand what we mean even better than it does now.&lt;/p&gt;

&lt;p&gt;As a specific example, there are various ways things could improve if we muster the courage to break the ``weird&amp;rdquo; relationship between &lt;code&gt;@foo&lt;/code&gt; and &lt;code&gt;$foo[]&lt;/code&gt;. True, we&amp;rsquo;d lose the current slice notation (it can be replaced with something better, I expect). But by consistently treating &lt;code&gt;@foo&lt;/code&gt; as an utterance that in scalar context returns an array reference, we can make subscripts always &lt;em&gt;take&lt;/em&gt; an array reference, which among other things fixes the botch that in Perl 5 requires us to distinguish &lt;code&gt;$foo[]&lt;/code&gt; from &lt;code&gt;$foo-&amp;gt;[]&lt;/code&gt;. There will be more discussion of this in Apocalypse 2, when we&amp;rsquo;ll dissect ideas like RFC 9: Highlander Variable Types.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-16-html-id-rfc16-rfc-16-keep-default-perl-free-of-constraints-such-as-warnings-and-strict-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/16.html&#34; id=&#34;rfc16&#34;&gt;RFC 16: Keep default Perl free of constraints such as warnings and strict.&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I am of two minds about this debate—there are good arguments for both sides. And if you read through the discussions, all those arguments were forcefully made, repeatedly. The specific discussion centered around the issue of strictness, of course, but the title of the RFC claims a more general philosophical position, and so it ended up in this Apocalypse.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll talk about strictness and warnings in a moment, and I&amp;rsquo;ll also talk about constraints in general, but I&amp;rsquo;d like to take a detour through some more esoteric design issues first. To my mind, this RFC (and the ones it is reacting against), are examples of why some language designer like me has to be the one to judge them, because they&amp;rsquo;re all right, and they&amp;rsquo;re all wrong, simultaneously. Many of the RFCs stake out polar positions and defend them ably, but fail to point out possible areas of compromise. To be sure, it is right for an RFC to focus in on a particular area and not try to do everything. But because all these RFCs are written with (mostly) the design of Perl 5 in mind, they cannot synthesize compromise even where the design of Perl 6 will make it mandatory.&lt;/p&gt;

&lt;p&gt;To me, one of the overriding issues is whether it&amp;rsquo;s possible to translate Perl 5 code into Perl 6 code. One particular place of concern is in the many one-liners embedded in shell scripts here and there. There&amp;rsquo;s no really good way to translate those invocations, so requiring a new command line switch to set ``no strict&amp;rdquo; is not going to fly.&lt;/p&gt;

&lt;p&gt;A closely related question is how Perl is going to recognize when it has accidentally been fed Perl 5 code rather than Perl 6 code. It would be rather bad to suddenly give working code a brand new set of semantics. The answer, I believe, is that it has to be impossible by definition to accidentally feed Perl 5 code to Perl 6. That is, Perl 6 must assume it is being fed Perl 5 code until it knows otherwise. And that implies that we must have some declaration that unambiguously declares the code to be Perl 6.&lt;/p&gt;

&lt;p&gt;Now, there are right ways to do this, and wrong ways. I was peeved by the approach taken by DEC when they upgraded BASIC/PLUS to handle long variable names. Their solution was to require every program using long variable names to use the command &lt;code&gt;EXTEND&lt;/code&gt; at the top. So henceforth and forevermore, every BASIC/PLUS program had &lt;code&gt;EXTEND&lt;/code&gt; at the top of it. I don&amp;rsquo;t know whether to call it Bad or Ugly, but it certainly wasn&amp;rsquo;t Good.&lt;/p&gt;

&lt;p&gt;A better approach is to modify something that would have to be there anyway. If you go out to CPAN and look at every single module out there, what do you see at the top? Answer: a ``&lt;code&gt;package&lt;/code&gt;&amp;rdquo; declaration. So we break that.&lt;/p&gt;

&lt;p&gt;I hereby declare that a &lt;code&gt;package&lt;/code&gt; declaration at the front of a file unambiguously indicates you are parsing Perl 5 code. If you want to write a Perl 6 module or class, it&amp;rsquo;ll start with the keyword &lt;code&gt;module&lt;/code&gt; or &lt;code&gt;class&lt;/code&gt;. I don&amp;rsquo;t know yet what the exact syntax of a module or a class declaration will be, but one thing I do know is that it&amp;rsquo;ll set the current global namespace much like a &lt;code&gt;package&lt;/code&gt; declaration does.&lt;/p&gt;

&lt;p&gt;Now with one fell swoop, much of the problem of programming in the large can be dealt with simply by making modules and classes default to strict, with warnings. But note that the default in the main program (and in one liners) is Perl 5, which is non-strict by definition. We still have to figure out how Perl 6 main programs should distinguish themselves from Perl 5 (with a ``&lt;code&gt;use 6.0&lt;/code&gt;&amp;rdquo; maybe?), and whether Perl 6 main programs should default to strict or not (I think not), but you can already see that a course instructor could threaten to flunk anyone who doesn&amp;rsquo;t put ``&lt;code&gt;module Main&lt;/code&gt;&amp;rdquo; at the front each program, and never actually tell their pupils that they want that because it turns on strictures and warnings.&lt;/p&gt;

&lt;p&gt;Other approaches are possible, but that leads us to a deeper issue, which is the issue of project policy and site policy. People are always hankering for various files to be automatically read in from various locations, and I&amp;rsquo;ve always steadfastly resisted that because it makes scripts implicitly non-portable. However, explicit non-portability is okay, so there&amp;rsquo;s no reason our hypothetical class instructor could not insist that programs start with a ``&lt;code&gt;use Policy;&lt;/code&gt;&amp;rdquo; or some such.&lt;/p&gt;

&lt;p&gt;But now again we see how this leads to an even deeper language design issue. The real problem is that it&amp;rsquo;s difficult to write such a Policy module in Perl 5, because it&amp;rsquo;s really not a module but a meta-module. It wants to do ``&lt;code&gt;use strict&lt;/code&gt;&amp;rdquo; and ``&lt;code&gt;use warnings&lt;/code&gt;&amp;rdquo; on behalf of the student, but it cannot do so. Therefore one thing we must implement in Perl 6 is the ability to write meta-use statements that look like ordinary use statements but turn around and declare other things on behalf of the user, for the good of the user, or of the project, or of the site. (Whatever. I&amp;rsquo;m not a policy wonk.)&lt;/p&gt;

&lt;p&gt;So whether I agree with this RFC really depends on what it means by ``default&amp;rdquo;. And like Humpty Dumpty, I&amp;rsquo;ll just make it mean whatever I think is most convenient. That&amp;rsquo;s context sensitivity at work.&lt;/p&gt;

&lt;p&gt;I also happen to agree with this RFC because it&amp;rsquo;s my philosophical position that morality works best when chosen, not when mandated. Nevertheless, there are times when morality should be strongly suggested, and I think modules and classes are a good place for that.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-73-html-id-rfc73-rfc-73-all-perl-core-functions-should-return-objects-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/73.html&#34; id=&#34;rfc73&#34;&gt;RFC 73: All Perl core functions should return objects&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;m not sure this belongs in the overview, but here it is nonetheless. In principle, I agree with the RFC. Of course, if all Perl variables are really objects underneath, this RFC is trivially true. But the real question is how interesting of an object you can return for a given level of performance. Perl 5&amp;rsquo;s objects are relatively heavyweight, and if all of Perl 6&amp;rsquo;s objects are as heavy, things might bog down.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m thinking that the solution is better abstract type support for data values that happen to be represented internally by C &lt;code&gt;struct&lt;/code&gt;s. We get bogged down when we try to translate a C &lt;code&gt;struct&lt;/code&gt; such a &lt;code&gt;struct tm&lt;/code&gt; into an actual hash value. On the other hand, it&amp;rsquo;s rather efficient to translate a &lt;code&gt;struct tm&lt;/code&gt; to a &lt;code&gt;struct tm&lt;/code&gt;, since it&amp;rsquo;s a no-op. We can make such a &lt;code&gt;struct&lt;/code&gt; look like a Perl object, and access it efficiently with attribute methods as if it were a ``real&amp;rdquo; object. And the typology will (hopefully) mostly only impose an abstract overhead. The biggest overhead will likely be memory management of a &lt;code&gt;struct&lt;/code&gt; over an &lt;code&gt;int&lt;/code&gt; (say), and that overhead could go away much of the time with some amount of contextually aware optimization.&lt;/p&gt;

&lt;p&gt;In any event, I just want to point out that nobody should panic when we talk about making things return objects that didn&amp;rsquo;t used to return them. Remember that any object can define its &lt;code&gt;stringify&lt;/code&gt; and &lt;code&gt;numify&lt;/code&gt; overloadings to do whatever the class likes, so old code that looks like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print scalar localtime;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;can continue to run unchanged, even though &lt;code&gt;localtime&lt;/code&gt; might be returning an object in scalar context.&lt;/p&gt;

&lt;h3 id=&#34;a-href-http-dev-perl-org-rfc-26-html-id-rfc26-rfc-26-named-operators-versus-functions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/26.html&#34; id=&#34;rfc26&#34;&gt;RFC 26: Named operators versus functions&lt;/a&gt;&lt;/h3&gt;

&lt;p&gt;Here&amp;rsquo;s another RFC that&amp;rsquo;s here because I couldn&amp;rsquo;t think of a better place for it.&lt;/p&gt;

&lt;p&gt;I find this RFC somewhat confusing because the abstract seems to suggest something more radical than the description describes. If you ignore the abstract, I pretty much agree with it. It&amp;rsquo;s already the case in Perl 5 that we distinguish operators from functions primarily by how they are called, not by how they are defined. One place where the RFC could be clarified is that Perl 5 distinguishes two classes of named operators: named unary operators vs list operators. They are distinguished because they have different precedence. We&amp;rsquo;ll discuss precedence reform under Apocalypse 3, but I doubt we&amp;rsquo;ll combine the two kinds of named operators. (As a teaser, I do see ways of simplifying Perl&amp;rsquo;s precedence table from 24 levels down to 18 levels, albeit with some damage to C compatibility in the less frequently used ops. More on that later.)&lt;/p&gt;

&lt;hr /&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Perl 6 Apocalypse&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;The rest of the &amp;quot;Apocalypse&amp;quot; series can be found &lt;a href=&#34;http://localhost:1313/authors/larry-wall&#34;&gt;here&lt;/a&gt;, as well as other articles by Larry Wall.&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Do you begin to see why my self-appointed job here is much larger than just voting RFCs up or down? There are many big issues to face that simply aren&amp;rsquo;t covered by the RFCs. We have to decide how much of our culture is just baggage to be thrown overboard, and how much of it is who we are. We have to smooth out the migration from Perl 5 to Perl 6 to prevent people from using that as an excuse not to adopt Perl 6. And we have to stare at all those deep issues until we see through them down to the underlying deeper issues, and the issues below that. And then in our depths of understanding, we have to keep Perl simple enough for anyone to pick up and start using to get their job done right now.&lt;/p&gt;

&lt;p&gt;Stay tuned for Apocalypse 2, wherein we will attempt to vary our variables, question our quotes, recontextualize our contexts, and in general set the lexical stage for everything that follows.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>State of the Onion 2000</title>
      <link>http://localhost:1313/pub/2000/10/23/soto2000.html/</link>
      <pubDate>Tue, 24 Oct 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/10/23/soto2000.html/</guid>
      <description>

&lt;p&gt;Today, I&amp;rsquo;ll need all of the support I can get. I&amp;rsquo;m running an experiment today in sleep deprivation. Actually, I&amp;rsquo;ve been running the experiment in sleep deprivation for the past six months or so. If what I say today comes out like puddle mush, well, you can just assume that I used up all my pitiful supply of good writing for that little book some of you have been carrying around.&lt;/p&gt;

&lt;p&gt;I decided to talk about music this year because I talked about chemistry last year. The two are naturally associated in my brain for some reason. Of course, all music can be viewed as better living through chemistry - brain chemistry that is. Here, have some neurotransmitters. [Plays music] Feel happier? This talk will mostly be auditory, but for you people who are visually oriented I have a sop. I have some new tokens that we&amp;rsquo;ll be adding to Perl. Actually, these are some of the Unicode characters that are in the process of being approved up in the surigate area, but, you know, UPSA can handle that. No, I can&amp;rsquo;t wait until I can overload some of these as operators. I&amp;rsquo;m not entirely sure what &amp;ldquo;dollar A trill dollar B&amp;rdquo; would mean, but it will do something to your neurotransmitters.&lt;/p&gt;

&lt;p&gt;But neurotransmitters aside, chemistry and music are also associated in my mind because, although I eventually graduated in computers and linguistics for my first two years in college, I was pursuing a double major in chemistry and music. Kind of the story of my life that I&amp;rsquo;ve always been interested in too many things. Jack of all trades and master of maybe one, I don&amp;rsquo;t know. Anyway, I&amp;rsquo;ve uttered that phrase chemistry and music so often that it&amp;rsquo;s almost a Pavlovian response. &amp;ldquo;Hey Larry, you talked about chemistry last year. What are you going to talk about this year?&amp;rdquo; [Sound of bell] Slobber, slobber, slobber. I&amp;rsquo;ll talk about music.&lt;/p&gt;

&lt;p&gt;It wasn&amp;rsquo;t until three days ago, though, that I actually sat down and asked my left brain, &amp;ldquo;Why do you want to talk about music this year?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Dah, I don&amp;rsquo;t know. Ask my right brain.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;I am your right brain, stupid.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;I think part of the answer is that I worry about how Perl culture is going to grow up. If any of you have kids, you know that kids are complex and they get more complex as they get older. Fortunately, there&amp;rsquo;s only so much complexity that any one kid can hold and either they eventually go insane or, if you&amp;rsquo;re really lucky, they go sane. Even so, understanding any individual completely is impossible. The Perl culture is composed of many people and so the complexity of Perl culture can grow without bounds. No one person can understand Perl culture completely. If the complexity of Perl culture is going to continue to grow beyond the ability of any one person to fathom, even me, how can we continue to think constructively about it? I believe that we must learn to apply constructive analogies from other systems that are too complicated to understand completely. On the one hand, we can pull ideas from those scientists that have had to deal with overwhelming complexity, such as chemistry, biology, neurophysiology and so on. On the other hand, the more humanistic pursuits have always been overwhelmed by complexity, whether you&amp;rsquo;re talking about sociology or political science. You can study literature all your life and not even read everything you&amp;rsquo;re supposed to read, let alone what you want to read.&lt;/p&gt;

&lt;p&gt;Music is the same way. Many of us know thousands of songs or musical pieces, but nobody can know them all. Even if you could somehow combine all the songs that are currently playing somewhere in the world, it would just come out as pink noise. Terribly musical. And that&amp;rsquo;s exactly how your brain feels if you&amp;rsquo;ve read too many Perl mailing lists all at once. Only God can hear all the songs that are being played simultaneously and only God can read all the simultaneous mailing lists, newsgroups and Web sites of the world. Pretty soon, only God will be able to understand the CPAN. As humans, we have to simplify. In fact, we must oversimplify. We all specialize. We can focus in one style of music or on a particular piece of music or on a particular instrument. We can focus on rhythm or harmony or melody. We can focus on any of the ways that music affects our moods, whether tied directly to words or subtly as background music in a movie or background music in an elevator. We can focus on any of who, what, where, why, when or how. On a good day, we can focus on several things. But, we can never focus on all of them. So for the rest of this talk, I&amp;rsquo;d like to oversimplify Perl culture by looking at it through the lens of music culture.&lt;/p&gt;

&lt;p&gt;Now the problem with music culture is, of course, that although it makes a nice analogy, it&amp;rsquo;s also too complicated to talk about or even think about. So I brought along a few props. You can think of them as extension modules. Extension modules come in all shapes and sizes. Of course, you can program without extension modules. Those of you who have evolved far enough to have opposable thumbs have a built-in percussion instrument. [Snapping fingers] OK, that&amp;rsquo;s a snap, of course. With a little work, you can develop a crackle and a pop as well. To do the crackle, you first learn to snap twice with each hand and then you combine them in sequence. OK, that&amp;rsquo;s your crackle. To do a pop, you just make a little resonant cavity with your hand and you go [popping sounds], something like that. And then you get, you know, [sounds of snapping and popping combined], things like that.&lt;/p&gt;

&lt;p&gt;Long, long ago at a campfire far away, somebody discovered that pigs have spare ribs. At least they&amp;rsquo;re spare after all the meat is gone. Well, at least the pig doesn&amp;rsquo;t need them anymore. Now, if you work these just right, you can get a kind of a triple rhythm. You know, they say it&amp;rsquo;s all in the wrist. [Sounds of triple rhythm] Well, I&amp;rsquo;m going to have to bone up on that. [Drum &amp;amp; cymbal] Here&amp;rsquo;s a more intuitive interface. These are called claves. At least these would be called claves if they were from Spain, but they&amp;rsquo;re not. They&amp;rsquo;re from Papua-New Guinea, so I have no idea what they&amp;rsquo;re called there. I&amp;rsquo;ve asked various people from Papua-New Guinea what they&amp;rsquo;re called and they have no idea either. They&amp;rsquo;re probably called about 750 different things, since that&amp;rsquo;s about how many languages there are in New Guinea. Every time you go over a hill the next tribe speaks an entirely different language. It&amp;rsquo;s like being in your typical computer science department where every professor wants you to learn their favorite computer language which is different from the other 750 favorite computer languages of all the other professors. I suppose you could think of these as opposable sticks, though, in the history of our species, sticks have usually been opposed to crania.&lt;/p&gt;

&lt;p&gt;Eventually our ancestors got tired of grilled spare ribs so they figured out how to boil pigs. Not long after that, they discovered soup. And not long after that, they invented the spoon. Technology was developing really fast back then. Anyway, shortly after they invented the spoon, they invented two spoons because that way they didn&amp;rsquo;t have to share. [Sounds of two spoons] Now, this module is actually rather awkward to use, kind of like a Perl 4 module. That&amp;rsquo;s the same sort of, well, you know, I&amp;rsquo;ve got a better thing. Here&amp;rsquo;s the Perl 5 version of the same module. [Sounds] OK, I am going to move this over. We have the technology. [Laughter] We don&amp;rsquo;t need the technology. [Laughter] OK. Now we&amp;rsquo;re missing the technology. OK.&lt;/p&gt;

&lt;p&gt;OK, back to our regularly scheduled program. This is the same sort of noise you get when two people butt heads against each other in Perl 5 quarters, you know, bonk, bonk. That&amp;rsquo;s what oppositional behavior sounds like. The entire field of percussion is based on oppositional behavior - two objects trying to occupy the same space at the same time. So this is definitely an object-oriented module. You notice the relationship between the two spoons has been encapsulated so that the user no longer has to specify it explicitly. Actually, this is the second version of this module. Unfortunately, one of my kids broke the encapsulation on the first version. But, in fact, all percussion instruments are object oriented. After all, they indicate the rhythm, right? And rhythm is object oriented. You look like you don&amp;rsquo;t believe me. Rhythm really is object oriented. Surely you&amp;rsquo;ve all heard of the rhythm method. [Laughter. Drums and cymbal.] Furthermore, you&amp;rsquo;ll note that people who use the rhythm method are frequently members of the Lamaze class. [Laughter. Drums and cymbal.] Personally, I&amp;rsquo;ve been through three Lamaze classes, so has my wife. Now, many of you know that we have four kids. For our fourth kid they told us not to come back, since it was obvious we already knew all there was to know about heavy breathing. Actually, the Lamaze techniques are an interesting application of rhythm for the purpose of distracting the participants with pantings of various sorts. &amp;ldquo;OK, honey, now do sixes, twos, threes, sevens, and fives, not necessarily in that order.&amp;rdquo; &amp;ldquo;Nurse, take my husband, please.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;In the abstract, rhythm is about even programming, kind of like a Geiger counter. Here&amp;rsquo;s our current background radiation. [Sounds.] Here&amp;rsquo;s if you sit too close to the TV in your hotel room. [Sounds.] Those of you who know Morse code probably know what that said. I don&amp;rsquo;t. If you don&amp;rsquo;t care to sit too close to your TV, just move to Boulder or stay here and wait for the Diablo Canyon reactor to melt down. Random events aren&amp;rsquo;t really all that interesting, however. It&amp;rsquo;s get more interesting when you program which events happen when. [Sounds] You can do all sorts of, don&amp;rsquo;t do that - [Sounds.] Enough of that. Other than little games like that, there&amp;rsquo;s really only one sound that spoons can make. The conga drums, by contract, provide a richer interface. You can think of the interface as parameterized in several different dimensions, most of which are infinitely variable, but for all its richness, it&amp;rsquo;s still an event-driven module. Perl also has an event module and it&amp;rsquo;s maybe a little more portable than these, but it could use a little more work on that. But you can do some various interesting event loops on these things. [Conga drums] Now as a linguist trained in Tagnue, I tend to think of these things in terms of fields, waves and particles. Harmony is a field while melody is a wave. I think of rhythm as particles where the events are the points at which things happen. Actually, it&amp;rsquo;s the events themselves that are particles, but rhythm is a higher level of abstraction, sort of connecting the dots in our head. So event questions start with &amp;ldquo;when?&amp;rdquo; while rhythm questions tend to start with &amp;ldquo;how often?&amp;rdquo; like, &amp;ldquo;How often should we have a Perl conference?&amp;rdquo; [Rhythm] &amp;ldquo;How often should we have a Perl Whirl cruise?&amp;rdquo; [Faster Rhythm - Laughter] Actually, it&amp;rsquo;s like this. [Rhythm] It&amp;rsquo;s a three against two rhythm, a sort of hemiola. You know, the Perl Conference is once a year, while the Perl cruise is scheduled to be once every 18 months, which gives you three beats in one hand to two beats in the other.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s three beats against four. [Rhythm] Here&amp;rsquo;s three against five. [Rhythm.] If you want to figure these out for yourself, it&amp;rsquo;s really just a bit of math. Multiply the two numbers to find out how many subdivisions you need. With three against four, you need 12 subdivisions and with three against five, 15, and you just chart it out.&lt;/p&gt;

&lt;p&gt;Now, in reality the rhythm of Perl culture is more of a fractile with many smaller interactions for all of the larger ones. You know, here&amp;rsquo;s the Perl conference. [Rhythm] All sorts of stuff going on in the interest of these. But, speaking of fractiles, I noticed an interesting thing about the rhythm of releases. As the size of the Perl core and libraries gets bigger, it takes longer to rev a major release, so it naturally gets slower. Perl 1, Perl 2, Perl 3, Perl 4, Perl 5. [Sound of beat on drum gets slower] Then we start getting subreleases and then they get slower. Then we get sub-sub versions, and they get slower and slower. Eventually the subversions are taking as long as the original Perl 1 - Perl 2 thing, but that&amp;rsquo;s because they are actually accomplishing just as much. Anyway, I just thought that was interesting. In compensation - up until now, we&amp;rsquo;ve seen instruments that specialize in rhythm, which is a particle effect. In contrast, there are other instruments that specialize in harmony and melody. Here is an auto harp. You know, it&amp;rsquo;s always on the wrong side. [Harp sounds] Well, you push buttons and you get harmony. It&amp;rsquo;s almost a pure harmony instrument with a little bit of rhythm on the strum a little.&lt;/p&gt;

&lt;p&gt;But harmony is an abstraction, a construct we manufacture in our own minds. Unlike rhythm, harmony is spread out in the pitch dimension and behaves as a field. By that, I mean it seems to fill space in a way that neither rhythm nor melody does. You can play rhythms and melodies simultaneously and they tend to keep their individual identities. But if you tried playing two chords simultaneously, you either get a different chord from either of them or you just get mush. Interestingly, you can&amp;rsquo;t actually add two chords together on an auto harp because an auto harp builds harmonies by subtraction not by addition. You know, it&amp;rsquo;s like trying to mix paints when you ought to be mixing light, and the more you try to mix the less you end up with. So we [Harp sound] subtract the most to get what we want and we subtract - we get fewer and fewer notes. Eventually we get no notes and that&amp;rsquo;s not the way to make harmony. To actually mix harmony you need an additive device like a keyboard. [Sound of electronic keyboard] Something else again entirely.&lt;/p&gt;

&lt;p&gt;We talk a lot about harmony in Perl culture and actually we yell at each other a lot about harmony and Perl culture, but it&amp;rsquo;s very harmonious yelling. Remember that harmony tends to monopolize your mental space, but that&amp;rsquo;s kind of an illusion. It&amp;rsquo;s easy when you hear two people arguing in a public forum to think that the entire whole forum is bogus, but if you look carefully there&amp;rsquo;s usually still a background of nonfighting going on as well. Normally people fight all the time. It just seems that way when we try to fit too many notes into the same mental space. You don&amp;rsquo;t actually have to harmonize every note everywhere all at once. We have different locations. Different chords can happen in different places. Different pieces have different standards for dissonance and that&amp;rsquo;s fine. Maybe a Perl friend&amp;rsquo;s mailing list would be like Mozart and comp.lang.perl.misc is like Schoenburg mixed with John Cage with Metallica thrown in for good measure. Well, five quarters is slightly more civilized. It&amp;rsquo;s a bit like late Mahler where part of the time the music is atonal and tortured and the rest of the time the music is tonal but still tortured. Actually, I like Mahler an awful lot. He&amp;rsquo;s my favorite composer and this is no coincidence. Mahler once said he always tried to put the whole world into each of his symphonies. Know also that my favorite author is Tolkin, who also put an entire world into his work, so perhaps this is kind of natural that I try to hook up the entire world to Perl one way or another. Of course, you can&amp;rsquo;t have the whole world in one spot without accepting a certain amount of dissonance.&lt;/p&gt;

&lt;p&gt;But there&amp;rsquo;s another form of abstraction which we call melody. In some ways, it&amp;rsquo;s the most mysterious because, in fact, it really is object oriented and in a deep way. A melody is a sequence of notes that we perceive to have been played or performed by a single object, which we often call a voice even if it isn&amp;rsquo;t one. Object permanence is something we learn at a young age. That&amp;rsquo;s why we play peek-a-boo: to figure out that mommy didn&amp;rsquo;t actually disappear when she went behind the towel. Similarly, you can take temporally separate notes and creatively imagine that they came from the same instrument. How many of you have ever played the computer game The Seventh Guest? You may recognize this melody, which is permanently burned into my personal E-prom. And then you solve that particular puzzle. I hope I didn&amp;rsquo;t give anything away. That game intentionally makes it really hard to follow the melody since it treats the notes as discreet, but some instruments make it really easy to follow a melody by making the transitions continuous.&lt;/p&gt;

&lt;p&gt;Life is always interesting, isn&amp;rsquo;t it?&lt;/p&gt;

&lt;p&gt;OK. Wonder how you play one of these things. Actually, you need a double inflection point, a double inflection here, or a double curve and you find the inflection point in the middle, maybe. We&amp;rsquo;ll try for &amp;ldquo;Mary Had a Little Lamb.&amp;rdquo; [Plays something - laughter] Wow, learn something new everyday. Now, I don&amp;rsquo;t know who first came up with the idea of playing a saw. It&amp;rsquo;s not what you would call obvious. On the other hand, some things are so obvious that if one person didn&amp;rsquo;t invent it, the next person would. For example, whistling. [Whistles &amp;ldquo;We Wish You a Merry Christmas&amp;rdquo;] Another rather obvious invention I think is the bottle whistle. [Whistles in bottle] Perrier works really great for this. As W. C. Fields once said, &amp;ldquo;I&amp;rsquo;d rather have a bottle in front of me than a frontal lobotomy.&amp;rdquo; Actually, a bottle in front of you doesn&amp;rsquo;t have a lot to recommend it either. In particular, the melodies you can play with this module are rather monotonic, not to mention monotonous. Here&amp;rsquo;s &amp;ldquo;The William Tell Overture&amp;rdquo; on the bottle. [Plays bottle] Other wind instruments can at least vary the pitch parameter, but most wind instruments are by nature melodic in that they can only produce one single note at a time. There are exceptions, of course. Take the bagpipes, please. I don&amp;rsquo;t think the bagpipes are an obvious interface either. I don&amp;rsquo;t know whether playing your hands would be considered obvious or not. I don&amp;rsquo;t know why but you have to wet your whistle to do this. It doesn&amp;rsquo;t make sense to me. [Whistles hands] I discovered that one by accident myself. One day I was leaning on a table with my hands folded and I just happened to blow in my hands suddenly to warm or something. [Tries blowing] Can&amp;rsquo;t do it anymore, can I? [Tries blowing] Well, this is actually the hard way - with your fingers interlaced.&lt;/p&gt;

&lt;p&gt;Now, but this actually illustrates a very important musical technique. One that many of us have had to learn repeatedly. Oddly, this technique is called unlearning. It&amp;rsquo;s like back-tracking in real life. Sometimes you have make negative progress in order to go forward in the long run. For instance, when I started taking private lessons on the violin, I had to unlearn a year&amp;rsquo;s worth of bad habits I&amp;rsquo;d picked up in school. Now in the case of playing of my hands, I had to learn to hold my hands a different way if I wanted to have greater pitch range. So once I&amp;rsquo;d relearned how to play my hands, I could get almost an octave. That leaves out &amp;ldquo;The Star Spangled Banner,&amp;rdquo; but there&amp;rsquo;s lots of melodies that will fit into an octave. [Plays hands] I almost have that octave. Let me tune it up here a little bit. [Plays hands] Which is, of course, &amp;ldquo;How Much Is That Camel in the Window?&amp;rdquo; Of course, you can do much the same thing with an extension mechanism that&amp;rsquo;s official. Anybody want to play the box? [Plays something] Easy does it, Larry. [Plays something] One and three. Thank you. This is my wife&amp;rsquo;s. [Plays.] OK. Obviously, that&amp;rsquo;s my main instrument. And certainly one of the most obvious wind instruments is your voice, at least we certainly produce a lot of wind with our voice, but - no, I&amp;rsquo;m not going to sing anything operatic for you and, although I&amp;rsquo;m preaching to the choir, I&amp;rsquo;m not going to make you sing either. That should play something on my computer. We have ways to make you talk. [Computer sings &amp;ldquo;Allelulia&amp;rdquo;] Hey, a percussion instrument. Yeah, I know. I&amp;rsquo;m a sound engineer at my church, I&amp;rsquo;m allowed to do that.&lt;/p&gt;

&lt;p&gt;Anyway, but you&amp;rsquo;ll recall that melody is an abstraction of object permanence. As I mentioned earlier, these instruments call such an object a voice whether it&amp;rsquo;s a really a human voice or any of the other instruments, but the really interesting thing to me is the relationship of melody to harmony and it has to do with what we call voice leading. Here&amp;rsquo;s a guitar. You can play the guitar in many styles, but the most notable feature of the guitar is how much it&amp;rsquo;s used for harmony rather than melody regardless of the style. I don&amp;rsquo;t want the pick yet. [Plays guitar] You know, that&amp;rsquo;s a little more Spanish. Here&amp;rsquo;s something else. [Plays guitar] Something like that. [Applause] Of course, if you&amp;rsquo;re a classical guitarist, you&amp;rsquo;d do a lot of melody, too, but the very basis of harmony is all the little melodies going on in the middle of the chords and you can actually hear the little waves in there if you listen. You can hear a chord change. [Plays] But you hear things like this happening in the middle and things like that - little voices - and so the harmony is actually, in a reductionist fashion, it&amp;rsquo;s just a bunch of little harmonies, but holistically, melodies. But, holistically, you don&amp;rsquo;t perceive it that way. It&amp;rsquo;s perceived as a field, you know, so when you hear chords, you don&amp;rsquo;t actually hear the individual notes here, you somehow intuit the whole - whatever it is.&lt;/p&gt;

&lt;p&gt;You ever notice that music is sometimes hard to talk about? I never have any trouble talking about Perl. Anyway, the bottom note of a chord is kind of in a privileged position. It behaves more like a melody of its own, but it&amp;rsquo;s a funny kind of melody in that it&amp;rsquo;s perceived to drive the rhythm and the harmony. If you take the bottom four strings of a guitar and drop them an octave, you get one of these. [Shows something] Yeah. Got to get the slouch right here. Ready? [Plays something] Now, some of you will think that that&amp;rsquo;s &amp;ldquo;Mission Impossible,&amp;rdquo; but that&amp;rsquo;s actually &amp;ldquo;Man from Uncle,&amp;rdquo; which was my favorite show when I was young. Here&amp;rsquo;s &amp;ldquo;Mission Impossible.&amp;rdquo; [Plays] Recognize that? Bass guitar is really fun even if you&amp;rsquo;re not good at it. Sometimes I think I&amp;rsquo;m the bass guitarist of Perl culture. I play the strange melody and then a whole bunch of other people start playing these strange rhythms and harmonies around me, but now I&amp;rsquo;m going to go back to hitting things again. This is what is known as a hammer dulcimer. It actually belongs to my wife, whom I like because she lets me borrow her things. The one thing about this that is harder on other instruments, especially wind instruments, is it&amp;rsquo;s actually multithreaded. It&amp;rsquo;s the beginnings of multithreading. It has two separate threads of control, so - [Plays] What shall I play? OK. [Plays] Nope. [Plays &amp;ldquo;Oh Suzanna&amp;rdquo;] OK. [Applause] &amp;ldquo;It rained all night the day I left, the weather was dry. Got so hot I froze to death, Suzanna, don&amp;rsquo;t you cry.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Musicians delight in contradictions, but so do language designers. You have to be able to see both sides of every question when you design a language. It helps to have multiple-personality disorder. It also helps to have a multithreaded interface like the piano. [Plays &amp;ldquo;Oh Suzanna&amp;rdquo; on piano] You know, a piano is just a fancier interface for a dulcimer in a way. It still has hammers - a real piano does - that go out and strike the strings in another form of oppositional behavior, but it&amp;rsquo;s a percussion instrument, in other words, but it happens to have a pitch parameter as well. It also has a more developed multithreading model. It supports up to 10 threads in two groups of five. Advanced implementations can handle 20 threads, but that requires two CPUs. You know, I&amp;rsquo;m afraid the piano module must still be considered experimental.&lt;/p&gt;

&lt;p&gt;Still, the interface is somewhat user friendly. [Plays &amp;ldquo;Chopsticks&amp;rdquo; on piano] Etc. I don&amp;rsquo;t actually have time to talk about counterpoint, except to say that this simple tune illustrates two contrapuntle principles we see in the Perl community: contrary motion and parallel motion. Contrary motion is when you have two programmers, or that is melodies, going in opposite directions. [Plays] Parallel motion is when the programmers agree on how to get where they&amp;rsquo;re going. [Plays &amp;ldquo;Chopsticks&amp;rdquo;] Actually, I joked about it being experimental, but the piano interface is actually one of the most standard interfaces we have. Unfortunately, organs are not so standard. Once you get away from the keyboard itself, how you set one particular stop really depends on the kind of organ you have. In pipe organs, you might pull out one of the stops puller-outerers. On a Hammond organ, you might just adjust the draw bar. On this organ, I push D-35. [Plays organ] You got to love Bach. The next time someone says Perl is baroque, thank them for the compliment. [Plays organ]&lt;/p&gt;

&lt;p&gt;They say it&amp;rsquo;s easy to get a composer out of bed in the morning. All you have to do is go over to the piano - or the organ in this case - and play an unresolved chord and then they have to get out of bed and resolve the chord. [Laughter] It&amp;rsquo;s hard. I can&amp;rsquo;t stand it. [Plays] Now, I promised I&amp;rsquo;d bring my violin and, as you can see, I didn&amp;rsquo;t break my arm in Aikido, so I guess I&amp;rsquo;ll have to play it some. The violin is one of those traditional standard instruments. As I say, nobody ever got fired for buying a symphony orchestra. But, if you did get fired, your orchestra can play for you. [Plays violin] That&amp;rsquo;s very sad. There&amp;rsquo;s lots of happy music, too.&lt;/p&gt;

&lt;p&gt;But, a violin is actually two different instruments and I actually brought it here to illustrate polymorphism. People ask what&amp;rsquo;s the difference between a violin and a fiddle. There&amp;rsquo;s no difference really, it only depends on which class you call the method from. Here&amp;rsquo;s the fiddle interface. You just choke up on the bow a little bit here and a - [Plays fiddle] [Applause] Funny how people who claim to be tone deaf can nonetheless recognize various styles of music when they hear them. Our pattern-matching capabilities are usually much better than we admit. In fact, Perl&amp;rsquo;s design banks on that. That last little bit of music actually can stand on its own. [Plays] That&amp;rsquo;s usually known as &amp;ldquo;Shave and a Haircut, Two Bits,&amp;rdquo; so music also has its one-liners.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s another piece known as &amp;ldquo;The Mouse Trap Concerto.&amp;rdquo; [Plays one note] [Laughter and applause] Actually, I&amp;rsquo;ve played a lot of serious music on my violin. It was my privilege to spend six years in the Seattle Youth Symphony under the direction of Wilhelm Sokle. There wasn&amp;rsquo;t anything that we couldn&amp;rsquo;t play, but we just had to work at it a little longer than a professional orchestra would, which reminds me of Perl development sometimes. One thing I learned while playing in various orchestras is the importance of faking it. You have to be able to fake playing an instrument before you can really play it and I&amp;rsquo;m faking most of these instruments. My whole first year in the youth symphony I was petrified that I might get called upon during rehearsal to play a part that I wasn&amp;rsquo;t ready to play. Fortunately, I was never called upon. My second year I made a startling discovery. I just learned the music thoroughly and then I didn&amp;rsquo;t have to worry about whether anybody called on me to play it.&lt;/p&gt;

&lt;p&gt;How does this play out in Perl culture? Well, we have to be willing to let people fake it for a while. If Perl is getting their job done, then that&amp;rsquo;s fine, but we also have to find ways of encouraging people to upgrade their abilities when they&amp;rsquo;re ready for that step, and we don&amp;rsquo;t do that by beating them over the head. We do it by showing the positive benefits of learning Perl for real. You know, I probably could have actually been a professional violinist. Had I been only interested in music, I might have been, but then I wouldn&amp;rsquo;t be up here waving around a violin at you. But I&amp;rsquo;d also like to use this violin to illustrate reusability. [Plays portion of &amp;ldquo;William Tell Overture&amp;rdquo; on violin] Or something like that. Well, I don&amp;rsquo;t think William Tell would have minded the Lone Ranger using his music, but when I was growing up there were still cigarette commercials on TV and sometimes you heard, &amp;ldquo;Have a Lark, have a Lark, have a Lark, today.&amp;rdquo; Later on it was &amp;ldquo;Have a pizza, have a pizza, have a pizza roll.&amp;rdquo; I&amp;rsquo;m sure William Tell would just love to shoot a pizza roll off of someone&amp;rsquo;s head.&lt;/p&gt;

&lt;p&gt;Finally, I&amp;rsquo;d like to finally introduce officially my synthesizer here, Korg 5S, meet Perl hackers. Perl hackers meet Korg 5S. I&amp;rsquo;ve been pretending it&amp;rsquo;s a piano and an organ and any number of other things, but it&amp;rsquo;s really just a bunch of switches and oscillators and such. Like Perl, it can be viewed as a tool that got out of hand. Like Perl, it can be viewed as just another tool in the toolbox as well. I joke that the piano interface was experimental, but this interface really is experimental. The keyboard interface is pretty standard, it&amp;rsquo;s an awful lot of fun to use this thing in its current state, kind of like Perl. It does a pretty good job of emulating some other tools in the toolbox. For instance - [Plays on keyboard] - easier here than there, unless you&amp;rsquo;re my wife. She does this easier here too. Now I&amp;rsquo;m going to get in trouble. The thing that is really cool about this keyboard is that it can play various different styles of music, Tim Tody and all that. My favorite button is the one that locks in the different styles into the same tempo so that you can go from one style to another and see how the same tune sounds in different cultural contexts. For example, how would &amp;ldquo;Pachabel&amp;rsquo;s Canon&amp;rdquo; come out if it were played by Mick and Keith or by John, Paul, George, and Ringo, or by Elvis? Well, we can find out. [Plays] [Applause] Well, one could go on all day with that.&lt;/p&gt;

&lt;p&gt;One of the things we love about Perl is that it supports many different styles of programming. That&amp;rsquo;s something we never want to lose with Perl. There&amp;rsquo;s also just the intrinsic joy in making music that has nothing to do with whether we&amp;rsquo;re using the music for some other purpose. Likewise, there&amp;rsquo;s an intrinsic joy in programming in Perl that has nothing to do with the purpose we&amp;rsquo;re putting it to. That is also something we never want to lose. In fact, there are many features we want to conserve in Perl, but music is continually re-inventing itself and so is Perl culture. Most music is evolutionary, not revolutionary. People don&amp;rsquo;t usually riot over new music - Stravinsky&amp;rsquo;s &amp;ldquo;Rite of Spring&amp;rdquo; being the exception that proves the rule, but people don&amp;rsquo;t usually riot over new Perl modules either. But occasionally there does come a time when we have to think like revolutionaries. Someone has to throw the tea into the Boston Harbor. Someone has to decide that it was time to write the document starting out, &amp;ldquo;When in the course of human events it becomes necessary&amp;rdquo; etc., etc., but before that someone had to decide to alter the course of human events.&lt;/p&gt;

&lt;p&gt;Yesterday, a bunch of us radicals decided that it was time to alter the course of human events. Some of you may have heard rumors of this. So, today, I&amp;rsquo;d like to announce to the world that the effort to write Perl 6 has begun in earnest. [Applause] And I&amp;rsquo;d like to use the synthesizer to make an important point. If you manufacture something like this, you eventually come to a point where you say, &amp;ldquo;This is a really neat gismo, but we can do something better. Do we continue to make small improvements in the current design or do we redesign the interface to let us do what we would really do down the road? And, if we do a redesign, can we keep everything people like about the old design while getting rid of all the things people don&amp;rsquo;t like about the thing they have right now?&amp;rdquo; Well, that&amp;rsquo;s kind of the state Perl is in right now. We really, really like what we have. We like it a lot, but we can think of lots of ways we can do it better and the things we&amp;rsquo;d like to do better come in several categories.&lt;/p&gt;

&lt;p&gt;First, the language itself could use some revision. I&amp;rsquo;m allowed to admit that. There are many historical warts on Perl that wouldn&amp;rsquo;t have been there if I&amp;rsquo;d known what I was doing, but, hey, I was faking it back then. You didn&amp;rsquo;t know that, did you? I&amp;rsquo;m more of a competent language designer than I was 13 years ago and I have a lot more help these days, plus it&amp;rsquo;s time to steal all the good ideas we can from those other languages that developed in the last decade. One of the things I realized yesterday was that we&amp;rsquo;re actually in a much better position than when I designed Perl 5. Nowadays, we have code back-ins, such as B::B Parse, that can spit out the Perl code corresponding to the compiled syntax tree. If you think about that, it means that it would be relatively easy to make it spit out a closely related language, such as Perl 6.&lt;/p&gt;

&lt;p&gt;Perl has always been designed to evolve but now we actually have the capability to be evolving a little faster. This means that for the first time in history we have the opportunity to make some incompatible fixes to Perl while preserving a migration path for the current code. I really couldn&amp;rsquo;t do that when I designed Perl 5. We had to make almost everything upward compatible, or backward compatible, whichever one it is. But now it&amp;rsquo;s the first chance to make that sort of changes and, since it is the first chance, it probably is also the last chance, so I think we should. Of course, we are not interested in breaking things just to break things, but I&amp;rsquo;m sure you can think of things you might have done differently. Myself, I really wish I&amp;rsquo;d made the system call return &amp;ldquo;true&amp;rdquo; on success rather than &amp;ldquo;false.&amp;rdquo; I wish I&amp;rsquo;d made local time return the actual year and not the year minus 1900. I&amp;rsquo;d really love to throw out select file handle and there&amp;rsquo;s general consensus that type gloves may have outlived their usefulness, and a number of simple but potentially powerful features have already been put on the table for consideration. That&amp;rsquo;s not to say we&amp;rsquo;re going to do all of them. My overriding goal for the redesign of Perl&amp;rsquo;s language is that easy things should stay easy, hard things should get easier, and impossible things should get hard, as it were.&lt;/p&gt;

&lt;p&gt;Another place we&amp;rsquo;d like to do better is in the implementation of the language as opposed to the language itself. I think I did a pretty good job with the design of Perl 5 and making it extensible at the language level, but the internal APIs necessary to write extension modules could really use to be cleaned up. Some of you may have noticed that. We could scrap Excess for something better, and, of course, we want the chord to be smaller and faster, always. I&amp;rsquo;d like to run Perl on my Palm, but perhaps more importantly we could design the extension system so that installing a new version of Perl doesn&amp;rsquo;t break all your existing extension modules. We have many other ideas for improving the implementation as well and these will come filtering out, but neither language changes nor implementation changes will happen unless we also reinvent how we do things.&lt;/p&gt;

&lt;p&gt;So we&amp;rsquo;ve already started a redesign of Perl culture, trying to keep the good aspects and leaving behind the nonproductive aspects. We intend to abandon the Perl 5 porter&amp;rsquo;s model of development, which demonstrably leads to a lot of talk but little action. Instead we&amp;rsquo;ll break down the design of Perl 6 and the maintenance of Perl 5 into manageable tasks given to meaningful working groups with meaningful charters and meaningful goals. We have collectively resolved to make these working groups work, and where they do not work to work at making them work until they do work. We will continue to refine all aspects of our development model until every itch is scratched as efficiently as possible.&lt;/p&gt;

&lt;p&gt;We are really jazzed about this. It is our belief that if Perl culture is designed right, Perl will be able to evolve into the language we need 20 years from now. It&amp;rsquo;s also our belief that only a radical rethinking of both the Perl language and its implementation can energize the community in the long run. In the long run means 10 and 20 years down the road. Finally, it is our belief that Perl 5 will be better supported than it would be if we merely tried to guard what we already have. The best defense is a good offense. Now, this is not going to happen quickly. We expect to have alpha code a year from now, or some definition of alpha. We might even ship it, but we expect it to be well-designed alpha code.&lt;/p&gt;

&lt;p&gt;In the meantime, we are not abandoning Perl 5 anytime soon. We all like Perl 5 a lot. We all use it a lot. Many commercial interests will guarantee that Perl 5 continues to be well-maintained and stabilized for quite a few years to come, and we fully expect, given the history of Perl 4, that five years from now a lot of people will still be using Perl 5. We do expect the rate of new development in Perl 5 to taper off, of course, and that can be viewed as a feature, but no, open-source software specifically rejects the get-big-quick philosophy of the typical Web startup. Such rapid growth tends to fragment the culture and, in the long run, leads to ruin. Instead, we intend to proceed at the fastest speed at which we can efficiently propagate our cultural values to newcomers in our culture, but no faster. This is the healthy way forward and the only way to compete in a competitive space.&lt;/p&gt;

&lt;p&gt;We have to be better, not just get there faster. Part of being better is making sure the stragglers don&amp;rsquo;t get left behind. We are determined to do the right thing by everyone. To this we pledge our lives, our fortunes, and our sacred honor, as it were, what there is of it. Many more details of our plans will be coming out in the next few days and weeks, and we&amp;rsquo;ll tell you who has taken responsibility for what. We&amp;rsquo;ll set out a road map or chart if you&amp;rsquo;re into music of where we&amp;rsquo;d like to be when. Look at www.perl.org for more as time goes on. Things should be showing up there today even. But right now I would like to call each of you to play your part, whatever that part is. You, yourselves, are individual melodies. Your being here today may be an event that changes the course of your tune. Certainly your being here with everyone else who is here today makes a kind of harmony, a lost chord that will never be played exactly the same again. Together we perform a contrapuntal jazz improvisation that can only be recorded imperfectly. Music has always been an ephemeral art, and even with CDs and DVDs people still go to live concerts. So remember, you were here when a new thing was born.&lt;/p&gt;

&lt;p&gt;Every Perl conference is a cool event because Perl people are the best people in the world. In this age of mailing lists and Web pages, it&amp;rsquo;s really nice to get personally acquainted with all the folks that you&amp;rsquo;ve met on the Net. But this conference is not just about getting together with your buds. It&amp;rsquo;s also about finding new friends, forming new bands, creating cool new sounds, maybe landing a recording contract on the CPAN. Sometimes it&amp;rsquo;s about more than that. Today it&amp;rsquo;s about more than than. We&amp;rsquo;re really serious about reinventing everything that needs reinventing. The way I look at it, Perl 5 was a composition largely by a single composer - me. It&amp;rsquo;s a fine classical composition, but in essence it&amp;rsquo;s one person&amp;rsquo;s view of how to make music. If you work with Perl 5 you have to follow the score pretty closely. Perl 6 is going to be designed by the community. We&amp;rsquo;re going to be doing some jamming. I&amp;rsquo;ll still be exercising some artistic control over the language itself, but instead of playing off a score, I&amp;rsquo;m going to be playing off charts now and you&amp;rsquo;re going to be seeing a lot of people improvising melodies of their own and interweaving them creatively in ways that will make Perl 6 much better than Perl 5, just as Perl 5 was much better than Perl 4, and if you know anything about me, you know I take the promised land quite seriously. We&amp;rsquo;re all going to march in there someday. [Plays music.] I&amp;rsquo;m jazzed. [Applause.]&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Narrator:&lt;/strong&gt; John has very kindly offered to let Larry do a Q&amp;amp;A for the next 15 minutes on the grounds that there is not enough time to cover the full details of how to rebuild civilization after the Apocalypse. Larry would you be willing to do a Q&amp;amp;A?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Larry:&lt;/strong&gt; If you&amp;rsquo;ll help, I&amp;rsquo;d like to introduce our interim program manager for Perl 6. [Applause.] Now that we&amp;rsquo;ve got that out of the way.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Larry:&lt;/strong&gt; Is Perl 6 going to be in C++? Maybe. Chip has a lot of experience with thinking about Perl and C++ and we intend to use the lessons he&amp;rsquo;s learned one way or another.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; When do you expect the Perl 6 plan to appear and when can we start work on it?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Larry:&lt;/strong&gt; Well, it will come out in stages. We are, in cultural terms, we are starting working on it already, and over the next month or so you are going to see the chart, the road map, come out and my own personal goal - for some reason, they wanted me to take the position of language designer - of course, I&amp;rsquo;ll have a lot of help on that, but my goal for that part of it - I&amp;rsquo;m giving a talk at Linux World Expo in Atlanta in October and they wanted me to do a keynote there and I didn&amp;rsquo;t know what I was going to talk about. Well, now I do, and I&amp;rsquo;ll talk about the new Perl and where it&amp;rsquo;s going as a language. The language design is now going to be separate from the implementation design and we&amp;rsquo;ve got a number of other positions that we&amp;rsquo;ve named names for and you&amp;rsquo;ll see those if you look at the press release, but the schedule is not nailed down yet, but we&amp;rsquo;ll try to act a bit like pointy-haired bosses and do some of that scheduling.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Will Perl 6 have specs and then you could implement something that looks like this, or will it be kind of like now, where the system won&amp;rsquo;t work?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Larry:&lt;/strong&gt; Yeah. I don&amp;rsquo;t know how strict a spec it will be from the language design point of view. I&amp;rsquo;m not really big on that sort of spec and there is some value to using the reference implementation approach and what we currently have is a reference implementation will no second implementation, well, unless you count the JVM work, but, obviously there are benefits to having things justified well enough that you could implement another one even if you didn&amp;rsquo;t want to, so we&amp;rsquo;ll definitely be working in that direction and - do you have something? And there was something else I was going to say - what we particularly want to stress in terms of - is not perhaps so much the spec as developing our current regression test. Well, we call them regression tests, but they&amp;rsquo;re almost more acceptance tests, but, we developed our acceptance into real regression tests then you&amp;rsquo;d further develop the real regression tests into a validation test of what the language actually means and actually go out and explore all the nooks and crannies and say, &amp;ldquo;This is Perl, this is not Perl,&amp;rdquo; and then we actually have a machine-readable spec. And to me that&amp;rsquo;s actually a lot more important than what the verbiage on the human readable thing says.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Question&lt;/strong&gt;: I think that one of the problems with the P5P model is the infrastructure of mailing lists tends to push people into a &amp;ldquo;I say this,&amp;rdquo; &amp;ldquo;but I say that,&amp;rdquo; &amp;ldquo;but I say this,&amp;rdquo; &amp;ldquo;but I say that.&amp;rdquo; Kind of heads banging against each other and not really resolving anything. There&amp;rsquo;s various kinds of work. Horscht Ritter did his Ivis project and there&amp;rsquo;s Wicki&amp;rsquo;s and things like that that are used to try and resolve things and give people a place to put their argument as best possible and then they can move on to something else, so you might want to look into some of that.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Larry:&lt;/strong&gt; Yes, we&amp;rsquo;re already planning to do some of that. Each working group will have somebody in charge who makes the final decisions. We will have mailing lists which are at least two tiered in that they will have official inner ringers but anybody can listen in and contribute indirectly if they want to contribute to the actual working group - the people who are actually on the working group. We want to have an official RFC sort of kind of mechanism for not just this sort of off-the-top-of-your-head &amp;ldquo;Oh, wouldn&amp;rsquo;t it be nice if this,&amp;rdquo; &amp;ldquo;Wouldn&amp;rsquo;t it be nice if that.&amp;rdquo; If you have a real proposal for a feature, make an official proposal in an official place with all the things that make it an official proposal, and, you know - I guess that&amp;rsquo;s it about that one.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Thank you for taking on this endeavor. Can you hint at any language changes that you&amp;rsquo;re considering?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Larry:&lt;/strong&gt; I hinted at some of them. Everything is negotiable, but everything will not be traded away. On a philosophical level, I have the profound feeling that if I like something, other people will like it and if I don&amp;rsquo;t like something, other people probably don&amp;rsquo;t like it so much, and so I really trust my instincts on where things will be going. I&amp;rsquo;ll be getting a lot of feedback on that, too. We&amp;rsquo;ve been getting a lot of feedback for the past 10 years on things that people think are kind of grouty. For instance, there&amp;rsquo;s really no reason why formats should be in the core anymore. They should be a, you know, come in as a module. There are things that could be done perhaps to clean up ambiguities and indirect object impacts. Basically what we are saying at this point is if we are going to bite the bullet and require translation of Perl 5 to Perl 6, that really means that we can consider anything that still allows us to translate most scripts. Now we do not expect to be able to translate a 100 percent, but if we can translate with 95-percent accuracy 95 percent of the scripts, and 100-percent accuracy 80 percent of the scripts, then that&amp;rsquo;s getting into the ballpark, but on the other hand, sometimes you have to break a few somethings or other to make an omelette. Other specific features, can you remember any of the ones we named?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; One of the problems with language translators is you lose all the comments and formatting and things like that.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Larry:&lt;/strong&gt; Not the Ox to Perl translators. I wrote that.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Audience member:&lt;/strong&gt; Well, can you make sure that will be the way it works in the Perl 5 to Perl 6.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Larry:&lt;/strong&gt; It may, it may lose some of the formatting information, but there&amp;rsquo;s ways to annotate a syntax tree with additional information. And if we have to get a little incestuous with the compiler and turn off certain optimizations to get a more pristine syntax tree to translate that &amp;ndash; lots of things like that can be done. This is subject that &amp;ndash; I enjoy doing things like that, so I don&amp;rsquo;t think you need to worry about that not getting done reasonably adequately.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; I somewhat disagree with your bracketing and indentation style, but respect your right to observe your particular religion. With the automatic language translation that you&amp;rsquo;re having, will I have, within reason, the ability to observe my religion? How long have you been thinking about doing this? How long have you been stewing on it?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Larry:&lt;/strong&gt; Since yesterday.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Audience member:&lt;/strong&gt; Are you contemplating any changes to Pod?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Larry:&lt;/strong&gt; Everything is negotiable.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Audience member:&lt;/strong&gt; You said you wish to steal from some languages. Which languages in particular over the last decade?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Larry:&lt;/strong&gt; COBOL. Identification Division. I always wanted an identification divisioner. No, really, I don&amp;rsquo;t want an identification division. The problem with identification division is it really puts a crimp in Perl&amp;rsquo;s poetry, or in COBOL poetry. How many poems can you start off identification division? One. What&amp;rsquo;s your favorite language, besides Perl? You know, lots of languages do more of a byte code thing. Some of these things, a lot of these things are not borrowing from a specific language. There&amp;rsquo;s multiple languages that use the byte code thing. There&amp;rsquo;s various languages with a cleaner object interface to their IL and such. There&amp;rsquo;s lots of languages that, I don&amp;rsquo;t know, do various things, but we - when something like - when you see all the new languages coming out and they all have a garbage collector and that helps them fit together into browsers and things like that better, you start thinking, maybe we ought to think about that.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Question:&lt;/strong&gt; Larry, more and more people, of course, are using Perl today to write larger and larger software. Is there anything in Perl 6 that you can think of off hand that might make that easier? Large software tend to have - tend to appreciate things like stronger type checking, for example.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Larry:&lt;/strong&gt; Yes, certainly. We already got the hooks in there to start putting some things in there optionally, and you could have used strict-type checking if you wanted to or you could use Stricter or something. You can use bondage and discipline - whatever you want to call the module. Also, as part of the redesign - here&amp;rsquo;s a biggie - we intend to get rid of quite a few of those strange global variables or the strange one. We will certainly get rid of dollar sharp.&lt;/p&gt;

&lt;h3 id=&#34;audio&#34;&gt;Audio&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://youtu.be/a1SEt_-QMDo&#34;&gt;On Youtube&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_10_23_soto2000/part1.mp3&#34;&gt;MP3 - Part 1&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;media/_pub_2000_10_23_soto2000/part2.mp3&#34;&gt;MP3 - Part 2&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;media/_pub_2000_10_23_soto2000/part3.mp3&#34;&gt;MP3 - Part 3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;media/_pub_2000_10_23_soto2000/part4.mp3&#34;&gt;MP3 - Part 4&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>3rd State of the Onion</title>
      <link>http://localhost:1313/pub/1999/08/onion/talk1.html/</link>
      <pubDate>Mon, 30 Aug 1999 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/1999/08/onion/talk1.html/</guid>
      <description>&lt;p&gt;This talk was delivered by &lt;a href=&#34;http://www.wall.org/~larry&#34;&gt;Larry Wall&lt;/a&gt; on August 23, 1999 at the &lt;a href=&#34;http://conference.oreilly.com&#34;&gt;Perl Conference 3.0&lt;/a&gt; in Monterey, CA.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;(Note: most of the pictures this year were images of molecules that I animated using a program called &lt;a href=&#34;http://www.umass.edu/microbio/rasmol/&#34;&gt;RasMol&lt;/a&gt;, along with a &lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/pmol&#34;&gt;Perl script&lt;/a&gt; to drive it and make the molecules rotate. You probably don&amp;rsquo;t have RasMol on your computer, and if you do, you probably don&amp;rsquo;t have my script. So in the following I&amp;rsquo;ve substituted static images, but these link to the corresponding PDB files, which can be fed to RasMol (or my script, pmol) if you want to play with the images yourself. You can find many more PDB files on the net if you&amp;rsquo;re interested.)&lt;/em&gt;&lt;/p&gt;

&lt;hr /&gt;

&lt;p&gt;Two years ago, in my &lt;a href=&#34;http://localhost:1313/pub/1997/wall/keynote.html&#34;&gt;first&lt;/a&gt; State of the Onion speech, I used sounds.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[I play ``&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/absorbed.au&#34;&gt;You will be absorbed&lt;/a&gt;.&amp;rdquo;]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Last year, in my &lt;a href=&#34;http://localhost:1313/pub/1998/08/show/onion.html&#34;&gt;second&lt;/a&gt; State of the Onion speech, I used pictures.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/hap.gif&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/hap2.gif&#34; alt=&#34;Happy face&#34; width=&#34;315&#34; height=&#34;240&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Those of you who heard or read that speech will recall that I threatened to use smellovision this year. So guess what.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[I hold up an onion.]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an onion. Allow me to cut it here in front of you.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[I cut the onion.]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;They laughed, they cried&amp;hellip;&lt;/p&gt;

&lt;p&gt;And just this last week, they &lt;a href=&#34;http://dailynews.yahoo.com/h/ap/19990816/pl/senate_fumes_1.html&#34;&gt;evacuated&lt;/a&gt; a federal building in Washington, D.C. because people were getting sick from some mysterious toxic fumes. Guess what sort of toxic fumes they turned out to be?&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[I wave the onion.]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The active ingredient in onion, the one that makes you cry, is thought to be something called 1-propenyl sulfenic acid. In chemistry shorthand, that looks something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    CH3-CH=CH-SOH
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may be wondering what this has to do with programming. Other than the fact that reading other people&amp;rsquo;s code sometimes makes you want to cry.&lt;/p&gt;

&lt;p&gt;The point I would like to make today is that I think the Perl community has ``good chemistry&amp;rdquo;. We often talk about groups of people having ``good chemistry&amp;rdquo;. Especially when the group consists of two people who suddenly like each other very much.&lt;/p&gt;

&lt;p&gt;Unfortunately, what the phrase ``good chemistry&amp;rdquo; usually means is that we don&amp;rsquo;t understand what&amp;rsquo;s making the chemistry good. Chemistry is a mystery to most of us. It&amp;rsquo;s like saying ``It&amp;rsquo;s all Greek to me.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s one little problem with that saying. I can read Greek. I learned some classical Greek at &lt;a href=&#34;http://www.spu.edu&#34;&gt;Seattle Pacific University&lt;/a&gt; as part of my declared major, Natural and Artificial Languages. That was just an excuse to mix up linguistics and computer science. You probably know that already.&lt;/p&gt;

&lt;p&gt;What you may not know is that I started off college with a double major in Chemistry and Music. If I can&amp;rsquo;t say, ``It&amp;rsquo;s all Greek to me,&amp;rdquo; neither can I say, ``We have good chemistry.&amp;rdquo; At least, I can&amp;rsquo;t say it without wondering what it means. I have some ideas about what good chemistry is, and that&amp;rsquo;s what I&amp;rsquo;m going to talk about today.&lt;/p&gt;

&lt;p&gt;So to start, here&amp;rsquo;s one of our favorite molecules.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/caffeine.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/caffeine.gif&#34; alt=&#34;Caffeine&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is caffeine. Good chemistry in this case means keeping you awake through my talk.&lt;/p&gt;

&lt;p&gt;Actually, you should find this talk interesting if you&amp;rsquo;ve ever had anything to do with chemistry. And if you are lifeform that is not based on chemistry, I apologize in advance. Well hey, this&amp;rsquo;ll talk will probably get slashdotted, and who knows how many AI projects are reading slashdot these days?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m also tempted to apologize for the fact that this talk is organized organically. But I won&amp;rsquo;t. It&amp;rsquo;s funny, but the way the English language is going, ``organized organically&amp;rdquo; is becoming an oxymoron. You wouldn&amp;rsquo;t think so, since the two words are based on the same root. But our world today has two opposing views on the goodness of hierarchy, and each of these words has fallen down on opposite sides of the fence. Modern life is organized, while postmodern life is merely organic.&lt;/p&gt;

&lt;p&gt;But I&amp;rsquo;m not here to talk about postmodernism. I &lt;a href=&#34;http://www.wall.org/~larry/pm.html&#34;&gt;tried&lt;/a&gt; to do that last spring, and afterwards I was thoroughly deconstructed by the deconstructionists for attempting to deconstruct deconstructionism. At least, that&amp;rsquo;s the construction I put on their construction of it. I was talking about postmodern culture, and they thought I was talking about postmodern literature. Not at all the same thing!&lt;/p&gt;

&lt;p&gt;Anyway, I&amp;rsquo;m enough of a postmodern that if you tell me my talk is &lt;em&gt;organized&lt;/em&gt;, I&amp;rsquo;ll be insulted, but if you tell me my talk is &lt;em&gt;organic&lt;/em&gt;, I&amp;rsquo;ll be complimented.&lt;/p&gt;

&lt;p&gt;If you tell me my talk is &lt;em&gt;orgasmic&lt;/em&gt;, I won&amp;rsquo;t believe you.&lt;/p&gt;

&lt;p&gt;At least, not until I light this candle.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[I wave around an oversized votive candle.]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;I ordered this candle a couple of days ago over the Web from a company called &lt;a href=&#34;http://www.erox.com&#34;&gt;Realm Fragrances&lt;/a&gt;. They hold the patent on fragrances containing human pheromones. This candle purports to contain human pheromones.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[I light the candle.]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Come on baby, light my fire&amp;hellip;&lt;/p&gt;

&lt;p&gt;If you didn&amp;rsquo;t think Perl was sexy before, you will now.&lt;/p&gt;

&lt;p&gt;(Whether you want to or not.)&lt;/p&gt;

&lt;p&gt;Better programming through chemistry&amp;hellip;&lt;/p&gt;

&lt;p&gt;Actually, I just read another &lt;a href=&#34;http://www.discover.com/sep_99/breakfollies.html&#34;&gt;news item&lt;/a&gt; a couple of weeks ago that said that some study had just shown that the recently discovered vomeronasal receptors in the human nose are, in fact, vestigial, and don&amp;rsquo;t have neurons to them in adults. Ah, well. Studies are a dime a dozen. If you try hard enough, you can even find studies that prove cigarette smoking is bad for you.&lt;/p&gt;

&lt;p&gt;Speaking of studies, a bright fellow by the name of &lt;a href=&#34;http://opensource.activestate.com/authors/tedshieh/index.html&#34;&gt;Ted Shieh&lt;/a&gt; has been &lt;a href=&#34;http://opensource.activestate.com/authors/tedshieh/software.html&#34;&gt;studying&lt;/a&gt; the demand for programmers of various kinds. He&amp;rsquo;s been analyzing the web site &lt;a href=&#34;http://www.dice.com&#34;&gt;www.dice.com&lt;/a&gt;, where corporate America advertises openings for high-tech jobs, about 132,000 as of today. This is what is known to pollsters as a large statistical sample.&lt;/p&gt;

&lt;p&gt;Of course, to a chemist it would be a very small statistical sample. Chemists aren&amp;rsquo;t impressed until you start using exponential notation. You know, Avocado&amp;rsquo;s number, and all that.&lt;/p&gt;

&lt;p&gt;Anyway, here&amp;rsquo;s a chart that Ted came up with. It charts the number of job listings on dice.com that mention any of the top programming languages. The chart shows growth over the last six months.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/gch.gif&#34; alt=&#34;job listings on dice.com&#34; width=&#34;918&#34; height=&#34;621&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Perl is the yellow line.&lt;/p&gt;

&lt;p&gt;Allow me to point out this spot in April when Perl passed up COBOL.&lt;/p&gt;

&lt;p&gt;Of course, passing up COBOL is no big deal these days, since demand for COBOL seems to be trailing off, for some strange reason.&lt;/p&gt;

&lt;p&gt;Perhaps more to the point, notice this spot in July when Perl passed up Visual Basic.&lt;/p&gt;

&lt;p&gt;Finally, notice this spot way down in the corner, where Python finally got off the baseline. A little.&lt;/p&gt;

&lt;p&gt;In the race to the millennium, it looks like C++ will win, Java will place, and Perl will show. Some of you no doubt will wish we could erase those top two lines, but I don&amp;rsquo;t think you should be unduly concerned. Note that both C++ and Java are systems programming languages. They&amp;rsquo;re the two sports cars out in front of the race. Meanwhile, Perl is the fastest SUV, coming up in front of all the other SUVs. It&amp;rsquo;s the best in its class.&lt;/p&gt;

&lt;p&gt;Of course, we all know Perl is in a class of its own.&lt;/p&gt;

&lt;p&gt;Our real competitor according to this chart is JavaScript. They&amp;rsquo;re coming along strong in fourth place. That&amp;rsquo;s not terribly surprising, considering that JavaScript has taken over a lot of the role in the browser that everyone originally thought Java was going to fill by itself.&lt;/p&gt;

&lt;p&gt;This chart actually lies a little, since it&amp;rsquo;s not scaled by the number of jobs listed on dice.com. And that number has been doubling once every year or so. So all these lines are a little too optimistic.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s another chart from Ted that corrects for that.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/pct.gif&#34; alt=&#34;correction on jobs listed on dice.com&#34; width=&#34;931&#34; height=&#34;601&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In this chart, all the languages add up to 100%, so we can see what the relative demand has been over the last six months.&lt;/p&gt;

&lt;p&gt;See the pinkish band at the top. Imminent death of COBOL predicted.&lt;/p&gt;

&lt;p&gt;Look at these bottom two bands. Of course, we don&amp;rsquo;t want to be fooled by the fact that they&amp;rsquo;re next to each other, but I do think that Java is growing primarily at the expense of C++. And maybe COBOL.&lt;/p&gt;

&lt;p&gt;Meanwhile, both Perl and JavaScript are chewing into Visual Basic, and maybe COBOL. Nobody else on the screen is doing any chewing. The thin blue band at the top is Smalltalk. If you look really closely at the black line above that, it gets a little thicker in spots. That&amp;rsquo;s Python.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s another way in which these charts might be lying. They don&amp;rsquo;t tell us how many jobs there actually are out there.&lt;/p&gt;

&lt;p&gt;Perhaps there&amp;rsquo;s no demand for Python programmers simply because Python programmers are really easy to find without using dice.com.&lt;/p&gt;

&lt;p&gt;Some of you look dubious.&lt;/p&gt;

&lt;p&gt;On the other hand, maybe the demand for Java programmers is driven entirely by hype, and there are in reality no Java programmers out there.&lt;/p&gt;

&lt;p&gt;Well hey, maybe that&amp;rsquo;s why they cancelled JavaOS last week.&lt;/p&gt;

&lt;p&gt;I really do have a hard time believing that COBOL is dying. Maybe the demand is going down for COBOL programmers because there are billions of COBOL programmers beating down the doors of businesses looking for jobs. Maybe the demand was artificially high because of Y2K fixups. I dunno. Maybe someone did a study that proves COBOL is bad for your health.&lt;/p&gt;

&lt;p&gt;Well, enough disclaimers. As long as the demand for Perl keeps going up, we&amp;rsquo;re doing something right. You can call it buzz or you can call it brownian motion, but let&amp;rsquo;s keep doing the good chemistry.&lt;/p&gt;

&lt;p&gt;So, all right, what &lt;em&gt;is&lt;/em&gt; good chemistry. First of all, good chemistry is a little bit messy. Good chemistry is not the same as perfect chemistry. If you want perfect chemistry, here&amp;rsquo;s an example.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/diamond.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/diamond.gif&#34; alt=&#34;Diamond&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s a bit of diamond crystal. Diamonds may be a girl&amp;rsquo;s best friend (next to pheromone candles), but they&amp;rsquo;re actually rather boring. Crystals are pretty, but they just kind of sit there, not doing much of anything.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/prl.gif&#34; alt=&#34;Pearls&#34; width=&#34;325&#34; height=&#34;281&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Pearls are much more interesting. They&amp;rsquo;re produced by living oysters, after all. They consist of alternating layers of calcium carbonate crystals and an organic binder known as conchiolin. (I suppose it must have something to do with conches.) These alternating layers are what make the pearl irridescent. Calcium carbonate is, of course, a compound of calcium, carbon, and oxygen. Conchiolin is a mixture of various proteins and polysaccharides, rather like your fingernails.&lt;/p&gt;

&lt;p&gt;In other words, pearls are complicated, and a little bit messy.&lt;/p&gt;

&lt;p&gt;I think good chemistry is complicated, and a little bit messy. I suppose one of the reasons I think that is because, when I was young, I had a chemistry set.&lt;/p&gt;

&lt;p&gt;Back in those days, men were men, boys were boys, and chemistry sets were Chemistry Sets. Chemistry sets had real test tubes, and a real alcohol burner, and real chemicals. Dangerous chemicals. The bottles had warnings like, ``Eat thou not of this. If thou eatest of this, thou shalt surely die.&amp;rdquo; Or something like that.&lt;/p&gt;

&lt;p&gt;Sure, you could do all the fun experiments turning things red or blue or clear again, but you could also do the things that really matter to a junior high boy. You could make things that stink. You could make things that explode.&lt;/p&gt;

&lt;p&gt;Of course, they didn&amp;rsquo;t give you everything you needed for that in the chemistry set. You were expected to go down to the drug store and buy your own potassium nitrate, otherwise known as saltpeter. Saltpeter is cool stuff, for a junior high boy.&lt;/p&gt;

&lt;p&gt;One day I mixed some saltpeter with sulfur and sugar. You&amp;rsquo;re all familiar with sugar at the macroscopic level. Here&amp;rsquo;s a picture of a sucrose molecule.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/sucrose.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/sucrose.gif&#34; alt=&#34;Sucrose&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Nowadays it seems sort of a shame to use such a pretty, not to mention tasty, molecule merely for fuel, but that&amp;rsquo;s what I did. I discovered a couple of things. First, I discovered that this mixture makes an excellent stink bomb. As you can see here, the sugar molecule has lots of hydrogens. When you burn the mixture, apparently the sugar donates hydrogen and the sulfur donates, well, sulfur, producing hydrogen sulfide in copious quantities.&lt;/p&gt;

&lt;p&gt;I also discovered that I should not light off stink bombs in the basement. Besides smelling like rotten eggs, hydrogen sulfide is rather poisonous in large quantities. Guess who had just manufactured large quantities of it. In the basement. Fortunately, no one else was home at the time, and I had the house aired out by the time anyone came home. But I didn&amp;rsquo;t know that, so all morning, the door to the basement had a sign that said, ``If thou goest down here, thou shalt surely die.&amp;rdquo; Or something like that.&lt;/p&gt;

&lt;p&gt;Maybe someday I&amp;rsquo;ll talk about the rockets. Rocket science is messy too.&lt;/p&gt;

&lt;p&gt;By the way, I&amp;rsquo;m showing you this molecule courtesy of a program called ``RasMol&amp;rdquo;. No, it&amp;rsquo;s not written in Perl. It&amp;rsquo;s written in C. Sorry.&lt;/p&gt;

&lt;p&gt;Believe it or not, there really are a few good programs out there written in C. You know, &lt;em&gt;rn&lt;/em&gt;&amp;hellip; &lt;em&gt;patch&lt;/em&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;Maybe &lt;em&gt;perl&lt;/em&gt;&amp;hellip;&lt;/p&gt;

&lt;p&gt;But in my defense, allow me to point out that I&amp;rsquo;m running the animation by piping commands to RasMol from a Perl script. And that&amp;rsquo;s as it should be. We don&amp;rsquo;t have to do everything with Perl. We just have to be in control.&lt;/p&gt;

&lt;p&gt;Actually, I&amp;rsquo;m not a control freak. I think I&amp;rsquo;m more of a chaos freak.&lt;/p&gt;

&lt;p&gt;Well, okay, I&amp;rsquo;m really a controlled chaos freak. Here&amp;rsquo;s some &lt;a href=&#34;http://dir.yahoo.com/Entertainment/Comics_and_Animation/Characters/Wallace_and_Gromit&#34;&gt;Wallace and Gromit&lt;/a&gt;:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[I play ``&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/WG_control.au&#34;&gt;Everything seems to be under control!&lt;/a&gt;&amp;ldquo;]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Seriously, Perl doesn&amp;rsquo;t have to be in control. It just likes to be in the middle. Kind of like those carbon atoms there in sucrose. Or here.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/cynac.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/cynac.gif&#34; alt=&#34;polycyanoacrylate&#34; width=&#34;568&#34; height=&#34;264&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is a strand of polycyanoacrylate, more commonly known as superglue. In the middle of things is where a glue language belongs. The world will always have interstices, and we&amp;rsquo;ll always be needing to put glue into them upon occasion. We&amp;rsquo;re in the business of developing better glue molecules. So don&amp;rsquo;t fret yourselves about whether Perl is doing better or worse than some other language in the job market. We&amp;rsquo;re not in that kind of a race.&lt;/p&gt;

&lt;p&gt;We do not define Perl as an improved version of some other language. Nor do we have to define Perl as the next universal language. We&amp;rsquo;re not trying to make Perl a better language than C++, or Python, or Java, or JavaScript. We&amp;rsquo;re trying to make Perl a better language than Perl. That&amp;rsquo;s all.&lt;/p&gt;

&lt;p&gt;So, what do you want in a glue language?&lt;/p&gt;

&lt;p&gt;Well, you have to have the basics, of course. The BASIC programming language was called BASIC for a reason, after all. This superglue molecule shows us a nice bit of linear programming along the backbone. It&amp;rsquo;s a bit obscured by all the cyanide groups. I find it a bit odd that surgeons use superglue because it&amp;rsquo;s non-toxic. Hydrogen cyanide is what they use in the gas chamber in California. Go figure.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a simpler example of linear programming, without all the cyanide on the side.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/decane.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/decane.gif&#34; alt=&#34;decane&#34; width=&#34;560&#34; height=&#34;295&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is decane, a simple linear hydrocarbon. We don&amp;rsquo;t use it for glue. I am undoubtedly burning some decane in my candle here, since parafin is largely made up of long linear alkanes. If we chop this molecule in half, we get a shorter script. Er, program. Er, molecule.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/pentane.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/pentane.gif&#34; alt=&#34;pentane&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is a simple molecule of pentane. We don&amp;rsquo;t use it for glue, either. Mostly we burn it up, because pentane is a basic ingredient of gasoline. But certainly not the only ingredient. You&amp;rsquo;d never want to burn 100% pentane in your car. 100% pentane is the very definition of 0 octane gas. To get 100 octane gas, we have to add a branching capability to our language.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/hexamethylethane.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/hexamethylethane.gif&#34; alt=&#34;hexamethylethane&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This molecule defines the standard for 100 octane gas. Not suprisingly, it&amp;rsquo;s called octane, or at least one variety thereof. It&amp;rsquo;s official name is 2,2,3,3-tetramethyl butane, which is a really stupid name, because the methyl groups added onto the side of the butane are exactly equivalent to the methyl groups at the ends of the butane. I think it should be called 1,1,1,2,2,2-hexamethyl ethane. But that&amp;rsquo;s not how chemical names officially work. You have to pick the longest carbon chain you can, four in this case, even if thereby you deny the basic symmetry of the molecule. It&amp;rsquo;s kind of like the standard definition of regular expressions, where you always have to match the longest string. Of course, lots of people call it hexamethyl ethane anyway, since real people really do believe there&amp;rsquo;s more than one way to do it. People use minimal regular expressions now too, thanks to Perl. I&amp;rsquo;m not sure what the octane rating of Perl is. Perl doesn&amp;rsquo;t make your engine knock, but it&amp;rsquo;s not very expensive either.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a cool molecule, if you&amp;rsquo;re into explosions. Or branching structures.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/nitroglycerin.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/nitroglycerin.gif&#34; alt=&#34;nitroglycerin&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It seems like whenever you run into a cool explosive, you tend to find nitrogen involved, whether you&amp;rsquo;re talking about potassium nitrate, or nitrogen triiodide, or in this case glyceryl trinitrate. More commonly known as nitroglycerin. Also more commonly &lt;em&gt;used&lt;/em&gt; as a heart medication than as an explosive. Still, to a junior high boy, it&amp;rsquo;s dynamite.&lt;/p&gt;

&lt;p&gt;Of course, not only do we need branching structures in our programming language, but we need various looping constructs.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/tnt.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/tnt.gif&#34; alt=&#34;tnt&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s TNT, trinitrotoluene, frequently confused with dynamite. But it takes a detonator to get TNT to explode. You can take pure TNT and hit it with a hammer, and nothing will happen. Don&amp;rsquo;t try this with dynamite. It will ruin your day, if not your hammer.&lt;/p&gt;

&lt;p&gt;TNT is based on toluene, which is a benzene ring with one methyl group. People used to think of benzene and other aromatic molecules as having double bonds that alternated rapidly with single bonds. But it turns out that all the extra electrons are usually out in a cloud on either side of the ring, which hangs a great big negative charge out there, which is why many potent biological molecules use them. Loops are a powerful part of Perl too. That&amp;rsquo;s why there are so many different kinds of loops in Perl.&lt;/p&gt;

&lt;p&gt;And there&amp;rsquo;s more than one way to do it in chemistry as well. Interestingly, you can substitute nitrogens for carbons and get aromatic loops as well. You can always tell the aromatic loops from the non-aromatic loops because the aromatics don&amp;rsquo;t seem to have enough hydrogens attached to the carbons or nitrogens. Perl has other ways of telling loops apart. Here&amp;rsquo;s a molecule that will drive you loopy.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/histamine.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/histamine.gif&#34; alt=&#34;histamine&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is histamine. Many of you are intimately familiar with histamines, because as loops, they program you to sneeze repeatedly. Some of you may be producing histamines because of the fragrances in this candle. Some of you may have gone so far as to program your body with an antihistamine such as &lt;a href=&#34;http://www.healing-aid.com&#34;&gt;Benadryl&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/benadryl.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/benadryl.gif&#34; alt=&#34;benadryl&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Obviously, Benadryl is the more powerful program because it has two loops instead of one.&lt;/p&gt;

&lt;p&gt;Alternately, you can view it as the reuse of modules. Though it looks more like cut and paste to me. For real reusability, of course, you need to study catalysts, and their proteinaceous cousins, enzymes. Most enzymes are just chock full of loops, branches, objects, interfaces, and what have you. Many reusable enzymes can be downloaded from the CDAN. That&amp;rsquo;s the Comprehensive DNA Archive Network, replicated in the nucleus of each of your cells.&lt;/p&gt;

&lt;p&gt;Just a few more loops. I like loops a lot.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/cyclonite.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/cyclonite.gif&#34; alt=&#34;cyclonite&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s another dual-use explosive, cyclonite. It doubles as a rat poison. Rat eats it, KABOOM! In this case you can see that the ring is not aromatic, so all the carbons connect to four things and the nitrogens to three things.&lt;/p&gt;

&lt;p&gt;One thing we haven&amp;rsquo;t figured out how to do in Perl is three-dimensional loops. Hey, Sarathy, let&amp;rsquo;s put this on the Todo list:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/cubane.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/cubane.gif&#34; alt=&#34;cubane&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is cubane. Not aromatic. See all the hydrogens.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/dodecahedrane.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/dodecahedrane.gif&#34; alt=&#34;dodecahedrane&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is dodecahedrane. Also not aromatic.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/buckyball.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/buckyball.gif&#34; alt=&#34;buckyball&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;And of course, buckminsterfullerene, which is aromatic, for some definition of the term. Note that there are no hydrogens at all. Buckyballs are a recently discovered form of pure carbon, like graphite and diamond. Making organic molecules without hydrogen is kind of like writing Perl without dollar signs. Which oddly enough you will be able to do easily, now that we&amp;rsquo;re getting lvalue subroutines, another recent discovery.&lt;/p&gt;

&lt;p&gt;I have a gazillion other molecules I could show you, but I&amp;rsquo;d like to go back and explain a little more personal history. After all, the theme of all these keynote speeches has been that you can&amp;rsquo;t really understand Perl without understanding Larry. There is an unfortunate corollary, however. Since it&amp;rsquo;s not possible to understand Larry, it&amp;rsquo;s not possible to understand Perl either.&lt;/p&gt;

&lt;p&gt;But that&amp;rsquo;s okay, because Perl is a bit like those early chemistry sets. You didn&amp;rsquo;t really have to understand what you were doing in order to do interesting things. You might blow yourself up, but more likely, you&amp;rsquo;d have a great deal of fun.&lt;/p&gt;

&lt;p&gt;I remember a lot more about my chemistry set than I do of high school chemistry. In fact, about the only thing I learned in high school chemistry was Avocado&amp;rsquo;s, er, Avogadros number, 6.02 times 10 to the something big. But between my chemistry set and Avogadro&amp;rsquo;s number, I managed to persuade myself to major in Chemistry in college.&lt;/p&gt;

&lt;p&gt;Among other things.&lt;/p&gt;

&lt;p&gt;My first year at college, I took inorganic chemistry. Inorganic chemistry is mostly about weighing things. I spent an awful lot of time trying to get the scales to read what they were supposed to read. The error bars on my graphs were always rather too large.&lt;/p&gt;

&lt;p&gt;I remember wandering into the lab next door, and being shocked to find a jar of potassium cyanide sitting in the cupboard. I suppose that&amp;rsquo;s when it first occurred to me that we really do expect people not to be idiots. For example, we really do expect people not to call &lt;code&gt;system(&amp;quot;rm -rf *&amp;quot;)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;I also learned something about ambiguity that year. I was leafing through a chemistry book when I saw an entry that said, ``periodic acid&amp;rdquo;. ``Huh,&amp;rdquo; I said. I should really have figured it out sooner, since I knew about perchloric acid. Periodic acid is &lt;em&gt;not&lt;/em&gt; acid that&amp;rsquo;s periodically acidic, but rather it&amp;rsquo;s per-iodic acid, based on iodine, just as perchloric acid is based on chlorine.&lt;/p&gt;

&lt;p&gt;Even if periodic acid isn&amp;rsquo;t, the periodic table is. We studied the periodic table of the elements a lot in inorganic chemistry. There&amp;rsquo;s a reason it&amp;rsquo;s called periodic, and it also has to do with the fact that iodine is like chlorine, and fluorine, and bromine. Sort of.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/pt2.gif&#34; alt=&#34;periodic table&#34; width=&#34;801&#34; height=&#34;575&#34; /&gt;&lt;/p&gt;

&lt;p&gt;You know, if this were a computer language, people would say it has too many ways to do the same thing. It has too many features that work too similarly, and at the same time it&amp;rsquo;s missing key features of higher abstraction that would really help an &lt;a href=&#34;http://www.mit.edu&#34;&gt;MIT&lt;/a&gt; grad student. Elements do multiple inheritance of properties, which is evil. Strong typing is not enforced. Nothing should be made of carbon, because organic programming gives you too many ways to get into trouble. There are too many metals, too many gasses, and not enough semiconductors like silicon. There ought to be more elements like carbon. Everything should be made of carbon atoms. Silicon is only good for sand, it should be removed. If this were really object-oriented, electrons and quarks would have the same interface as atoms and molecules. There&amp;rsquo;s not enough encapsulation of electrons in the metals. There&amp;rsquo;s too much encapsulation in the lanthanides and the noble gasses. And why the heck do we need so many different noble gasses anyway? They don&amp;rsquo;t do anything! Throw &amp;lsquo;em into that big hole at the top of the chart. And don&amp;rsquo;t get me started on isotopes!&lt;/p&gt;

&lt;p&gt;The periodic table is a mess. It should be redesigned.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s what I learned in inorganic chemistry. My second year I took organic chemistry. That&amp;rsquo;s the same year I started working as a computer programmer. Before that I was working as a projectionist.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[I look at the projection screen in the auditorium.]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You know, I&amp;rsquo;m still a projectionist. You can never entirely stop being what you once were. That&amp;rsquo;s why it&amp;rsquo;s important to be the right person today, and not put it off till tomorrow.&lt;/p&gt;

&lt;p&gt;Organic chemistry is way cool, but there&amp;rsquo;s a problem. You can always tell who is taking organic chemistry on campus. That whole second year, whenever I wandered into the computer center, I was told I smelled like a goat. (In retrospect, I would rather have smelled like a camel.) Anyway, the odor of everything from ether to isoamyl acetate was oozing out of my pores, and it took several weeks for it to wear off after the school year was out. At least, so I&amp;rsquo;m told. I couldn&amp;rsquo;t smell much of anything for the rest of the summer.&lt;/p&gt;

&lt;p&gt;But I enjoyed organic chemistry. We did both synthesis and analysis, but I think I enjoyed the synthesis more. Not too surprising, given who I am. I&amp;rsquo;ve never stopped being a synthesist.&lt;/p&gt;

&lt;p&gt;Actually, I think chemistry strikes a good balance between synthesis and analysis, between holism and reductionism. As a synthesist, I tend to be scared of reductionism. You know, behavior can be reduced to biology, biology can be reduced to biochemistry, and biochemistry can be reduced to chemistry. Chemistry, in turn, can be reduced to physics. And physics, of course, can be reduced to theology.&lt;/p&gt;

&lt;p&gt;Well, hey, that follows logically from the fact that physics can be reduced to math.&lt;/p&gt;

&lt;p&gt;Ask most any mathemetician about God, and he&amp;rsquo;ll say something like, ``We can&amp;rsquo;t prove that God exists. However, we can prove that if God does exist, he&amp;rsquo;s pretty good at math. In fact, we can prove that even if God doesn&amp;rsquo;t exist, he&amp;rsquo;s still pretty good at math.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Personally, I think God is pretty good at both analysis and synthesis. I like the periodic table the way it is, thank you.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an ester I synthesized, called isoamyl acetate.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/banana.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/banana.gif&#34; alt=&#34;banana&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;You know this better as the smell of banana.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;[I eat a banana.]&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;You might think bananas are relatively harmless, but after the quarter was over, I took my precious isoamyl acetate to my dorm room. During an all-dorm water fight, I had the bright idea of turning another floor of the dorm into banana heaven, so I got out my stash of banana perfume. One of my floormates grabbed it from me, went down to the other floor and threw it in someone&amp;rsquo;s face, who proceeded to almost asphyxiate. Fortunately, he didn&amp;rsquo;t, so no one ever asked where the banana perfume came from, and I had a close escape from the law of unintended consequences. But one of the consequences was that chemistry lost a bit of its glamour for me that day. Eventually I realized I didn&amp;rsquo;t want to be a chemist. By my third year in college, I had changed my major to Premed, but I didn&amp;rsquo;t really want to be a doctor either. It was just an excuse to take all the science courses I wanted.&lt;/p&gt;

&lt;p&gt;But another consequence was that I realized that, whenever you synthesize something, people will find a way misuse it. People misuse Perl too&amp;ndash;if you can call spammers people. Perl is the language of choice for network abuse. That doesn&amp;rsquo;t mean Perl isn&amp;rsquo;t a net win for the world. In the long run, I suspect more lives will be saved by nitroglycerin than will be destroyed by it. But &lt;a href=&#34;http://www.nobel.se/alfred/index.html&#34;&gt;Alfred Nobel&lt;/a&gt;&amp;rsquo;s brother was one of the people destroyed by it. I&amp;rsquo;d rather not be destroyed by Perl.&lt;/p&gt;

&lt;p&gt;Chemistry is a serious subject. Sometimes it&amp;rsquo;s a matter of life and death. Here&amp;rsquo;s vitamin C.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/vit-c.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/vit-c.gif&#34; alt=&#34;Vitamin C&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Now that&amp;rsquo;s what you call mission critical programming. Here&amp;rsquo;s vitamin B-12.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/vitamin-b12.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/vitamin-b12.gif&#34; alt=&#34;Vitamin B-12&#34; width=&#34;512&#34; height=&#34;544&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Vitamin B-12 is the proof that cobalt is necessary in your diet. Cobalt is the pinkish atom in the middle attached to five nitrogens and a cyanide group. In this context, cyanide gives life rather than taking it away. Context is everything in chemistry, just as it is in Perl.&lt;/p&gt;

&lt;p&gt;Even when chemistry is not life and death to people, it&amp;rsquo;s life and death to bacteria and insects. Here&amp;rsquo;s malathion.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/malathion.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/malathion.gif&#34; alt=&#34;malathion&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;One year when my wife was pregnant with one of our kids, we were camped here near &lt;a href=&#34;http://www.monterey.com&#34;&gt;Monterey&lt;/a&gt;, and we got sprayed with malathion.&lt;/p&gt;

&lt;p&gt;That kid turned out strange. But then, all my kids turned out strange.&lt;/p&gt;

&lt;p&gt;Strange and wonderful. Kind of like Perl.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/nicotine.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/nicotine.gif&#34; alt=&#34;nicotine&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a naturally occuring insecticide. An organic pesticide, if you will. It occurs naturally in the leaves of the species &lt;em&gt;Nicotiana Tabacum&lt;/em&gt;. Obviously, since nicotine is a natural insecticide, it can&amp;rsquo;t be bad for you, can it?&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/ddt.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/ddt.gif&#34; alt=&#34;ddt&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This molecule with the &lt;a href=&#34;http://einstein.drexel.edu/pages/students/kohr/pages/Who_is_Mr.Yuck.html&#34;&gt;Mr. Yuk&lt;/a&gt; chlorines is DDT, still used in many parts of the world, but not here. We thought it was death for insects, but it was also death for birds. The law of unintended consequences again. But where DDT is still used, millions of people are alive who would have been dead of malaria.&lt;/p&gt;

&lt;p&gt;To an organic chemist, pesticides are organic.&lt;/p&gt;

&lt;p&gt;To an organic farmer, pesticides are &lt;em&gt;not&lt;/em&gt; organic.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s okay, you can make Perl mean opposite things too. I &lt;em&gt;expect&lt;/em&gt; people to make Perl mean opposite things, both good and bad. That doesn&amp;rsquo;t take anything away from the central meaning of Perl. To explain the central meaning of Perl, let&amp;rsquo;s look at the central meaning of the word ``organic&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;If you go back to ancient Greek, the noun &lt;em&gt;organon&lt;/em&gt; already meant what we often mean by ``organ&amp;rdquo; today; that is, a functional subsystem of your body. But &lt;em&gt;organon&lt;/em&gt; could also mean an implement, or a tool, such as a surgical instrument. The related adjective &lt;em&gt;organikos&lt;/em&gt; meant ``serving as a tool, or engine.&amp;rdquo; There you have it. If Perl is a tool or engine, then you&amp;rsquo;re doing organic programming by definition.&lt;/p&gt;

&lt;p&gt;Interestingly, not only could the Greek word mean a surgical instrument, it could also mean a musical instrument. So music is also organic. Perl and music have a lot in common. Maybe next year I should talk about music. After all, I majored in Music too.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;re really lucky, I&amp;rsquo;ll forget to bring my violin.&lt;/p&gt;

&lt;p&gt;Somewhere between music and chemistry there&amp;rsquo;s got to be a joke about organ grinders, but I&amp;rsquo;ll be a monkey&amp;rsquo;s uncle if I can see it.&lt;/p&gt;

&lt;p&gt;Anyway, now you know that the ancient Greeks thought their tools were organs, or their organs were tools.&lt;/p&gt;

&lt;p&gt;Hmm, maybe I&amp;rsquo;d better not expand on that.&lt;/p&gt;

&lt;p&gt;Actually, as a linguist, I don&amp;rsquo;t believe in etymological meanings. The meanings of words depend on many contexts, but all of the real contexts are in the present language, and true etymology is only in the past. On the other hand, part of the current context is what you &lt;em&gt;think&lt;/em&gt; the etymology of a word is. That&amp;rsquo;s why people like me keep trotting out etymological arguments, even though they&amp;rsquo;re relatively meaningless, not to mention wrong half the time.&lt;/p&gt;

&lt;p&gt;So, what &lt;em&gt;do&lt;/em&gt; I mean when I say I program organically? The central meaning of ``organic&amp;rdquo; these days derives from the organs of the body. It means doing business naturally, the way that your body does business, complicated and messy, with lots of interconnections and ramifications and stuff we don&amp;rsquo;t entirely understand yet. But that&amp;rsquo;s the way nature does business.&lt;/p&gt;

&lt;p&gt;On the basis of that, the organic farmers can tell you that it&amp;rsquo;s unnatural to use pesticides, because we don&amp;rsquo;t want it to be part of us, while organic chemists can tell you that it&amp;rsquo;s natural to use carbon-based chemistry, because what we&amp;rsquo;re made of. They&amp;rsquo;re both right, in their way.&lt;/p&gt;

&lt;p&gt;Likewise, Perl is designed to let you program naturally. Whatever &lt;em&gt;you&lt;/em&gt; think natural means.&lt;/p&gt;

&lt;p&gt;Perl culture must also be organic. That means that each bond in the molecule of Perl culture must work the way it&amp;rsquo;s supposed to. There is no central atom to the Perl molecule. Maybe I&amp;rsquo;m a heavy cobalt atom hidden off somewhere in the middle, but the whole molecule is what works. The molecule has what is called &lt;a href=&#34;http://www.sciam.com/1998/0198issue/0198ingber.html&#34;&gt;tensegrity&lt;/a&gt;: the proper balance of pushes and pulls to maintain its integrity. In terms of our culture, it means that sometimes we attract each other, and sometimes we repel each other, but more importantly, it means that we&amp;rsquo;re there for each other there to attract or repel as necessary. Look for balance in your attractions and repulsions. Look for equilibrium.&lt;/p&gt;

&lt;p&gt;What&amp;rsquo;s good for the Perl molecule is good for the Open Source molecule. Last year I gave you a picture of the Open Source world taken from physics.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/roche.gif&#34; alt=&#34;Rocheworld&#34; width=&#34;399&#34; height=&#34;187&#34; /&gt;&lt;/p&gt;

&lt;p&gt;This is &lt;a href=&#34;http://www.baen.com/catalog/rlforwar.htm&#34;&gt;Rocheworld&lt;/a&gt;, where two gravitationally bound bodies approach each other. It&amp;rsquo;s a curious coincidence that the word &lt;em&gt;rapp-roche-ment&lt;/em&gt; has a ``roche&amp;rdquo; in the middle. The picture was intended to indicate the approach of the open source world to the commercial world. I wondered at the time whether things would become unstable if the two worlds got even closer together. That&amp;rsquo;s what would happen in a real Rocheworld. But gravitation turns out to be an incomplete model for what&amp;rsquo;s really going to happen. Gravity is never repulsive, and can only be balanced by centrifugal force, but the combination of electromagnetism and the strong force make atomic bonds that can push as well as pull. So I think that the open source folks and the commercial folks will find the right balance. Here&amp;rsquo;s a sample molecule.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/ethyne.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/ethyne.gif&#34; alt=&#34;ethyne&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;This is the molecule known to most of you as acetylene.&lt;/p&gt;

&lt;p&gt;If we&amp;rsquo;re to make this correspond to last year&amp;rsquo;s picture, then this hydrogen atom on the left is named Richard, and the one on the right is named Bill. (Hmm, they seem to be circling each other. How appropriate.) [Well, they were circling in my talk, anyway.] This carbon atom on the left is all the open source folks that are trying to cooperate constructively with commercial folks, and this other carbon atom is all the commercial folks trying to cooperate with open source folks. The bond in the middle is simultaneously the strongest bond and the weakest bond. It&amp;rsquo;s the strongest bond, because it&amp;rsquo;s a triple bond. It&amp;rsquo;s also the weakest bond, because it&amp;rsquo;s a very energetic bond, and could be broken by outside forces.&lt;/p&gt;

&lt;p&gt;But not by inside forces.&lt;/p&gt;

&lt;p&gt;Let me be specific. Some folks in this room are extremely leary of Bill. Others are extremely leary of Richard. These people tend to be leary not only of the opposite hydrogen, but also the opposite carbon. They are supplying the repulsive forces, because they fear the opposite extreme.&lt;/p&gt;

&lt;p&gt;At the same time, there are lots of good people who are actively supplying the attractive forces. Nobody has enough power to crush the two carbons together. Nobody has enough power to tear them apart. They&amp;rsquo;re in a metastable state. They have tensegrity. It&amp;rsquo;s my hope that the open source movement achieves this kind of tensegrity.&lt;/p&gt;

&lt;p&gt;That being said, acetylene &lt;em&gt;is&lt;/em&gt; flammable. If it is abused too much, it can explode. I only ever had one unanticipated explosion when I was doing chemistry in my basement, and that was when I was generating acetylene. I was an idiot, and was generating it in a small glass jar. Don&amp;rsquo;t try this at home. Fortunately, it was a very small glass jar, and I was already wearing glasses at the time. I was shaken but unhurt. I don&amp;rsquo;t play with acetylene much any more, because it is rather touchy stuff. So maybe, if you&amp;rsquo;re thinking about starting a war between the open source folks and the commercial folks, you should think again. First of all, you&amp;rsquo;ll be fighting against a lot of good folks, and you&amp;rsquo;ll probably lose. Second of all, you might win, and the world will be split up into separate atoms. Maybe that&amp;rsquo;s what the hydrogens on the end want, but the carbons in the middle would really like to stick together and make something useful.&lt;/p&gt;

&lt;p&gt;If we try hard enough, maybe we can make open source into something stable in the middle. Here&amp;rsquo;s the funniest molecule I saw in my research.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/bcfimethane.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/bcfimethane.gif&#34; alt=&#34;bromochlorofluoroiodomethane&#34; width=&#34;300&#34; height=&#34;300&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s called bromochlorofluoroiodomethane. I have no idea what it&amp;rsquo;s good for (or more likely, bad for), just as I have no idea where open source culture is going. But I think of open source as the single carbon in the middle, holding steady the separate interests of these four different atoms, bromine, chlorine, fluorine, and iodine, which to my mind represent the domains .gov, .edu, .org, and .com. If we work things right, maybe we can balance things tetrahedrally so that, for instance, the .govs and .edus keep the .coms and .orgs from destroying each other, and vice versa every whichaway.&lt;/p&gt;

&lt;p&gt;I guess I really am an optimist. A paranoid optimist, true, but an optimist nonetheless.&lt;/p&gt;

&lt;p&gt;Of course, this picture is also an oversimplification. The true picture is much more organic. Whatever that means.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_1999_08_onion_talk1/vit-e.pdb&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_1999_08_onion_talk1/vit-e.gif&#34; alt=&#34;Vitamin&amp;quot; e&amp;quot;E&amp;quot;&#34; width=&#34;512&#34; height=&#34;283&#34; /&gt;&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;I leave you with some vitamin E. Like many of the most useful molecules in biology, it is self contradictory. It has a strongly polar end, and a strongly nonpolar end. It has a funny shape. It smells a little odd. It looks like it was designed by a committee. It&amp;rsquo;s sort of a molecular camel, if you will.&lt;/p&gt;

&lt;p&gt;Nevertheless, it&amp;rsquo;s a useful beast. Just as each of those atoms is necessary to the proper functioning of the molecule as a whole, the molecule as a whole is necessary to the functioning of each of you sitting here today. Each of you in turn can be a vitamin that helps keeps the Perl community healthy.&lt;/p&gt;

&lt;p&gt;And our collective hope is that the Perl community is one of the vitamins that will keep the world healthy.&lt;/p&gt;

&lt;p&gt;The key to equilibrium is to balance out all your reactions.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t overreact. Don&amp;rsquo;t underreact.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t overact. Don&amp;rsquo;t underact.&lt;/p&gt;

&lt;p&gt;But do act. And act passionately, with balance.&lt;/p&gt;

&lt;p&gt;I wasn&amp;rsquo;t going to talk about rockets. But I want the Perl community to behave like a rocket engine. What&amp;rsquo;s the point of rocket science? It&amp;rsquo;s to see how big of an explosion you can have without blowing your rocket chamber apart. I want to have the maximum amount of passion in the Perl community without blowing the community apart. So have a little tolerance for other people&amp;rsquo;s passions, even if they don&amp;rsquo;t match your own. Let&amp;rsquo;s balance our passions.&lt;/p&gt;

&lt;p&gt;``Churn, baby, churn,&amp;rdquo; as &lt;a href=&#34;http://www.garage.com&#34;&gt;Guy Kawasaki&lt;/a&gt; told us earlier today. It&amp;rsquo;s the only way we&amp;rsquo;ll jump to the next curve. It&amp;rsquo;s how we&amp;rsquo;ll let a thousand flowers bloom.&lt;/p&gt;

&lt;p&gt;I feel like I&amp;rsquo;m still playing with my chemistry set here, and I still don&amp;rsquo;t know what I&amp;rsquo;m doing entirely. Doubtless there will be more cool stinks and explosions this year, just as we&amp;rsquo;ve had our fair share of stinks and explosions in the last year. But face it, we&amp;rsquo;ve made many more good smells than bad ones. And the explosions haven&amp;rsquo;t done much besides ruffle a few feathers.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s keep doing organic chemistry this year. It&amp;rsquo;s good chemistry, even if we do smell like a camel occasionally.&lt;/p&gt;

&lt;p&gt;Thanks for letting me douse you with weird chemicals today.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl, the first postmodern computer language</title>
      <link>http://localhost:1313/pub/1999/03/pm.html/</link>
      <pubDate>Tue, 09 Mar 1999 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/1999/03/pm.html/</guid>
      <description>

&lt;h2 id=&#34;span-id-perl-the-first-postmodern-compu-span-perl-the-first-postmodern-computer-language&#34;&gt;&lt;span id=&#34;Perl_the_first_postmodern_compu&#34;&gt;&lt;/span&gt;Perl, the first postmodern computer language&lt;/h2&gt;

&lt;p&gt;&lt;em&gt;The following is the text of Larry Wall&amp;rsquo;s talk at Linux World on Wednesday, March 3.   He explains why Perl is a fitting language for the postmodern era.  As a member of the audience commented: &amp;ldquo;Another mindbender from Larry.&amp;rdquo;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;highlights-which-should-convince-you-to-read-the-text-in-its-entirety&#34;&gt;Highlights (Which Should Convince You To Read the Text in its Entirety)&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;m here to talk about &lt;a href=&#34;#jump1&#34;&gt;why Perl and Linux have both been so successful.&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;I still feel like I have to &lt;a href=&#34;#jump2&#34;&gt;justify Perl all the time to a lot of people&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The Modernist believes in OR more than AND. Postmodernists believe in AND more than OR. &amp;hellip; At least we can use Perl as an example. In Perl, AND has higher precedence than OR does. There you have it. &lt;a href=&#34;#jump3&#34;&gt;That proves Perl is a postmodern language&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;I picked the feature set of Perl because I thought they were cool features. I left the other ones behind because &lt;a href=&#34;#jump4&#34;&gt;I thought they sucked&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;When&amp;rsquo;s the last time you used &lt;a href=&#34;#jump5&#34;&gt;duct tape&lt;/a&gt; on a duct?&lt;/li&gt;
&lt;li&gt;One of the characteristics of a postmodern computer language is that it puts the focus not so much onto the problem to be solved, but rather onto &lt;a href=&#34;#jump6&#34;&gt;the person trying to solve the problem&lt;/a&gt;.&lt;/li&gt;
&lt;li&gt;The very fact that it&amp;rsquo;s possible to write messy programs in Perl is also &lt;a href=&#34;#jump6&#34;&gt;what makes it possible to write programs that are cleaner in Perl&lt;/a&gt; than they could ever be in a language that attempts to enforce cleanliness.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;#jump7&#34;&gt;We&amp;rsquo;re not objective about Perl&lt;/a&gt;, but as postmodernists, we freely admit that we&amp;rsquo;re not objective, and we try to compensate for it when we want people to think we&amp;rsquo;re objective. Or when we want to think ourselves objective. Or, at least, not objectionable.&lt;/li&gt;
&lt;li&gt;We&amp;rsquo;ve actually been &lt;a href=&#34;#jump8&#34;&gt;doing open source for a couple of decades now&lt;/a&gt;. Why is it suddenly taking off now? Why not twenty years ago. Linux could have been written twenty years ago, albeit not by Linus.&lt;/li&gt;
&lt;li&gt;As Heidi would say: &amp;lsquo;&lt;a href=&#34;#jump9&#34;&gt;Tsall good. Except when it sucks&lt;/a&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;hr /&gt;

&lt;p&gt;Thank you all for coming. I was hoping the title of this talk would scare away everyone who shouldn&amp;rsquo;t be here.
Obviously I should have made up a scarier title&amp;hellip;&lt;/p&gt;

&lt;p&gt;Perl meets Godzilla?&lt;/p&gt;

&lt;p&gt;Bambi meets Perl?&lt;/p&gt;

&lt;p&gt;I just did an interview for Feed Magazine. When I read their intro to it, I was interested to see that they made reference to my ``curious speeches.&amp;rdquo; I&amp;rsquo;ll take that as a compliment. Why I take it as a compliment is the subject of this speech. That&amp;rsquo;s assuming this speech actually has a subject, which is still in doubt. Hey, at least it has a title. That&amp;rsquo;s something.&lt;/p&gt;

&lt;p&gt;By the way, I&amp;rsquo;m planning to leave some amount of time at the end for Q and A, so you should start thinking about the Q part while I&amp;rsquo;m talking.&lt;/p&gt;

&lt;p&gt;When I was invited to talk here, it occurred to me that most of the people here would be more interested in Linux than in Perl, so, in the interests of universal harmonic convergence, I thought I should talk about both Perl and Linux. To do that, I had to figure out what Perl and Linux have in common. Besides the obvious, of course.&lt;/p&gt;

&lt;p&gt;Obviously, both Perl and Linux owe a lot to Unix culture, but this is well documented. If I merely pointed out the obvious commonalities, I&amp;rsquo;d have to talk the whole time about things you can find out from the manuals. (Or should I say, things you &lt;em&gt;ought&lt;/em&gt; to be able to find out from the manuals? Whatever.)&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not here today to teach you how to use Perl or Linux. I&amp;rsquo;m not here to teach you what Perl or Linux are.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;jump1&#34;&gt;&lt;/span&gt;I&amp;rsquo;m here to talk about why Perl and Linux have both been so successful. Note that I&amp;rsquo;m measuring success here not so much in terms of numbers of users, but in terms of satisfaction of users.&lt;/p&gt;

&lt;p&gt;So I started thinking about deeper connections between Perl and Linux, and that led me to think more about the deeper reasons for writing software. And that led to the subject of this talk. I&amp;rsquo;m going to start off talking by about postmodernism. After that, I&amp;rsquo;ll switch to talking about postmodernism. And at the conclusion, I&amp;rsquo;ll return to the subject of postmodernism.&lt;/p&gt;

&lt;p&gt;However, since this talk is itself a postmodern work of art, I&amp;rsquo;ll be dragging in all sort of other cool things along the way, so maybe you won&amp;rsquo;t fall asleep.&lt;/p&gt;

&lt;p&gt;Nowadays people are actually somewhat jaded by the term ``postmodern&amp;rdquo;. Well, perhaps jaded is an understatement. Nauseated might be more like it. But, anyway, I still distinctly remember the first time I heard it back in the &amp;lsquo;70s. I think my jaw fell and bounced off the floor several times. To me it was utterly inconceivable that anything could follow modern. Isn&amp;rsquo;t the very idea of ``modern&amp;rdquo; always associated with the ideas ``new&amp;rdquo; and ``now&amp;rdquo;?&lt;/p&gt;

&lt;p&gt;The idea was so inconceivable to me that it took me at least ten seconds to figure it out. Or to think I&amp;rsquo;d figured it out. As a musician, the pat answer occurred to me almost immediately. I was familiar with the periods of music: Baroque, Classical, Romantic, and Modern. Obviously, if there were to be a period of music following the Modern, it would have to be called something other than Modern. And postmodern is as good a name as any, especially since it&amp;rsquo;s a bit of a joke on the ordinary meaning of modern. Obviously the Modern period was misnamed.&lt;/p&gt;

&lt;p&gt;But, as I said, that was the pat answer. The Modern period was not misnamed. True, the ordinary word ``modern&amp;rdquo; is associated with ``new&amp;rdquo; and ``now&amp;rdquo;, but the historical period we call Modern chose to associate itself with the ``new&amp;rdquo; and the ``now&amp;rdquo; in such a deep way that we actually see the breakdown of the whole notion of periods. The Modern period is the period that refuses to die. The world is now an odd mix of the Modern and the postmodern. Oddly, it&amp;rsquo;s not just because the Modern refuses to die, but also because the postmodern refuses to kill the Modern. But then, the postmodern refuses to kill anything completely.&lt;/p&gt;

&lt;p&gt;For example, it&amp;rsquo;s been several decades now since a certain set of Bible translations came out, and you&amp;rsquo;ll notice a pattern: the New English Bible, the New American Standard Bible, and the New International Version, to name a few. It&amp;rsquo;s really funny. I suspect we&amp;rsquo;ll still be calling them ``new this&amp;rdquo; and ``new that&amp;rdquo; a hundred years from now. Much like New College at Oxford. Do you know when New College was founded. Any guesses? New College was new in 1379.&lt;/p&gt;

&lt;p&gt;A couple of days ago I was discussing all this with my daughter on the way to school. As usual, I turned on the radio to hear the news, and Heidi immediately started surfing all the music stations. Since this is one of the perils of fatherhood, I only said, ``I have to talk about postmodernism on Wednesday. What should I say?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;She said, ``Like, it&amp;rsquo;s all about how you don&amp;rsquo;t have justify everything with a reason anymore. You can just put in stuff because you like it, you know, because it&amp;rsquo;s cool. With Modern stuff you always had to justify everything.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;jump2&#34;&gt;&lt;/span&gt;I said, ``I still feel like I have to justify Perl all the time to a lot of people.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;She settled on a station with some interesting music, and said, ``This is Dave Matthews&amp;rsquo; Band. The thing that&amp;rsquo;s really cool about him is that he, like, went out and found all these different artists who have different styles, and combined them all in ways you&amp;rsquo;ve never heard before.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;I said, ``Isn&amp;rsquo;t it interesting how postmodernism has become so much a part of our culture that it&amp;rsquo;s sort of fading into the woodwork?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Heidi frowned and said, ``Dude, dad, it&amp;rsquo;s not like it&amp;rsquo;s some kind of a fad. Postmodernism is deeper than that&amp;ndash;it really is the culmination of everything that went before it. Like, it&amp;rsquo;s all about coming full circle. It&amp;rsquo;s not like we&amp;rsquo;re going to stop wanting to do that next week.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;I said, ``I suspect you&amp;rsquo;re right. After all, the various earlier periods of music were measured in centuries.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;``It&amp;rsquo;s not just music,&amp;rdquo; she said.&lt;/p&gt;

&lt;p&gt;``Well, of course not,&amp;rdquo; I replied, ``all these things go together, but some disciplines change at different rates. The reason I&amp;rsquo;m giving this talk on Wednesday is because I think there&amp;rsquo;s still a big streak of Modernism running through the middle of computer science, and a lot of people are out of touch with their culture. On the other hand, I&amp;rsquo;m not really out to fight Modernism, since postmodernism includes Modernism as just another valid source of ideas. In fact, Perl contains lots of modern ideas from computer science. Along with all the rest of the ideas in there.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Heidi said, ``You wanna know something really funny. In my IMP class, our class slogan is, &amp;lsquo;There&amp;rsquo;s more than one way to do it.&amp;ldquo;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;``You&amp;rsquo;re kidding,&amp;rdquo; I said. [I should also say that that IMP stands for Interactive Math Program, which is a math curriculum in which you sort of learn everything at once. In sort of a postmodern way.] Anyway, I said, ``You&amp;rsquo;re kidding.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;``No,&amp;rdquo; she said, ``That&amp;rsquo;s why IMP is better for math students like me&amp;ndash;we learn better when we can see the big picture, and how everything fits in. The old way of learning math never gave you any context&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;While I was digesting this, and thinking about how it applied to computer science, she went on, ``Well, it&amp;rsquo;s like, you know, we have this saying at school, when somebody gets uptight about something, we say: &amp;lsquo;Tsall good. If someone is depressed, we say: &amp;lsquo;Tsall good.&amp;ldquo;&amp;rsquo;&lt;/p&gt;

&lt;p&gt;``But you don&amp;rsquo;t actually think everything is good, do you?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;``No, of course not.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;``Are you saying that everything has good elements in it?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;``No, Dad, I think when we say that, we&amp;rsquo;re saying that, overall, things are good. Like, look at the big picture, don&amp;rsquo;t just focus in on the two or three bad things that are happening to you right now.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;I report this conversation to you not just because I think my kids are cute and smart, but also because I think it&amp;rsquo;s important that we know where our culture is going, and because it&amp;rsquo;s our kids that will shape our culture in the future. I don&amp;rsquo;t think I could have defined postmodernism better than Heidi. Look at the big picture. Don&amp;rsquo;t focus in on two or three things to the exclusion of other things. Keep everything in context. Don&amp;rsquo;t go out of your way to justify stuff that&amp;rsquo;s obviously cool. Don&amp;rsquo;t ridicule ideas merely because they&amp;rsquo;re not the latest and greatest. Pick your own fashions. Don&amp;rsquo;t let someone else tell you what you should like. &amp;lsquo;Tsall good.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all well and good, but I ask you, if it&amp;rsquo;s all good, why, in every other breath, does my daughter say ``That sucks.&amp;ldquo;?&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a mystery here, and if we can fathom it, perhaps we&amp;rsquo;ll learn a thing or two. I think that what&amp;rsquo;s going on here is that our culture has undergone a basic shift, one that is actually healthy. It used to be that we evaluated everything and everyone based on reputation or position. And the basic underlying assumption was that we all had to agree whether something (or someone) was good or bad. Most of us actually used to believe in monoculturalism. Although even back then, we didn&amp;rsquo;t really practice it. And in fact, you could argue that the whole point of Modernism was to &lt;em&gt;break&lt;/em&gt; our cultural assumptions. We could argue all day long about whether postmodernism came about because Modernism succeeded or because it failed. As a postmodern myself, I take both sides. To some extent.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;jump3&#34;&gt;&lt;/span&gt;This would bother a Modernist, because a Modernist has to decide whether this is true OR that is true. The Modernist believes in OR more than AND. Postmodernists believe in AND more than OR. In the very postmodern Stephen Sondheim musical, _Into the Woods_, one of the heroines laments, ``Is it always or, and never and?&amp;rdquo; Of course, at the time, she was trying to rationalize an adulterous relationship, so perhaps we&amp;rsquo;d better drop that example. Well, hey. At least we can use Perl as an example. In Perl, AND has higher precedence than OR does. There you have it. That proves Perl is a postmodern language.&lt;/p&gt;

&lt;p&gt;But back to the monoculturism of Modernism, or rather the assumption of monoculturalism. Nowadays we&amp;rsquo;ve managed to liberate ourselves from that assumption, by and large (where by and large doesn&amp;rsquo;t yet include parts of the Midwest). This has had the result that we&amp;rsquo;re actually free to evaluate things (and people) on the basis of what&amp;rsquo;s actually good and what&amp;rsquo;s actually bad, rather than having to take someone&amp;rsquo;s word for it.&lt;/p&gt;

&lt;p&gt;More than that, we&amp;rsquo;re &lt;em&gt;required&lt;/em&gt; to make individual choices, the assumption being that not everyone is going to agree, and that not everyone should be required to agree. However, in trade for losing our monoculturalism, we are now required to discuss things. We&amp;rsquo;re not required to agree about everything, but we are required to at least agree to disagree. Since we&amp;rsquo;re required to discuss things, this has the effect that we tend to ``deconstruct&amp;rdquo; the things we evaluate. I&amp;rsquo;ll talk more about the pros and cons of deconstructionism in a bit, but let me just throw out an example to wake you up.&lt;/p&gt;

&lt;p&gt;The most deconstructed man on the planet right now is Bill Clinton. The public, and later the Senate, chose to evaluate Bill Clinton&amp;rsquo;s morality separately from Clinton&amp;rsquo;s fitness to govern. I&amp;rsquo;m not going to comment on whether I agree with that decision, but I&amp;rsquo;d just like to point out that this could not have happened thirty or forty years ago. We were not postmoderns back then. We had to have a whole president, or no president, so  hanky panky going on back then as there is now). Everything used to be in black and white, like our TVs. We kept our presidents looking good until we got one we couldn&amp;rsquo;t make look good, and then everyone switched to making the president look bad for a while. But we never did deconstruct Nixon the way we&amp;rsquo;ve deconstructed all the presidents since Nixon. Nixon is still monolithic, even though we&amp;rsquo;ve managed to bypass him and deconstruct Kennedy in hindsight. Perhaps it&amp;rsquo;s all related to the saying that ``Beauty is skin deep, but ugly goes right to the bone.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;If that&amp;rsquo;s the case, I pity the person who&amp;rsquo;s only skin and bones.&lt;/p&gt;

&lt;p&gt;Now you may be wondering what all this has to do with Perl. So am I. I&amp;rsquo;ll think of something presently.&lt;/p&gt;

&lt;p&gt;Time passes&amp;hellip;&lt;/p&gt;

&lt;p&gt;While I&amp;rsquo;m thinking about the next thing to say in my talk, let me say a bit more about deconstructionism. I do not view deconstructionism as a form of postmodernism so much as I view deconstructionism as the bridge between Modernism and postmodernism. Modernism, as a form of Classicalism, was always striving for simplicity, and was therefore essentially reductionistic. That is, it tended to take things to pieces. That actually hasn&amp;rsquo;t changed much. It&amp;rsquo;s just that Modernism tended to take one of the pieces in isolation and glorify it, while postmodernism tries to show you all the pieces at once, and how they relate to each other.&lt;/p&gt;

&lt;p&gt;For instance, this talk. If this were a Modern talk, I&amp;rsquo;d try to have one major point, and drive it into the ground with many arguments, all coherently arranged. Instead, however, I let you see that there&amp;rsquo;s a progression in my own thought process as I&amp;rsquo;m writing. I would pause in my talk at the same point that I paused in my thought process. If I were a journalist, I&amp;rsquo;d spend as much time talking about my angst in covering the story as I&amp;rsquo;d spend covering the actual story. And if I were building a building instead of writing a talk, I&amp;rsquo;d let the girders and ductwork show. These are all forms of deconstructionism.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m still trying to think about how this relates to Perl, by the way.&lt;/p&gt;

&lt;p&gt;More time passes&amp;hellip;&lt;/p&gt;

&lt;p&gt;I first heard about postmodernism in the late &amp;lsquo;70s at Seattle Pacific University from my wife&amp;rsquo;s Lit Crit professor, Dr. Janet Blumberg. Postmodernism came early to literature, so it&amp;rsquo;s no surprise that we heard it first from a literary critic. By the way, don&amp;rsquo;t think of literary critics like you think of theatre critics. Literary critics usually know what they&amp;rsquo;re talking about.&lt;/p&gt;

&lt;p&gt;Even if they&amp;rsquo;re wrong.&lt;/p&gt;

&lt;p&gt;Anyway, we heard it first from Dr. Blumberg, who was never wrong, so naturally we first thought about in in terms of literature. In fact, most people still think of postmodernism as a kind of weird literature. But postmodernism was also coming along in architecture too, as we were soon to find out. Seattle Pacific was wanting to build a new science and math building, so they decided to recycle an old warehouse down by the ship canal. Note the first element of postmodernism there&amp;ndash;they were reusing something old, taking the good parts, and leaving behind the bad parts, though they probably didn&amp;rsquo;t say to themselves, ``This rules,&amp;rdquo; or ``That sucks.&amp;rdquo; But I&amp;rsquo;m sure they &lt;em&gt;thought&lt;/em&gt; it. Anyway, they combined the old with modern ideas about having a large open lab inside, and making the whole building solar heated. They made it a comfy place at the same time, with a sunken study area containing sofas. And they made all the girders and ductwork show, because they thought it was cool. They also did it because it was postmodern, though they didn&amp;rsquo;t know that yet.&lt;/p&gt;

&lt;p&gt;I think I know now how this relates to Perl.&lt;/p&gt;

&lt;p&gt;When I started writing Perl, I&amp;rsquo;d actually been steeped in enough postmodernism to know that that&amp;rsquo;s what I wanted to do. Or rather, that I wanted to do something that would turn out to be postmodern, because you can&amp;rsquo;t actually do something postmodern, you can only really do something cool that turns out to be postmodern. Hmm. Do I really believe that? I dunno. Maybe. Sometimes. You may actually find this difficult to believe, but I didn&amp;rsquo;t actually set out to write a postmodern talk. I was just going to talk about how Perl is postmodern. But it just kind of happened. So you get to see all the ductwork.&lt;/p&gt;

&lt;p&gt;Anyway, back to Perl. When I started designing Perl, I explicitly set out to deconstruct all the computer languages I knew and recombine or reconstruct them in a different way, because there were many things I liked about other languages, and many things I disliked. I lovingly reused features from many languages. (I suppose a Modernist would say I stole the features, since Modernists are hung up about originality.) Whatever the verb you choose, I&amp;rsquo;ve done it over the course of the years from C, sh, csh, grep, sed, awk, Fortran, COBOL, PL/I, BASIC-PLUS, SNOBOL, Lisp, Ada, C++, and Python. To name a few. To the extent that Perl rules rather than sucks, it&amp;rsquo;s because the various features of these languages ruled rather than sucked.&lt;/p&gt;

&lt;p&gt;But note something important here. I left behind more than I took. A lot more. In modern terms, there was a lot of stuff that sucked. Now, on the feature set issue, Perl is always getting a lot of bad press.&lt;/p&gt;

&lt;p&gt;I think people who give bad press to Perl&amp;rsquo;s feature set should have more angst about their reporting.&lt;/p&gt;

&lt;p&gt;&lt;span id=&#34;jump4&#34;&gt;&lt;/span&gt;I picked the feature set of Perl because I thought they were cool features. I left the other ones behind because I thought they sucked.&lt;/p&gt;

&lt;p&gt;More than that, I combined these cool features in a way that makes sense to me as a postmodern linguist, not in a way that makes sense to the typical Modernistic computer scientist. Recall that the essence of Modernism is to take one cool idea and drive it into the ground. It&amp;rsquo;s not difficult to look at computer languages and see which ones are trying to be modern by driving something into the ground. Think about Lisp, and parentheses. Think about Forth, and stack code. Think about Prolog, and backtracking. Think about Smalltalk, and objects. (Or if you don&amp;rsquo;t want to think about Smalltalk, think about Java, and objects.)&lt;/p&gt;

&lt;p&gt;Think about Python, and whitespace. Hi, Guido.&lt;/p&gt;

&lt;p&gt;Or think about shell programming, and reductionism. How many times have we heard the mantra that a program should do one thing and do it well?&lt;/p&gt;

&lt;p&gt;Well&amp;hellip;Perl does one thing, and does it well. What it does well is to integrate all its features into one language. More importantly, it does this without making them all look like each other. Ducts shouldn&amp;rsquo;t look like girders, and girders shouldn&amp;rsquo;t look like ducts. Neither of those should look like water pipes, and it&amp;rsquo;s really important that water pipes not look like sewer pipes. Or smell like sewer pipes. Modernism says that we should make all these things look the same (and preferably invisible). Postmodernism says it&amp;rsquo;s okay for them to stick out, and to look different, because a duct ought to look like a duct, and a sewer pipe ought to look like a sewer pipe, and hammer ought to look like a hammer, and a telephone ought to look like either a telephone, or a Star Trek communicator. Things that are different should look different.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ve all heard the saying: If all you have is a hammer, everything starts to look like a nail. That&amp;rsquo;s actually a Modernistic saying. The postmodern version is: If all you have is duct tape, everything starts to look like a duct. Right. &lt;span id=&#34;jump5&#34;&gt;&lt;/span&gt;When&amp;rsquo;s the last time you used duct tape on a duct?&lt;/p&gt;

&lt;p&gt;The funny thing is, Modernism itself was a kind of hammer, and it made everything look like something to be hammered. The protest movement of the &amp;lsquo;60s was Modernistic: ``If I had a hammer, I&amp;rsquo;d hammer all over this land.&amp;rdquo; The focus was always on the nail, or on whatever it was that was getting pounded. And many things did get hammered in the Modern age. Architectural beauty, for one. That one is obvious just by looking at the skyline of any major city. It&amp;rsquo;s easy to tell which buildings were built in the 50&amp;rsquo;s and 60&amp;rsquo;s. They&amp;rsquo;re the ones that look like boxes. When we first saw them, we thought they looked very modern. Well, they did. But when the Seattle First National Bank was built in, you guessed it, Seattle, we all made jokes about how it looked like the box the Space Needle came in. At least the Space Needle was cute, kinda like the Jetsons were cute. But the Space Needle wasn&amp;rsquo;t really very functional, unless you go in for rotating restaurants.&lt;/p&gt;

&lt;p&gt;In fact, at many different levels, Modernism brought us various kinds of &lt;em&gt;dysfunction&lt;/em&gt;. Every cultural institution took a beating. Government took a beating. Schools took a beating. Certainly the family took a beating. Everyone took a beating, because Modernism was about attacking problems. Modernism was the hammer. (I&amp;rsquo;d like to make a pun on hammer and sickle here, but I&amp;rsquo;m not sure what it would be. Certainly Russia was more hammered than we were by Modernism, in the cloak of Marxism. I know what it means to be hammered, but I&amp;rsquo;m still trying to figure out what it would mean to be more sickled. Hmm. Unless that&amp;rsquo;s talking about the Grim Reaper. Russia has a lot of experience with that too.) Anyway, back to our talk. Modernism oversimplifies. Modernism puts the focus squarely on the hammer and the nail.&lt;/p&gt;

&lt;p&gt;In contrast, postmodernism puts the focus back onto the carpenter. You&amp;rsquo;ll note that carpenters are allowed to choose whether or not to use hammers. They can use saws and tape measures if they choose, too. They have some amount of free will in the matter. They&amp;rsquo;re allowed to be creative. Especially if they&amp;rsquo;re working on Mrs. Winchester&amp;rsquo;s house. Hey, it&amp;rsquo;s right down the road, if you don&amp;rsquo;t believe me.&lt;/p&gt;

&lt;p&gt;So, to drag the subject back to computers, &lt;span id=&#34;jump6&#34;&gt;&lt;/span&gt;one of the characteristics of a postmodern computer language is that it puts the focus not so much onto the problem to be solved, but rather onto the person trying to solve the problem. I claim that Perl does that, and I also claim that, on some level or other, it was the first computer language to do that. I&amp;rsquo;d also like to claim that, in many ways, it&amp;rsquo;s still the only language to do that.&lt;/p&gt;

&lt;p&gt;How does Perl put the focus onto the creativity of the programmer? Very simple. Perl is humble. It doesn&amp;rsquo;t try to tell the programmer how to program. It lets the programmer decide what rules today, and what sucks. It doesn&amp;rsquo;t have any theoretical axes to grind. And where it has theoretical axes, it doesn&amp;rsquo;t grind them. Perl doesn&amp;rsquo;t have any agenda at all, other than to be maximally useful to the maximal number of people. To be the duct tape of the Internet, and of everything else. You&amp;rsquo;ve heard the joke, I&amp;rsquo;m sure. How is duct tape like the Force? It has a light side, and a dark side, and it holds the universe together. Later in this talk, I intend to define the universe and give three examples.&lt;/p&gt;

&lt;p&gt;I have to be honest here. I&amp;rsquo;m with Linus&amp;ndash;I personally want to take over the world. I want to take over the world because I&amp;rsquo;m an egomaniac. A nice sort of egomaniac, an egomaniac moderated by belief in the value of humility, but an egomaniac nonetheless.&lt;/p&gt;

&lt;p&gt;Fortunately, I am not Perl. Perl was my servant before it was anyone else&amp;rsquo;s, so I taught Perl to be a better servant than I could ever teach myself to be. Perl is like the perfect butler. Whatever you ask Perl to do, it says ``Very good, sir,&amp;rdquo; or ``Very good, madam.&amp;rdquo; Only occasionally does Perl give you a stiff upper lip, or say ``Tsk, tsk.&amp;rdquo; But if you ask Perl its opinion, it will advise you on matters of taste. ``I&amp;rsquo;m sorry sir, but bareword &amp;lsquo;foo&amp;rsquo; is not allowed while &amp;lsquo;strict subs&amp;rsquo; is in use.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Contrast that with the Modern idea of how a computer should behave. It&amp;rsquo;s really rather patronizing: ``I&amp;rsquo;m sorry Dave. I can&amp;rsquo;t allow you to do that.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;The trouble with having a submissive servant is that it puts the burden back on you to make the decisions. Come to think of it, that&amp;rsquo;s the problem with having a submissive wife too. My wife is very submissive. She&amp;rsquo;s always saying, ``I submit this problem to you because I don&amp;rsquo;t want to decide it.&amp;rdquo; Ah, well.&lt;/p&gt;

&lt;p&gt;If the burden of decision making is on the programmer, then it&amp;rsquo;s possible for the programmer to make a mess of things. It&amp;rsquo;s possible for Perl programmers to write messy programs. (In case you hadn&amp;rsquo;t noticed.) It&amp;rsquo;s also possible for Perl programmers to write extremely clean, concise, and beautiful programs.&lt;/p&gt;

&lt;p&gt;Let me state my beliefs about this in the strongest possible way. The very fact that it&amp;rsquo;s possible to write messy programs in Perl is also what makes it possible to write programs that are cleaner in Perl than they could ever be in a language that attempts to enforce cleanliness. The potential for greater good goes right along with the potential for greater evil. A little baby has little potential for good or evil, at least in the short term. A President of the United States has tremendous potential for both good and evil.&lt;/p&gt;

&lt;p&gt;I do not believe it is wrong to aspire to greatness, if greatness is properly defined. Greatness does not imply goodness. The President is not intrisically ``gooder&amp;rdquo; than a baby. He merely has more options for exercising creativity, for good or for ill.&lt;/p&gt;

&lt;p&gt;True greatness is measured by how much freedom you give to others, not by how much you can coerce others to do what you want. I remember praying a prayer when I was very young, not much more than a baby myself. ``God is great. God is good. Let us thank him for our food. Amen.&amp;rdquo; Well, I&amp;rsquo;m here to say amen to that. God&amp;rsquo;s greatness and goodness are measured by the fact that he gives us choices. He doesn&amp;rsquo;t require us to thank him for our food. (In case you hadn&amp;rsquo;t noticed.) God is not a Modernist. He doesn&amp;rsquo;t view us as nails. God expects us to behave like carpenters. Indeed, he gave us a carpenter as an example.&lt;/p&gt;

&lt;p&gt;So I think God is postmodern. He has his own ideas of what rules, and what sucks, and he doesn&amp;rsquo;t expect everyone else to agree with him. Mind you, he &lt;em&gt;likes&lt;/em&gt; it when people agree with him. I like it when people agree with me about Perl. But I don&amp;rsquo;t expect everyone to agree with me. Of course, some of my loyal followers expect everyone to agree with me. I try to think of it as an endearing characteristic. Personally, I think the Perl slogan, There&amp;rsquo;s More Than One Way To Do It, applies outside of Perl as well as inside. I explicitly give people the freedom &lt;em&gt;not&lt;/em&gt; to use Perl, just as God gives people the freedom to go to the devil if they so choose.&lt;/p&gt;

&lt;p&gt;As long as we&amp;rsquo;re in a demonizing frame of mind, please allow me to demonize Modernism a little more. True, postmodernism admits Modernism as one source of inspiration, along with Romanticism, Classicalism, and, er, uh, Baroqueism. Baroqueness? I always thinks it&amp;rsquo;s a compliment when someone says Perl is baroque. I just think of J.S. Bach. He wrote a lot of way cool stuff. Handel also had his moments.&lt;/p&gt;

&lt;p&gt;Anyway, back to Modernism. Postmodernism does draw some inspiration from Modernism. And, in fact, postmodernism could not have come about without Modernism before it, because deconstructionism is simultaneously Modern and postmodern, being both reductionistic and holistic. Be that as it may, Postmodernism has deconstructed Modernism and determined that large parts of it suck. In religious terms, Modernism can be viewed as a series of cults. And postmodernism is defined as an escape from those cults. A kind of deprogramming, if you will. Perhaps the title of this talk should have been, ``Perl, the first postmodern DEprogramming language&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;We won&amp;rsquo;t go into the fact that ``Perl culture&amp;rdquo; sometimes gets shortened to ``Perl cult&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;I have to give credit where credit is due here. And to show my ductwork. I didn&amp;rsquo;t think of all this myself. I was flying up to Seattle with my wife and my daughter (yes, that one) because my daughter is thinking about attending Seattle Pacific University, that hotbed of subversive postmodernism. Surprise, surprise. So I asked my wife about the differences between Modernism and postmodernism. After all, one has to talk about &lt;em&gt;something&lt;/em&gt; with one&amp;rsquo;s spouse.&lt;/p&gt;

&lt;p&gt;Especially in front of one&amp;rsquo;s daughter.&lt;/p&gt;

&lt;p&gt;Before I get into the list of Modernistic cults, though, I just remembered another cute story about Seattle Pacific. The school had commissioned a Modern Artist to produce a Modern Art, you know the kind, a sculpture, if you can call it that, to be placed on the lawn out in front of student union building, on the corner of campus where anyone driving by could see it. It was most definitely Modern. It consisted of two large black surfaces, partly rounded and partly square, leaning against each other. It was actually rather hideous. You know the sort.&lt;/p&gt;

&lt;p&gt;Well, one day we noticed that the large sculpture had had babies. There were seven or eight of the cute little beggars, perfect little replicas huddling around their mommy. It was wonderful. It was precious. It was funny. At least, it was funny until the Modern Artist came storming in and, with no sense of humor at all, removed his work of art, threatening never to have anything to do with Seattle Pacific again. Good riddance, we thought. And smiled. We&amp;rsquo;re still smiling. In case you hadn&amp;rsquo;t noticed.&lt;/p&gt;

&lt;p&gt;Anyway, back to cults. The story I just told is illustrative of several of them. First of all, we have the Cult of Spareness. The example of Modern Art I just mentioned was very spare. It was minimalistic. It was almost an artless Art. Certainly the emotion it was trying to instill was something akin to hammering. We felt like nails.&lt;/p&gt;

&lt;p&gt;Many modern computer languages aspire to be minimalistic. They either succeed in being minimalistic, in which case they&amp;rsquo;re relatively useless, or they don&amp;rsquo;t succeed in being truly minimalistic, in which case you can actually solve real problems with them. A number of languages give lip service to the idea of minimalism, but merely sweep the complexity of the problem under the carpet of the programmer. C is a minimalistic language, but only if you don&amp;rsquo;t count all the libraries that are necessary to use it usefully. C++ is obviously not trying to be minimalistic. Unix is considered by some to be a minimalistic operating system, but the fact of the matter is that if you think of Unix as a programming language, it&amp;rsquo;s far richer than even Perl. Perl is, by and large, a digested and simplified version of Unix. Perl is the Cliff Notes of Unix.&lt;/p&gt;

&lt;p&gt;Unix (and by extension Linux) are really simultaneously Modern and postmodern. Unix philosophy is supposedly reductionistic, and minimalistic. But instead of being Modernistic, Unix is actually deconstructionistic. The saving grace of deconstructionism is that it is also reconstructionism. When you&amp;rsquo;ve broken everything down into bits, you&amp;rsquo;re required to put them back together again a different way. In order to solve real problems, Unix requires you not only to be reductionistic, but also holistic. It&amp;rsquo;s no accident that the ductwork shows in shell scripts. Only we call them pipes.&lt;/p&gt;

&lt;p&gt;Postmodernism isn&amp;rsquo;t afraid of ornamentation, because postmodernism is a retreat from classicalism back to romanticism. That particular pendulum is quite periodic. The Classical and Modern periods of art identified beauty with simplicity. The Baroque and Romantic periods of art identified beauty with complexity. I think it&amp;rsquo;s an interesting synchronicity that, even as our art is becoming more complex again, science is also discovering beauty in complexity theory. Perhaps it&amp;rsquo;s more than a synchronicity. Just as Modern art had exhausted the possibilities of bigger hammers, so had science. In short, we&amp;rsquo;d been oversimplifying for too long, and hence couldn&amp;rsquo;t see the simplicity within the complexity of a leaf. I would like to tell you that Perl is simple in its complexity. But some people won&amp;rsquo;t understand that. So pretend I didn&amp;rsquo;t say that, unless you do.&lt;/p&gt;

&lt;p&gt;I could go on about simplicity, but let&amp;rsquo;s move on to the next cult. Modernism is also a Cult of Originality. It didn&amp;rsquo;t matter if the sculpture was hideous, as long as it was original. It didn&amp;rsquo;t matter if there was no music in the music. Plagiarism was the greatest sin. To have your work labeled ``pastiche&amp;rdquo; was the worst insult. The only artistic endeavor in the Modern period not to suffer greatly from the Cult of Originality was architecture. Architecture went in for simplicity and functionalism instead. With the notable exception of certain buildings that were meant to look like Modern art, usually because they contained Modern art. Odd how that happens.&lt;/p&gt;

&lt;p&gt;The Cult of Originality shows up in computer science as well. For some reason, many languages that came out of academia suffer from this. Everything is reinvented from first principles (or in some cases, zeroeth principles), and nothing in the language resembles anything in any other language you&amp;rsquo;ve ever seen. And then the language designer wonders why the language never catches on.&lt;/p&gt;

&lt;p&gt;No computer language is an island, either.&lt;/p&gt;

&lt;p&gt;In case you hadn&amp;rsquo;t noticed, Perl is not big on originality. Come to think of it, neither is Linux. Does this bother you? Good, perhaps our culture really is getting to be more postmodern.&lt;/p&gt;

&lt;p&gt;The next cult on the hit parade is the Cult of Seriousness. Recall how seriously our Modern Artist took himself and his art. He was unable to laugh at himself.&lt;/p&gt;

&lt;p&gt;I find that there are a certain number of humorless people who don&amp;rsquo;t appreciate, um, humor. There is a small but steady drizzle of messages into O&amp;rsquo;Reilly &amp;amp; Associates from people who are offended by the fact that my book, the Camel book, contains jokes. It&amp;rsquo;s really quite funny reading the messages from these people. It reminds me of the time I was sitting in a theatre in Palo Alto. It was intermission, and we were in the middle of watching a hilarious play about a dysfunctional family. You know, kind of like a sitcom, only done right. The audience just roared throughout the first act. Anyway, at intermission, this older guy with a deep, gruff voice behind me says to his wife, in all seriousness, ``I don&amp;rsquo;t see what&amp;rsquo;s so funny. It&amp;rsquo;s just like an ordinary family.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;I confess, I had to cover my mouth with my hands to keep from guffawing like Tom Christiansen. That&amp;rsquo;s got to be one of the funniest things I&amp;rsquo;ve ever heard. Well, maybe you had to be there.&lt;/p&gt;

&lt;p&gt;Postmodernism is not afraid to laugh at itself. It&amp;rsquo;s not afraid of cute, and it&amp;rsquo;s not afraid of funky, and it&amp;rsquo;s not afraid of what a Modernist would call kitsch. You know, it&amp;rsquo;s actually kind of liberating to be going down the road, and be able to yell, ``New buggie! Pea soup green.&amp;rdquo; Postmoderns aren&amp;rsquo;t afraid to be nostalgic about old slug bugs, either. Sentimentality is cool, if you&amp;rsquo;re into that sort of thing. Retro rules. Unless it rocks. I don&amp;rsquo;t know if sentimentality rules or rocks, but&amp;rsquo;s it&amp;rsquo;s definitely cool.&lt;/p&gt;

&lt;p&gt;As Heidi would say, ``Dude, I&amp;rsquo;m stoked.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll notice I keep talking about my wife and my daughter. In case you hadn&amp;rsquo;t noticed. The Modernist would of course explain to you that I was resorting to cheap sentimental tricks to try to establish an emotional bond with my audience. A postmodernist would, of course, agree. But the postmodernist will point out that cheap tricks are less expensive than costly tricks. Showing your ductwork is usually cheaper than hiding it. Even if it&amp;rsquo;s not cheaper, it&amp;rsquo;s certainly more entertaining. I certainly find the Iron Chef entertaining. That&amp;rsquo;s definitely a postmodern show. There&amp;rsquo;s lots of cool stuff on TV these days. My daughter enjoys Daria, because it&amp;rsquo;s so cynical about everything, including itself. And if you&amp;rsquo;d like to see an unashamedly postmodern anime, you should get ahold of Revolutionary Girl Utena.&lt;/p&gt;

&lt;p&gt;Well, enough of that. Let&amp;rsquo;s see what&amp;rsquo;s next in our talk. Oh, oh, here comes a biggie. The Cult of Objectivity.&lt;/p&gt;

&lt;p&gt;You know, Modernism tried. It tried real hard. It really, really tried. It tried to get rid of conventions. It thought it got rid of conventions. But all it really did was make its conventions invisible. At least to itself.&lt;/p&gt;

&lt;p&gt;Reductionists often feel like they&amp;rsquo;re being objective. But the problem with reductionism is that, once you&amp;rsquo;ve split your universe into enough pieces, you can&amp;rsquo;t keep track of them any more. Psychologists tell us that the human mind can only keep track of about about seven objects, plus or minus two. That&amp;rsquo;s for short-term memory. It gets both worse and better for long-term memory, but the principle still stands. If you lose track of something, it&amp;rsquo;s because you thought it was less important, and didn&amp;rsquo;t think about it often enough to remind yourself. This is what happened to Modernists in literature. They&amp;rsquo;ve forgotten what&amp;rsquo;s important about literature.&lt;/p&gt;

&lt;p&gt;Note how we still periodically hear the phrase ``serious literature&amp;rdquo;. This is literature that is supposedly about Real Life. Let me tell you something. The most serious literature I&amp;rsquo;ve ever read is by Lois McMaster Bujold. Any of you read her? It&amp;rsquo;s also the funniest literature I&amp;rsquo;ve ever read. It&amp;rsquo;s also space opera. ``Genre fiction,&amp;rdquo; sneers the Modernist. Meaning it follows certain conventions. So what? Nobody in the world can mix gravity and levity the way Bujold does in her Vorkosigan books. It&amp;rsquo;s oh so definitely about real life. So what if it follows space opera conventions. Sonnets follow certain conventions too, but I don&amp;rsquo;t see them getting sneered at much these days. Certainly they were always called ``serious&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;How long till Bujold becomes required reading in high school? Far too long, in my opinion. Horrors. We wouldn&amp;rsquo;t want our students actually enjoying what they read. It&amp;rsquo;s not&amp;ndash;it&amp;rsquo;s not Real Life.&lt;/p&gt;

&lt;p&gt;As if the Lord of the Flies is real life. Feh.&lt;/p&gt;

&lt;p&gt;Perl programming is unabashedly genre programming. It has conventions. It has culture. Perl was the first computer language whose culture was designed for diversity right along with the language. &lt;span id=&#34;jump7&#34;&gt;&lt;/span&gt;We&amp;rsquo;re not objective about Perl, but as postmodernists, we freely admit that we&amp;rsquo;re not objective, and we try to compensate for it when we want people to think we&amp;rsquo;re objective. Or when we want to think ourselves objective. Or, at least, not objectionable.&lt;/p&gt;

&lt;p&gt;Or, at least, not object-oriented.&lt;/p&gt;

&lt;p&gt;I would like to say one thing here about objectivity, however. While I despise the Modern Cult of Objectivity, I also despise the quasi-postmodern Cult of Subjectivity. I call it absolute cultural relativism. It&amp;rsquo;s the notion that everything is as good as everything else, because goodness is only a matter of opinion. It&amp;rsquo;s like claiming that the only thing you can know absolutely is that you can&amp;rsquo;t know anything absolutely. I think this is really just another form of Modernism, a kind of existentialism really, though unfortunately it&amp;rsquo;s come to be associated with postmodernism. But I think it sucks.&lt;/p&gt;

&lt;p&gt;The funny thing is, it&amp;rsquo;s almost right. It&amp;rsquo;s very close to what I do, in fact, believe. I&amp;rsquo;d go so far as to call myself a strong postmodernist. Strong postmodernism says that all truth is created. But this really isn&amp;rsquo;t a problem for anyone who believes in a Creator. All truths are created relative, but some are more relative than others. A universal truth only has to be true about our particular universe, so to speak. It doesn&amp;rsquo;t much matter whether the universe itself is true or false, just as long as it makes a good story. And I think our universe does make a good story. I happen to like the Author.&lt;/p&gt;

&lt;p&gt;I like Lois McMaster Bujold too, so I read her stories. Same for Tolkien, and C.S. Lewis. Turning that around, some people use Perl because they like me. Who am I to argue with them? You&amp;rsquo;re all totally objective about Linus and Linux, right? Uh, huh. Three cheers for objectivity.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m getting tired of talking about cults, and you&amp;rsquo;re probably getting tired of listening to me talk about cults. However, I want to talk about the open source phenomenon now, and I&amp;rsquo;m afraid I&amp;rsquo;ll have to drag the cults in occasionally. But fear not. I think the open source movement is, actually, a postmodern movement.&lt;/p&gt;

&lt;p&gt;Think about it. &lt;span id=&#34;jump8&#34;&gt;&lt;/span&gt;We&amp;rsquo;ve actually been doing open source for a couple of decades now. Why is it suddenly taking off now? Why not twenty years ago. Linux could have been written twenty years ago, albeit not by Linus.&lt;/p&gt;

&lt;p&gt;Of course there are lots of mundane reasons why Linux wasn&amp;rsquo;t written twenty years ago, not the least of which is that we didn&amp;rsquo;t really have the ubiquitous, cheap hardware to support it yet. Nor did we have the networking to support cooperative development. But since this is a philosophical talk, I&amp;rsquo;ll ignore reality and talk about what I think was really going on. Here&amp;rsquo;s where the cults come back in again.&lt;/p&gt;

&lt;p&gt;The Cult of Spareness decreed that we should all use the same operating system. Of course, everyone had their own idea of what that was, but Bill Gates actually had the most success in carrying out the decree. For which he is now on trial, where he may eventually have to consent to a consent decree. All in all, it&amp;rsquo;s been a bad year to be named Bill. The wolves are circling, and waiting for further signs of weakness, and everyone&amp;rsquo;s hedging their bets by attending LinuxWorld, and making sure the press know it.&lt;/p&gt;

&lt;p&gt;Meanwhile, back on the Unix side of the universe, The Cult of Originality decreed that, if you were going to work on something, it had to be something new. Reimplementing an open source Unix would have been laughable, especially since any university could get the sources to Unix anyway for next to nothing. When other companies besides Ma Bell figured out that they should have an implementation of Unix, they all had to make it different enough that they could distinguish themselves in the marketplace. That is, what they wrote had to be original.&lt;/p&gt;

&lt;p&gt;The Cult of Seriousness decreed that everyone had to keep their source code hidden, because other people might laugh at how bad our code is, and make us fix it. Or worse, someone might steal our bad code and make it better. Then we would be out of business, and Life is Serious Business. A peek at the source code for Unix is obviously worth $100,000, because we can get that much for it. Programming for the fun of it? Get real!&lt;/p&gt;

&lt;p&gt;Finally, the Cult of Objectivity decreed that the way we always did business was obviously the only way to do business. Our culture is the only possible culture. There are no social conventions here. These aren&amp;rsquo;t the droids you&amp;rsquo;re looking for. Move along.&lt;/p&gt;

&lt;p&gt;In short, think about what it takes to put together an open source project such as Linux or Perl. You need a lot of people who think programming is serious fun. You need a culture of sharing, which is just the flip side of a culture in which you can borrow things without shame. You need people who have been hammered into dysfunctionality &lt;em&gt;long&lt;/em&gt; enough that they&amp;rsquo;re looking for new ways to form communities. You need people who are willing to be partisan on behalf of their chosen culture, while remaining sufficiently non-partisan to keep in touch with the rest of the world. It&amp;rsquo;s no fun to create a new culture and then cut it off from the rest of humanity. No, the fun thing is to try to persuade others to share your opinions about what rules and what sucks. Nothing is more fun than evangelism.&lt;/p&gt;

&lt;p&gt;There are two kinds of joiners in the world. Think of it in terms of anthropology. There are the kinds of people who join a tribe, and kind of get sucked in, like a black hole. That&amp;rsquo;s the last you hear from them, unless you happen to be in the black hole with them. And we need people like this in our tribes, if only to be cheerleaders.&lt;/p&gt;

&lt;p&gt;But the open source movement is energized by the other sort of joiner. This sort of person joins many tribes. These are the people who inhabit the intersections of the Venn diagrams. They believe in ANDs rather than ORs. They&amp;rsquo;re a member of more than one subset, more than one tribe. The reason these people are important is, just like merchants who go between real tribes, they carry ideas from one intellectual tribe to another. I call these people ``glue people&amp;rdquo;, because they not only join themselves to a tribe, they join tribes together. Twenty years ago, you couldn&amp;rsquo;t easily be a glue person, because our culture was not yet sufficiently accepting of diversity. It was also not accepting of information sharing. If you got sucked in by Bell Labs, you might get out to the occasional Usenix, but that was about it. If you got sucked in by the NSA, nobody ever heard from you again. Come to think of it, that&amp;rsquo;s still true.&lt;/p&gt;

&lt;p&gt;Still and all, things have improved greatly, and the bridges across the gaps have gotten sturdier. Now people can send their memes across a wider chasms without getting crucified on one end of the bridge or the other. And as we started sending these memes across the chasms, what we discovered was that we didn&amp;rsquo;t have a bunch of separate open source movements, but rather a single big open source movement. To be sure, it&amp;rsquo;s a fuzzy, postmodern sort of movement, with lots of diversity, and a certain amount of turmoil, but it&amp;rsquo;s about as good as any movement gets these days. We all suck at slightly different things, but we&amp;rsquo;re in basic agreement that the old way of business sucked a lot worse that whatever it is we&amp;rsquo;re doing now. We&amp;rsquo;ve agreed to agree. Except when we don&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;That sounds like it ought to be the end of my talk, but I still have a bunch of things to say, so I&amp;rsquo;ll just keep going. Who knows, maybe it&amp;rsquo;ll relate.&lt;/p&gt;

&lt;p&gt;The other day, I was talking to a glue person whose name is Sharon Hopkins. Among other things, she&amp;rsquo;s known as the Perl Poet, because she&amp;rsquo;s written more poetry in Perl than anyone else. She also writes a kind of non-Perl poetry that was dubbed by another poet as ``sharonesque&amp;rdquo;. Here&amp;rsquo;s a cute example:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;            I&#39;d travel to the ends of time
            For you, my one, my only love.
            I&#39;d force the sun to leave its track
            (If you were lost) to fetch you back.
            I&#39;d suck the juices from a lime,
            I&#39;d re-write Moby Dick in rhyme,
            I&#39;d happily commit a crime!
            For you, my dearest darling dove.
            I&#39;d do it all, and more beside --
 
            Now *would* you take the trash outside?

                                    Sharon Hopkins
                                    Winter, 1989-90
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I had to write a response to that poem. Actually, two responses. I won&amp;rsquo;t inflict the longer one on you, but here&amp;rsquo;s the shorter one:
            I&amp;rsquo;ve taken the trash out innumerable times,
            I&amp;rsquo;ve taken the trash out in inclement climes,
            I&amp;rsquo;ve taken the trash out &amp;lsquo;cuz that&amp;rsquo;s what I do,
            But I &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; take the trash out when you tell me to.&lt;/p&gt;

&lt;p&gt;Well, anyway, most of Sharon&amp;rsquo;s poetry is relational, as befits a postmodern glue person. As I was saying, we were talking recently. Oddly, the subject was postmodernism. Fancy that. We were discussing how postmodern stuff can have goofy things mixed in with things that matter. She likes Iron Chef, too. That&amp;rsquo;s a Japanese show where you have some seriously good cooking mixed with an extremely silly race to cook the best meal. Watching the judges judge the meals is the best part. We were also talking about Revolutionary Girl Utena, where we have the Absolute Destiny Apocalypse mixed in with octopi falling out of closets. Both shows are full of arbitrary but endearing conventions. Anyway, I said something about what I was going to talk about here, and she said an interesting thing:
&amp;gt; Yes, Modernism created a lot of dysfunction&amp;ndash;nobody disputes that. We were encouraged to revolt, deconstruct, cut apart our papers, run away from home and take drugs, not get married, and so on. Modernism tore a lot of things apart, but especially the family. The interesting thing to me is that postmodernism is propagating the dysfunction, because it actually finds its meaning in dysfunction. Postmodernism really is a result of Modernism.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;For one thing, notice how you can&amp;rsquo;t rebel by being dysfunctional any more. It&amp;rsquo;s no longer interesting&amp;ndash;we&amp;rsquo;ve done that already.&lt;/p&gt;

&lt;p&gt;But it&amp;rsquo;s more than that. Think of Perl culture as a dysfunctional family. Or think of the various communities that arise on the net. Think of our Gen X group at church and their obviously postmodern tastes: night club decor mixed with candles. But it&amp;rsquo;s really about being together. Nowadays, family is where you find it. Family is where you create it.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;I think Sharon knows what she&amp;rsquo;s talking about here. She actually met her current boyfriend online, but don&amp;rsquo;t tell her I said that. Anyway, I thought she has an interesting perspective on the way the net works nowadays. Imagine, open source is merely a byproduct of our need for family. So, look at all of you out there. You&amp;rsquo;re just a big, dysfunctional family trying to create meaning. Don&amp;rsquo;t look so nervous. I&amp;rsquo;m not going to call for a group hug.
Let&amp;rsquo;s see, what else can I talk about. Did you realize how many things can be abbreviated ``pm&amp;rdquo;? Prime Minister. Post Meridian. Post Modern. Perl Module. Perl Monger. Are there any Perl Mongers out there today? There you have it&amp;ndash;yet another dysfunctional family. You guys can go out and have a group hug later in the pub.&lt;/p&gt;

&lt;p&gt;Okay, let&amp;rsquo;s see. ``pm&amp;rdquo; is an abbreviation for Perl Module, which is why, of course, we use ``.pm&amp;rdquo; is the extension for a Perl module. It used to be that we used ``.pl&amp;rdquo; for Perl code. People still do use ``.pl&amp;rdquo; in Windows, but that&amp;rsquo;s because they&amp;rsquo;re all still stuck back in the Modern age. Anyway, there&amp;rsquo;s a funny thing about using ``.pl&amp;rdquo; for the Perl extension. People used to argue a lot about what the next language after C would be. Everone knew that the previous language had been called ``B&amp;rdquo;, after the first letter in BCPL, which came even earlier than B. The two proposed candidates for the next language were ``D&amp;rdquo;, because that&amp;rsquo;s what comes after ``C&amp;rdquo; in the alphabet, and ``P&amp;rdquo;, because that was the next letter in BCPL.&lt;/p&gt;

&lt;p&gt;Well, as you can see, it didn&amp;rsquo;t work out either way. One of the successors to C was C++, which is a cute pun on the autoincrement operator, but makes it an absolute pain to try to figure out what the proper extension for a C++ file should be. .C? .cpp? .cxx? I suppose as a postmodern person, I shouldn&amp;rsquo;t mind the diversity, but somehow I do. I suppose a little inconsistency is good for the soul.&lt;/p&gt;

&lt;p&gt;Anyway, the other successor to C gobbled up two letters instead of one. Which is why many Perl scripts have the extension, ``.pl&amp;rdquo;, finishing off BCPL. It&amp;rsquo;s a pity, in a way. Now there can never be a language named ``L&amp;rdquo;. Perhaps it&amp;rsquo;s just as well. Quite apart from the annual yuletide puns we&amp;rsquo;d get on ``noel, noel&amp;rdquo;, there&amp;rsquo;s also the problem that people would have confused the language with lex, which already uses a ``.l&amp;rdquo; extension. Since lex had already taken it, noel was available. So to speak. Sorry.&lt;/p&gt;

&lt;p&gt;Anyway. Isn&amp;rsquo;t history fascinating? Especially postmodern history? &lt;span id=&#34;jump9&#34;&gt;&lt;/span&gt;As Heidi would say: &amp;lsquo;Tsall good. Except when it sucks.&lt;/p&gt;

&lt;p&gt;Or as Tiny Tim says, God bless us, every one.&lt;/p&gt;

&lt;p&gt;If you guys want me to stop talking, you&amp;rsquo;d better ask some questions.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

