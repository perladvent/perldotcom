<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Joe Johnston on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/joe-johnston/</link>
    <description>Recent content in Joe Johnston on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 20 Sep 2000 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/joe-johnston/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Ilya Regularly Expresses</title>
      <link>http://localhost:1313/pub/2000/09/ilya.html/</link>
      <pubDate>Wed, 20 Sep 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/09/ilya.html/</guid>
      <description>&lt;p&gt;&lt;em&gt;Dr. Ilya Zakharevich is well known to the Perl community as along-time contributor to the Perl5 Porters mailing list and for being a regular expression wizard extraordinaire. Ilya has been a major figure in the Perl world for years, contributing Perl 5&amp;rsquo;s operator overloading feature, much of the current shape of the regex engine, the OS/2 port, and the &lt;code&gt;FreezeThaw&lt;/code&gt;, &lt;code&gt;Devel::Peek&lt;/code&gt;, &lt;code&gt;Math::Pari&lt;/code&gt; and &lt;code&gt;Term::Readline&lt;/code&gt; modules. Dr. Zakharevich also teaches mathematics at Ohio State University. Below he shares his thoughts on Perl 6, the U.S. educational system, and Gödel&amp;rsquo;s theorem.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Many people know your extensive work with Perl&amp;rsquo;s regular expressions. What is the most common misunderstanding new programmers have about this pattern-matching language?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IZ&lt;/strong&gt;: I do not remember. For me, the beginner stage was so long ago, and I try to avoid questions on c.l.p.misc which many posters have enough expertise to answer. Let me guess.&lt;/p&gt;

&lt;p&gt;Perl&amp;rsquo;s regular expressions are modeled (eventually) after command-line parameters to grep and other similar utilities. In the command-line world, everything is a string. Bingo: Perl regular expressions look like strings. (Let us forget for a moment that operators &lt;code&gt;qq()&lt;/code&gt; etc. were introduced to make strings look like regular expressions &amp;hellip; .)&lt;/p&gt;

&lt;p&gt;We have a language with binary operators (for example, `&lt;code&gt;|&lt;/code&gt;&amp;rsquo;, `&lt;code&gt;{4}&lt;/code&gt;&amp;rsquo;, or `&amp;rsquo; - this was concatenation), unary operators (`&lt;code&gt;[]&lt;/code&gt;&amp;rsquo;, `&lt;code&gt;[^]&lt;/code&gt;&amp;rsquo;, `&lt;code&gt;(?!)&lt;/code&gt;&amp;rsquo;, &amp;lsquo;&lt;code&gt;+&lt;/code&gt;&amp;rsquo; - both postfix and aroundfix), grouping (`&lt;code&gt;(?:)&lt;/code&gt;&amp;rsquo;), keywords (`&lt;code&gt;\w&lt;/code&gt;&amp;rsquo;, `&lt;code&gt;^&lt;/code&gt;&amp;rsquo;), ternary (&amp;rsquo;&lt;code&gt;{3,7}&lt;/code&gt;&amp;rsquo;), naming (`&lt;code&gt;()&lt;/code&gt;&amp;rsquo;) etc. All of this is packed into a string. No wonder that even inherently unreadable languages like Tcl or Lisp start looking like Dr. Seuss compared to regular expressions.&lt;/p&gt;

&lt;p&gt;Additionally, newcomers do not understand that one needs to break a regular expression into tokens (not mentioning how to do it!), all these rules about what is special when backslashed, what is special when not backslashed and so on. To add insult to injury, &lt;code&gt;m&lt;/code&gt; in &lt;code&gt;m//&lt;/code&gt; is optional, but &lt;code&gt;s&lt;/code&gt; in &lt;code&gt;s///&lt;/code&gt; is not, &lt;code&gt;//x&lt;/code&gt; would require you to go into &amp;ldquo;gory details,&amp;rdquo; some switches in &lt;code&gt;//ioxmsg&lt;/code&gt; apply to regular expressions, some to the operator in which the regular expression appears, &lt;code&gt;print /foo/, &#39;bar&#39;&lt;/code&gt; is applied to &lt;code&gt;$_&lt;/code&gt;, but &lt;code&gt;split /foo/, &#39;bar&#39;&lt;/code&gt; is not etc., etc., etc.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;//x&lt;/code&gt; was introduced as a clever hack around the problem of &amp;ldquo;packing a language into a string,&amp;rdquo; but it went only a small part of the way to make things more maintainable. Languages like SNOBOL introduced COBOL-style patterns, which swing into the opposite end of the scale: things become less readable due to the sheer size of patterns for any nontrivial task.&lt;/p&gt;

&lt;p&gt;Regular expressions are extremely powerful tools, they are the functional-programming oasis inside a procedural language, and, when well understood, they map wonderfully into the problem domain they address. Making them into eye candy is not impossible, but requires a lot of work (and probably significant changes in the current mindsets).&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;For those of us who use the Beast Emacs, you have provided the outstanding cperl-mode syntax highlighter and indenting system. What was so bad about the traditional perl-mode that made you want an alternative?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IZ&lt;/strong&gt;: Again, I do not remember the details. But I did not invent the alternative, I just adopted an existing branch. Here&amp;rsquo;s my attempt to reconstruct how it did happen (but it may be a false memory): At the time I grabbed &lt;code&gt;cperl-mode.el&lt;/code&gt; v1.3 (by Bob Olson) from gnu.emacs.source, &lt;code&gt;perl-mode.el&lt;/code&gt; was handling about 30% of constructs, while &lt;code&gt;cperl-mode.el&lt;/code&gt; was handling 60%. Additionally, electric constructs were decreasing the irritation factor a lot. This was what I started with. Bob named and coded &lt;code&gt;cperl-mode.el&lt;/code&gt; similarly to the difference between &lt;code&gt;c-mode.el&lt;/code&gt; and &lt;code&gt;cc-mode.el&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Being locked into Emacs, being used to (extremely high) standards of good DOS programmers editors, and having a very low irritation threshold for bookkeeping-related repetitive tasks got me some minimal experience with Emacs Lisp (I needed several years to make my Emacs config tolerable). So when facing a problem with the existing cperl-mode.el, I would try to fix it instead of working around it.&lt;/p&gt;

&lt;p&gt;While not time-efficient, this was bringing this warm fuzzy feeling of improving the universe instead of just increasing its entropy. So it went and went, with additional fuel supplied by annoyed/pleased/patchy users around the world.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What first attracted you to Perl?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IZ&lt;/strong&gt;: Oh, this is easy to answer: &lt;code&gt;command.com&lt;/code&gt;. If all you have are scissors, everything starts looking like a nail. So you learn to deal with everything using your scissors. I remember my impression when I printed out the documentation for 4DOS/4OS2: Wow, these guys thought of everything! I may replace half of the tiny utilities I need with this one program!&lt;/p&gt;

&lt;p&gt;Then I saw a &amp;ldquo;go&amp;rdquo; script for running LaTeX/BibTeX until successful completion. It required an additional program, perl.exe, which was not exactly tiny (around 200K), but obviously demonstrated quite enough bang for a K. The manpage for this program had a few kilolines, was very well written, so was easy to grasp. Browsing &amp;ldquo;Programming Perl&amp;rdquo; did not hurt, either. (It took a lot of time to understand that the title is a false advertisement). Using this program for intelligent format conversion between bibliographical databases and BibTeX proved to be a success, including a chain of regular expressions like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; elsif (/^\s*No\.\s+([-\d\/]+(\s*\([-\/\d]+\))?)\s+(pp\.\s*)?([-\d]+)(\s*pp\.?)?
       (\s*\((\d{4})\))\s*$/i) {
 elsif (/^\s*(pp\.\s*)?(([ivxlcd]+\+)?([-\d]+)|((\w)\d+-+\6\d+))(\s*pp\.?)?\s*$/) {
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then there was the year I was trying to make a math-editing widget based on a beefed up TK&amp;rsquo;s text widget. With all the work for &amp;ldquo;typesetting&amp;rdquo; components of formula delegated by the widget to TCL callbacks, TCL turned out to be not an answer.&lt;/p&gt;

&lt;p&gt;Then I got an impression that seeing exact numeric answers for the simplest particular cases of a conjecture I was working on would help me treat general cases. A couple of months of programming in a mini-language of the PARI package for math-related calculations (and several weeks of running the code). Custom mini-languages were not the answers. (My conjecture is still there, though the &amp;ldquo;famous&amp;rdquo; conjecture it was a stepping stone to was soon established by my colleagues.)&lt;/p&gt;

&lt;p&gt;Stroustroup&amp;rsquo;s &amp;ldquo;Annotated reference&amp;rdquo; showed clearly that C++ is not going to be an answer, either. Aha, Perl is going to be redesigned to allow objects! Given overloading, one could use it for math. But there were no plans to add overloading. &amp;hellip; Well, adding overloading to Perl would clearly improve the universe, and spending some time to improve Perl looked like a just cause &amp;hellip; .&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;At Perl Conference 4.0, Larry Wall and the Perl 5 Porters announced a complete rewrite of Perl. What are three things that a rewrite of Perl needs to get right?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IZ&lt;/strong&gt;: Currently, I have only one sentiment about this effort: It should be terminated ASAP. There are many problems with Perl, but I would consider a ground-up rewrite as the last alternative for fixing these problems.&lt;/p&gt;

&lt;p&gt;The only aspect in which a ground-up rewrite would help is PR. While PR is important, I would think that there should be less wasteful ways to improve PR than locking the resources into a possible vaporware for 2 to 3 years.&lt;/p&gt;

&lt;p&gt;But let me interpret your question the other way: Which changes to Perl as a language would be beneficial to the users? Well, this is not a question which may be solved in two months. And I did not think about it even for a day. All I can do is to list some ideas I had before. All these ideas are very minor &lt;em&gt;additions&lt;/em&gt; to the language. (I do not list badly needed improvements to particular operators, like regular expressions or &lt;code&gt;pack&lt;/code&gt;/&lt;code&gt;unpack&lt;/code&gt;, or missing operators.) And it is not three most-important things, but just a random pick of ilyaisms:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Introduce pragmas to tame the bizarreness level. These may go in many different levels, starting, for example, with prohibiting (read warn or die) default arguments, or indirect object (IO) syntax, or &lt;code&gt;?REx?&lt;/code&gt;, and possibly going to radical degrees, like&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I will not use the IO syntax (or &lt;code&gt;?REx?&lt;/code&gt;), so if a particular construct may be interpreted as IO syntax (or &lt;code&gt;?REx?&lt;/code&gt;), do not warn me, but choose the other interpretation.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;or even&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I will not use cryptocontext, so execute everything in the list context, and return the number of elements if the actual context is scalar.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;Another pragmatically controlled thing may be an introduction of a &amp;ldquo;floating precedence&amp;rdquo; of operators. Obviously, one cannot design a precedence table with 20 or so levels of precedence which gives an &amp;ldquo;intuitively obvious&amp;rdquo; or &amp;ldquo;natural&amp;rdquo; parsing of parentheses-less expressions. A solution I can see is to make some operators have a &lt;em&gt;range&lt;/em&gt; of precedence, and warn/die on expressions which do not have the same interpretation when the precedences of operators move in these ranges. (Think of A &amp;amp; B || C.) (I confess that I do not know how to do it with yacc, so this may be not so minor.)&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;One of the few things (the only one?) where Tcl has a clear advantage over Perl is the I/O control. You can control the I/O buffers with Perl, you can control the blocking state, you can control the autoflush, input granularity, newline translation, etc. However, all these things are done by absolutely different (and quite obscure) means, some of them are done in the core, some by different modules. Having a unified interface, like &lt;code&gt;$fh-&amp;gt;configure(blocking =&amp;gt; 0, text_nl =&amp;gt; 1)&lt;/code&gt; would remove a lot of unnecessary complexity.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Order of destruction. Due to a known bug (or, more precise, a made-in-haste bug fix) the order of destruction of lexicals at the end of scope is reversed (in fact, this is a simplification of what actually happens). Recently I spent several hours tracing a segfault which eventually turned out to be a result of this problem. (In pure-Perl cases this is OK, since if one object needs a longer existence than another, it implies keeping a reference inside the latter object, thus a correct order is guaranteed. However, if objects are just handles into the &amp;ldquo;outside&amp;rdquo; world objects, it may be not possible to reflect their interdependence by the refcount alone.)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;strong&gt;It was widely reported that you left the Perl 5 Porters list earlier is summer. Will you continue to submit patches? Will you continue to use Perl at all? What will you be doing with all your new found spare time?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IZ&lt;/strong&gt;: My &amp;ldquo;impedance mismatch&amp;rdquo; with p5p has nothing to do with any unwillingness to improve Perl or my choice of favorite tools to work with. Of course, one should keep in mind that it is not technically simple to continue submitting patches while not on p5p, since a lot of things could have been decided/done which is hard to deduce from &amp;ldquo;Changes&amp;rdquo; files. Additionally, it is not clear now whether Perl v5 development would co-exist with the Perl v6 extravaganza - or it would follow the fate of other promised (but never delivered) maintenance tracks. When was the last release of 5.005_*?&lt;/p&gt;

&lt;p&gt;I continue to think that Perl maps better than the alternatives into the mindset of many problems solvers. Given a few of well-focused improvements, Perl might evolve into a Swiss army toolset appropriate for solutions in a very wide problem area. However, at least as far as my experience shows, Perl is as bad as the alternatives for solving those (more complicated?) problems arising in my research-related work. Somehow the advantages above are not fulfilled. Almost all I use Perl for is the system-maintenance-related tasks. Would you maintain a system the principal occupation of which is its own maintenance? I do not think these shortcomings may be resolved by a better support for programming (as opposed to scripting) in Perl which I mention above. Some radical changes, such as better text handling capabilities, a more efficient support for &amp;ldquo;alient objects&amp;rdquo; may help, and these changes are appropriate for Perl 6, but as I see it, Perl 6 advocates have somewhat perpendicular agendas.&lt;/p&gt;

&lt;p&gt;As far as my spare time goes, I would not classify my tinkering with Perl into this category. It was more like a necessary distraction: an orthogonal way to keep the mind wheels rolling when it feels like they stuck too deep in the rut. (Of course, one should fight the tendency of the wheels to stuck in that &amp;ldquo;other&amp;rdquo; rut, as well.) And since I did not need such upwheeling yet, I have no idea what kind of occupation will take the place of p5p-ing.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://www.cs.bell-labs.com/cm/cs/who/rob/utah2000.pdf&#34;&gt;Rob Pike was recently lamenting the death of innovative operating-system research&lt;/a&gt;. Do you feel the same can be said for programming languages? Will be you learning Microsoft&amp;rsquo;s C# anytime soon?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The first time the Plan 9 people impressed me so much, it was their position on Unicode at time when it was widely considered as a marketing gimmick. Unfortunately, this time their stand has practically no conflict with what I think today, so I could not improve myself by switching to the other side. &lt;code&gt;;-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;I suspect that it was my emphasis on the role of delayed gratification which made you remember this paper &amp;hellip; &amp;ldquo;Too much phenomenology: invention has been replaced by observation&amp;rdquo; is also quite Perl-connected. One can find authors of well-written and well-researched Perl books spending an incredible amount of time investigating Perl weaknesses and the ways to work around them. In a lot of cases one could &lt;em&gt;fix&lt;/em&gt; these weaknesses in a fraction of time it took to write down these workarounds. And when this becomes published, other people would surely fix these problems, so such a book can become a doorstop soon. Unfortunately, there is cash value in publishing instead of fixing. &amp;hellip;&lt;/p&gt;

&lt;p&gt;What I cannot agree with is the nodding down to &amp;ldquo;take an existing thing and tweak it&amp;rdquo; approach. Innovation != redoing everything from scratch. In programming languages, innovation requires&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;categorizing programming subtasks into appropriate groups;&lt;/li&gt;
&lt;li&gt;providing uniform efficient ways to solve the problems within one group; and&lt;/li&gt;
&lt;li&gt;the tools to collect the subtasks into a solution of the problem.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;code&gt;sscanf()&lt;/code&gt; was such an innovation. Having regular expressions instead of &lt;code&gt;sscanf()&lt;/code&gt; was an innovation. Saying goodbye to distributed shell scripting and replacing it by a monstrously monolithic Perl scripting was an innovation.&lt;/p&gt;

&lt;p&gt;My feelings are that &amp;ldquo;tweak it&amp;rdquo; is the best approach to be innovative today. There are still many chances to discover a new category of subtasks the programs spend 90% of time doing which, or programmers spend 90% of time coding which. Even if it is 10% (or 2%) of programs/programmers who do this, a canned elegant solution to this category would be a significant innovation. Even if it is provided as a tweak to something else.&lt;/p&gt;

&lt;p&gt;About C# - this was the first time I&amp;rsquo;ve heard about it. What I see is that it replaced something else with the lifespan of what, two years? What is the projected half-life of C# then?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You are an Assistant Professor of Mathematics at Ohio State University where your Web page identifies your research area as &amp;ldquo;studying analytic, geometric and algebraic foundations for the phenomenon of integrability of dynamic systems.&amp;rdquo; For those that have been out of school for a while (like myself), what does this mean and how does this study intersect with our everyday world?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IZ&lt;/strong&gt;: First of all, this is the departmental page, not mine. I think that in my case FTP speaks louder than HTTP, so do not have any Web presence. But the phrase you quoted is mine (taken from some &amp;ldquo;promotional&amp;rdquo; material), so I cannot avoid your question with this trick.&lt;/p&gt;

&lt;p&gt;The short answer first: You do not want to know. This is deep magic, even deeper than the question, &amp;ldquo;What does `deeper magic&amp;rsquo; mean?&amp;rdquo; And it would not bring you any new microchip architecture, won&amp;rsquo;t save any lives, and/or won&amp;rsquo;t lead to new significant fuel economy in your car. At least not in any foreseeable future.&lt;/p&gt;

&lt;p&gt;For those nasty persistent minds which are not discouraged by so many negatives, a &amp;ldquo;what Perl does is finishing your assignments on time&amp;rdquo;-style explanation is the best one can hope for. But I need to start it from far away.&lt;/p&gt;

&lt;p&gt;There are several dichotomies in modeling a &amp;ldquo;physical&amp;rdquo; system. The first one is of the simple, hairy type: simple systems are &amp;ldquo;linear,&amp;rdquo; so the &amp;ldquo;response&amp;rdquo; of a component is proportional to the &amp;ldquo;stimulus.&amp;rdquo; For a linear system, no matter how many &amp;ldquo;components&amp;rdquo; it has, the behavior is essentially the same: There is a way to break the system into new &amp;ldquo;components&amp;rdquo; without any interaction between these new components. Think of an ideal crystal: There are many interacting atoms, but the oscillation can be also described by phonons (&amp;ldquo;modes&amp;rdquo; of oscillation) which travel without any interaction between them.&lt;/p&gt;

&lt;p&gt;This leads to another dichotomy: chaotic versus integrable systems. Oscillations of an ideal crystal are not any more chaotic than a typical random number generator is random. But most &amp;ldquo;hairy&amp;rdquo; systems behave differently: Theoretically, if you know the state of the system at some moment of time, you should be able to predict the future; practically, due to errors in the measurement of the initial state, your predictions about the future behaviour degrade as time goes. For integrable systems, this degradation is linear - you measure things twice as precise, you can predict the future for an interval twice as long. For chaotic systems the degradation is exponential - you collect twice as much meteorological data, you can increase the weather prediction interval by (say) a day; you collect a million times as much data, you get an extra 20 days. In such a situation, do not even think of a two-month prediction; this is the chaos domain.&lt;/p&gt;

&lt;p&gt;Nonlinear (read nontrivial) systems are expected to be chaotic. You can get &amp;ldquo;truly random&amp;rdquo; signal from the crystal oscillators in your computer, though the &amp;ldquo;amount of nonlinearity&amp;rdquo; there is minuscule. Here comes &amp;ldquo;integrability.&amp;rdquo; There are exceptions to this law. Say, the two-body gravitational attraction problem is nonlinear, but in Newtonian approximation it is integrable. The &amp;ldquo;standard&amp;rdquo; predator-prey model of the food chain is integrable in many cases. Until 50 years ago such systems were considered to be interesting, but isolated exceptions. The situation changed when one of the first computer simulations modelled a nonlinear interaction of atoms in a crystal. Amazingly, this model did not demonstrate any chaos.&lt;/p&gt;

&lt;p&gt;Now we know that a lot of (physically interesting or artificial) examples when hairy systems remain integrable. For example, &amp;ldquo;string theories&amp;rdquo; of elementary particles lead to an enormous amount of different integrable systems. Moreover, there are plenty of known explanations of why a particular system is integrable. Here comes the problem. Typically, all these explanations are applicable &lt;em&gt;simultaneously&lt;/em&gt;. Imagine that you cannot start your car because it ran out of gas, the battery is dead, the key broke, the garage door won&amp;rsquo;t open and your driver&amp;rsquo;s license expired. Maybe you should ignore all these explanations, and just go to a shrink.&lt;/p&gt;

&lt;p&gt;This is close to outline of what I do: I investigate what could be the reason which connects these fantastically beautiful, but deeply dissimilar explanations of integrability. Going back to the everyday world: Finding such reason(s) would not make any known system &amp;ldquo;more integrable,&amp;rdquo; but I&amp;rsquo;ll be surprised if such new viewpoints would not bring new unknown applications of integrability. But applications to &amp;ldquo;more fundamental&amp;rdquo; physics are more probable, so if you do not interact with strings, you should not worry about this.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Well, I use Perl which has extremely agile text handling facilities, so I&amp;rsquo;m not worried about your bothersome &amp;lsquo;strings.&amp;rsquo; Seriously, that sounds like really engaging, but very elusive research. Do you ever think, &amp;ldquo;This is an intractable problem which the human mind can&amp;rsquo;t solve&amp;rdquo;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IZ&lt;/strong&gt;: Taken theoretically, your question is very dear for a lot of mathematicians (and very demanding of them). It is the fundamental ignoramus-or-ignorabimus dilemma of the life-after-Gödel: Will we ever know? What Gödel says is: If the society of mathematicians may be modeled by a computer, then most of the questions which make sense cannot be resolved, even if we have unlimited resources. However, we know that in practice this is far from happening. Most working mathematicians do not spend their life banging forever against a dead end.&lt;/p&gt;

&lt;p&gt;There may be many explanations for this. First of all, bad emotions being bad, we just forget about our failures when we switch to something more rewarding. Second, the most interesting questions are not &amp;ldquo;formalized,&amp;rdquo; they sound more like &amp;ldquo;explain why&amp;rdquo; than &amp;ldquo;calculate this.&amp;rdquo; For example, the problem I mentioned above is about finding an appropriate point of view which would clarify many known coincidences at once. We, mathematicians, as a class, have a very good record in producing new and enlightening points of view. It could take 50 or 100 years, but typically it comes sooner or later. Maybe such questions may not be mapped into the negative spirit of the Gödel program?&lt;/p&gt;

&lt;p&gt;Lastly, the questions on whether humans may be modelled by computers is far from having the &amp;ldquo;Of course, yes!&amp;rdquo; answer. Remember that there is a natural ladder of sciences: physics, chemistry, cytology, physiology, ethology, sociology, ecology. We know that the attempts to describe the next step of the ladder basing &lt;em&gt;only&lt;/em&gt; on the information obtained on the previous steps would spectacularly fail. And one of the possible explanations of this is quite similar to the chaos semantic of weather forecasts. For example, yes, molecules are built of atoms, which are built of elementary particles. But this does not necessarily mean that we may explain properties of molecules basing of the known properties of elementary particles.&lt;/p&gt;

&lt;p&gt;How this can be so? Here is one - imaginary - scenario. Suppose that calculating properties of an n-atom molecule requires the knowledge of the charge of the electron with n decimal places. This would mean a complete separation of physics and organic chemistry into unrelated sciences, since they depend on different decimal places of this number. You may tell me that one can use properties of one n-atom molecule to find the n first digits of the charge of electron, then use this number for other n-atom molecules. Just throw in a cryptographically strong one-way function, and this possibility goes away. And chaotic systems provide spectacularly good one-way functions. There &lt;em&gt;may&lt;/em&gt; be obstacles for modeling a human brain (or a human society) by a Turing machine, similar to the obstacles in modeling molecules in terms of the physics of elementary particles.&lt;/p&gt;

&lt;p&gt;Now you should not be surprised by me not worrying much about the question you asked. Additionally, what I wrote is just a motto-ized outline of what I&amp;rsquo;m working over. Any particular time I work over something more or less concrete and more or less reachable in a meaningful time frame.&lt;/p&gt;

&lt;p&gt;Let me also mention that classifying the text handling facilities of Perl as &amp;ldquo;extremely agile&amp;rdquo; gives me the willies. Perl&amp;rsquo;s regular expressions are indeed more convenient than in other languages. However, the lack of a lot of key text-processing ingredients makes Perl solutions for many averagely complicated tasks either extremely slow, or not easier to maintain than solutions in other languages (and in some cases both).&lt;/p&gt;

&lt;p&gt;I wrote a (heuristic-driven) Perlish syntax parser and transformer in Emacs Lisp, and though Perl as a language is incomparably friendlier than Lisps, I would not be even able of thinking about rewriting this tool in Perl: there are just not enough text-handling primitives hardwired into Perl. I will need to code all these primitives first. And having these primitives coded in Perl, the solution would turn out to be (possibly) hundreds times slower than the built-in Emacs operations.&lt;/p&gt;

&lt;p&gt;My current conjecture on why people classify Perl as an agile text-handler (in addition to obvious traits of false advertisements) is that most of the problems to handle are more or less trivial (&amp;ldquo;system maintenance&amp;rdquo;-type problems). For such problems Perl indeed shines. But between having simple solutions for simple problems and having it possible to solve complicated problems, there is a principle of having moderately complicated solutions for moderately complicated problems. There is no reason for Perl to be not capable of satisfying this requirement, but currently Perl needs improvement in this regard.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Could you describe in more detail what additional text-handling primitives you would like to see included with Perl? What string munging operations are absent that really ought to be included in Perl&amp;rsquo;s core?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The problem: Perl&amp;rsquo;s text-handling abilities do not scale well. This has two faces, both invisible as far as you confine yourselves to simple tasks only. The first face is not that Perl lacks some &amp;ldquo;operations;&amp;rdquo; it is not that some &amp;ldquo;words&amp;rdquo; are missing, whole &amp;ldquo;word classes&amp;rdquo; are not present. Imagine expressive power of a language without adjectives.&lt;/p&gt;

&lt;p&gt;In Perl text-handling equals string-handling. But there is more in a text than the sequence of characters. You see a text of a program - you can see boundaries of blocks, etc.; you see an English text, you can see word boundaries and sentence boundaries, etc. With the exception of the word boundaries, all these &amp;ldquo;distinctive features&amp;rdquo; become very hard to recognize by a &amp;ldquo;local inspection of a sequence of characters near an offset&amp;rdquo; - unless you agree to use a heuristic which works only time to time. But a lot of problems require recognition of the relative position of a substring w.r.t. these &amp;ldquo;distinctive features&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Remember those &amp;ldquo;abstract algorithms&amp;rdquo; books and lessons? You can solve the problems &amp;ldquo;straightforwardly,&amp;rdquo; or you can do it &amp;ldquo;smartly.&amp;rdquo; Typically, &amp;ldquo;straightforward&amp;rdquo; algorithms are easy to code, but they do not scale well. Smart algorithms start by an appropriate preprocessing step. You organize your data first. The particular ways to do this may be quite different: you sort the data, or keep an &amp;ldquo;index&amp;rdquo; of some kind &amp;ldquo;into your data,&amp;rdquo; you hash things appropriately, your balance some trees, and so on. The algorithms use the initial data &lt;em&gt;together&lt;/em&gt; with such an &amp;ldquo;index.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Perl provides a few primitives to work with strings, which are quite enough to code any &amp;ldquo;straightforward&amp;rdquo; algorithm. What about &amp;ldquo;smart&amp;rdquo; ones? You need preprocessing. Typically, digging out the info is easy with Perl, but how would you store what you dug? The information should be kept &amp;ldquo;off band,&amp;rdquo; for example, in an array or hash of offsets into the string.&lt;/p&gt;

&lt;p&gt;Now modify the string a little bit, say, perform some &lt;code&gt;s()()&lt;/code&gt; substitutions, or cut-and-paste with &lt;code&gt;substr()&lt;/code&gt;. What happens with your &amp;ldquo;off band&amp;rdquo; information? It went out of sync. You need to update your annotating structures. Do not even think about doing &lt;code&gt;s()()g&lt;/code&gt;, since you do not have enough info about the changes after the fact. You need to do your &lt;code&gt;s()()&lt;/code&gt; one-by-one - but while &lt;code&gt;s()()g&lt;/code&gt; is quite optimized, a series of &lt;code&gt;s()()&lt;/code&gt; is not - and you get stuck again into the land of badly scaling algorithms.&lt;/p&gt;

&lt;p&gt;(Strictly speaking, for this particular example &lt;code&gt;s()()eg&lt;/code&gt; could save you - as well as code-embedded-into-a-regular-expression, but this was only a simple illustration of why off-band data is not appropriate for many algorithms. Please be lenient with this example!)&lt;/p&gt;

&lt;p&gt;Even if no modification is done, using off-band data is very awkward: how to check what are the attributes of the character at offset 2001 when there are many different attributes, each marking a large subset of the string?&lt;/p&gt;

&lt;p&gt;That was the problem, and the solution supported by many text-processing systems is to have &amp;ldquo;in-band annotations&amp;rdquo;, which is recognized by the editing primitives, and easily queryable. Perl allows exactly one item of in-band data for strings: pos(), which is respected by regular expressions. But it is not preserved by string-editing operations, or even by &lt;code&gt;$s1 = $s2&lt;/code&gt;!&lt;/p&gt;

&lt;p&gt;&amp;ldquo;In-band&amp;rdquo; data comes in several &amp;ldquo;kinds&amp;rdquo;. A particular &amp;ldquo;kind&amp;rdquo; describes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;how it behaves with respect to insertion or deletion of characters nearby;&lt;/li&gt;
&lt;li&gt;can the &amp;ldquo;same&amp;rdquo; markup appear &amp;ldquo;several times&amp;rdquo;;&lt;/li&gt;
&lt;li&gt;can the markup &amp;ldquo;nest&amp;rdquo; (like nested comments in some languages); and&lt;/li&gt;

&lt;li&gt;&lt;p&gt;is there an internal structure of the markup (as in a loop, which may be&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    [[LABEL DELIM0] KEYWORD [DELIM1 VAR1 SEP VAR2 ... DELIM2] 
     [DELIM4 EXPR DELIM4] [DELIM5 BODY DELIM6]]
&lt;/code&gt;&lt;/pre&gt;

&lt;ul&gt;
&lt;li&gt;with some parts possibly missing, so the internal structure is a tree).&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Different answers lead to a zoo of intuitively different kinds of markup, each kind useful for some categories of problems. You can mark &amp;ldquo;gaps between&amp;rdquo; characters, or you can mark characters themselves. The markup may &amp;ldquo;name&amp;rdquo; a position (&amp;ldquo;the first &lt;code&gt;__END__&lt;/code&gt; in a Perl program&amp;rdquo;), or cover a subset of the string (&amp;ldquo;show in red&amp;rdquo;, &amp;ldquo;is a link to &lt;em&gt;this&lt;/em&gt; URL&amp;rdquo;, or &amp;ldquo;inside comment&amp;rdquo;). Since the kind of the markup defines what happens when the string is modified, the system can support self-consistency of the markup &amp;ldquo;automatically&amp;rdquo; (in exceptionally complicated cases one may need to register a callback or two).&lt;/p&gt;

&lt;p&gt;The second face of problem is not with the expressive power of Perl, but with the implementation. Perl has a very rigid rule: a string must be stored in a consecutive sequence of bytes. Remove a character in the middle of the string, and all the chars after it (or before it) should be moved. As I said, &lt;code&gt;s()()g&lt;/code&gt; has some optimizations which allow doing such movements &amp;ldquo;in one pass&amp;rdquo;, but what if your problem cannot be reduced to &lt;em&gt;one&lt;/em&gt; pass of &lt;code&gt;s()()g&lt;/code&gt;? Then each of the tiny modification you do one-at-a-time may require a huge relocation - or maybe even copying of the whole string. This is why a lot of algorithms for text manipulation &lt;em&gt;require&lt;/em&gt; a &amp;ldquo;split buffer&amp;rdquo; implementation, when several chunks of the string may be stored (transparently!) at unrelated addresses.&lt;/p&gt;

&lt;p&gt;Such &amp;ldquo;split-buffer&amp;rdquo; strings may look incredibly hard to implement, as in &amp;ldquo;all the innards of Perl should be changed&amp;rdquo;, but it is not. Just store &amp;ldquo;split strings&amp;rdquo; similarly to &lt;code&gt;tie()&lt;/code&gt;d data. The &lt;code&gt;FETCH&lt;/code&gt; (actually, the low-level MAGIC-read method) would &amp;ldquo;glue&amp;rdquo; all the chunks into one - and would remove the MAGIC - before the actual read is performed; and now no part of Perl &lt;em&gt;requires&lt;/em&gt; any change. Now four or five primitives for text-handling may be changed to recognize the associated &lt;code&gt;tie()&lt;/code&gt;d structures - and act without gluing chunks together. We may even do it in arbitrarily small steps, one opcode at a time.&lt;/p&gt;

&lt;p&gt;Another important performance improvement needed for many algorithms would be the copy-on-write, when several variables may refer to the same buffer in memory, or different parts of the same buffer - with suitable semantic what to do when one of these variables is modified. (In fact the core of this is already implemented in one of my patches!) Together with other benefits, this would solve the performance problems of &lt;code&gt;$&amp;amp;&lt;/code&gt; and friends, as well as would make &lt;code&gt;m/foo/; $&amp;amp; = &#39;bar&#39;;&lt;/code&gt; equivalent to &lt;code&gt;s/foo/bar/&lt;/code&gt;. Having copy-on-write *sub*strings may be slightly more patch-intensive than copy-on-write &lt;em&gt;strings&lt;/em&gt;, though. The complication: currently the buffers are required to be 0-terminated (so that they may be used with the system APIs). It is hard to make &amp;lsquo;b&amp;rsquo; as in &lt;code&gt;substr(&#39;abc&#39;,1,1)&lt;/code&gt; refer to the same buffer (containing &amp;ldquo;abc\0&amp;rdquo;) as &amp;lsquo;abc&amp;rsquo;. The solution may be to remove this requirement, and have two low-level string access API, SvPV() and SvPVz(), so that SvPVz() may perform the actual copying (as in copy-on-write) and the appending of &lt;code&gt;\0&lt;/code&gt; - but only when needed!&lt;/p&gt;

&lt;p&gt;Without these - or similar - changes Perl would not scale well as a language for efficient text-processing. What is more, I believe that the changes above can remove most of the significant bottlenecks for the problems we have in text-processing of today. At least I know a lot of problems which would have feasible solutions given these changes.&lt;/p&gt;

&lt;p&gt;And I need not repeat that a handful of small extensions to the expressive power of the regular expression engine could radically extend the domain of its applicability. &lt;code&gt;;-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Dr. Nikolai Bezroukov cautions newbies about Perl&amp;rsquo;s Do What I Mean (DWIM) number/string conversions (&lt;a href=&#34;http://www.softpanorama.org/Scripting/perl.shtml&#34;&gt;http://www.softpanorama.org/Scripting/perl.shtml&lt;/a&gt;). He says:&lt;/strong&gt;&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;&lt;em&gt;[Perl&amp;rsquo;s automatic conversions] lead to problems that are well known to seasoned PL/1 programmers &amp;ndash; all [is] well until Perl [makes] a wrong decision and you end up searching this error for a week or more.&lt;/em&gt;&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;As a mathematician, do you feel Perl should allow programmers to have better control over these conversions?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;A number is a number, whether it is written as &amp;ldquo;3e2&amp;rdquo;, 3e2, &amp;ldquo;300.&amp;rdquo;, 300., &amp;ldquo;300&amp;rdquo; or 300. Of course, if something can/cannot have bugs, it has. Until recently Perl numeric conversions needed a lot of improvement.&lt;/p&gt;

&lt;p&gt;Well, actually there &lt;em&gt;is&lt;/em&gt; a not-yet-fixed loophole in Perl&amp;rsquo;s conversions. Perl uses the system-supplied float-to-string conversions. They originated in the times of Fortran, when programmers knew what a number is, and knew pitfalls in computer representations of numbers. They could resolve the problems associated with too much precision on output, or could accept tradeoffs of lower precision. (Remember the hardware of 50s which was working in &lt;em&gt;ternary&lt;/em&gt;, since it gave better &amp;ldquo;transistor count&amp;rdquo; for memory?) Perl uses these functions for today&amp;rsquo;s programming needs. This results in Perl&amp;rsquo;s conversions which have &lt;em&gt;both&lt;/em&gt; a fuzz, &lt;em&gt;and&lt;/em&gt; output unneeded digits - depending on what a user of today would think is the phase of the moon.&lt;/p&gt;

&lt;p&gt;Now, when we have reproducible (and mostly documented!) numeric conversions, it is very important to use float-to-string conversion which is both lossless (when used with a consequent string-to-float conversion), and uses as few decimal places as possible. Yes, I know that the code to do this was tried with Perl, and this resulted in measurable slowdowns. But first of all, I do not believe that it is hard to modify the current sprintf() code to do &amp;ldquo;the right thing&amp;rdquo; without a lot of slowdown. The tested code being slow does not mean that it &lt;em&gt;should&lt;/em&gt; be slow. Second, this testing was done year ago, perl of today is optimized to use conversions much less often.&lt;/p&gt;

&lt;p&gt;About control? You got as much as you need with sprintf(). (Overloaded data is an exception, but with more overloaded operations this may be fixed too.) If Nikolai knows some cases where a minimal lossless reproducible conversion leads to problems, and sprintf() is not desired, I would like to hear why not.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I see you received your Ph.D from Moscow State. Political ideology aside, do you think the Russian education system is more effective than that of the US? What element is most lacking in US higher education today?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IZ&lt;/strong&gt;: The short answers: you cannot put ideology aside; elementary education.&lt;/p&gt;

&lt;p&gt;Now the longer ones. It is extremely difficult to compare the systems. And the results would depend on how deep you are ready to dig. First, consider the purely subjective feelings. (Especially important since &amp;ldquo;objective&amp;rdquo; comparisons produce almost pure garbage.) Yes, it feels like the Russian system gives much better results than the U.S. one. On the other hand, look at top level achievers. Obviously, the &amp;ldquo;stars&amp;rdquo; in the U.S. were not less starry than the &amp;ldquo;stars&amp;rdquo; in the SU.&lt;/p&gt;

&lt;p&gt;One of the reasons for a possibly skewed perception is an unbelievable concentration of resources in Russia. Let&amp;rsquo;s look: scratching the surface, SU was significantly larger than US, it is enough to mention 10 (or 11?) time zones. It was a big surprise for me when after several months in US I understood that my &lt;em&gt;feelings&lt;/em&gt; about the size were exactly the opposite to the &amp;ldquo;objective&amp;rdquo; sizes. Digging into these feelings brought the following conjecture: subjectively SU was a disk with the radius circa 25 miles.&lt;/p&gt;

&lt;p&gt;Why? Imagine that 80% of everything good was in Moscow. Out of the rest, 15% were in Leningrad and Kiev. (I&amp;rsquo;m still subjective!) Well, there is some distance between Moscow and Leningrad, but given sleeper trains, it mostly disappears. This was squeezing resources into a very tight knot. The critical mass requires high mass and high density simultaneously, both were present. The synergetic effects were omnipresent.&lt;/p&gt;

&lt;p&gt;Imagine a prevalent migration of talents to metropolises with a negligible back-current. Imagine that top students go not to 25 different universities, but to one, and &lt;em&gt;stay&lt;/em&gt; there (the math department in the Moscow University is 5..10 times larger than the largest math departments in the USA). What does this lead to? If you are a good student, then the proportion of good students around you would be much higher.&lt;/p&gt;

&lt;p&gt;This skews perceptions, but there is also a giant &amp;ldquo;objective&amp;rdquo; boost due to increased interaction between &amp;ldquo;stars&amp;rdquo; (and &amp;ldquo;starlets&amp;rdquo;). US students in general are much more ready to work hard, but their achievements in the domain of their immediate speciality are only as good as those for Russian students, and not spectacularly better. Typically their knowledge outside this narrow region wishes a lot of improvement.&lt;/p&gt;

&lt;p&gt;Additionally, for the most of the beneficial factors, one would not want to copy them. Why &amp;ldquo;stars&amp;rdquo; remain in Moscow? Because there was no way to go abroad. What choices there were for a bright kid? Very few. Learn, learn, and learn. What choices there were for philanthropy? Very few. Teach, teach, and teach. Just consider the payroll differential, which was at most 2x&amp;ndash;4x. So even if elementary education was relatively low-paying, the enthusiasts would not be stopped by this: the difference was not that striking.&lt;/p&gt;

&lt;p&gt;Consider also differences in the spending pattern. It was not absolutely ridiculous to spend 10% or 15% of your income on books. Books being cheap, you could allow yourselves to buy &lt;em&gt;all&lt;/em&gt; the decent books in your wide speciality, and several related specialities, not even mentioning what is called &amp;ldquo;literature&amp;rdquo; in US. Clearly, there is no way to graft this to the US situation.&lt;/p&gt;

&lt;p&gt;Now a theory one of my friends favors, take it at least as a parable: The humanitarian aspect of the elementary education in the U.S. is based on tolerance, basically, all the ideas are considered created equal. Pluralism, respect for opinions of other persons, the ability to look at the problem from different sides and so on. So far so good. Now: math is based on exactly the opposite premise: some arguments are correct, some are wrong. People can tell them apart.&lt;/p&gt;

&lt;p&gt;This creates a conflict. Correspondingly, all non-mechanical aspects of math, which is the ultimate device to transfer knowledge in a reproducible way, and to build new knowledge, are censored out (not necessarily consciously). Now kids come to university: &amp;ldquo;Proof? Eh?&amp;rdquo; Bad? Would you like to sacrifice the widespread tolerance to improve math?&lt;/p&gt;

&lt;p&gt;So my point is: a lot of ground for success of the Russian education system was hardwired into the ideological situation. However, it might be that the situation already bootstrapped itself into a self-supporting state of a widespread readiness to get fascination from a play of mind, even if this play requires some nontrivial mental tension. Maybe this readiness can survive the &amp;ldquo;return to the normal ideology.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Suppose that all you need is such a readiness in a sufficient number of teachers, and this would create enough interested pupils to form the next generation of such teachers. How to bootstrap such a situation in U.S.? There may be some US-specific answers which I would not be able to even imagine. Something crazy like a philanthropist buying an hour a week on MTV, with MTV specialists who know how to speak to kids-of-today collaborating with science enthusiasts and some cold minds (so that it would not degenerate into another kindergarten like Sesame Street).&lt;/p&gt;

&lt;p&gt;Myself, I favor something less focussed on the situation of today. Say, there are teacher&amp;rsquo;s conventions anyway. Why not organize math/physics/chemistry/biology/linguistics problem-solving competition there? It would be quite low-budget. Here I mean &amp;ldquo;cool&amp;rdquo; problems, as on international olympiads (but of course, slightly simpler). It should not be hard to find volunteers to design the problems, the Bay Area already has a Russian-style math olympiad running.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Can the internet be better leveraged as a tool for creating a distributed group of academic specialists? It seems like Perl development models this bringing and binding together of very bright people for a focused task. Can this model work for academia?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;IZ&lt;/strong&gt;: This would be a wonderful achievement. And I think that in some branches, where many researchers work over many similar problems with the difficulties being more or less technicalities, it is quite close to being possible. But in general, there are many reasons which make this much harder.&lt;/p&gt;

&lt;p&gt;One of the reasons I&amp;rsquo;m even ready to spell out. It is the delayed gratification. Math research is very special in the typical delay between the moment you start to work over a particular question, and the moment you can report &lt;em&gt;anything&lt;/em&gt;. While the delay of five or 10 years would be rare, for important breakthroughs it may be typical, and the delay of a few years is quite common. In between you accumulate &amp;ldquo;gut feelings,&amp;rdquo; but successful sharing of gut feelings is a special skill which is lacking in most people.&lt;/p&gt;

&lt;p&gt;It may be similar to the situation in some experimental sciences, when the results follow from tiny but statistically significant mismatches between vast collections of experimental data. You start to collect the data, but until you are done, you cannot explain &lt;em&gt;why&lt;/em&gt; you collect it: you do not even know whether the data is going to self-consistent or not. And if it turns out to be self-consistent, your time is wasted.&lt;/p&gt;

&lt;p&gt;There are many timers hardwired into human brains. It is a common delay of 2 months until you are ready to take a newly explained to you point of view (at least in math, where different points of view differ &lt;em&gt;a lot&lt;/em&gt;). It is a common delay of three years when a mathematician switches to a completely new to him branch of math. I have not heard it discussed, but there may be a significant reproducible delay when newly invented concepts need to remain in a &amp;ldquo;wordless&amp;rdquo; state. And when you can write them down, usually there is a significant &amp;ldquo;technicalities-only&amp;rdquo; period until these concepts turn out into results.&lt;/p&gt;

&lt;p&gt;Given that the gratification is delayed for so long, cooperation between people requires much closer relationships than what the Internet Neighborhood can provide. Who will you trust enough to dedicate several years of your time (even in the time-to-time mode)?&lt;/p&gt;

&lt;p&gt;By the way, this may be a major obstacle on the way to Perl 6. People will need to code &amp;ldquo;into their tables:&amp;rdquo; What they produce will not be able to run until all the other required components are finished, too. I would expect that after the initial frenzy there will be a long lull period. Some new ideas will be needed to break the lull.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;If you couldn&amp;rsquo;t lecture at a university, how would you spend your days, assuming money wasn&amp;rsquo;t an issue?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;It may be I&amp;rsquo;m a very undemanding person, so I&amp;rsquo;m very content with what I already have. Or maybe I&amp;rsquo;m just scared of change &amp;hellip; At least it was always hard to imagine any other way of life than one I had at the moment. (Not that I cannot move my seat if needed - but only if needed indeed!)&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Damian Conway Talks Shop</title>
      <link>http://localhost:1313/pub/2000/08/conway.html/</link>
      <pubDate>Mon, 21 Aug 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/08/conway.html/</guid>
      <description>&lt;p&gt;&lt;em&gt;Dr. Damian Conway is best known in the United States for authoring&lt;/em&gt; Object Oriented Perl&lt;em&gt;, published by Manning. His lectures at Perl conferences are becoming legendary and are a joy for Perl hackers of all levels. I managed to catch up with Dr. Conway just before his fall semester of lecturing at Monash University in Australia began.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Joe Johnston: Although you give a pretty decent account of your teaching career at &lt;a href=&#34;http://www.csse.monash.edu.au/~damian/bio.html&#34;&gt;http://www.csse.monash.edu.au/~damian/bio.html&lt;/a&gt;, could you state your day job for the record?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Damian Conway&lt;/strong&gt;:&lt;/p&gt;

&lt;p&gt;Name: Conway, D. M.
Rank: Senior Lecturer, Computer Science, Monash University.
Serial number: 8371 466.
&lt;strong&gt;JJ: Fred Brook&amp;rsquo;s Mythical Man Month and No Silver Bullet are classic essays on the business and art of software engineering. The main point of the former is that application developers need to be managed more like commissioned artists, rather than as factory workers. The later work suggests that there will never be a design tool that significantly makes software development schedules more deterministic. Are these works still relevant and do you have your undergrads read either of these?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; I often recommend &amp;ldquo;MMM&amp;rdquo; to my software engineering students, but mainly for the real life horror stories it includes. They do a semester of SE and think they&amp;rsquo;re ready to build their own operating system. Brooks&amp;rsquo; tales from the trenches are a useful antidote.&lt;/p&gt;

&lt;p&gt;Both books &lt;em&gt;are&lt;/em&gt; still relevant, even though we&amp;rsquo;re now living in The Future. The situations and problems they describe may be now mainly historical, but the underlying issues are perennial.&lt;/p&gt;

&lt;p&gt;Programming is a Dark Art, and it will always be. The programmer is fighting against the two most destructive forces in the universe: entropy and human stupidity. They&amp;rsquo;re not things you can always overcome with a &amp;ldquo;methodology&amp;rdquo; or on a schedule.&lt;/p&gt;

&lt;p&gt;And when you look at it, we haven&amp;rsquo;t come that far in the quarter century since Brooks first published &amp;ldquo;MMM.&amp;rdquo; Sure we have more development tools and techniques, but most of them (and most programming languages too!) don&amp;rsquo;t really help. Especially not on large projects (i.e., anything over three or four developers).&lt;/p&gt;

&lt;p&gt;They&amp;rsquo;re designed to force the software team into someone else&amp;rsquo;s (usually academic) conception of how a program should be created. Generally they advocate ways of working that make &lt;em&gt;no&lt;/em&gt; allowance for the needs, motivations, and goals of the humans in the system. So Real Programmers don&amp;rsquo;t use them, and programming stays a handicraft &amp;ndash; a multi-trillion dollar cottage industry.&lt;/p&gt;

&lt;p&gt;Of course, it would be easy to fix that: make the software vendors liable for the correctness and reliability of their software and you&amp;rsquo;d see an instant revolution in development. There&amp;rsquo;s plenty of research and practical experience in building reliable systems using unreliable components (i.e., programmers). But as long a companies can turn a buck or two (billion) by shipping pre-beta quality software, why would they bother to find or mandate better ways?&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: There are those in the Open Source Community that point out that greed is not sufficient motivation to produce quality software, which is often the labor of love. How can Joe Programmer (not this Joe programmer) learn to love developing accounting applications?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; He or she &lt;em&gt;can&amp;rsquo;t&lt;/em&gt;. No more than you can make a COBOL programmer love hacking kernel. People sometimes offer me contracts writing DB interfaces or building websites, but I tell them I&amp;rsquo;m not worth what I&amp;rsquo;d charge to do that. Because I&amp;rsquo;d be doing it strictly for the (very large amount of) money, rather than for love of the project. They wouldn&amp;rsquo;t get my best.&lt;/p&gt;

&lt;p&gt;Whatever software your trying to build, you need people who are inspired by the &lt;em&gt;idea&lt;/em&gt; of that software. Even if they aren&amp;rsquo;t virtuoso hackers: you can always teach a person to code better, or tidy their code after it&amp;rsquo;s written; you can &lt;em&gt;never&lt;/em&gt; teach a person to love your project. And without that emotional engagement, you&amp;rsquo;ll never get the superhuman effort that&amp;rsquo;s required to produce quality software.&lt;/p&gt;

&lt;p&gt;It often seems to me that recruiters ask the wrong questions when interviewing programmers. Sure you have to find out if they know the difference between an argument and a parameter, but it&amp;rsquo;s vastly more important to discover what kind of enthusiasm and energy they&amp;rsquo;re going to bring to your project, why they&amp;rsquo;ll put in 18-hour days on it, why they&amp;rsquo;d pay &lt;em&gt;you&lt;/em&gt; to work on it. Find those people and you&amp;rsquo;ll get quality accounting software.&lt;/p&gt;

&lt;p&gt;And in a roundabout way, that&amp;rsquo;s why we need diversity in languages (and &lt;em&gt;within&lt;/em&gt; languages). So that there can be languages that fit a diversity of brains. So that every kind of geek can find his or her passion. Many of us love to diss COBOL and VB and Ada and PHP and Python, but we need to remember that, without those languages and the brave souls dedicated to &amp;ndash; and inspired by &amp;ndash; them, &lt;em&gt;we&lt;/em&gt; would have to write accounting software and bad GUIs and defence protocols and dull websites. In Perl. &lt;code&gt;:-(&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: The world needs uncool software. Can we judge the hepness of an application by its quality?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; No. Because to some folks it &lt;em&gt;really is&lt;/em&gt; hip to be square. All you can tell about quality software is that someone thought it was important enough to care about, to invest themselves in. And people can feel that way about the oddest, unheppest things: model trains, mime, cloisonne eggs, folk dancing, even accounting applications.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: At Perl Conference 4.0, the Best Technical Paper award was renamed the Damian Conway Award. I don&amp;rsquo;t even have a name on my office door. Will you be posing for the award statue?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; I&amp;rsquo;m only 5&amp;rsquo;6&amp;rdquo;. Put me on a block of marble and I could &lt;em&gt;be&lt;/em&gt; the award statue!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: That won&amp;rsquo;t work. You wouldn&amp;rsquo;t stand still long enough to present the award.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; That could be the criterion: to win the award you have to keep up with it &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: If a calendar of Perl Hunks were assembled, which month would you be?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC&lt;/strong&gt;: JJ: You &lt;em&gt;have&lt;/em&gt; to get off the drugs, Joe! And soon! A Perl Hunk calendar??? How sick is that?&lt;/p&gt;

&lt;p&gt;Oh, very well then: August.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: This just in from the Perl section of Teen Beat, what tunes are on your CD/LP/MP3 player these days?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&amp;ldquo;Five&amp;rdquo;, J.J.Cale&lt;/li&gt;
&lt;li&gt;&amp;ldquo;Oxygene&amp;rdquo;, Jean-Michel Jarre&lt;/li&gt;
&lt;li&gt;&amp;rdquo;&amp;lsquo;Gladiator&amp;rsquo; soundtrack&amp;rdquo;, Zimmer &amp;amp; Gerrard&lt;/li&gt;
&lt;li&gt;&amp;rdquo;&amp;lsquo;Sense &amp;amp; Sensibility&amp;rsquo; soundtrack&amp;rdquo;, Carl Davis&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;JJ: Speaking of fluff, Paul Allen has been &lt;em&gt;real&lt;/em&gt; busy spending money these days. From seeding Transmeta to donating millions to the Search for ExtraTerrestrial Intelligence (SETI), Allen has been spreading his Microsoft millions liberally. What projects would you like to fund with your future trillions?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; C&amp;rsquo;mon! I&amp;rsquo;m a mad scientist/hacker from Australia. I &lt;em&gt;seriously&lt;/em&gt; doubt I will ever have major disposable income.&lt;/p&gt;

&lt;p&gt;But if I did, I&amp;rsquo;d be funding:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Nanotechnology. I &lt;em&gt;want&lt;/em&gt; microbots tending each blade of grass on my lawn and quitely rolling dust and dirt off my floors.&lt;/li&gt;
&lt;li&gt;Vacuum point energy research. I hate having to recharge lap-top batteries. Energy wants to be Free.&lt;/li&gt;
&lt;li&gt;Gerontology. We only get one go, and 100 years isn&amp;rsquo;t nearly long enough.&lt;/li&gt;
&lt;li&gt;Education. Better education reduces world misery in so many ways. It fights poverty, overpopulation, prejudice, and tyranny.&lt;/li&gt;
&lt;li&gt;People. I&amp;rsquo;d spend my time finding humanity&amp;rsquo;s best and most creative people, and just pay them to be them. Sure, you might not pick the right person 9 times out of 10. But what if the tenth were another Mary Shelley, or Frank Lloyd Wright, or Murasaki Shikibu, or Larry Wall?&lt;/li&gt;

&lt;li&gt;&lt;p&gt;A Buddhist monastery. Peace is a renewable resource, but the world lacks enough processing capacity.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: For the people that have read your book &amp;ldquo;Object Oriented Perl&amp;rdquo; or heard your conference lectures, your commitment to bring respectability to Perl&amp;rsquo;s OO model is well known. Oddly enough, you have seem to have other comp sci interests. What is &amp;ldquo;automation of hypermedia&amp;rdquo; and how does it apply to user interfaces?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; Anyone who has put together a large website knows how long and hard the process is. Anyone who has tried to use a large website knows how rarely the process is done well.&lt;/p&gt;

&lt;p&gt;For a time, I was developing tools to make it possible to generate navigable, comprehensible, usable websites with nothing more that vi. I developed a system that used text files for content, with very minimal mark-up, to generate full websites for various programming courses I was running. It would index all the material, cross-reference it, annotate it with exercises, hyperlink it back to glossaries and bibliographies, construct course syllabuses and outlines, etc., etc.&lt;/p&gt;

&lt;p&gt;And, of course, it was all done with a single, rambling, arcane, semi-sentient Perl program &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: Have you used HTML::Template or HTML::Mason? Both allow Perl to be embedded in an otherwise static HTML page. This is sort of the server-side include method as used by ASP and Cold Fusion.&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC&lt;/strong&gt;: I haven&amp;rsquo;t used them, but I&amp;rsquo;ve heard very good things about both modules.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: More generally, is Perl ready for next generation web applications or are Perl tools not evolving fast enough for very large websites with large and diverse development teams?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; I&amp;rsquo;m not sure anyone or any tool is ready for the demands of mega-websites, anymore than existing software development approaches are ready for Programming In The Very Large. I don&amp;rsquo;t think we know how to reliably create huge linear programs that are safe, robust, and efficient. Add in the web&amp;rsquo;s demands for multimedia, hyperconnectivity, and interactivity, and I think our software technologies are at least a decade behind demand.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Some parent groups in the U.S. question whether computers are having a positive impact on children. They claim that video games are not meaningfully more interactive than Plain Old TV (POTV). Should any nation eschew raising teachers&amp;rsquo; salaries in favor of installing classroom computers? Are the Luddites right?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; Technology is not the enemy. &lt;em&gt;Deification&lt;/em&gt; of technology is the enemy.&lt;/p&gt;

&lt;p&gt;Any nation that favours a technological fix over funding good teaching is going to get what it deserves: neither a technological fix, nor good teaching.&lt;/p&gt;

&lt;p&gt;Western culture is increasing about magic bullets. We think a pill or a weekend course or a laying-on-of-hands is going to instantly solve our problem. As though we lived in a weekly sitcom with a 30-minute story arc.&lt;/p&gt;

&lt;p&gt;Putting computers in classrooms instead of teachers is doing just that: Latching on to a single &amp;ldquo;quick fix&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Of course, you do have to give the kids access to the technology. Not doing so nowadays is as criminal as not teaching them to read. But you still have to teach them to read, and think, and learn, as well!&lt;/p&gt;

&lt;p&gt;Put 30 kids in a room with an easel, a computer, and a guitar. You&amp;rsquo;ll get one Van Gogh, one Von Neumann, and one Van Halen (or Van Morrison). And 27 burger flippers. &lt;code&gt;:-(&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Every child has some great potential, but almost all of them need help to find it, and nurture it, and control it, and master it. They need a teacher, a guide, a role model. No machine is going to give them that. At least, not for a long time yet.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: The big news at TPC 4.0 of course was Perl Episode 6, The Phantom Rewrite. What are three (or more) things you&amp;rsquo;d most like to see addressed in this reconstruction?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; Well, I have a list of 40 or so things I&amp;rsquo;m hoping to propose for Perl 6. The big ones include:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Getting rid of the requirement for a final true value in &lt;code&gt;require&lt;/code&gt;&amp;rsquo;d files&lt;/li&gt;
&lt;li&gt;Finding a better name for &lt;code&gt;local&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Making == work more DWIMly on numeric operands strings&lt;/li&gt;
&lt;li&gt;New control structures: co-routines, switch statement, multiway comparisons&lt;/li&gt;
&lt;li&gt;Fixing the nested iteration behaviour of hashes&lt;/li&gt;
&lt;li&gt;Redesigning the format syntax and make it a subroutine in a pragma&lt;/li&gt;
&lt;li&gt;Subroutine parameter lists and extra context specifiers&lt;/li&gt;
&lt;li&gt;Numerous enhancements to OO Perl:

&lt;ul&gt;
&lt;li&gt;hierarchical construction and destruction&lt;/li&gt;
&lt;li&gt;built-in encapsulation of attributes&lt;/li&gt;
&lt;li&gt;extended, integrated operator overloading&lt;/li&gt;
&lt;li&gt;multimethods&lt;/li&gt;
&lt;li&gt;method redispatch&lt;/li&gt;
&lt;li&gt;method pre-conditions, post-conditions, and invariants (also for ordinary subroutines)&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Regular expression matching against subroutines and filehandles&lt;/li&gt;
&lt;li&gt;Run-time access to source code parse tree, and simpler source filters&lt;/li&gt;
&lt;li&gt;Higher order functions&lt;/li&gt;
&lt;li&gt;Lazy evaluation of subroutine argument lists&lt;/li&gt;
&lt;li&gt;Extended context detection features&lt;/li&gt;
&lt;li&gt;Superpositions&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;JJ: What are the three scariest nightmares the corporate world has about Perl that prevent wider adoption of our favorite language?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC&lt;/strong&gt;: I don&amp;rsquo;t know very much about the corporate world, but I guess three common fears might be:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;Perl is unclassifiable&lt;br /&gt;
COBOL is a banking language, Fortran is a numerical computation language, C is a systems programming language, Visual Basic is a GUI applications language, Java is a web programming language. What is Perl?&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perl is unmaintainable&lt;br /&gt;
Line noise programs, numerous defaults, subtle context propagation, symbolic references, closures, unconstrained OO model, one-liners, weird modules maintained by weirder hackers, typeglobs, AUTOLOADING, operator overloading, source filters, etc., etc.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Perl is unsupported&lt;br /&gt;
Yeah, I know, I know. But there&amp;rsquo;s no $599 MS-Perl with a GUI interface and an exorbitant support contract.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The Perl Mongers are making valiant in-roads against those perceptions, but they can&amp;rsquo;t make Perl the static, commercial, boring tool that many managers are used to. And hence comfortable with.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll have to wait until the grunts who are actually using Perl in the trenches &amp;ndash; and holding entire organizations together with it &amp;ndash; get promoted into management. For them, Perl &lt;em&gt;will&lt;/em&gt; be the safe and familiar option.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: You&amp;rsquo;re a big burly OO dude. Why aren&amp;rsquo;t you programming in Python?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; When you live in Australia, you learn to be wary of snakes.&lt;/p&gt;

&lt;p&gt;Seriously though, I don&amp;rsquo;t use Python because I&amp;rsquo;m not &lt;em&gt;just&lt;/em&gt; a big burly OO dude. I&amp;rsquo;m also a frightening functional dude, and a devious declarative dude, and an insidious imperative dude. In order to mess with people&amp;rsquo;s minds, I need to be able to mess with a programming language&amp;rsquo;s syntax and semantics: add a switch statement, change the dispatch model, superimpose scalars, lock down hash access, intercept error messages and convert them to haiku, impose design-by-contract constraints, or reconstruct the language in Latin or Klingon. Only Perl lets me push (fold, spindle, multilate) the envelope like that.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: What&amp;rsquo;s your favorite part of your native country?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; The hilly spa country around Daylesford, Victoria. Rolling green hills, temperate climate, clean air, perfect.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: The US &amp;ldquo;Dot.COMomy&amp;rdquo; has become colder than a bartender after closing time. Will those programmers who have only been in start-ups have a hard time adjusting to an economy in which they aren&amp;rsquo;t lusted after like jade idols?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC:&lt;/strong&gt; Good programmers will always be in demand &amp;ndash; there are so few of them around. And computers and the Internet are here to stay, even after the hype has died.&lt;/p&gt;

&lt;p&gt;Those refugees from Start-Ups are not going to see the same mania for their services, but they&amp;rsquo;ll still see good salaries and packages. What they&amp;rsquo;ll have trouble adjusting to is an economy where they&amp;rsquo;re expected to perform within the rules, keep office hours, wear shoes, write reports, cut code to spec rather than because it&amp;rsquo;s cool. That&amp;rsquo;s going to hurt. But the companies that survive will survive because they extract more value from their employees than those employees cost. In that sense, there is no &amp;ldquo;new&amp;rdquo; economy.&lt;/p&gt;

&lt;p&gt;The down side is that, in the future, you&amp;rsquo;ll have to be right on the end of the bell curve to offer your boss enough value to justify the cost of your bohemian behaviour.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;JJ: If Perl were to disappear tomorrow, what would its legacy be?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;DC&lt;/strong&gt; That programing languages should be made to fit humans, not vice versa.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>ANSI Standard Perl?</title>
      <link>http://localhost:1313/pub/2000/06/rosler.html/</link>
      <pubDate>Tue, 06 Jun 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/06/rosler.html/</guid>
      <description>

&lt;h3 id=&#34;an-interview-with-hp-s-larry-rosler&#34;&gt;An Interview with HP&amp;rsquo;s Larry Rosler&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Larry Rosler was both editor of the draft standard and chairman of the Language Subcommittee for X3J11. He helped put &amp;lsquo;ANSI&amp;rsquo; in front of C. He is also just another Perl hacker. Larry recently took time out of his busy schedule to share his thoughts on the value of standards, how Sun ought to handle Java and optimizing Perl code.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What&amp;rsquo;s your background? How did you get interested in computers?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: My formal education was in physics; my research field was experimental nuclear physics. However, I soon learned that I was more interested in the equipment used to gather and analyze the data than in the physics. The equipment was essentially a digital computer, but there were no degrees in computer science in those days.&lt;/p&gt;

&lt;p&gt;In my first major job, with Bell Labs in New Jersey, I worked on solid-state devices. I found that simulation was faster than building and measuring test devices. When others began to use the programs I wrote, I realized that my greatest professional satisfaction would be as a software &amp;lsquo;toolmaker&amp;rsquo;. So I switched to building tools such as graphical design terminals, and then focused on programming languages and libraries.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I was taught by several &amp;ldquo;hardware&amp;rdquo; guys who got into programming somewhat reluctantly. Do you feel that novice programmers lose an important perspective without knowing what goes on under the hood?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: I taught the first course on C at Bell Labs, using a draft of K&amp;amp;R, which helped vet the exercises. The students were hardware engineers who were being induced to learn programming. They found C (which is &amp;lsquo;portable assembly language&amp;rsquo;) much to their liking. Essentials such as pointers are very clear if you have a machine model in mind.&lt;/p&gt;

&lt;p&gt;Perl is at a higher level of abstraction, so the machine model isn&amp;rsquo;t as necessary &lt;em&gt;at first&lt;/em&gt;. But when you get to complex data structures, which require references (which are like pointers in C, but much safer), a grounding in addressing becomes useful.&lt;/p&gt;

&lt;p&gt;In an ideal world, a student would first learn an abstract assembly language such as MIX (see Knuth, Vol. 1), do some useful exercises, then take on a higher-level language with the machine model in the back of the head.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;When did you run into Perl? What did you think of the language the first time you saw it?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: I am a relative latecomer to Perl. I was experimenting with CGI programming using shell scripts (!) because they were better for rapid prototyping than C. Soon I discovered that Perl offered advantages similar to the shell, but was much more expressive (particularly in the manipulation of data structures) and much faster to execute.&lt;/p&gt;

&lt;p&gt;Because of my familiarity with Unix commands such as &amp;lsquo;sed&amp;rsquo;, which made heavy use of regular expressions, and because of my C experience, I was quite comfortable with Perl syntax. The hardest adjustment was to learn to write code with as few Perl operations as possible, because of the costs of dispatching each instruction. The Benchmark module became the most important tool I used to learn how to write efficient (and hence, sometimes elegant) Perl. I also learned a lot from the newsgroup comp.lang.perl.misc, to which I eventually became able to contribute.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Often Perl claims to be efficient in the scarce resource of the programmer&amp;rsquo;s time. It isn&amp;rsquo;t often that people tune scripts for optimum performance. Are there a few tips you can give to new Perl programmers on how squeak out a little better runtime performance?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: &amp;lsquo;Script&amp;rsquo; &lt;code&gt;ne&lt;/code&gt; &amp;lsquo;program&amp;rsquo;. When dealing with data sets that will grow (one hopes and expects), performance becomes important. I proposed a tutorial to Perl Conference 4.0 this year on this subject, but it wasn&amp;rsquo;t accepted. Maybe next year.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;0. Don&amp;rsquo;t optimize prematurely!&lt;/li&gt;
&lt;li&gt;1. Don&amp;rsquo;t use an external command where Perl can do a task internally.&lt;/li&gt;
&lt;li&gt;2. Refine the data structures and algorithms. References: The Practice of Programming (Kernighan and Pike), Programming Pearls (Bentley), Algorithms with Perl (Orwant et al).&lt;/li&gt;
&lt;li&gt;3. After these are optimal, identify the remaining hot spots. (Judicious use of the time() and times() functions, or the Benchmark module.)&lt;/li&gt;
&lt;li&gt;4. Try to improve the hot spots by using functions such as map() and grep() instead of explicit loops; make regexes more explicit to minimize backtracking; cache intermediate results to avoid unnecessary recalculation (memoization), &amp;hellip;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;strong&gt;What&amp;rsquo;s your favorite part of programming? Design or implementation (or other)?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Happy users.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I understand you were the Chairman of the ANSI C committee. How did that come about?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Not the chairman &amp;ndash; that was primarily an administrative function, and what I did was more technical. I was the chairman of one of the three major subcommittees (Language; the others were Library and Environment), and &amp;ndash; most important &amp;ndash; I was the editor of the Draft Standard. The hand that holds the pen controls the direction of the work and the results. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;This all happened because at Bell Labs I was one of the managers of the effort to turn C from a research vehicle to a commercially useful language, which began with internal standardization. Because of the demands of some major users, such as the US Government, commercialization required the development of a formal standard. My colleague Dennis Ritchie (who created C) didn&amp;rsquo;t want to participate personally, but he was always active behind the scenes in reviewing and improving my efforts. He was quite satisfied with the final results.&lt;/p&gt;

&lt;p&gt;A few years later, now working at Hewlett Packard, I found myself in the same position regarding C++. I persuaded Bjarne Stroustrup, the creator of C++, to support standardization, as a prerequisite for successful commercialization. He agreed, and took a very active role.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;There&amp;rsquo;s certainly no ANSI Perl. Does Perl need the same kind of official standardization that C got?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: I believe that it does, in order to increase its acceptability. Many organizations either cannot or will not endorse the use of unstandardized languages in their business-critical activities.&lt;/p&gt;

&lt;p&gt;The current situation with Perl is better than it was with the other two languages I mentioned. Perl has one official open source for its implementation, whereas the others had multiple proprietary implementations, leading to different semantics for many language features. But this single &amp;lsquo;official&amp;rsquo; Perl semantics has never been adequately characterized independent of the implementation, so is subject to arbitrary change.&lt;/p&gt;

&lt;p&gt;Building on quicksand is acceptable for &amp;lsquo;scripts&amp;rsquo; of limited longevity and applicability. It is not acceptable for &amp;lsquo;programs&amp;rsquo; of significant commercial value. I think the lack of a firm, stable, well-defined foundation is the major inhibitor for the continuing commercial evolution of Perl. Of the major contributors to Perl, Ilya Zakharevitch is most outspoken in his view that Perl is not (yet?) a &amp;lsquo;programming&amp;rsquo; language!&lt;/p&gt;

&lt;p&gt;Many of the people who contribute their efforts to the Perl community are interested in adding features, perhaps to overflowing. More people should devote their attention to firming up the semantics and making sure that the implementation conforms to those semantics, rather than the other way around.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Your point is well taken about focusing future Perl development on producing consistent semantics. I&amp;rsquo;m a bit surprised that you see this as a barrier to greater Perl acceptance. Some might suggest the interpretive nature of the language is a greater barrier (&amp;ldquo;Why can&amp;rsquo;t I get a hello.pl.exe?&amp;rdquo;).
Or point to Perl&amp;rsquo;s endearingly unique syntax.
Or to Perl&amp;rsquo;s charmingly permissive OO implementation.
Are there particular areas of Perl&amp;rsquo;s semantics in which the inconsistencies are glaring?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: I am less concerned about individual programmers&amp;rsquo; decisions for their own projects and more concerned about major corporations or government agencies that reject Perl because of lack of formal support and lack of standardization.&lt;/p&gt;

&lt;p&gt;An example of excellent work that is long overdue is Ilya&amp;rsquo;s document &amp;lsquo;perlnumber&amp;rsquo;, new in Perl 5.6.0, which specifies for the first time the semantics of Perl&amp;rsquo;s string-to-number conversions.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I&amp;rsquo;m curious how one would standardize Perl when the language changes so quickly and committees move so slowly. Consider that three years ago, Perl was not threaded. Now, threads are standard, but their interface may change in the near future. Mr. Zakharevich continues to pull new regex constructs from head of Zeus. Even more striking, Perl supports unicode. Is there some way to stage the standardization so that it isn&amp;rsquo;t painfully out-of-date? Would standardization necessarily slow down perl development?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Sometimes standardization speeds up development, by forcing convergence on a specified way of doing things. Sometimes features are characterized and implemented during standardization (wide-character types for C, for example; the Standard Template Library and many other features for C++).&lt;/p&gt;

&lt;p&gt;One way to view it is re Samuel Johnson&amp;rsquo;s famous mot: &amp;ldquo;When a man knows he is to be hanged in a fortnight, it concentrates his mind wonderfully.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Are you following the debate amongst programmers who favor Sun lessening their control over Java (especially after Sun withdrew it from the &lt;a href=&#34;http://www.zdnet.com/eweek/stories/general/0,11011,2405787,00.html&#34;&gt;independent standardization process&lt;/a&gt;)? Do you feel Java might benefit from a more open/chaotic development model (ala Perl), should it follow the C path of getting independent standardization, or is Sun doing the best thing for the language by keeping it &amp;ldquo;in-house&amp;rdquo;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: My prejudice should be clear from what I have already written. AT&amp;amp;T handed control over C and C++ to ANSI/ISO technical committees, while keeping an active leadership role to ensure that the goals of the originators of the languages were met. Sun should do the same.&lt;/p&gt;

&lt;p&gt;On the other hand, Microsoft&amp;rsquo;s desire to &amp;lsquo;embrace and extend&amp;rsquo; Java should be doomed by standardization, just as they failed to subvert the target independence of C and C++.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;My understanding is that Microsoft is &amp;lsquo;embracing&amp;rsquo; ActiveState&amp;rsquo;s Perl. They will be shipping Perl with their &amp;ldquo;Services for UNIX 2.0&amp;rdquo;. Do you see any chance for Perl to compete on a Windows Platform as a replacement for Visual Basic? In particular, as application &amp;ldquo;glue&amp;rdquo;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Why not? Perl is superior to Visual Basic in every way imaginable.&lt;/p&gt;

&lt;p&gt;Maybe a push from Microsoft will help overcome the barrier of acceptability that I focused on above.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Back to Java for a moment. Because they are both &amp;ldquo;web technologies&amp;rdquo;, Perl and Java are often seen as competitors. There have been attempts, like Larry Wall&amp;rsquo;s JPL, to provide better integration between these two beasties. What sort of utility do you see in such a marriage?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Hard for me to say. Java forces OO programming from the beginning, and I have never needed to write an object in any program. This may be for me a conceptual hurdle that I need not overcome.&lt;/p&gt;

&lt;p&gt;C++ provides sweetened C syntax and semantics (particularly toward bits and bytes), generic programming (templates), and OO if you want it. This can all be done with almost the efficiency of C.&lt;/p&gt;

&lt;p&gt;Perl provides higher-level syntax and semantics (particularly toward strings and complex data structures), and OO if you want it. I know how to write efficient Perl when I have to.&lt;/p&gt;

&lt;p&gt;Java, in my opinion, fills a much-needed gap between those two approaches. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Speaking of competitors, Python is making a big splash this year. Although it seems to satisfy many of the same itches Perl does, its proponents point to its cleaner syntax and more tradition OO implementation as making it a &amp;ldquo;better Perl&amp;rdquo;. What are your thoughts on Python?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Whatever improvements Python may offer are not sufficient to give it a critical mass of programmers and programming support relative to Perl. There is an order-of-magnitude difference in this metric (programmers, modules, books, &amp;hellip;), and I don&amp;rsquo;t think significant inroads are being made. And, as I said, to me OO is a big yawner.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What five people would you like to see learn Perl?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Hah! Some colleagues are now trying to convince me to move on to Python. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Have you had the chance to read Mr. Conway&amp;rsquo;s _Object Oriented Perl_? I found I learned more about general Perl from it than OO techniques (which by no means is to say book is inadequate in the latter department).&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Yes. It is a fine book. But it still didn&amp;rsquo;t convince me about the necessity of objects. All I see is the performance-damaging complexity of the interfaces.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How much longer do you see the &amp;ldquo;Internet Goldrush&amp;rdquo; continuing?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Judging by the recent performance of the NASDAQ, it may be over already.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You presented a paper at TPC on efficient sorting with Uri Guttman, a fellow Boston Perl Monger. How did you two meet?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: We met in comp.lang.perl.misc in March 1998 (soon after I began to post questions to the newsgroup). Uri educated me on &amp;lsquo;hash slices&amp;rsquo;, which he eventually turned into a tutorial. That July, I spotted his and his wife&amp;rsquo;s names in the credits at the end of a movie, which exposed a common non-Perl interest (in Jews and Buddhism, to be specific). We met for the first time at TPC2 in San Jose that August.&lt;/p&gt;

&lt;p&gt;The paper on sorting was developed entirely by email. The next time we met in person &amp;ndash; together with Damian Conway and our wives &amp;ndash; was at TPC3 in Monterey. We will meet again there at TPC4 this summer. Each of us is working on the Perl Golf tournament, which Uri organized.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Do you have any tips for new programmers dealing with management?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Agree on useful metrics for progress and completion. Never report that your code is 90% complete, 90 days from completion, because that tends to be a steady-state description.&lt;/p&gt;

&lt;p&gt;Never estimate more than about half your time actually working on the project, because other things will always happen.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Has this rapid web development trampled on software quality control irreparably?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: Not only the web &amp;ndash; Microsoft. Who would have imagined that the world would tolerate an environment with the dismal quality of Windows? So now every company, even those such as Hewlett Packard with long-standing reputations for high quality, has to compromise in order to compete in a timely way.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Since you&amp;rsquo;ve in the business for a respectable number of years, what are your five biggest pet peeves about programming?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;LR&lt;/strong&gt;: That&amp;rsquo;s a toughie. How about four, in no particular order:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Extracting from the potential user a complete and useful specification of a problem.&lt;/li&gt;
&lt;li&gt;Coping with buggy or inadequately documented tools.&lt;/li&gt;
&lt;li&gt;Keeping things functioning as operating environments evolve. (No one wants anything to change except the things that that person wants changed. &lt;code&gt;:-)&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;As I said above, evaporating expectations of quality.
(1980&amp;rsquo;s paradigm: If it&amp;rsquo;s worth implementing once, it&amp;rsquo;s worth implementing twice.
1990&amp;rsquo;s paradigm: Ship the prototype!
2000&amp;rsquo;s paradigm: Ship the idea!)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

