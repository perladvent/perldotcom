<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Doug Sheppard on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/authors/doug-sheppard/</link>
    <description>Recent content in Doug Sheppard on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 07 May 2008 00:00:00 -0800</lastBuildDate>
    <atom:link href="/authors/doug-sheppard/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Beginner&#39;s Introduction to Perl 5.10, Part 2</title>
      <link>http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html/</link>
      <pubDate>Wed, 07 May 2008 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl 5.10&lt;/a&gt; talked about the core elements of Perl: variables (scalars, arrays, and hashes), math operators and some basic flow control (the &lt;code&gt;for&lt;/code&gt; statement). Now it&amp;rsquo;s time to interact with the world. (&lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt; explores regular expressions, matching, and substitutions. &lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt; demonstrates how to write web programs.)&lt;/p&gt;

&lt;p&gt;This installment discusses how to slice and dice strings, how to play with files and how to define your own functions. First, you need to understand one more core concept of the Perl language: conditions and comparisons.&lt;/p&gt;

&lt;h3 id=&#34;comparison-operators&#34;&gt;Comparison operators&lt;/h3&gt;

&lt;p&gt;Like all good programming languages, Perl allows you ask questions such as &amp;ldquo;Is this number greater than that number?&amp;rdquo; or &amp;ldquo;Are these two strings the same?&amp;rdquo; and do different things depending on the answer.&lt;/p&gt;

&lt;p&gt;When you&amp;rsquo;re dealing with numbers, Perl has four important operators: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;. These are the &amp;ldquo;less than,&amp;rdquo; &amp;ldquo;greater than,&amp;rdquo; &amp;ldquo;equal to&amp;rdquo; and &amp;ldquo;not equal to&amp;rdquo; operators. (You can also use &lt;code&gt;&amp;lt;=&lt;/code&gt;, &amp;ldquo;less than or equal to,&amp;rdquo; and &lt;code&gt;&amp;gt;=&lt;/code&gt;, &amp;ldquo;greater than or equal to.)&lt;/p&gt;

&lt;p&gt;You can use these operators along with one of Perl&amp;rsquo;s &lt;em&gt;conditional&lt;/em&gt; keywords, such as &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;. Both of these keywords take a condition that Perl will test, and a block of code in curly brackets that Perl will run if the test works. These two words work just like their English equivalents &amp;ndash; an &lt;code&gt;if&lt;/code&gt; test succeeds if the condition turns out to be true, and an &lt;code&gt;unless&lt;/code&gt; test succeeds if the condition turns out to be false:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

if ($year_according_to_computer == 1900) {
    say &amp;quot;Y2K has doomed us all!  Everyone to the compound.&amp;quot;;
}

unless ($bank_account &amp;gt; 0) {
    say &amp;quot;I&#39;m broke!&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Be careful of the difference between &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;! One equals sign means &amp;ldquo;assignment&amp;rdquo;, two means &amp;ldquo;comparison for equality&amp;rdquo;. This is a common, evil bug:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

if ($a = 5) {
    say &amp;quot;This works - but doesn&#39;t do what you want!&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may be asking what that extra line of code at the start does. Just like the &lt;code&gt;use feature :5.10;&lt;/code&gt; code from the previous article, this enables new features of Perl 5.10. (Why 5.010 and not 5.10? The version number is not a single decimal; there may eventually be a Perl 5.100, but probably not a Perl 5.1000. Just trust me on this for now.)&lt;/p&gt;

&lt;p&gt;Instead of testing whether &lt;code&gt;$a&lt;/code&gt; is equal to five, you&amp;rsquo;ve made &lt;code&gt;$a&lt;/code&gt; equal to five and clobbered its old value. (A future article will show how to avoid this bug in running code.)&lt;/p&gt;

&lt;p&gt;Both &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt; can be followed by an &lt;code&gt;else&lt;/code&gt; statement and code block, which executes if your test failed. You can also use &lt;code&gt;elsif&lt;/code&gt; to chain together a bunch of &lt;code&gt;if&lt;/code&gt; statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

if ($a == 5) {
    say &amp;quot;It&#39;s five!&amp;quot;;
} elsif ($a == 6) {
    say &amp;quot;It&#39;s six!&amp;quot;;
} else {
    say &amp;quot;It&#39;s something else.&amp;quot;;
}

unless ($pie eq &#39;apple&#39;) {
    say &amp;quot;Ew, I don&#39;t like $pie flavored pie.&amp;quot;;
} else {
    say &amp;quot;Apple!  My favorite!&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You don&amp;rsquo;t always need an &lt;code&gt;else&lt;/code&gt; condition, and sometimes the code to execute fits on a single line. In that case, you can use &lt;em&gt;postfix conditional&lt;/em&gt; statements. The name may sound daunting, but you already understand them if you can read this sentence.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

say &amp;quot;I&#39;m leaving work early!&amp;quot; if $day eq &#39;Friday&#39;;

say &amp;quot;I&#39;m burning the 7 pm oil&amp;quot; unless $day eq &#39;Friday&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Sometimes this can make your code clearer.&lt;/p&gt;

&lt;h3 id=&#34;while-and-until&#34;&gt;&lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt;&lt;/h3&gt;

&lt;p&gt;Two slightly more complex keywords are &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt;. They both take a condition and a block of code, just like &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;, but they act like loops similar to &lt;code&gt;for&lt;/code&gt;. Perl tests the condition, runs the block of code and runs it over and over again for as long as the condition is true (for a &lt;code&gt;while&lt;/code&gt; loop) or false (for a &lt;code&gt;until&lt;/code&gt; loop).&lt;/p&gt;

&lt;p&gt;Try to guess what this code will do:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

my $count = 0;

while ($count != 3) {
   $count++;
   say &amp;quot;Counting up to $count...&amp;quot;;
}

until ($count == 0) {
   $count--;
   say &amp;quot;Counting down to $count...&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s what you see when you run this program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Counting up to 1...
Counting up to 2...
Counting up to 3...
Counting down to 2...
Counting down to 1...
Counting down to 0...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;string-comparisons&#34;&gt;String comparisons&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s how you compare numbers. What about strings? The most common string comparison operator is &lt;code&gt;eq&lt;/code&gt;, which tests for &lt;em&gt;string equality&lt;/em&gt; &amp;ndash; that is, whether two strings have the same value.&lt;/p&gt;

&lt;p&gt;Remember the pain of mixing up &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;? You can also mix up &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;eq&lt;/code&gt;. This is one of the few cases where it &lt;em&gt;does&lt;/em&gt; matter whether Perl treats a value as a string or a number. Try this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

my $yes_no = &#39;no&#39;;
say &amp;quot;How positive!&amp;quot; if $yes_no == &#39;yes&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why does this code think you said yes? Remember that Perl automatically converts strings to numbers whenever it&amp;rsquo;s necessary; the &lt;code&gt;==&lt;/code&gt; operator implies that you&amp;rsquo;re using numbers, so Perl converts the value of &lt;code&gt;$yes_no&lt;/code&gt; (&amp;ldquo;no&amp;rdquo;) to the number 0, and &amp;ldquo;yes&amp;rdquo; to the number 0 as well. Because this equality test works (0 is equal to 0), the condition is true. Change the condition to &lt;code&gt;$yes_no eq &#39;yes&#39;&lt;/code&gt;, and it&amp;rsquo;ll do what it should.&lt;/p&gt;

&lt;p&gt;Things can work the other way, too. The number five is &lt;em&gt;numerically&lt;/em&gt; equal to the string &lt;code&gt;&amp;quot; 5 &amp;quot;&lt;/code&gt;, so comparing them to &lt;code&gt;==&lt;/code&gt; works. When you compare five and &lt;code&gt;&amp;quot; 5 &amp;quot;&lt;/code&gt; with &lt;code&gt;eq&lt;/code&gt;, Perl will convert the number to the string &lt;code&gt;&amp;quot;5&amp;quot;&lt;/code&gt; first, and then ask whether the two strings have the same value. Because they don&amp;rsquo;t, the &lt;code&gt;eq&lt;/code&gt; comparison fails. This code fragment will print &lt;code&gt;Numeric equality!&lt;/code&gt;, but not &lt;code&gt;String equality!&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

my $five = 5;

say &amp;quot;Numeric equality!&amp;quot; if $five == &amp;quot; 5 &amp;quot;;
say &amp;quot;String equality!&amp;quot;  if $five eq &amp;quot; 5 &amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;more-fun-with-strings&#34;&gt;More fun with strings&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ll often want to manipulate strings: Break them into smaller pieces, put them together and change their contents. Perl offers three functions that make string manipulation easy and fun: &lt;code&gt;substr()&lt;/code&gt;, &lt;code&gt;split()&lt;/code&gt;, and &lt;code&gt;join()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you want to retrieve part of a string (say, the first four characters or a 10-character chunk from the middle), use the &lt;code&gt;substr()&lt;/code&gt; function. It takes either two or three parameters: the string you want to look at, the character position to start at (the first character is position 0) and the number of characters to retrieve. If you leave out the number of characters, you&amp;rsquo;ll retrieve everything up to the end of the string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $greeting = &amp;quot;Welcome to Perl!\n&amp;quot;;

print substr($greeting, 0, 7);     # &amp;quot;Welcome&amp;quot;
print substr($greeting, 7);        # &amp;quot; to Perl!\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A neat and often-overlooked thing about &lt;code&gt;substr()&lt;/code&gt; is that you can use a &lt;em&gt;negative&lt;/em&gt; character position. This will retrieve a substring that begins with many characters from the &lt;em&gt;end&lt;/em&gt; of the string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $greeting = &amp;quot;Welcome to Perl!\n&amp;quot;;

print substr($greeting, -6, 4);      # &amp;quot;Perl&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Remember that inside double quotes, &lt;code&gt;\n&lt;/code&gt; represents the single new-line character.)&lt;/p&gt;

&lt;p&gt;You can also manipulate the string by using &lt;code&gt;substr()&lt;/code&gt; to assign a new value to part of it. One useful trick is using a length of zero to &lt;em&gt;insert&lt;/em&gt; characters into a string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $greeting = &amp;quot;Welcome to Java!\n&amp;quot;;

substr($greeting, 11, 4) = &#39;Perl&#39;;    # $greeting is now &amp;quot;Welcome to Perl!\n&amp;quot;;
substr($greeting, 7, 3)  = &#39;&#39;;        #       ... &amp;quot;Welcome Perl!\n&amp;quot;;
substr($greeting, 0, 0)  = &#39;Hello. &#39;; #       ... &amp;quot;Hello. Welcome Perl!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;split()&lt;/code&gt; breaks apart a string and returns a list of the pieces. &lt;code&gt;split()&lt;/code&gt; generally takes two parameters: a &lt;em&gt;regular expression&lt;/em&gt; to split the string with and the string you want to split. (The next article will discuss regular expressions in more detail; for the moment, all you need to know is that this regular expression represents a single space character: &lt;code&gt;/ /&lt;/code&gt;.) The characters you split won&amp;rsquo;t show up in any of the list elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $greeting = &amp;quot;Hello. Welcome Perl!\n&amp;quot;;
my @words    = split(/ /, $greeting);   # Three items: &amp;quot;Hello.&amp;quot;, &amp;quot;Welcome&amp;quot;, &amp;quot;Perl!\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also specify a third parameter: the maximum number of items to put in your list. The splitting will stop as soon as your list contains that many items:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $greeting = &amp;quot;Hello. Welcome Perl!\n&amp;quot;;
my @words    = split(/ /, $greeting, 2);   # Two items: &amp;quot;Hello.&amp;quot;, &amp;quot;Welcome Perl!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, what you can split, you can also &lt;code&gt;join()&lt;/code&gt;. The &lt;code&gt;join()&lt;/code&gt; function takes a list of strings and attaches them together with a specified string between each element, which may be an empty string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @words         = (&amp;quot;Hello.&amp;quot;, &amp;quot;Welcome&amp;quot;, &amp;quot;Perl!\n&amp;quot;);
my $greeting      = join(&#39; &#39;, @words);       # &amp;quot;Hello. Welcome Perl!\n&amp;quot;;
my $andy_greeting = join(&#39; and &#39;, @words);   # &amp;quot;Hello. and Welcome and Perl!\n&amp;quot;;
my $jam_greeting  = join(&#39;&#39;, @words);        # &amp;quot;Hello.WelcomePerl!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;filehandles&#34;&gt;Filehandles&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s enough about strings. It&amp;rsquo;s time to consider files &amp;ndash; after all, what good is string manipulation if you can&amp;rsquo;t do it where it counts?&lt;/p&gt;

&lt;p&gt;To read from or write to a file, you have to &lt;em&gt;open&lt;/em&gt; it. When you open a file, Perl asks the operating system if the file is accessible &amp;ndash; does the file exist if you&amp;rsquo;re trying to read it (or can it be created if you&amp;rsquo;re trying to create a new file), and do you have the necessary file permissions to do what you want? If you&amp;rsquo;re allowed to use the file, the operating system will prepare it for you, and Perl will give you a &lt;em&gt;filehandle&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Ask Perl to create a filehandle for you by using the &lt;code&gt;open()&lt;/code&gt; function, which takes two or three arguments: the filehandle you want to create, the mode of the file, and the file you want to work with. First, we&amp;rsquo;ll concentrate on reading files. The following statement opens the file &lt;em&gt;log.txt&lt;/em&gt; using the filehandle &lt;code&gt;$logfile&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $logfile, &#39;log.txt&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Opening a file involves several behind-the-scenes tasks that Perl and the operating system undertake together, such as checking that the file you want to open actually exists (or creating it if you&amp;rsquo;re trying to create a new file) and making sure you&amp;rsquo;re allowed to manipulate the file (do you have the necessary file permissions, for instance). Perl will do all of this for you, so in general you don&amp;rsquo;t need to worry about it.&lt;/p&gt;

&lt;p&gt;Once you&amp;rsquo;ve opened a file to read, you can retrieve lines from it by using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; construct, also known as &lt;code&gt;readline&lt;/code&gt;. Inside the angle brackets, place your filehandle. What you get from this depends on what you &lt;em&gt;want&lt;/em&gt; to get: in a scalar context (a more technical way of saying &amp;ldquo;if you&amp;rsquo;re assigning it to a scalar&amp;rdquo;), you retrieve the next line from the file, but if you&amp;rsquo;re looking for a list, you get a list of all the remaining lines in the file.&lt;/p&gt;

&lt;p&gt;You can, of course, &lt;code&gt;close&lt;/code&gt; a filehandle that you&amp;rsquo;ve opened. You don&amp;rsquo;t always have to do this, because Perl is clever enough to close a filehandle when your program ends, when you try to reuse an existing filehandle, or when the lexical variable containing the filehandle goes out of scope.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a simple program that will display the contents of the file &lt;em&gt;log.txt&lt;/em&gt;, and assumes that the first line of the file is its title:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $logfile, &#39;log.txt&#39; or die &amp;quot;I couldn&#39;t get at log.txt: $!&amp;quot;;

my $title = &amp;lt;$logfile&amp;gt;;
print &amp;quot;Report Title: $title&amp;quot;;

print while &amp;lt;$logfile&amp;gt;;
close $logfile;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That code may seem pretty dense, but it combines ideas you&amp;rsquo;ve seen before. The &lt;code&gt;while&lt;/code&gt; operator loops over every line of the file, one line at a time, putting each line into the Perl pronoun &lt;code&gt;$_&lt;/code&gt;. (A pronoun? Yes &amp;ndash; think of it as &lt;em&gt;it&lt;/em&gt;.) For each line read, Perl &lt;code&gt;prints&lt;/code&gt; the line. Now the pronoun should make sense. While you read it from the file, print it.&lt;/p&gt;

&lt;p&gt;Why not use &lt;code&gt;say&lt;/code&gt;? Each &lt;em&gt;line&lt;/em&gt; in the file ends with a newline &amp;ndash; that&amp;rsquo;s how Perl knows that it&amp;rsquo;s a line. There&amp;rsquo;s no need to add an additional newline, so &lt;code&gt;say&lt;/code&gt; would double-space the output.&lt;/p&gt;

&lt;h3 id=&#34;writing-files&#34;&gt;Writing files&lt;/h3&gt;

&lt;p&gt;You also use &lt;code&gt;open()&lt;/code&gt; when you are writing to a file. There are two ways to open a file for writing: &lt;em&gt;overwrite&lt;/em&gt; and &lt;em&gt;append&lt;/em&gt;. When you open a file in overwrite mode, you erase whatever it previously contained. In append mode, you attach your new data to the end of the existing file without erasing anything that was already there.&lt;/p&gt;

&lt;p&gt;To indicate that you want a filehandle for writing, use a single &lt;code&gt;&amp;gt;&lt;/code&gt; character as the mode passed to &lt;code&gt;open&lt;/code&gt;. This opens the file in overwrite mode. To open it in append mode, use two &lt;code&gt;&amp;gt;&lt;/code&gt; characters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $overwrite, &#39;&amp;gt;&#39;, &#39;overwrite.txt&#39; or die &amp;quot;error trying to overwrite: $!&amp;quot;;
# Wave goodbye to the original contents.

open my $append, &#39;&amp;gt;&amp;gt;&#39;, &#39;append.txt&#39; or die &amp;quot;error trying to append: $!&amp;quot;;
# Original contents still there; add to the end of the file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once your filehandle is open, use the humble &lt;code&gt;print&lt;/code&gt; or &lt;code&gt;say&lt;/code&gt; operator to write to it. Specify the filehandle you want to write to and a list of values you want to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

say $overwrite &#39;This is the new content&#39;;
print $append &amp;quot;We&#39;re adding to the end here.\n&amp;quot;, &amp;quot;And here too.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;live-free-or-die&#34;&gt;Live free or die!&lt;/h3&gt;

&lt;p&gt;Most of these &lt;code&gt;open()&lt;/code&gt; statements include &lt;code&gt;or die &amp;quot;some sort of message&amp;quot;&lt;/code&gt;. This is because we live in an imperfect world, where programs don&amp;rsquo;t always behave exactly the way we want them to. It&amp;rsquo;s always possible for an &lt;code&gt;open()&lt;/code&gt; call to fail; maybe you&amp;rsquo;re trying to write to a file that you&amp;rsquo;re not allowed to write, or you&amp;rsquo;re trying to read from a file that doesn&amp;rsquo;t exist. In Perl, you can guard against these problems by using &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A series of statements separated by &lt;code&gt;or&lt;/code&gt; will continue until you hit one that works, or returns a true value. This line of code will either succeed at opening &lt;code&gt;$output&lt;/code&gt; in overwrite mode, or cause Perl to quit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $output, &#39;&amp;gt;&#39;, $outfile or die &amp;quot;Can&#39;t write to &#39;$outfile&#39;: $!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;die&lt;/code&gt; statement ends your program with an error message. The special variable &lt;code&gt;$!&lt;/code&gt; contains Perl&amp;rsquo;s explanation of the error. In this case, you might see something like this if you&amp;rsquo;re not allowed to write to the file. Note that you get both the actual error message (&amp;ldquo;Permission denied&amp;rdquo;) and the line where it happened:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Can&#39;t write to &#39;a2-die.txt&#39;: Permission denied at ./a2-die.pl line 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Defensive programming like this is useful for making your programs more error-resistant &amp;ndash; you don&amp;rsquo;t want to write to a file that you haven&amp;rsquo;t successfully opened! (Putting single-quotes around the filename may help you see any unexpected whitespace in the filename. You&amp;rsquo;ll slap your forehead when it happens to you.)&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example: As part of your job, you write a program that records its results in a file called &lt;em&gt;vitalreport.txt&lt;/em&gt;. You use the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $vital, &#39;&amp;gt;&#39;, &#39;vitalreport.txt&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this &lt;code&gt;open()&lt;/code&gt; call fails (for instance, &lt;em&gt;vitalreport.txt&lt;/em&gt; is owned by another user who hasn&amp;rsquo;t given you write permission), you&amp;rsquo;ll never know it until someone looks at the file afterward and wonders why the vital report wasn&amp;rsquo;t written. (Just imagine the joy if that &amp;ldquo;someone&amp;rdquo; is your boss, the day before your annual performance review.) When you use &lt;code&gt;or die&lt;/code&gt;, you avoid all this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $vital, &#39;&amp;gt;&#39;, &#39;vitalreport.txt&#39; or die &amp;quot;Can&#39;t write vital report: $!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of wondering whether your program wrote your vital report, you&amp;rsquo;ll immediately have an error message that both tells you what went wrong and on what line of your program the error occurred.&lt;/p&gt;

&lt;p&gt;You can use &lt;code&gt;or&lt;/code&gt; for more than just testing file operations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;
($pie eq &#39;apple&#39;) or ($pie eq &#39;cherry&#39;) or ($pie eq &#39;blueberry&#39;)
        or say &#39;But I wanted apple, cherry, or blueberry!&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this sequence, if you have an appropriate pie, Perl skips the rest of the chain. Once one statement works, the rest are ignored. The &lt;code&gt;and&lt;/code&gt; operator does the opposite: It evaluates your chain of statements, but stops when one of them &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; work.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;open my $log, &#39;log.file&#39; and say &#39;Logfile is open!&#39;;
say &#39;Logfile is open!&#39; if open my $log, &#39;log.file&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This statement will only show you the words &lt;em&gt;Logfile is open!&lt;/em&gt; if the &lt;code&gt;open()&lt;/code&gt; succeeds &amp;ndash; do you see why?&lt;/p&gt;

&lt;p&gt;Again, just because there&amp;rsquo;s more than one way to execute code conditionally doesn&amp;rsquo;t mean you have to use every way in a single program or the most clever or creative way. You have plenty of options. Consider using the most readable one for the situation.&lt;/p&gt;

&lt;h3 id=&#34;subs&#34;&gt;Subs&lt;/h3&gt;

&lt;p&gt;So far, the example Perl programs have been a bunch of statements in series. This is okay if you&amp;rsquo;re writing very small programs, but as your needs grow, you&amp;rsquo;ll find it limiting. This is why most modern programming languages allow you to define your own functions; in Perl, we call them &lt;em&gt;subs&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A sub, declared with the &lt;code&gt;sub&lt;/code&gt; keyword, adds a new function to your program&amp;rsquo;s capabilities. When you want to use this new function, you call it by name. For instance, here&amp;rsquo;s a short definition of a sub called &lt;code&gt;boo&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

sub boo {
    say &#39;Boo!&#39;;
}

boo();   # Eek!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Subs are useful because they allow you to break your program into small, reusable chunks. If you need to analyze a string in four different places in your program, it&amp;rsquo;s much easier to write one &lt;code&gt;analyze_string&lt;/code&gt; sub and call it four times. This way, when you make an improvement to your string-analysis routine, you&amp;rsquo;ll only need to do it in one place, instead of four.&lt;/p&gt;

&lt;p&gt;In the same way that Perl&amp;rsquo;s built-in functions can take parameters and can return values, your subs can, too. Whenever you call a sub, any parameters you pass to it appear in the special array &lt;code&gt;@_&lt;/code&gt;. You can also return a single value or a list by using the &lt;code&gt;return&lt;/code&gt; keyword.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use 5.010;

sub multiply {
    my (@ops) = @_;
    return $ops[0] * $ops[1];
}

for my $i (1 .. 10) {
     say &amp;quot;$i squared is &amp;quot;, multiply($i, $i);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There&amp;rsquo;s an interesting benefit from using the the &lt;code&gt;my&lt;/code&gt; keyword in &lt;code&gt;multiply&lt;/code&gt;? It indicates that the variables are private to that sub, so that any existing value for the &lt;code&gt;@ops&lt;/code&gt; array used elsewhere in our program won&amp;rsquo;t get overwritten. This means that you&amp;rsquo;ll evade a whole class of hard-to-trace bugs in your programs. You don&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to use &lt;code&gt;my&lt;/code&gt;, but you also don&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to avoid smashing your thumb when you&amp;rsquo;re hammering nails into a board. They&amp;rsquo;re both just good ideas.&lt;/p&gt;

&lt;p&gt;You can also assign to multiple lexical variables (declared with &lt;code&gt;my&lt;/code&gt;) in a single statement. You can change the code within &lt;code&gt;multiply&lt;/code&gt; to something like this without having to modify any other code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub multiply {
    my ($left, $right) = @_;
    return $left * $right;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t expressly use the &lt;code&gt;return&lt;/code&gt; statement, the sub returns the result of the last statement. This implicit return value can sometimes be useful, but it does reduce your program&amp;rsquo;s readability. Remember that you&amp;rsquo;ll read your code many more times than you write it!&lt;/p&gt;

&lt;h3 id=&#34;putting-it-all-together&#34;&gt;Putting it all together&lt;/h3&gt;

&lt;p&gt;The previous article demonstrated a simple interest calculator. You can make it more interesting by writing the interest table to a file instead of to the screen. Another change is to break the code into subs to make it easier to read and maintain.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2008_05_07_beginners-introduction-to-perl-510-part-2/compound_interest_file.pl&#34;&gt;[Download this program]&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#! perl

# compound_interest_file.pl - the miracle of compound interest, part 2

use 5.010;

use strict;
use warnings;

# First, we&#39;ll set up the variables we want to use.
my $outfile   = &#39;interest.txt&#39;;    # This is the filename of our report.
my $nest_egg  = 10000;             # $nest_egg is our starting amount
my $year      = 2008;              # This is the starting year for our table.
my $duration  = 10;                # How many years are we saving up?
my $apr       = 9.5;               # This is our annual percentage rate.

my $report_fh = open_report( $outfile );
print_headers(   $report_fh );
interest_report( $report_fh, $nest_egg, $year, $duration, $apr );
report_footer(   $report_fh, $nest_egg, $duration, $apr );

sub open_report {
    my ($outfile) = @_;
    open my $report, &#39;&amp;gt;&#39;, $outfile or die &amp;quot;Can&#39;t open &#39;$outfile&#39;: $!&amp;quot;;
    return $report;
}

sub print_headers {
    my ($report_fh) = @_;

    # Print the headers for our report.
    say $report_fh &amp;quot;Year\tBalance\tInterest\tNew balance&amp;quot;;
}

sub calculate_interest {
    # Given a nest egg and an APR, how much interest do we collect?
    my ( $nest_egg, $apr ) = @_;

    return int( ( $apr / 100 ) * $nest_egg * 100 ) / 100;
}

sub interest_report {
    # Get our parameters.  Note that these variables won&#39;t clobber the
    # global variables with the same name.
    my ( $report_fh, $nest_egg, $year, $duration, $apr ) = @_;

    # Calculate interest for each year.
    for my $i ( 1 .. $duration ) {
        my $interest = calculate_interest( $nest_egg, $apr );
        my $line     =
            join &amp;quot;\t&amp;quot;, $year + $i, $nest_egg, $interest, $nest_egg + $interest;

        say $report_fh $line;

        $nest_egg += $interest;
    }
}

sub report_footer {
    my ($report_fh, $nest_egg, $duration, $apr) = @_;

    say $report_fh &amp;quot;\n Our original assumptions:&amp;quot;;
    say $report_fh &amp;quot;   Nest egg: $nest_egg&amp;quot;;
    say $report_fh &amp;quot;   Number of years: $duration&amp;quot;;
    say $report_fh &amp;quot;   Interest rate: $apr&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how much clearer the program logic becomes when you break it down into subs. One nice quality of a program written as small, well-named subs is that it almost becomes &lt;em&gt;self-documenting&lt;/em&gt;. Consider these four lines:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $report_fh = open_report( $outfile );
print_headers(   $report_fh );
interest_report( $report_fh, $nest_egg, $year, $duration, $apr );
report_footer(   $report_fh, $nest_egg, $duration, $apr );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code like this is invaluable when you come back to it six months later and need to figure out what it does &amp;ndash; would you rather spend your time reading the entire program trying to figure it out or read four lines that tell you the program 1) opens a report file, 2) prints some headers, 3) generates an interest report, and 4) prints a report footer?&lt;/p&gt;

&lt;h3 id=&#34;play-around&#34;&gt;Play around!&lt;/h3&gt;

&lt;p&gt;This article has explored files (filehandles, &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;close()&lt;/code&gt;, and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;), string manipulation (&lt;code&gt;substr()&lt;/code&gt;, &lt;code&gt;split()&lt;/code&gt; and &lt;code&gt;join()&lt;/code&gt;) and subs. Here&amp;rsquo;s a pair of exercises &amp;ndash; again, one simple and one complex:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;You have a file called &lt;em&gt;dictionary.txt&lt;/em&gt; that contains dictionary definitions, one per line, in the format &amp;ldquo;word &lt;code&gt;space&lt;/code&gt; definition&amp;rdquo;. (&lt;a href=&#34;http://localhost:1313/media/_pub_2008_05_07_beginners-introduction-to-perl-510-part-2/dictionary.txt&#34;&gt;Here&amp;rsquo;s a sample&lt;/a&gt;.) Write a program that will look up a word from the command line. (Hints: &lt;code&gt;@ARGV&lt;/code&gt; is a special array that contains your command line arguments and you&amp;rsquo;ll need to use the three-argument form of &lt;code&gt;split()&lt;/code&gt;.) Try to enhance it so that your dictionary can also contain words with multiple definitions in the format &amp;ldquo;word &lt;code&gt;space&lt;/code&gt; definition:alternate definition:alternate definition, etc&amp;hellip;&amp;ldquo;.&lt;/li&gt;
&lt;li&gt;Write an analyzer for your Apache logs. You can find a brief description of the common log format at &lt;a href=&#34;http://www.w3.org/Daemon/User/Config/Logging.html&#34;&gt;http://www.w3.org/Daemon/User/Config/Logging.html&lt;/a&gt;. Your analyzer should count the total number of requests for each URL, the total number of results for each status code and the total number of bytes output.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Happy programming!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>A Beginner&#39;s Introduction to Perl 5.10</title>
      <link>http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html/</link>
      <pubDate>Wed, 23 Apr 2008 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html/</guid>
      <description>

&lt;h3 id=&#34;first-a-little-sales-pitch&#34;&gt;First, a Little Sales Pitch&lt;/h3&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this series is based on &lt;a href=&#34;http://localhost:1313/authors/doug-sheppard&#34;&gt;Doug Sheppard&amp;rsquo;s&lt;/a&gt; &lt;a href=&#34;http://localhost:1313/pub/2000/10/begperl1.html&#34;&gt;Beginner&amp;rsquo;s Introduction to Perl&lt;/a&gt;&lt;/em&gt;. &lt;a href=&#34;http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Files and Strings with Perl 5.10&lt;/a&gt; explains how to use files and strings, and &lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt; explores regular expressions, matching, and substitutions. &lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt; demonstrates how to write web programs.&lt;/p&gt;

&lt;p&gt;Welcome to Perl.&lt;/p&gt;

&lt;p&gt;Perl is the Swiss Army chainsaw of programming languages: powerful and adaptable. It was first developed by Larry Wall, a linguist working as a systems administrator for NASA in the late 1980s, as a way to make report processing easier. Since then, it has moved into a several other areas: automating system administration, acting as glue between different computer systems, web programming, bioinformatics, data munging, and even application development.&lt;/p&gt;

&lt;p&gt;Why did Perl become so popular when the Web came along? Two reasons: First, most of what is being done on the Web happens with text, and is best done with a language that&amp;rsquo;s designed for text processing. More importantly, Perl was appreciably better than the alternatives at the time when people needed something to use. C is complex and can produce security problems (especially with untrusted data), Tcl can be awkward, and Python didn&amp;rsquo;t really have a foothold.&lt;/p&gt;

&lt;p&gt;It also didn&amp;rsquo;t hurt that Perl is a friendly language. It plays well with your personal programming style. The Perl slogan is &amp;ldquo;There&amp;rsquo;s more than one way to do it,&amp;rdquo; and that lends itself well to large and small problems alike. Even more so, Perl is very portable and widespread &amp;ndash; it&amp;rsquo;s available pre-installed almost everywhere &amp;ndash; and of course there are thousands of freely-distributable libraries available from the &lt;a href=&#34;http://www.cpan.org/&#34;&gt;CPAN&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;In this first part of our series, you&amp;rsquo;ll learn a few basics about Perl and see a small sample program.&lt;/p&gt;

&lt;h3 id=&#34;a-word-about-operating-systems&#34;&gt;A Word About Operating Systems&lt;/h3&gt;

&lt;p&gt;This series assumes that you&amp;rsquo;re using a Unix or Unix-like operating system (Mac OS X and Cygwin qualify) and that you have the &lt;code&gt;perl&lt;/code&gt; binary available at &lt;em&gt;/usr/bin/perl&lt;/em&gt;. It&amp;rsquo;s OK if you&amp;rsquo;re running Windows through ActivePerl or Strawberry Perl; most Perl code is platform-independent.&lt;/p&gt;

&lt;h3 id=&#34;your-first-perl-program&#34;&gt;Your First Perl Program&lt;/h3&gt;

&lt;p&gt;Save this program as a file called &lt;em&gt;first.pl&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;
say &amp;quot;Hi there!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The traditional first program says &lt;code&gt;Hello world!&lt;/code&gt;, but I&amp;rsquo;m an iconoclast.)&lt;/p&gt;

&lt;p&gt;Run the program. From a command line, go to the directory with this file and type &lt;code&gt;perl first.pl&lt;/code&gt;. You should see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Hi there!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Friendly, isn&amp;rsquo;t it?&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m sure you can guess what &lt;code&gt;say&lt;/code&gt; does. What about the &lt;code&gt;use feature &#39;:5.10&#39;;&lt;/code&gt; line? For now, all you need to know is that it allows you to use nice new features found in Perl 5.10. This is a very good thing.&lt;/p&gt;

&lt;h3 id=&#34;functions-and-statements&#34;&gt;Functions and Statements&lt;/h3&gt;

&lt;p&gt;Perl has a rich library of built-in &lt;em&gt;functions&lt;/em&gt;. They&amp;rsquo;re the verbs of Perl, the commands that the interpreter runs. You can see a list of all the built-in functions in the &lt;a href=&#34;https://perldoc.perl.org/index-functions.html&#34;&gt;perlfunc&lt;/a&gt; man page (&lt;code&gt;perldoc perlfunc&lt;/code&gt;, from the command line). Almost all functions can take a list of commma-separated &lt;em&gt;parameters&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;print&lt;/code&gt; function is one of the most frequently used parts of Perl. You use it to display things on the screen or to send information to a file. It takes a list of things to output as its parameters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print &amp;quot;This is a single statement.&amp;quot;;
print &amp;quot;Look, &amp;quot;, &amp;quot;a &amp;quot;, &amp;quot;list!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Perl program consists of &lt;em&gt;statements&lt;/em&gt;, each of which ends with a semicolon. Statements don&amp;rsquo;t need to be on separate lines; there may be multiple statements on one line. You can also split a single statement across multiple lines.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print &amp;quot;This is &amp;quot;; print &amp;quot;two statements.\n&amp;quot;;
print &amp;quot;But this &amp;quot;, &amp;quot;is only one statement.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Wait a minute though. What&amp;rsquo;s the difference between &lt;code&gt;say&lt;/code&gt; and &lt;code&gt;print&lt;/code&gt;? What&amp;rsquo;s this &lt;code&gt;\n&lt;/code&gt; in the &lt;code&gt;print&lt;/code&gt; statements?&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;say&lt;/code&gt; function behaves just like the &lt;code&gt;print&lt;/code&gt; function, except that it appends a newline at the end of its arguments. It prints all of its arguments, and then a newline character. Always. No exceptions. &lt;code&gt;print&lt;/code&gt;, on the other hand, only prints what you see explicitly in these examples. If you want a newline, you have to add it yourself with the special character escape sequence &lt;code&gt;\n&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;

say &amp;quot;This is a single statement.&amp;quot;;
say &amp;quot;Look, &amp;quot;, &amp;quot;a &amp;quot;, &amp;quot;list!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why do both exist? Why would you use one over the other? Usually, most &amp;ldquo;display something&amp;rdquo; statements need the newline. It&amp;rsquo;s common enough that &lt;code&gt;say&lt;/code&gt; is a good default choice. Occasionally you need a little bit more control over your output, so &lt;code&gt;print&lt;/code&gt; is the option.&lt;/p&gt;

&lt;p&gt;Note that &lt;code&gt;say&lt;/code&gt; is two characters shorter than &lt;code&gt;print&lt;/code&gt;. This is an important design principle for Perl &amp;ndash; common things should be easy and simple.&lt;/p&gt;

&lt;h3 id=&#34;numbers-strings-and-quotes&#34;&gt;Numbers, Strings, and Quotes&lt;/h3&gt;

&lt;p&gt;There are two basic data types in Perl: numbers and strings.&lt;/p&gt;

&lt;p&gt;Numbers are easy; we&amp;rsquo;ve all dealt with them. The only thing you need to know is that you never insert commas or spaces into numbers in Perl. Always write 10000, not 10,000 or 10 000.&lt;/p&gt;

&lt;p&gt;Strings are a bit more complex. A string is a collection of characters in either single or double quotes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&#39;This is a test.&#39;
&amp;quot;Hi there!\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The difference between single quotes and double quotes is that single quotes mean that their contents should be taken &lt;em&gt;literally&lt;/em&gt;, while double quotes mean that their contents should be &lt;em&gt;interpreted&lt;/em&gt;. Remember the character sequence &lt;code&gt;\n&lt;/code&gt;? It represents a newline character when it appears in a string with double quotes, but is literally the two characters backslash and &lt;code&gt;n&lt;/code&gt; when it appears in single quotes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;
say &amp;quot;This string\nshows up on two lines.&amp;quot;;
say &#39;This string \n shows up on only one.&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Two other useful backslash sequences are &lt;code&gt;\t&lt;/code&gt; to insert a tab character, and &lt;code&gt;\\&lt;/code&gt; to insert a backslash into a double-quoted string.)&lt;/p&gt;

&lt;h3 id=&#34;variables&#34;&gt;Variables&lt;/h3&gt;

&lt;p&gt;If functions are Perl&amp;rsquo;s verbs, then variables are its nouns. Perl has three types of variables: &lt;em&gt;scalars&lt;/em&gt;, &lt;em&gt;arrays&lt;/em&gt;, and &lt;em&gt;hashes&lt;/em&gt;. Think of them as things, lists, and dictionaries respectively. In Perl, all variable names consist of a punctuation character, a letter or underscore, and one or more alphanumeric characters or underscores.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Scalars&lt;/em&gt; are single things. This might be a number or a string. The name of a scalar begins with a dollar sign, such as &lt;code&gt;$i&lt;/code&gt; or &lt;code&gt;$abacus&lt;/code&gt;. Assign a value to a scalar by telling Perl what it equals:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $i                = 5;
my $pie_flavor       = &#39;apple&#39;;
my $constitution1776 = &amp;quot;We the People, etc.&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You don&amp;rsquo;t need to specify whether a scalar is a number or a string. It doesn&amp;rsquo;t matter, because when Perl needs to treat a scalar as a string, it does; when it needs to treat it as a number, it does. The conversion happens automatically. (This is different from many other languages, where strings and numbers are two separate data types.)&lt;/p&gt;

&lt;p&gt;If you use a double-quoted string, Perl will insert the value of any scalar variables you name in the string. This is often useful to fill in strings on the fly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;
my $apple_count  = 5;
my $count_report = &amp;quot;There are $apple_count apples.&amp;quot;;
say &amp;quot;The report is: $count_report&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final output from this code is &lt;code&gt;The report is: There are 5 apples.&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You can manipulate numbers in Perl with the usual mathematical operations: addition, multiplication, division, and subtraction. (The multiplication and division operators in Perl use the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; symbols, by the way.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $a = 5;
my $b = $a + 10;       # $b is now equal to 15.
my $c = $b * 10;       # $c is now equal to 150.
$a    = $a - 1;        # $a is now 4, and algebra teachers are cringing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all well and good, but what&amp;rsquo;s this strange &lt;code&gt;my&lt;/code&gt;, and why does it appear with some assignments and not others? The &lt;code&gt;my&lt;/code&gt; operator tells Perl that you&amp;rsquo;re &lt;em&gt;declaring&lt;/em&gt; a new variable. That is, you promise Perl that you deliberately want to use a scalar, array, or hash of a specific name in your program. This is important for two reasons. First, it helps Perl help you protect against typos; it&amp;rsquo;s embarrassing to discover that you&amp;rsquo;ve accidentally mistyped a variable name and spent an hour looking for a bug. Second, it helps you write larger programs, where variables used in one part of the code don&amp;rsquo;t accidentally affect variables used elsewhere.&lt;/p&gt;

&lt;p&gt;You can also use special operators like &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt; and &lt;code&gt;*=&lt;/code&gt;. These manipulate a scalar&amp;rsquo;s value without needing two elements in an equation. Some people like them, some don&amp;rsquo;t. I like the fact that they can make code clearer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $a = 5;
$a++;        # $a is now 6; we added 1 to it.
$a += 10;    # Now it&#39;s 16; we added 10.
$a /= 2;     # And divided it by 2, so it&#39;s 8.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Strings in Perl don&amp;rsquo;t have quite as much flexibility. About the only basic operator that you can use on strings is &lt;em&gt;concatenation&lt;/em&gt;, which is a ten dollar way of saying &amp;ldquo;put together.&amp;rdquo; The concatenation operator is the period. Concatenation and addition are two different things:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $a = &amp;quot;8&amp;quot;;    # Note the quotes.  $a is a string.
my $b = $a + &amp;quot;1&amp;quot;;   # &amp;quot;1&amp;quot; is a string too.
my $c = $a . &amp;quot;1&amp;quot;;   # But $b and $c have different values!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that Perl converts strings to numbers transparently whenever necessary, so to get the value of &lt;code&gt;$b&lt;/code&gt;, the Perl interpreter converted the two strings &lt;code&gt;&amp;quot;8&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;1&amp;quot;&lt;/code&gt; to numbers, then added them. The value of &lt;code&gt;$b&lt;/code&gt; is the number 9. However, &lt;code&gt;$c&lt;/code&gt; used concatenation, so its value is the string &lt;code&gt;&amp;quot;81&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Remember, the plus sign &lt;em&gt;adds numbers&lt;/em&gt; and the period &lt;em&gt;puts strings together&lt;/em&gt;. If you add things that aren&amp;rsquo;t numbers, Perl will try its best to do what you&amp;rsquo;ve told it to do, and will convert those non-numbers to numbers with the best of its ability.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Arrays&lt;/em&gt; are lists of scalars. Array names begin with &lt;code&gt;@&lt;/code&gt;. You define arrays by listing their contents in parentheses, separated by commas:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @lotto_numbers = (1, 2, 3, 4, 5, 6);  # Hey, it could happen.
my @months        = (&amp;quot;July&amp;quot;, &amp;quot;August&amp;quot;, &amp;quot;September&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You retrieve the contents of an array by an &lt;em&gt;index&lt;/em&gt;, sort of like &amp;ldquo;Hey, give me the first month of the year.&amp;rdquo; Indexes in Perl start from zero. (Why not 1? Because. It&amp;rsquo;s a computer thing.) To retrieve the elements of an array, you replace the &lt;code&gt;@&lt;/code&gt; sign with a &lt;code&gt;$&lt;/code&gt; sign, and follow that with the index position of the element you want. (It begins with a dollar sign because you&amp;rsquo;re getting a scalar value.) You can also modify it in place, just like any other scalar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;

my @months = (&amp;quot;July&amp;quot;, &amp;quot;August&amp;quot;, &amp;quot;September&amp;quot;);
say $months[0];         # This prints &amp;quot;July&amp;quot;.
$months[2] = &amp;quot;Smarch&amp;quot;;  # We just renamed September!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If an array value doesn&amp;rsquo;t exist, Perl will create it for you when you assign to it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @winter_months = (&amp;quot;December&amp;quot;, &amp;quot;January&amp;quot;);
$winter_months[2] = &amp;quot;February&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arrays always return their contents in the same order; if you go through &lt;code&gt;@months&lt;/code&gt; from beginning to end, no matter how many times you do it, you&amp;rsquo;ll get back &lt;code&gt;July&lt;/code&gt;, &lt;code&gt;August&lt;/code&gt;, and &lt;code&gt;September&lt;/code&gt; in that order. If you want to find the number of elements of an array, assign the array to a scalar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;
my @months      = (&amp;quot;July&amp;quot;, &amp;quot;August&amp;quot;, &amp;quot;September&amp;quot;);
my $month_count = @months;
say $month_count;  # This prints 3.

my @autumn_months; # no elements
my $autumn_count = @autumn_months;
say $autumn_count; # this prints 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Some programming languages call &lt;em&gt;hashes&lt;/em&gt; &amp;ldquo;dictionaries&amp;rdquo;. That&amp;rsquo;s what they are: a term and a definition. More precisely, they contain &lt;em&gt;keys&lt;/em&gt; and &lt;em&gt;values&lt;/em&gt;. Each key in a hash has one and only one corresponding value. The name of a hash begins with a percentage sign, like &lt;code&gt;%parents&lt;/code&gt;. You define hashes by comma-separated pairs of key and value, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %days_in_month = ( &amp;quot;July&amp;quot; =&amp;gt; 31, &amp;quot;August&amp;quot; =&amp;gt; 31, &amp;quot;September&amp;quot; =&amp;gt; 30 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can fetch any value from a hash by referring to &lt;code&gt;$hashname{key}&lt;/code&gt;, or modify it in place just like any other scalar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;say $days_in_month{September}; # 30, of course.
$days_in_month{February} = 29; # It&#39;s a leap year.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To see what keys are in a hash, use the &lt;code&gt;keys&lt;/code&gt; function with the name of the hash. This returns a list containing all of the keys in the hash. The list isn&amp;rsquo;t always in the same order, though; while you can count on &lt;code&gt;@months&lt;/code&gt; always to return &lt;code&gt;July&lt;/code&gt;, &lt;code&gt;August&lt;/code&gt;, &lt;code&gt;September&lt;/code&gt; in that order, &lt;code&gt;keys %days_in_month&lt;/code&gt; might return them in any order whatsoever.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my @month_list = keys %days_in_month;
# @month_list is now (&#39;July&#39;, &#39;September&#39;, &#39;August&#39;, &#39;February&#39;)!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The three types of variables have three separate &lt;em&gt;namespaces&lt;/em&gt;. That means that &lt;code&gt;$abacus&lt;/code&gt; and &lt;code&gt;@abacus&lt;/code&gt; are two different variables, and &lt;code&gt;$abacus[0]&lt;/code&gt; (the first element of &lt;code&gt;@abacus&lt;/code&gt;) is not the same as &lt;code&gt;$abacus{0}&lt;/code&gt; (the value in &lt;code&gt;%abacus&lt;/code&gt; that has the key &lt;code&gt;0&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;comments&#34;&gt;Comments&lt;/h3&gt;

&lt;p&gt;Some of the code samples from the previous section contained code comments. These are useful for explaining what a particular piece of code does, and vital for any piece of code you plan to modify, enhance, fix, or just look at again. (That is to say, comments are important.)&lt;/p&gt;

&lt;p&gt;Anything in a line of Perl code that follows a &lt;code&gt;#&lt;/code&gt; sign is a comment, unless that &lt;code&gt;#&lt;/code&gt; sign appears in a string.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;
say &amp;quot;Hello world!&amp;quot;;  # That&#39;s more like it.
# This entire line is a comment.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;loops&#34;&gt;Loops&lt;/h3&gt;

&lt;p&gt;Almost every program ever written uses a &lt;em&gt;loop&lt;/em&gt; of some kind. Loops allow you run a particular piece of code over and over again. This is part of a general concept in programming called &lt;em&gt;flow control&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Perl has several different functions that are useful for flow control, the most basic of which is &lt;code&gt;for&lt;/code&gt;. When you use the &lt;code&gt;for&lt;/code&gt; function, you specify a variable to use as the &lt;em&gt;loop index&lt;/em&gt;, and a list of values to loop over. Inside a pair of curly brackets, you put any code you want to run during the loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;

for my $i (1, 2, 3, 4, 5) {
     say $i;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This loop prints the numbers 1 through 5, each on a separate line. (It&amp;rsquo;s not very useful; you&amp;rsquo;re might think &amp;ldquo;Why not just write &lt;code&gt;say 1, 2, 3, 4, 5;&lt;/code&gt;?&amp;ldquo;. This is because &lt;code&gt;say&lt;/code&gt; adds only one newline, at the end of its list of arguments.)&lt;/p&gt;

&lt;p&gt;A handy shortcut for defining loop values is the &lt;em&gt;range&lt;/em&gt; operator &lt;code&gt;..&lt;/code&gt;, which specifies a range of numbers. You can write &lt;code&gt;(1, 2, 3, 4, 5)&lt;/code&gt; as &lt;code&gt;(1 .. 5)&lt;/code&gt; instead. You can also use arrays and scalars in your loop list. Try this code and see what happens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;

my @one_to_ten = (1 .. 10);
my $top_limit  = 25;

for my $i (@one_to_ten, 15, 20 .. $top_limit) {
    say $i;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, again you could write &lt;code&gt;say @one_to_ten, 15, 20 .. $top_limit;&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;The items in your loop list don&amp;rsquo;t have to be numbers; you can use strings just as easily. If the hash &lt;code&gt;%month_has&lt;/code&gt; contains names of months and the number of days in each month, you can use the &lt;code&gt;keys&lt;/code&gt; function to step through them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use feature &#39;:5.10&#39;;

for my $i (keys %month_has) {
    say &amp;quot;$i has $month_has{$i} days.&amp;quot;;
}

for my $marx (&#39;Groucho&#39;, &#39;Harpo&#39;, &#39;Zeppo&#39;, &#39;Karl&#39;) {
    say &amp;quot;$marx is my favorite Marx brother.&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-miracle-of-compound-interest&#34;&gt;The Miracle of Compound Interest&lt;/h3&gt;

&lt;p&gt;You now know enough about Perl &amp;ndash; variables, &lt;code&gt;print&lt;/code&gt;/&lt;code&gt;say&lt;/code&gt;, and &lt;code&gt;for()&lt;/code&gt; &amp;ndash; to write a small, useful program. Everyone loves money, so the first sample program is a compound-interest calculator. It will print a (somewhat) nicely formatted table showing the value of an investment over a number of years. (You can see the program at &lt;a href=&#34;http://localhost:1313/media/_pub_2008_04_23_a-beginners-introduction-to-perl-510/compound_interest.pl&#34;&gt;&lt;code&gt;compound_interest.pl&lt;/code&gt;&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;The single most complex line in the program is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $interest = int( ( $apr / 100 ) * $nest_egg * 100 ) / 100;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$apr / 100&lt;/code&gt; is the interest rate, and &lt;code&gt;($apr / 100) * $nest_egg&lt;/code&gt; is the amount of interest earned in one year. This line uses the &lt;code&gt;int()&lt;/code&gt; function, which returns the integer value of a scalar (its value after any stripping off any fractional part). We use &lt;code&gt;int()&lt;/code&gt; here because when you multiply, for example, 10925 by 9.25%, the result is 1010.5625, which we must round off to 1010.56. To do this, we multiply by 100, yielding 101056.25, use &lt;code&gt;int()&lt;/code&gt; to throw away the leftover fraction, yielding 101056, and then divide by 100 again, so that the final result is 1010.56. Try stepping through this statement yourself to see just how we end up with the correct result, rounded to cents.&lt;/p&gt;

&lt;h3 id=&#34;play-around&#34;&gt;Play Around!&lt;/h3&gt;

&lt;p&gt;At this point you have some basic knowledge of Perl syntax and a few simple toys to play with. Try writing some simple programs with them. Here are two suggestions, one simple and the other a little more complex:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A word frequency counter. How often does each word show up in an array of words? Print out a report. (Hint: Use a hash to count of the number of appearances of each word.)&lt;/li&gt;
&lt;li&gt;Given a month and the day of the week that&amp;rsquo;s the first of that month, print a calendar for the month.&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Beginners Intro to Perl - Part 6</title>
      <link>http://localhost:1313/pub/2001/01/begperl6.html/</link>
      <pubDate>Tue, 09 Jan 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/01/begperl6.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this venerable series is undergoing updates. You might be interested in the newer versions, available at:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Files and Strings with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/10/begperl1.html&#34;&gt;Part 1 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl2.html&#34;&gt;Part 2 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl3.html&#34;&gt;Part 3 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl4.html&#34;&gt;Part 4 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl5.html&#34;&gt;Part 5 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;#doing%20it%20right%20the%20first%20time&#34;&gt;Doing It Right the First Time&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#comments&#34;&gt;Comments&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#warnings&#34;&gt;Warnings&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#taint&#34;&gt;Taint&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#stuff%20taint%20doesn&amp;#39;t%20catch&#34;&gt;Stuff Taint Doesn&#39;t Catch&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#use%20strict&#34;&gt;&lt;code&gt;use strict&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#strict%20vars&#34;&gt;Strict vars&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#strict%20subs&#34;&gt;Strict subs&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#want%20a%20sub,%20get%20a%20string&#34;&gt;Want a Sub, Get a String&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#the%20one%20exception&#34;&gt;The One Exception&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#is%20this%20overkill&#34;&gt;Is This Overkill?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#play%20around!&#34;&gt;Play Around!&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h2 id=&#34;span-id-doing-it-right-the-first-time-doing-it-right-the-first-time-span&#34;&gt;&lt;span id=&#34;doing it right the first time&#34;&gt;Doing It Right the First Time&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Perl is a useful tool, which many people use to write some good software. But like all programming languages, Perl can also be used to create &lt;em&gt;bad&lt;/em&gt; software. Bad software contains bugs, has security holes and is hard to fix or extend.&lt;/p&gt;

&lt;p&gt;Fortunately, Perl offers you many ways to increase the quality of the programs you write. In this last installment in the Beginner&amp;rsquo;s Intro series, we&amp;rsquo;ll take a look at a few of them.&lt;/p&gt;

&lt;h3 id=&#34;span-id-comments-comments-span&#34;&gt;&lt;span id=&#34;comments&#34;&gt;Comments&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the first part of this series, we looked at the lowly &lt;code&gt;#&lt;/code&gt;, which indicates a comment. Comments are your first line of defense against bad software, because they help answer the two questions that people always have when they look at source code: What does this program do and how does it do it? Comments should &lt;em&gt;always&lt;/em&gt; be part of any software you write. Complex code with no comments is not &lt;em&gt;automatically&lt;/em&gt; evil, but bring some holy water just in case.&lt;/p&gt;

&lt;p&gt;Good comments are short, but instructive. They tell you things that aren&amp;rsquo;t clear from reading the code. For example, here&amp;rsquo;s some obscure code that could use a comment or two:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        for $i (@q) {
            my ($j) = fix($i);
            transmit($j);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Bad comments would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        for $i (@q) { # @q is list from last sub
            my ($j) = fix($i);  # Gotta fix $j...
            transmit($j);  # ...and then it goes over the wire
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that you don&amp;rsquo;t &lt;em&gt;learn&lt;/em&gt; anything from these comments. &lt;code&gt;my  ($j) = fix($i); # Gotta fix $j...&lt;/code&gt; is meaningless, the equivalent of a dictionary that contains a definition like &lt;em&gt;widget (n.): A widget&lt;/em&gt;. &lt;em&gt;What&lt;/em&gt; is &lt;code&gt;@q&lt;/code&gt;? &lt;em&gt;Why&lt;/em&gt; do you have to fix its values? That may be clear from the larger context of the program, but you don&amp;rsquo;t want to skip all around a program to find out what one little line does!&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s something a little clearer. Notice that we actually have &lt;em&gt;fewer&lt;/em&gt; comments, but they&amp;rsquo;re more instructive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       # Now that we&#39;ve got prices from database, let&#39;s send them to the buyer
       for $i (@q) {
           my ($j) = fix($i);  # Add local taxes, perform currency exchange
           transmit($j);
       }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now it&amp;rsquo;s obvious where &lt;code&gt;@q&lt;/code&gt; comes from, and what &lt;code&gt;fix()&lt;/code&gt; does.&lt;/p&gt;

&lt;h3 id=&#34;span-id-warnings-warnings-span&#34;&gt;&lt;span id=&#34;warnings&#34;&gt;Warnings&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Comments are good, but the most important tool for writing good Perl is the ``warnings&amp;rdquo; flag, the &lt;code&gt;-w&lt;/code&gt; command line switch. You can turn on warnings by placing &lt;code&gt;-w&lt;/code&gt; on the first line of your programs like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;         #!/usr/local/bin/perl -w
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or, if you&amp;rsquo;re running a program from the command line, you can use &lt;code&gt;-w&lt;/code&gt; there, as in &lt;code&gt;perl -w myprogram.pl&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Turning on warnings will make Perl yelp and complain at a &lt;em&gt;huge&lt;/em&gt; variety of things that are almost always sources of bugs in your programs. Perl normally takes a relaxed attitude toward things that may be problems; it assumes that you know what you&amp;rsquo;re doing, even when you don&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example of a program that Perl will be perfectly happy to run without blinking, even though it has an error on almost every line! (See how many you can spot.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       #!/usr/local/bin/perl

       $filename = &amp;quot;./logfile.txt&amp;quot;;
       open (LOG, $fn);
       print LOG &amp;quot;Test\n&amp;quot;;
       close LOGFILE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, add the &lt;code&gt;-w&lt;/code&gt; switch to the first line, and run it again. You should see something like this:&lt;/p&gt;

&lt;p&gt;Name ``main::filename&amp;rdquo; used only once: possible typo at ./a6-warn.pl line 3. Name ``main::LOGFILE&amp;rdquo; used only once: possible typo at ./a6-warn.pl line 6. Name ``main::fn&amp;rdquo; used only once: possible typo at ./a6-warn.pl line 4. Use of uninitialized value at ./a6-warn.pl line 4. print on closed filehandle main::LOG at ./a6-warn.pl line 5.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what each of these errors means:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;Name ``main::filename&amp;rdquo; used only once: possible typo at ./a6-warn.pl line 3.&lt;/em&gt; and &lt;em&gt;Name ``main::fn&amp;rdquo; used only once: possible typo at ./a6-warn.pl line 4.&lt;/em&gt; Perl notices that &lt;code&gt;$filename&lt;/code&gt; and &lt;code&gt;$fn&lt;/code&gt; both only get used once, and guesses that you&amp;rsquo;ve misspelled or misnamed one or the other. This is because this almost always happens because of typos or bugs in your code, like using &lt;code&gt;$filenmae&lt;/code&gt; instead of &lt;code&gt;$filename&lt;/code&gt;, or using &lt;code&gt;$filename&lt;/code&gt; throughout your program except for one place where you use &lt;code&gt;$fn&lt;/code&gt; (like in this program).&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Name ``main::LOGFILE&amp;rdquo; used only once: possible typo at ./a6-warn.pl line 6.&lt;/em&gt; In the same way that we made our &lt;code&gt;$filename&lt;/code&gt; typo, we mixed up the names of our filehandles: We use &lt;code&gt;LOG&lt;/code&gt; for the filehandle while we&amp;rsquo;re writing the log entry, but we try to close &lt;code&gt;LOGFILE&lt;/code&gt; instead.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Use of uninitialized value at ./a6-warn.pl line 4.&lt;/em&gt; This is one of Perl&amp;rsquo;s more cryptic complaints, but it&amp;rsquo;s not difficult to fix. This means that you&amp;rsquo;re trying to use a variable before you&amp;rsquo;ve assigned a value to it, and that is almost always an error. When we first mentioned &lt;code&gt;$fn&lt;/code&gt; in our program, it hadn&amp;rsquo;t been given a value yet. You can avoid this type of warning by always setting a &lt;em&gt;default&lt;/em&gt; value for a variable before you first use it.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;print on closed filehandle main::LOG at ./a6-warn.pl line 5.&lt;/em&gt; We didn&amp;rsquo;t successfully open &lt;code&gt;LOG&lt;/code&gt;, because &lt;code&gt;$fn&lt;/code&gt; was empty. When Perl sees that we are trying to print something to the &lt;code&gt;LOG&lt;/code&gt; filehandle, it would normally just ignore it and assume that we know what we&amp;rsquo;re doing. But when &lt;code&gt;-w&lt;/code&gt; is enabled, Perl warns us that it suspects there&amp;rsquo;s something afoot.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;So, how do we fix these warnings? The first step, obviously, is to fix these problems in our script. (And while we&amp;rsquo;re at it, I deliberately violated our rule of always checking if &lt;code&gt;open()&lt;/code&gt; succeeded! Let&amp;rsquo;s fix that, too.) This turns it into:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        #!/usr/local/bin/perl -w

        $filename = &amp;quot;./logfile.txt&amp;quot;;
        open (LOG, $filename) or die &amp;quot;Couldn&#39;t open $filename: $!&amp;quot;;
        print LOG &amp;quot;Test\n&amp;quot;;
        close LOG;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we run our corrected program, and get this back from it:&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Filehandle main::LOG opened only for input at ./a6-warn2.pl line 5.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Where did &lt;em&gt;this&lt;/em&gt; error come from? Look at our &lt;code&gt;open()&lt;/code&gt;. Since we&amp;rsquo;re not preceding the filename with &amp;gt; or &amp;gt;&amp;gt;, Perl opens the file for &lt;em&gt;reading&lt;/em&gt;, but in the next line we&amp;rsquo;re trying to &lt;em&gt;write&lt;/em&gt; to it with a &lt;code&gt;print&lt;/code&gt;. Perl will normally let this pass, but when warnings are in place, it alerts you to possible problems. Change line 4 to this instead and everything will be great:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       open (LOG, &amp;quot;&amp;gt;&amp;gt;$filename&amp;quot;) or die &amp;quot;Couldn&#39;t open $filename: $!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;-w&amp;gt;&lt;/code&gt; flag is your friend. Keep it on at all times. You may also want to read the &lt;code&gt;&amp;lt;perldiag&amp;gt;&lt;/code&gt; man page, which contains a listing of all the various messages (including warnings) Perl will spit out when it encounters a problem. Each message is accompanied by a detailed description of what the message means and how to fix it.&lt;/p&gt;

&lt;h3 id=&#34;span-id-taint-taint-span&#34;&gt;&lt;span id=&#34;taint&#34;&gt;Taint&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Using &lt;code&gt;-w&lt;/code&gt; will help make your Perl programs correct, but it won&amp;rsquo;t help make them &lt;em&gt;secure&lt;/em&gt;. It&amp;rsquo;s possible to write a program that doesn&amp;rsquo;t emit a single warning, but is totally insecure!&lt;/p&gt;

&lt;p&gt;For example, let&amp;rsquo;s say that you are writing a CGI program that needs to write a user&amp;rsquo;s comment to a user-specified file. You might use something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       #!/usr/local/bin/perl -w

       use CGI &#39;:standard&#39;;

       $file = param(&#39;file&#39;);
       $comment = param(&#39;comment&#39;);

       unless ($file) { $file = &#39;file.txt&#39;; }
       unless ($comment) { $comment = &#39;No comment&#39;; }

       open (OUTPUT, &amp;quot;&amp;gt;&amp;gt;/etc/webstuff/storage/&amp;quot; . $file) or die &amp;quot;$!&amp;quot;;
       print OUTPUT $comment . &amp;quot;\n&amp;quot;;
       close OUTPUT;

       print header, start_html;
       print &amp;quot;&amp;lt;P&amp;gt;Thanks!&amp;lt;/P&amp;gt;\n&amp;quot;;       
       print end_html;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you read the CGI programming installment, alarm bells are already ringing loud enough to deafen you. This program trusts the user to specify only a ``correct&amp;rdquo; filename, and you know better than to trust the user. But nothing in this program will cause &lt;code&gt;-w&lt;/code&gt; to bat an eye; as far as warnings are concerned, this program is completely correct.&lt;/p&gt;

&lt;p&gt;Fortunately, there&amp;rsquo;s a way to block these types of bugs before they become a problem. Perl offers a mechanism called &lt;em&gt;taint&lt;/em&gt; that marks any variable that the user can possibly control as being insecure. This includes user input, file input and environment variables. Anything that you set within your own program is considered safe:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     $taint = &amp;lt;STDIN&amp;gt;;   # This came from user input, so it&#39;s tainted
     $taint2 = $ARGV[1]; # The @ARGV array is considered tainted too.
     $notaint = &amp;quot;Hi&amp;quot;;    # But this is in your program... it&#39;s untainted
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You enable taint checking with the &lt;code&gt;-T&lt;/code&gt; flag, which you can combine with &lt;code&gt;-w&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      #!/usr/local/bin/perl -Tw
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-T&lt;/code&gt; will prevent Perl from running most code that may be insecure. If you try to do various dangerous things with tainted variables, like open a file for writing or use the &lt;code&gt;system()&lt;/code&gt; or &lt;code&gt;exec()&lt;/code&gt; functions to run external commands, Perl will stop right away and complain.&lt;/p&gt;

&lt;p&gt;You &lt;em&gt;untaint&lt;/em&gt; a variable by running it through a regex with matching subexpressions, and using the results from the subexpressions. Perl will consider &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; and so forth to be safe for your program.&lt;/p&gt;

&lt;p&gt;For example, our file-writing CGI program may expect that ``sane&amp;rdquo; filenames contain only the alphanumeric characters that are matched by the &lt;code&gt;\w&lt;/code&gt; metacharacter (this would prevent a malicious user from passing a filename like &lt;code&gt;~/.bashrc&lt;/code&gt;, or even &lt;code&gt;../test&lt;/code&gt;). We&amp;rsquo;d use a filter like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       $file = param(&#39;file&#39;);
       if ($file) {
           $file =~ /^(\w+)$/;
           $file = $1;
       }

       unless ($file) { $file = &amp;quot;file.txt&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, &lt;code&gt;$file&lt;/code&gt; is guaranteed to be untainted. If the user passed us a filename, we don&amp;rsquo;t use it until we&amp;rsquo;ve made sure it matches only &lt;code&gt;\w+&lt;/code&gt;. If there was no filename, then we specify a default in our program. As for &lt;code&gt;$comment&lt;/code&gt;, we never actually do anything that would cause Perl&amp;rsquo;s taint checking to worry, so it doesn&amp;rsquo;t need to be checked to pass &lt;code&gt;-T&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-stuff-taint-doesn-t-catch-stuff-taint-doesn-t-catch-span&#34;&gt;&lt;span id=&#34;stuff taint doesn&#39;t catch&#34;&gt;Stuff Taint Doesn&amp;rsquo;t Catch&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Be careful! Even when you&amp;rsquo;ve turned on taint checking, you can still write an insecure program. Remember that taint only gets looked at when you try to &lt;em&gt;modify&lt;/em&gt; the system, by opening a file or running a program. Reading from a file will not trigger taintedness! A &lt;em&gt;very&lt;/em&gt; common breed of security hole exploits code that doesn&amp;rsquo;t look very different from this small program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        #!/usr/local/bin/perl -Tw

        use CGI &#39;:standard&#39;;

        $file = param(&#39;filename&#39;);
        unless ($file) { $file = &#39;file.txt&#39;; }

        open (FILE, &amp;quot;&amp;lt;/etc/webstuff/storage/&amp;quot; . $file) or die &amp;quot;$!&amp;quot;;

        print header();
        while ($line = &amp;lt;FILE&amp;gt;) {
            print $line;
        }

        close FILE;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just imagine the joy when the ``filename&amp;rdquo; parameter contains &lt;code&gt;../../../../../../etc/passwd&lt;/code&gt;. (If you don&amp;rsquo;t see the problem: On a Unix system, the &lt;code&gt;/etc/passwd&lt;/code&gt; file contains a list of all the usernames on the system, and may also contain an encrypted list of their passwords. This is great information for crackers who want to get into a machine for further mischief.) Since you are only reading the file, Perl&amp;rsquo;s taint checking doesn&amp;rsquo;t kick in. Similarly, &lt;code&gt;print&lt;/code&gt; doesn&amp;rsquo;t trigger taint checking, so you&amp;rsquo;ll have to write your own value-checking code when you write any user input to a file!&lt;/p&gt;

&lt;p&gt;Taint is a good &lt;em&gt;first&lt;/em&gt; step in security, but it&amp;rsquo;s not the last.&lt;/p&gt;

&lt;h3 id=&#34;span-id-use-strict-use-strict-span&#34;&gt;&lt;span id=&#34;use strict&#34;&gt;&lt;code&gt;use strict&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Warnings and taint are two excellent tools for preventing your programs from doing bad things. If you want to go &lt;em&gt;further&lt;/em&gt;, Perl offers &lt;code&gt;use  strict&lt;/code&gt;. These two simple words can be put at the beginning of any program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        #!/usr/local/bin/perl -wT

        use strict;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A command like &lt;code&gt;use strict&lt;/code&gt; is called a &lt;em&gt;pragma&lt;/em&gt;. Pragmas are instructions to the Perl interpreter to do something special when it runs your program. &lt;code&gt;use strict&lt;/code&gt; does two things that make it harder to write bad software: It makes you declare all your variables (``strict vars&amp;rdquo;), and it makes it harder for Perl to mistake your intentions when you are using subs (``strict subs&amp;rdquo;).&lt;/p&gt;

&lt;p&gt;If you only want to use one or two types of strictness in your program, you can list them in the &lt;code&gt;use strict&lt;/code&gt; pragma, or you can use a special &lt;code&gt;no strict&lt;/code&gt; pragma to turn off any or all of the strictness you enabled earlier.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use strict &#39;vars&#39;;   # We want to require variables to be declared
        no strict &#39;vars&#39;;    # We&#39;ll go back to normal variable rules now

        use strict &#39;subs&#39;;   # We want Perl to distrust barewords (see below).

        no strict;           # Turn it off. Turn it all off. Go away, strict.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(There&amp;rsquo;s actually a third type of strictness - strict refs - which prevents you from using symbolic references. Since we haven&amp;rsquo;t really dealt with references, we&amp;rsquo;ll concentrate on the other two types of strictness.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-strict-vars-strict-vars-span&#34;&gt;&lt;span id=&#34;strict vars&#34;&gt;Strict vars&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl is generally trusting about variables. It will alllow you to create them out of thin air, and that&amp;rsquo;s what we&amp;rsquo;ve been doing in our programs so far. One way to make your programs more correct is to use &lt;em&gt;strict vars&lt;/em&gt;, which means that you must always &lt;em&gt;declare&lt;/em&gt; variables before you use them. You declare variables by using the &lt;code&gt;my&lt;/code&gt; keyword, either when you assign values to them or before you first mention them:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my ($i, $j, @locations);
        my $filename = &amp;quot;./logfile.txt&amp;quot;;
        $i = 5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This use of &lt;code&gt;my&lt;/code&gt; doesn&amp;rsquo;t interfere with using it elsewhere, like in subs, and remember that a &lt;code&gt;my&lt;/code&gt; variable in a sub will be used instead of the one from the rest of your program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        my ($i, $j, @locations);
        # ... stuff skipped ...
        sub fix {
            my ($q, $i) = @_;  # This doesn&#39;t interfere with the program $i!
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you end up using a variable &lt;em&gt;without&lt;/em&gt; declaring it, you&amp;rsquo;ll see an error before your program runs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use strict;
        $i = 5;
        print &amp;quot;The value is $i.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When you try to run this program, you see an error message similar to &lt;em&gt;Global symbol ``$i&amp;rdquo; requires explicit package name at a6-my.pl line 3.&lt;/em&gt; You fix this by declaring &lt;code&gt;$i&lt;/code&gt; in your program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use strict;
        my $i = 5;   # Or &amp;quot;my ($i); $i = 5;&amp;quot;, if you prefer...
        print &amp;quot;The value is $i.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Keep in mind that &lt;em&gt;some&lt;/em&gt; of what strict vars does will overlap with the &lt;code&gt;-w&lt;/code&gt; flag, but not all of it. Using the two together makes it much more difficult, but not impossible, to use an incorrect variable name. For example, strict vars &lt;em&gt;won&amp;rsquo;t&lt;/em&gt; catch it if you accidentally use the &lt;em&gt;wrong&lt;/em&gt; variable:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;         my ($i, $ii) = (1, 2);
         print &#39;The value of $ii is &#39;, $i, &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code has a bug, but neither strict vars nor the &lt;code&gt;-w&lt;/code&gt; flag will catch it.&lt;/p&gt;

&lt;h3 id=&#34;span-id-strict-subs-strict-subs-span&#34;&gt;&lt;span id=&#34;strict subs&#34;&gt;Strict subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;During the course of this series, I&amp;rsquo;ve deliberately avoided mentioning all sorts of tricks that allow you to write more &lt;em&gt;compact&lt;/em&gt; Perl. This is because of a simple rule: &lt;em&gt;readability always wins&lt;/em&gt;. Not only can compactness make it difficult to read code, it can sometimes have weird side effects! The way Perl looks up subs in your program is an example. Take a look at this pair of three-line programs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       $a = test_value;
       print &amp;quot;First program: &amp;quot;, $a, &amp;quot;\n&amp;quot;;
       sub test_value { return &amp;quot;test passed&amp;quot;; }

       sub test_value { return &amp;quot;test passed&amp;quot;; }
       $a = test_value;
       print &amp;quot;Second program: &amp;quot;, $a, &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The same program with one little, insignificant line moved, right? In both cases we have a &lt;code&gt;test_value()&lt;/code&gt; sub and we want to put its result into &lt;code&gt;$a&lt;/code&gt;. And yet, when we run the two programs, we get two different results:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;       First program&#39;s result: test_value
       Second program&#39;s result: test passed
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The reason &lt;em&gt;why&lt;/em&gt; we get two different results is a little convoluted.&lt;/p&gt;

&lt;p&gt;In the first program, at the point we get to &lt;code&gt;$a = test_value;&lt;/code&gt;, Perl doesn&amp;rsquo;t know of any &lt;code&gt;test_value()&lt;/code&gt; sub, because it hasn&amp;rsquo;t gotten that far yet. This means that &lt;code&gt;test_value&lt;/code&gt; is interpreted as if it were the string &amp;lsquo;test_value&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;In the second program, the definition of &lt;code&gt;test_value()&lt;/code&gt; comes &lt;em&gt;before&lt;/em&gt; the &lt;code&gt;$a = test_value;&lt;/code&gt; line. Since Perl has a &lt;code&gt;test_value()&lt;/code&gt; sub to call, that&amp;rsquo;s what it thinks &lt;code&gt;test_value&lt;/code&gt; means.&lt;/p&gt;

&lt;p&gt;The technical term for isolated words like &lt;code&gt;test_value&lt;/code&gt; that might be subs and might be strings depending on context, by the way, is &lt;em&gt;bareword&lt;/em&gt;. Perl&amp;rsquo;s handling of barewords can be confusing, and it can cause two different types of bug.&lt;/p&gt;

&lt;h3 id=&#34;span-id-want-a-sub-get-a-string-want-a-sub-get-a-string-span&#34;&gt;&lt;span id=&#34;want a sub, get a string&#34;&gt;Want a Sub, Get a String&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The first type of bug is what we encountered in our first program, which I&amp;rsquo;ll repeat here:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $a = test_value;
        print &amp;quot;First program: &amp;quot;, $a, &amp;quot;\n&amp;quot;;
        sub test_value { return &amp;quot;test passed&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that Perl won&amp;rsquo;t look forward to find &lt;code&gt;test_value()&lt;/code&gt;, so since it hasn&amp;rsquo;t &lt;em&gt;already&lt;/em&gt; seen &lt;code&gt;test_value()&lt;/code&gt;, it assumes that you want a string. Strict subs will cause this program to die with an error:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        use strict;

        my $a = test_value;
        print &amp;quot;Third program: &amp;quot;, $a, &amp;quot;\n&amp;quot;;
        sub test_value { &amp;quot;test passed&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Notice the &lt;code&gt;my&lt;/code&gt; put in to make sure that strict vars won&amp;rsquo;t complain about &lt;code&gt;$a&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Now you get an error message like &lt;em&gt;Bareword ``test_value&amp;rdquo; not allowed while ``strict subs&amp;rdquo; in use at ./a6-strictsubs.pl line 3.&lt;/em&gt; This is easy to fix, and there are two ways to do it:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Use parentheses to make it clear you&amp;rsquo;re calling a sub. If Perl sees &lt;code&gt;$a = test_value();&lt;/code&gt;, it will assume that even if it hasn&amp;rsquo;t seen &lt;code&gt;test_value()&lt;/code&gt; defined yet, it will sometime between now and the end of the program. (If there isn&amp;rsquo;t any &lt;code&gt;test_value()&lt;/code&gt; in your program, Perl will die while it&amp;rsquo;s running.) This is the easiest thing to do, and often the most readable.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Declare your sub before you first use it, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use strict;

    sub test_value;  # Declares that there&#39;s a test_value() coming later ...
    my $a = test_value;  # ...so Perl will know this line is okay.
    print &amp;quot;Fourth program: &amp;quot;, $a, &amp;quot;\n&amp;quot;;
    sub test_value { return &amp;quot;test_passed&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Declaring your subs has the advantage of allowing you to maintain the &lt;code&gt;$a =  test_value;&lt;/code&gt; syntax if that&amp;rsquo;s what you find more readable, but it&amp;rsquo;s also a little obscure. Other programmers may not see why you have &lt;code&gt;sub  test_value;&lt;/code&gt; in your code.&lt;/p&gt;

&lt;p&gt;Of course, you could always move the definition of your sub &lt;em&gt;before&lt;/em&gt; the line where you want to call it. This isn&amp;rsquo;t quite as good as either of the other two methods, because now you are moving code around instead of making your existing code clearer. Also, it can cause &lt;em&gt;other&lt;/em&gt; problems, which we&amp;rsquo;ll discuss now &amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-want-a-string-get-a-sub-want-a-string-get-a-sub-span&#34;&gt;&lt;span id=&#34;want a string, get a sub&#34;&gt;Want a String, Get a Sub&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve seen how &lt;code&gt;use strict&lt;/code&gt; can help prevent an error where you intend to call a sub, but instead get a string value. It also helps prevent the opposite error: wanting a string value, but calling a sub instead. This is a more dangerous class of bug, because it can be &lt;em&gt;very&lt;/em&gt; hard to trace, and it often pops up in the most unexpected places. Take a look at this excerpt from a long program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        #!/usr/local/bin/perl -Tw

        use strict;

        use SomeModule;
        use SomeOtherModule;
        use YetAnotherModule;

        # ... (and then there&#39;s hundreds of lines of code) ...

        # Now we get to line 400 of the program, which tests if we got an &amp;quot;OK&amp;quot;
        # before we act on a request from the user.
        if ($response_code eq OK) {
            act_on($request);
        } else {
            throw_away($request);
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This program works without a hitch for a long time, because Perl sees the bareword &lt;code&gt;OK&lt;/code&gt; and considers it to be a literal string. Then, two years later someone needs to add code to make this program understand HTTP status codes. They stick this in at line 2, or line 180, or line 399 (it doesn&amp;rsquo;t matter &lt;em&gt;exactly&lt;/em&gt; where, just that it comes before line 400):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        sub OK { return 200; } # HTTP &amp;quot;request ok, response follows&amp;quot; code
        sub NOT_FOUND { return 404; } # &amp;quot;URL not found&amp;quot; code
        sub SERVER_ERROR { return 500; } # &amp;quot;Server can&#39;t handle request&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Take a moment to guess what happens to our program now. Try to work the word ``disaster&amp;rdquo; into it.&lt;/p&gt;

&lt;p&gt;Thanks to this tiny change, our program now throws away every request that comes in to it. The &lt;code&gt;if ($response eq OK)&lt;/code&gt; test now calls the &lt;code&gt;OK()&lt;/code&gt; sub, which returns a value of 200. The &lt;code&gt;if&lt;/code&gt; now fails every time! The programmer, if they still have a job after this fiasco, must hunt through the entire program to find out exactly when the behavior of &lt;code&gt;if ($response eq OK)&lt;/code&gt; changed, and why.&lt;/p&gt;

&lt;p&gt;By the way, if the programmer is &lt;em&gt;really&lt;/em&gt; unlucky, that new &lt;code&gt;OK()&lt;/code&gt; sub wouldn&amp;rsquo;t even be in &lt;em&gt;their&lt;/em&gt; code at all, but defined somewhere in a new version of &lt;code&gt;SomeOtherModule.pm&lt;/code&gt; that just got installed!&lt;/p&gt;

&lt;p&gt;Barewords are dangerous because of this unpredictable behavior. &lt;code&gt;use  strict&lt;/code&gt; (or &lt;code&gt;use strict &#39;subs&#39;&lt;/code&gt;) makes them predictable, because barewords that might cause strange behavior in the future will make your program die before they can wreak havoc.&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-one-exception-the-one-exception-span&#34;&gt;&lt;span id=&#34;the one exception&#34;&gt;The One Exception&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s &lt;em&gt;one&lt;/em&gt; place where it&amp;rsquo;s OK to use barewords even when you&amp;rsquo;ve turned on strict subs: when you are assigning hash keys.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $hash{sample} = 6;   # Same as $hash{&#39;sample&#39;} = 6
        %other_hash = ( pie =&amp;gt; &#39;apple&#39; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Barewords in hash keys are always interpreted as strings, so there is no ambiguity.&lt;/p&gt;

&lt;h3 id=&#34;span-id-is-this-overkill-is-this-overkill-span&#34;&gt;&lt;span id=&#34;is this overkill&#34;&gt;Is This Overkill?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are times when using all of the quality enforcement functionality (or ``correctness police,&amp;rdquo; if you like to anthropmorphize) Perl offers seems like overkill. If you&amp;rsquo;re just putting together a quick, three-line tool that you&amp;rsquo;ll use once and then never touch again, you probably don&amp;rsquo;t care about whether it&amp;rsquo;ll run properly under &lt;code&gt;use strict&lt;/code&gt;. When you&amp;rsquo;re the only person who will run a program, you generally don&amp;rsquo;t care if the &lt;code&gt;-T&lt;/code&gt; flag will show that you&amp;rsquo;re trying to do something unsafe with a piece of user input.&lt;/p&gt;

&lt;p&gt;Still, it&amp;rsquo;s a good idea to use every tool at your disposal to write good software. Here are three reasons to be concerned about correctness when you write just about &lt;em&gt;anything&lt;/em&gt;:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;&lt;em&gt;One-off programs aren&amp;rsquo;t.&lt;/em&gt; There are few programs worth writing that only get run once. Software tools tend to accumulate, and get used. You&amp;rsquo;ll find that the more you use a program, the more you want it to do.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;em&gt;Other people will read your code.&lt;/em&gt; Whenever programmers write something really good, they tend to keep it around, and give it to friends who have the same problem. More importantly, most projects aren&amp;rsquo;t one-person jobs; there are teams of programmers who need to work together, reading, fixing and extennding one another&amp;rsquo;s code. Unless your plans for the future include always working alone and having no friends, you should expect that other people will someday read and modify your code.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;*&lt;strong&gt;You&lt;/strong&gt; will read your code.* Don&amp;rsquo;t think you have a special advantage in understanding your code just because you wrote it! Often you&amp;rsquo;ll need to go back to software you wrote months or even years earlier to fix it or extend it. During that time you&amp;rsquo;ll have forgotten all those clever little tricks you came up with during that caffeine-fueled all-nighter and all the little gotchas that you noticed but thought you would fix later.&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;These three points all have one thing in common: Your programs &lt;em&gt;will&lt;/em&gt; be rewritten and enhanced by people who will appreciate every effort you make to make their job easier. When you make sure your code is readable and correct, it tends to start out much more secure and bug-free, and it tends to stay that way, too!&lt;/p&gt;

&lt;h3 id=&#34;span-id-play-around-play-around-span&#34;&gt;&lt;span id=&#34;play around!&#34;&gt;Play Around!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;During the course of this series, we&amp;rsquo;ve only scratched the surface of what Perl can do. Don&amp;rsquo;t take these articles as being definitive - they&amp;rsquo;re just an introduction! Read the &lt;code&gt;perlfunc&lt;/code&gt; page to learn about all of Perl&amp;rsquo;s built-in functions and see what ideas they inspire. My biography page tells you how to get in touch with me if you have any questions.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Beginners Intro to Perl - Part 5</title>
      <link>http://localhost:1313/pub/2000/12/begperl5.html/</link>
      <pubDate>Mon, 18 Dec 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/12/begperl5.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this venerable series is undergoing updates. You might be interested in the newer versions, available at:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Files and Strings with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;strong&gt;Beginners Intro to Perl&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/10/begperl1.html&#34;&gt;Part 1 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl2.html&#34;&gt;Part 2 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl3.html&#34;&gt;Part 3 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl4.html&#34;&gt;Part 4 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2001/01/begperl6.html&#34;&gt;Part 6 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;#what%20is%20an%20object&#34;&gt;What Is an Object?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#our%20goal&#34;&gt;Our Goal&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#starting%20off&#34;&gt;Starting Off&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#what%20does%20our%20object%20do&#34;&gt;What Does Our Object Do?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#our%20goal,%20part%202&#34;&gt;Our Goal, Part 2&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#encapsulation&#34;&gt;Encapsulation&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#play%20around!&#34;&gt;Play Around!&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So far, we&amp;rsquo;ve mostly stuck to writing everything for our programs ourselves. One of the big advantages of Perl is that you don&amp;rsquo;t need to do this. More than 1,000 people worldwide have contributed more than 5,000 utility packages, or &lt;em&gt;modules&lt;/em&gt;, for common tasks.&lt;/p&gt;

&lt;p&gt;In this installment, we&amp;rsquo;ll learn how modules work by building one, and along the way we&amp;rsquo;ll learn a bit about &lt;em&gt;object-oriented programming&lt;/em&gt; in Perl.&lt;/p&gt;

&lt;h3 id=&#34;span-id-what-is-an-object-what-is-an-object-span&#34;&gt;&lt;span id=&#34;what is an object&#34;&gt;What Is an Object?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Think back to the first article in this series, when we discussed the two basic data types in Perl, strings and numbers. There&amp;rsquo;s a third basic data type: the &lt;em&gt;object&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Objects are a convenient way of packaging information with the things you actually &lt;em&gt;do&lt;/em&gt; with that information. The information an object contains is called its &lt;em&gt;properties&lt;/em&gt;, and the things you can do with that information are called &lt;em&gt;methods&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;For example, you might have an &lt;code&gt;AddressEntry&lt;/code&gt; object for an address book program - this object would contain &lt;em&gt;properties&lt;/em&gt; that store a person&amp;rsquo;s name, mailing address, phone number and e-mail address; and &lt;em&gt;methods&lt;/em&gt; that print a nicely formatted mailing label or allow you to change the person&amp;rsquo;s phone number.&lt;/p&gt;

&lt;p&gt;During the course of this article, we&amp;rsquo;ll build a small, but useful, class: a container for configuration file information.&lt;/p&gt;

&lt;h3 id=&#34;span-id-our-goal-our-goal-span&#34;&gt;&lt;span id=&#34;our goal&#34;&gt;Our Goal&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So far, we&amp;rsquo;ve put the code for setting various options in our programs directly in the program&amp;rsquo;s source code. This isn&amp;rsquo;t a good approach. You may want to install a program and allow multiple users to run it, each with their own preferences, or you may want to store common sets of options for later. What you need is a configuration file to store these options.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use a simple plain-text format, where name and value pairs are grouped in sections, and sections are indicated by a header name in brackets. When we want to refer to the value of a specific key in our configuration file, we call the key &lt;code&gt;section.name&lt;/code&gt;. For instance, the value of &lt;em&gt;author.firstname&lt;/em&gt; in this simple file is ``Doug:&amp;rdquo;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   [author]
   firstname=Doug
   lastname=Sheppard

   [site]
   name=Perl.com
   url=http://www.perl.com/
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(If you used Windows in the ancient days when versions had numbers, not years, you&amp;rsquo;ll recognize this as being similar to the format of INI files.)&lt;/p&gt;

&lt;p&gt;Now that we know the real-world purpose of our module, we need to think about what &lt;em&gt;properties&lt;/em&gt; and &lt;em&gt;methods&lt;/em&gt; it will have: What do &lt;code&gt;TutorialConfig&lt;/code&gt; objects store, and what can we do with them?&lt;/p&gt;

&lt;p&gt;The first part is simple: We want the object&amp;rsquo;s properties to be the values in our configuration file.&lt;/p&gt;

&lt;p&gt;The second part is a little more complex. Let&amp;rsquo;s start by doing the two things we &lt;em&gt;need&lt;/em&gt; to do: read a configuration file, and get a value from it. We&amp;rsquo;ll call these two methods &lt;code&gt;read&lt;/code&gt; and &lt;code&gt;get&lt;/code&gt;. Finally, we&amp;rsquo;ll add another method that will allow us to set or change a value from within our program, which we&amp;rsquo;ll call &lt;code&gt;set&lt;/code&gt;. These three methods will cover nearly everything we want to do.&lt;/p&gt;

&lt;h3 id=&#34;span-id-starting-off-starting-off-span&#34;&gt;&lt;span id=&#34;starting off&#34;&gt;Starting Off&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ll use the name &lt;code&gt;TutorialConfig&lt;/code&gt; for our configuration file class. (Class names are normally named in this InterCapitalized style.) Since Perl looks for a module by its filename, this means we&amp;rsquo;ll call our module file &lt;code&gt;TutorialConfig.pm&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Put the following into a file called &lt;code&gt;TutorialConfig.pm&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package TutorialConfig;

    warn &amp;quot;TutorialConfig is successfully loaded!\n&amp;quot;;
    1;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(I&amp;rsquo;ll be sprinkling debugging statements throughout the code. You can take them out in practice. The &lt;code&gt;warn&lt;/code&gt; keyword is useful for warnings - things that you want to bring to the user&amp;rsquo;s attention without ending the program the way &lt;code&gt;die&lt;/code&gt; would.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;package&lt;/code&gt; keyword tells Perl the name of the class you&amp;rsquo;re defining. This is generally the same as the module name. (It doesn&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to be, but it&amp;rsquo;s a good idea!) The &lt;code&gt;1;&lt;/code&gt; will return a true value to Perl, which indicates that the module was loaded successfully.&lt;/p&gt;

&lt;p&gt;You now have a simple module called &lt;code&gt;TutorialConfig&lt;/code&gt;, which you can use in your code with the &lt;code&gt;use&lt;/code&gt; keyword. Put the following into a very simple, one-line program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use TutorialConfig;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we run this program, we see the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    TutorialConfig is successfully loaded!
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-what-does-our-object-do-what-does-our-object-do-span&#34;&gt;&lt;span id=&#34;what does our object do&#34;&gt;What Does Our Object Do?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Before we can create an object, we need to know &lt;em&gt;how&lt;/em&gt; to create it. That means we must write a method called &lt;code&gt;new&lt;/code&gt; that will set up an object and return it to us. This is also where you put any special initialization code that you might need to run for each object when it is created.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;new&lt;/code&gt; method for our &lt;code&gt;TutorialConfig&lt;/code&gt; class looks like this, and goes into &lt;code&gt;TutorialConfig.pm&lt;/code&gt; right after the package declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub new {
        my ($class_name) = @_;

        my ($self) = {};
        warn &amp;quot;We just created our new variable...\n &amp;quot;;

        bless ($self, $class_name);
        warn &amp;quot;and now it&#39;s a $class_name object!\n&amp;quot;;

        $self-&amp;gt;{&#39;_created&#39;} = 1;
        return $self;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Again, you won&amp;rsquo;t need those &lt;code&gt;warn&lt;/code&gt; statements in actual practice.)&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s break this down line by line.&lt;/p&gt;

&lt;p&gt;First, notice that we define methods by using &lt;code&gt;sub&lt;/code&gt;. (All methods are really just a special sort of sub.) When we call &lt;code&gt;new&lt;/code&gt;, we pass it one parameter: the &lt;em&gt;type&lt;/em&gt; of object we want to create. We store this in a private variable called &lt;code&gt;$class_name&lt;/code&gt;. (You can also pass extra parameters to &lt;code&gt;new&lt;/code&gt; if you want. Some modules use this for special initialization routines.)&lt;/p&gt;

&lt;p&gt;Next, we tell Perl that &lt;code&gt;$self&lt;/code&gt; is a hash. The syntax &lt;code&gt;my ($self) = {};&lt;/code&gt; is a special idiom that&amp;rsquo;s used mostly in Perl object programming, and we&amp;rsquo;ll see how it works in some of our methods. (The technical term is that &lt;code&gt;$self&lt;/code&gt; is an &lt;em&gt;anonymous hash&lt;/em&gt;, if you want to read more about it elsewhere.)&lt;/p&gt;

&lt;p&gt;Third, we use the &lt;code&gt;bless&lt;/code&gt; function. You give this function two parameters: a variable that you want to make into an object, and the type of object you want it to be. This is the line that makes the magic happen!&lt;/p&gt;

&lt;p&gt;Fourth, we&amp;rsquo;ll set a &lt;em&gt;property&lt;/em&gt; called ``_created&amp;rdquo;. This property isn&amp;rsquo;t really that useful, but it does show the syntax for accessing the contents of an object: &lt;em&gt;$object_name-&amp;gt;{property_name}&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Finally, now that we&amp;rsquo;ve made &lt;code&gt;$self&lt;/code&gt; into a new &lt;code&gt;TutorialConfig&lt;/code&gt; object, we &lt;code&gt;return&lt;/code&gt; it.&lt;/p&gt;

&lt;p&gt;Our program to create a &lt;code&gt;TutorialConfig&lt;/code&gt; object looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use TutorialConfig;
    $tut = new TutorialConfig;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(You don&amp;rsquo;t need to use parentheses here, unless your object&amp;rsquo;s &lt;code&gt;new&lt;/code&gt; method takes any extra parameters. But if you feel more comfortable writing &lt;code&gt;$tut = new TutorialConfig();&lt;/code&gt;, it&amp;rsquo;ll work just as well.)&lt;/p&gt;

&lt;p&gt;When you run this code, you&amp;rsquo;ll see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    TutorialConfig is successfully loaded!
    We just created the variable ...
    and now it&#39;s a TutorialConfig object!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we have a class and we can create objects with it, let&amp;rsquo;s make our class &lt;em&gt;do&lt;/em&gt; something!&lt;/p&gt;

&lt;h3 id=&#34;span-id-our-goal-part-2-our-goal-part-2-span&#34;&gt;&lt;span id=&#34;our goal, part 2&#34;&gt;Our Goal, Part 2&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Look at our goals again. We need to write three methods for our &lt;code&gt;TutorialConfig&lt;/code&gt; module: &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first method, &lt;code&gt;read&lt;/code&gt;, obviously requires that we tell it what file we want to read. Notice that when we write the source code for this method, we must give it &lt;em&gt;two&lt;/em&gt; parameters. The first parameter is the object we&amp;rsquo;re using, and the second is the filename we want to use. We&amp;rsquo;ll use &lt;code&gt;return&lt;/code&gt; to indicate whether the file was successfully read.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   sub read {
      my ($self, $file) = @_;
      my ($line, $section);

      open (CONFIGFILE, $file) or return 0;

      # We&#39;ll set a special property 
      # that tells what filename we just read.
      $self-&amp;gt;{&#39;_filename&#39;} = $file;



      while ($line = &amp;lt;CONFIGFILE&amp;gt;) {

         # Are we entering a new section?
         if ($line =~ /^\[(.*)\]/) {
            $section = $1;
         } elsif ($line =~ /^([^=]+)=(.*)/) {
            my ($config_name, $config_val) = ($1, $2);
            if ($section) {
               $self-&amp;gt;{&amp;quot;$section.$config_name&amp;quot;} = $config_val;
            } else {
               $self-&amp;gt;{$config_name} = $config_val;
            }
         }
      }

      close CONFIGFILE;
      return 1;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now that we&amp;rsquo;ve read a configuration file, we need to look at the values we just read. We&amp;rsquo;ll call this method &lt;code&gt;get&lt;/code&gt;, and it doesn&amp;rsquo;t have to be complex:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub get {
        my ($self, $key) = @_;

        return $self-&amp;gt;{$key};
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These two methods are really all we need to begin experimenting with our &lt;code&gt;TutorialConfig&lt;/code&gt; object. Take the module and sample configuration file from above (or &lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl5/tutc.txt&#34;&gt;download the configuration file here&lt;/a&gt; and &lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl5/TutorialConfig.pm&#34;&gt;the module here&lt;/a&gt;), put it in a file called &lt;code&gt;tutc.txt&lt;/code&gt;, and then run &lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl5/sample.pl&#34;&gt;this simple program&lt;/a&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use TutorialConfig;

    $tut = new TutorialConfig;
    $tut-&amp;gt;read(&#39;tutc.txt&#39;) or die &amp;quot;Couldn&#39;t read config file: $!&amp;quot;;

    print &amp;quot;The author&#39;s first name is &amp;quot;, 
             $tut-&amp;gt;get(&#39;author.firstname&#39;), 
             &amp;quot;.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Notice the syntax for calling an object&amp;rsquo;s methods: &lt;code&gt;$object-&amp;gt;method(parameters)&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;When you run this program, you&amp;rsquo;ll see something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    TutorialConfig has been successfully loaded!
    We just created the variable... 
    and now it&#39;s a TutorialConfig object!
    The author&#39;s first name is Doug.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We now have an object that will read configuration files and show us values inside those files. This is good enough, but we&amp;rsquo;ve decided to make it better by writing a &lt;code&gt;set&lt;/code&gt; method that allows us to add or change configuration values from within our program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub set {
        my ($self, $key, $value) = @_;

        $self-&amp;gt;{$key} = $value;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now let&amp;rsquo;s test it out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use TutorialConfig;
    $tut = new TutorialConfig;

    $tut-&amp;gt;read(&#39;tutc.txt&#39;) or die &amp;quot;Can&#39;t read config file: $!&amp;quot;;
    $tut-&amp;gt;set(&#39;author.country&#39;, &#39;Canada&#39;);

    print $tut-&amp;gt;get(&#39;author.firstname&#39;), &amp;quot; lives in &amp;quot;,
          $tut-&amp;gt;get(&#39;author.country&#39;), &amp;quot;.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These three methods (&lt;code&gt;read&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt;) are everything we&amp;rsquo;ll need for our &lt;code&gt;TutorialConfig.pm&lt;/code&gt; module. More complex modules might have dozens of methods!&lt;/p&gt;

&lt;h3 id=&#34;span-id-encapsulation-encapsulation-span&#34;&gt;&lt;span id=&#34;encapsulation&#34;&gt;Encapsulation&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You may be wondering why we have &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; methods at all. Why are we using &lt;code&gt;$tut-&amp;gt;set(&#39;author.country&#39;, &#39;Canada&#39;)&lt;/code&gt; when we could use &lt;code&gt;$tut-&amp;gt;{&#39;author.country&#39;} = &#39;Canada&#39;&lt;/code&gt; instead? There are two reasons to use methods instead of playing directly with an object&amp;rsquo;s properties.&lt;/p&gt;

&lt;p&gt;First, you can generally trust that a module won&amp;rsquo;t change its methods, no matter how much their implementation changes. Someday, we might want to switch from using text files to hold configuration information to using a database like MySQL or Postgres. Our new &lt;code&gt;TutorialConfig.pm&lt;/code&gt; module might have &lt;code&gt;new&lt;/code&gt;, &lt;code&gt;read&lt;/code&gt;, &lt;code&gt;get&lt;/code&gt; and &lt;code&gt;set&lt;/code&gt; methods that look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      sub new {
          my ($class) = @_;
          my ($self) = {};
          bless $self, $class;
          return $self;
      }

      sub read {
          my ($self, $file) = @_;
          my ($db) = database_connect($file);
          if ($db) {
              $self-&amp;gt;{_db} = $db;
              return $db;
          }
          return 0;
      }

      sub get {
          my ($self, $key) = @_;
          my ($db) = $self-&amp;gt;{_db};

          my ($value) = database_lookup($db, $key);
          return $value;
      }

      sub set {
          my ($self, $key, $value) = @_;
          my ($db) = $self-&amp;gt;{_db};

          my ($status) = database_set($db, $key, $value);
          return $status;
      }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Our module would define the &lt;code&gt;database_connect&lt;/code&gt;, &lt;code&gt;database_lookup&lt;/code&gt; and &lt;code&gt;database_set&lt;/code&gt; routines elsewhere.)&lt;/p&gt;

&lt;p&gt;Even though the entire module&amp;rsquo;s source code has changed, all of our methods still have the same names and syntax. Code that uses these methods will continue working just fine, but code that directly manipulates properties will break!&lt;/p&gt;

&lt;p&gt;For instance, let&amp;rsquo;s say you have some code that contains this line to set a configuration value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     $tut-&amp;gt;{&#39;author.country&#39;} = &#39;Canada&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This works fine with the original &lt;code&gt;TutorialConfig.pm&lt;/code&gt; module, because when you call &lt;code&gt;$tut-&amp;gt;get(&#39;author.country&#39;)&lt;/code&gt;, it looks in the object&amp;rsquo;s properties and returns ``Canada&amp;rdquo; just like you expected. So far, so good. However, when you upgrade to the new version that uses databases, the code will no longer return the correct result. Instead of &lt;code&gt;get()&lt;/code&gt; looking in the object&amp;rsquo;s properties, it&amp;rsquo;ll go to the database, which won&amp;rsquo;t contain the correct value for ``author.country&amp;rdquo;! If you&amp;rsquo;d used &lt;code&gt;$tut-&amp;gt;set(&#39;author.country&#39;, &#39;Canada&#39;)&lt;/code&gt; all along, things would work fine.&lt;/p&gt;

&lt;p&gt;As a module author, writing methods will let you make changes (bug fixes, enhancements, or even complete rewrites) without requiring your module&amp;rsquo;s users to rewrite any of their code.&lt;/p&gt;

&lt;p&gt;Second, using methods lets you avoid impossible values. You might have an object that takes a person&amp;rsquo;s age as a property. A person&amp;rsquo;s age must be a positive number (you can&amp;rsquo;t be -2 years old!), so the &lt;code&gt;age()&lt;/code&gt; method for this object will reject negative numbers. If you bypass the method and directly manipulate &lt;code&gt;$obj-&amp;gt;{&#39;age&#39;}&lt;/code&gt;, you may cause problems elsewhere in the code (a routine to calculate the person&amp;rsquo;s birth year, for example, might fail or produce an odd result).&lt;/p&gt;

&lt;p&gt;As a module author, you can use methods to help programmers who use your module write better software. You can write a good error-checking routine once, and it will be used many times.&lt;/p&gt;

&lt;p&gt;(Some languages, by the way, &lt;em&gt;enforce&lt;/em&gt; encapsulation, by giving you the ability to make certain properties private. Perl doesn&amp;rsquo;t do this. In Perl, encapsulation isn&amp;rsquo;t the law, it&amp;rsquo;s just a very good idea.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-play-around-play-around-span&#34;&gt;&lt;span id=&#34;play around!&#34;&gt;Play Around!&lt;/span&gt;&lt;/h3&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Our &lt;code&gt;TutorialConfig.pm&lt;/code&gt; module could use a method that will write a new configuration file to any filename you desire. Write your own &lt;code&gt;write()&lt;/code&gt; method (use &lt;code&gt;keys %$self&lt;/code&gt; to get the keys of the object&amp;rsquo;s properties). Be sure to use &lt;code&gt;or&lt;/code&gt; to warn if the file couldn&amp;rsquo;t be opened!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Write a &lt;code&gt;BankAccount.pm&lt;/code&gt; module. Your &lt;code&gt;BankAccount&lt;/code&gt; object should have &lt;code&gt;deposit&lt;/code&gt;, &lt;code&gt;withdraw&lt;/code&gt;, and &lt;code&gt;balance&lt;/code&gt; methods. Make the &lt;code&gt;withdraw&lt;/code&gt; method fail if you try to withdraw more money than you have, or deposit or withdraw a negative amount of money.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;&lt;code&gt;CGI.pm&lt;/code&gt; also lets you use objects if you want. (Each object represents a single CGI query.) The method names are the same as the CGI functions we used in the last article:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use CGI;
$cgi = new CGI;

print $cgi-&amp;gt;header(), $cgi-&amp;gt;start_html();
print &amp;quot;The &#39;name&#39; parameter is &amp;quot;, $cgi-&amp;gt;param(&#39;name&#39;), &amp;quot;.\n&amp;quot;;
print $cgi-&amp;gt;end_html();
&lt;/code&gt;&lt;/pre&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Try rewriting one of your CGI programs to use &lt;code&gt;CGI&lt;/code&gt; objects instead of the CGI functions.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A big advantage of using CGI objects is that you can store and retrieve queries on disk. Take a look in the &lt;code&gt;CGI.pm&lt;/code&gt; documentation to learn how to use the &lt;code&gt;save()&lt;/code&gt; method to store queries, and how to pass a filehandle to &lt;code&gt;new&lt;/code&gt; to read them from disk. Try writing a CGI program that saves recently used queries for easy retrieval.&lt;/li&gt;
&lt;/ol&gt;

&lt;hr /&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl5/TutorialConfig.pm&#34;&gt;Complete &lt;code&gt;TutorialConfig.pm&lt;/code&gt; module&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl5/sample.pl&#34;&gt;Demo program&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl5/tutc.txt&#34;&gt;Sample configuration file&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Beginners Intro to Perl - Part 4</title>
      <link>http://localhost:1313/pub/2000/12/begperl4.html/</link>
      <pubDate>Wed, 06 Dec 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/12/begperl4.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this venerable series is undergoing updates. You might be interested in the newer versions, available at:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Files and Strings with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;it-s-cgi-time&#34;&gt;It&amp;rsquo;s CGI time&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;&lt;strong&gt;Beginners Intro to Perl&lt;/strong&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/10/begperl1.html&#34;&gt;Part 1 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl2.html&#34;&gt;Part 2 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl3.html&#34;&gt;Part 3 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl5.html&#34;&gt;Part 5 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2001/01/begperl6.html&#34;&gt;Part 6 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;#cgi&#34;&gt;What is CGI?&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#cgi_program&#34;&gt;A Real CGI Program&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#uhoh&#34;&gt;Uh-Oh!&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#second_script&#34;&gt;Our Second Script&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#sorting&#34;&gt;Sorting&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#trust&#34;&gt;Trust No One&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#play_around&#34;&gt;Play Around!&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;So far, we&amp;rsquo;ve talked about Perl as a language for mangling numbers, strings, and files - the original purpose of the language. Now it&amp;rsquo;s time to talk about what Perl does on the Web. In this installment, we&amp;rsquo;re going to talk about CGI programming.&lt;/p&gt;

&lt;h3 id=&#34;span-id-cgi-what-is-cgi-span&#34;&gt;&lt;span id=&#34;cgi&#34;&gt;What is CGI?&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The Web is based on a client-server model: your browser (the client) making requests to a Web server. Most of these are simple requests for documents or images, which the server delivers to the browser for display.&lt;/p&gt;

&lt;p&gt;Of course, sometimes you want the server to do more than just dump the contents of a file. You&amp;rsquo;d like to do something with a server-side program - whether that &amp;ldquo;something&amp;rdquo; is using Web-based e-mail, looking up a phone number in a database or ordering a copy of &lt;em&gt;Evil Geniuses in a Nutshell&lt;/em&gt; for your favorite techie. This means the browser must be able to send information (an e-mail address, a name to look up, shipping information for a book) to the server, and the server must be able to use that information and return the results to the user.&lt;/p&gt;

&lt;p&gt;The standard for communication between a user&amp;rsquo;s Web browser and a server-side program running on the Web server is called &lt;strong&gt;CGI&lt;/strong&gt;, or Common Gateway Interface. It is supported by all popular Web server software. To get the most out of this article, you will need to have a server that supports CGI. This may be a server running on your desktop machine or an account with your ISP (though probably not a free Web-page service). If you don&amp;rsquo;t know whether you have CGI capabilities, ask your ISP or a local sysadmin how to set things up.&lt;/p&gt;

&lt;p&gt;Notice that I haven&amp;rsquo;t described how CGI works; that&amp;rsquo;s because you don&amp;rsquo;t &lt;em&gt;need&lt;/em&gt; to know. There&amp;rsquo;s a standard Perl module called &lt;code&gt;CGI.pm&lt;/code&gt; that will handle the CGI protocol for you. CGI.pm is part of the core Perl distribution, and any properly installed Perl should have it available.&lt;/p&gt;

&lt;p&gt;Telling your CGI program that you want to use the CGI module is as simple as this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use CGI &#39;:standard&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;use CGI &#39;:standard&#39;;&lt;/code&gt; statement tells Perl that you want to use the CGI.pm module in your program. This will load the module and make a set of CGI functions available for your code.&lt;/p&gt;

&lt;h3 id=&#34;span-id-cgi-program-a-real-cgi-program-span&#34;&gt;&lt;span id=&#34;cgi_program&#34;&gt;A Real CGI Program&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s write our first real CGI program. Instead of doing something complex, we&amp;rsquo;ll write something that will simply throw back whatever we throw at it. We&amp;rsquo;ll call this script &lt;code&gt;backatcha.cgi&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/local/bin/perl

use CGI &#39;:standard&#39;;

print header();
print start_html();

for $i (param()) {
    print &amp;quot;&amp;lt;b&amp;gt;&amp;quot;, $i, &amp;quot;&amp;lt;/b&amp;gt;: &amp;quot;, param($i), &amp;quot;&amp;lt;br&amp;gt;\n&amp;quot;;
}

print end_html();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;ve never used HTML, the pair of &amp;lt;b&amp;gt; and &amp;lt;/b&amp;gt; tags mean &amp;ldquo;begin bold&amp;rdquo; and &amp;ldquo;end bold&amp;rdquo;, respectively, and the &amp;lt;br&amp;gt; tag means &amp;ldquo;line break.&amp;rdquo; (A good paper reference to HTML is O&amp;rsquo;Reilly&amp;rsquo;s &lt;em&gt;HTML &amp;amp; XHTML: The Definitive Guide&lt;/em&gt;, and online, I like &lt;a href=&#34;http://www.htmlhelp.com/&#34;&gt;the Web Design Group&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;Install this program on your server and do a test run. (If you don&amp;rsquo;t have a Web server of your own, we&amp;rsquo;ve put a copy online for you &lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl4/backatcha.pl&#34;&gt;here&lt;/a&gt;.) Here&amp;rsquo;s a short list of what you do to install a CGI program:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Make sure the program is placed where your Web server will recognize it as a CGI script. This may be a special &lt;code&gt;cgi-bin&lt;/code&gt; directory or making sure the program&amp;rsquo;s filename ends in &lt;code&gt;.pl&lt;/code&gt; or &lt;code&gt;.cgi&lt;/code&gt;. If you don&amp;rsquo;t know where to place the program, your ISP or sysadmin should.&lt;/li&gt;
&lt;li&gt;Make sure the program can be run by the server. If you are using a Unix system, you may have to give the Web-server user read and execute permission for the program. It&amp;rsquo;s easiest to give these permissions to everybody by using &lt;code&gt;chmod filename 755&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Make a note of the program&amp;rsquo;s URL, which will probably be something like http://&lt;em&gt;server name&lt;/em&gt;/cgi-bin/backatcha.cgi) and go to that URL in your browser. (Take a guess what you should do if you don&amp;rsquo;t know what the URL of the program is. Hint: It involves the words &amp;ldquo;ask,&amp;rdquo; &amp;ldquo;your&amp;rdquo; and &amp;ldquo;ISP.&amp;rdquo;)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;If this works, you will see in your browser &amp;hellip; a blank page! Don&amp;rsquo;t worry, this is what is &lt;em&gt;supposed&lt;/em&gt; to happen. The &lt;code&gt;backatcha.cgi&lt;/code&gt; script throws back what you throw at it, and we haven&amp;rsquo;t thrown anything at it yet. We&amp;rsquo;ll give it something to show us in a moment.&lt;/p&gt;

&lt;p&gt;If it &lt;em&gt;didn&amp;rsquo;t&lt;/em&gt; work, you probably saw either an error message or the source code of the script. We&amp;rsquo;ll try to diagnose these problems in the next section.&lt;/p&gt;

&lt;h3 id=&#34;span-id-uhoh-uh-oh-span&#34;&gt;&lt;span id=&#34;uhoh&#34;&gt;Uh-Oh!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If you saw an error message, your Web server had a problem running the CGI program. This may be a problem with the program or the file permissions.&lt;/p&gt;

&lt;p&gt;First, are you &lt;em&gt;sure&lt;/em&gt; the program has the correct file permissions? Did you set the file permissions on your program to 755? If not, do it now. (Windows Web servers will have a different way of doing this.) Try it again; if you see a blank page now, you&amp;rsquo;re good.&lt;/p&gt;

&lt;p&gt;Second, are you &lt;em&gt;sure&lt;/em&gt; the program actually works? (Don&amp;rsquo;t worry, it happens to the best of us.) Change the &lt;code&gt;use CGI&lt;/code&gt; line in the program to read:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use CGI &#39;:standard&#39;, &#39;-debug&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now run the program from the command line. You should see the following:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;(offline mode: enter name=value pairs on standard input)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This message indicates that you&amp;rsquo;re &lt;em&gt;testing&lt;/em&gt; the script. You can now press Ctrl-D to tell the script to continue running without telling it any form items.&lt;/p&gt;

&lt;p&gt;If Perl reports any errors in the script, you can fix them now.&lt;/p&gt;

&lt;p&gt;(The &lt;code&gt;-debug&lt;/code&gt; option is incredibly useful. Use it whenever you have problems with a CGI program, and ignore it at your peril.)&lt;/p&gt;

&lt;p&gt;The other common problem is that you&amp;rsquo;re seeing the source code of your program, not the result of running your program. There are two simple problems that can cause this.&lt;/p&gt;

&lt;p&gt;First, are you &lt;em&gt;sure&lt;/em&gt; you&amp;rsquo;re going through your Web server? If you use your browser&amp;rsquo;s &amp;ldquo;load local file&amp;rdquo; option (to look at something like &lt;code&gt;/etc/httpd/cgi-bin/backatcha.cgi&lt;/code&gt; instead of something like &lt;code&gt;http://localhost/cgi-bin/backatcha.cgi&lt;/code&gt;), you aren&amp;rsquo;t even touching the Web server! Your browser is doing what you &amp;ldquo;wanted&amp;rdquo; to do: loading the contents of a local file and displaying them.&lt;/p&gt;

&lt;p&gt;Second, are you &lt;em&gt;sure&lt;/em&gt; the Web server knows it&amp;rsquo;s a CGI program? Most Web server software will have a special way of designating a file as a CGI program, whether it&amp;rsquo;s a special &lt;code&gt;cgi-bin&lt;/code&gt; directory, the &lt;code&gt;.cgi&lt;/code&gt; or &lt;code&gt;.pl&lt;/code&gt; extension on a file, or something else. Unless you live up to these expectations, the Web server will think the program is a text file, and serve up your program&amp;rsquo;s source code in plain-text form. Ask your ISP for help.&lt;/p&gt;

&lt;p&gt;CGI programs are unruly beasts at the best of times; don&amp;rsquo;t worry if it takes a bit of work to make them run properly.&lt;/p&gt;

&lt;h3 id=&#34;making-the-form-talk-back&#34;&gt;Making the Form Talk Back&lt;/h3&gt;

&lt;p&gt;At this point, you should have a working copy of &lt;code&gt;backatcha.cgi&lt;/code&gt; spitting out blank pages from a Web server. Let&amp;rsquo;s make it actually tell us something. Take the following HTML code and put it in a file:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;FORM ACTION=&amp;quot;putyourURLhere&amp;quot; METHOD=GET&amp;gt;
    &amp;lt;P&amp;gt;What is your favorite color? &amp;lt;INPUT NAME=&amp;quot;favcolor&amp;quot;&amp;gt;&amp;lt;/P&amp;gt;
&amp;lt;INPUT TYPE=submit VALUE=&amp;quot;Send form&amp;quot;&amp;gt;
lt;/FORM&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Be sure to replace &lt;code&gt;putyourURLhere&lt;/code&gt; with the actual URL of your copy of &lt;code&gt;backatcha.cgi&lt;/code&gt;! If you want, you can use the &lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl4/backatcha.pl&#34;&gt;copy installed here&lt;/a&gt; at Perl.com.&lt;/p&gt;

&lt;p&gt;This is a simple form. It will show a text box where you can enter your favorite color and a &amp;ldquo;submit&amp;rdquo; button that sends your information to the server. Load this form in your browser and submit a favorite color. You should see this returned from the server:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;favcolor: green
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;cgi-functions&#34;&gt;CGI functions&lt;/h3&gt;

&lt;p&gt;The CGI.pm module loads several special CGI functions for you. What are these functions?&lt;/p&gt;

&lt;p&gt;The first one, &lt;code&gt;header()&lt;/code&gt;, is used to output any necessary HTTP headers before the script can display HTML output. Try taking this line out; you&amp;rsquo;ll get an error from the Web server when you try to run it. This is &lt;em&gt;another&lt;/em&gt; common source of bugs!&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;start_html()&lt;/code&gt; function is there for convenience. It returns a simple HTML header for you. You can pass parameters to it by using a hash, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;print $cgi-&amp;gt;start_html( -title =&amp;gt; &amp;quot;My document&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(The &lt;code&gt;end_html()&lt;/code&gt; method is similar, but outputs the footers for your page.)&lt;/p&gt;

&lt;p&gt;Finally, the most important CGI function is &lt;code&gt;param()&lt;/code&gt;. Call it with the name of a form item, and a list of all the values of that form item will be returned. (If you ask for a scalar, you&amp;rsquo;ll only get the first value, no matter how many there are in the list.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$yourname = param(&amp;quot;firstname&amp;quot;);
print &amp;quot;&amp;lt;P&amp;gt;Hi, $yourname!&amp;lt;/P&amp;gt;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you call &lt;code&gt;param()&lt;/code&gt; without giving it the name of a form item, it will return a list of &lt;em&gt;all&lt;/em&gt; the form items that are available. This form of &lt;code&gt;param()&lt;/code&gt; is the core of our backatcha script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for $i (param()) {
    print &amp;quot;&amp;lt;b&amp;gt;$i&amp;lt;/b&amp;gt;: &amp;quot;, param($i), &amp;quot;&amp;lt;br&amp;gt;\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember, a single form item can have more than one value. You might encounter code like this on the Web site of a pizza place that takes orders over the Web:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;P&amp;gt;Pick your toppings!&amp;lt;BR&amp;gt;
       &amp;lt;INPUT TYPE=checkbox NAME=top VALUE=pepperoni&amp;gt; Pepperoni &amp;lt;BR&amp;gt;
       &amp;lt;INPUT TYPE=checkbox NAME=top VALUE=mushrooms&amp;gt; Mushrooms &amp;lt;BR&amp;gt;
       &amp;lt;INPUT TYPE=checkbox NAME=top VALUE=ham&amp;gt; Ham &amp;lt;BR&amp;gt;
    &amp;lt;/P&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Someone who wants all three toppings would submit a form where the form item &lt;code&gt;top&lt;/code&gt; has three values: &amp;ldquo;pepperoni,&amp;rdquo; &amp;ldquo;mushrooms&amp;rdquo; and &amp;ldquo;ham.&amp;rdquo; The server-side code might include this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;&amp;lt;P&amp;gt;You asked for the following pizza toppings: &amp;quot;;
    @top = param(&amp;quot;top&amp;quot;);
    for $i (@top) {
        print $i, &amp;quot;. &amp;quot;;
    }
    print &amp;quot;&amp;lt;/P&amp;gt;&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, here&amp;rsquo;s something to watch out for. Take another look at the pizza-topping HTML code. Try pasting that little fragment into the backatcha form, just above the &lt;code&gt;&amp;lt;INPUT TYPE=submit...&amp;gt;&lt;/code&gt; tag. Enter a favorite color, and check all three toppings. You&amp;rsquo;ll see this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    favcolor: burnt sienna
    top: pepperonimushroomsham
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why did this happens? When you call &lt;code&gt;param(&#39;name&#39;)&lt;/code&gt;, you get back a &lt;em&gt;list&lt;/em&gt; of all of the values for that form item. This could be considered a bug in the &lt;code&gt;backatcha.cgi&lt;/code&gt; script, but it&amp;rsquo;s easily fixed - use &lt;code&gt;join()&lt;/code&gt; to separate the item values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;&amp;lt;b&amp;gt;$i&amp;lt;/b&amp;gt;: &amp;quot;, join(&#39;, &#39;, param($i)), &amp;quot;&amp;lt;br&amp;gt;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or call C&amp;lt;param()&amp;gt; in a scalar context first to get only the first value:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $j = param($i);
    print &amp;quot;&amp;lt;b&amp;gt;$i&amp;lt;/b&amp;gt;: $j
\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Always keep in mind that form items can have more than one value!&lt;/p&gt;

&lt;h3 id=&#34;span-id-second-script-our-second-script-span&#34;&gt;&lt;span id=&#34;second_script&#34;&gt;Our Second Script&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So now we know how to build a CGI program, and we&amp;rsquo;ve seen a simple example. Let&amp;rsquo;s write something useful. In the last article, we wrote a pretty good HTTP log analyzer. Why not Web-enable it? This will allow you to look at your usage figures from anywhere you can get to a browser.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl4/httpreport.pl&#34;&gt;Download the source code for the HTTP log analyzer&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s decide what we want to do with our analyzer. Instead of showing all of the reports we generate at once, we&amp;rsquo;ll show only those the user selects. Second, we&amp;rsquo;ll let the user choose whether each report shows the entire list of items, or the top 10, 20 or 50 sorted by access count.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll use a form such as this for our user interface:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;FORM ACTION=&amp;quot;/cgi-bin/http-report.pl&amp;quot; METHOD=POST&amp;gt;
        &amp;lt;P&amp;gt;Select the reports you want to see:&amp;lt;/P&amp;gt;

 &amp;lt;P&amp;gt;&amp;lt;INPUT TYPE=checkbox NAME=report VALUE=url&amp;gt;URLs requested&amp;lt;BR&amp;gt;
    &amp;lt;INPUT TYPE=checkbox NAME=report VALUE=status&amp;gt;Status codes&amp;lt;BR&amp;gt;
    &amp;lt;INPUT TYPE=checkbox NAME=report VALUE=hour&amp;gt;Requests by hour&amp;lt;BR&amp;gt;
    &amp;lt;INPUT TYPE=checkbox NAME=report VALUE=type&amp;gt;File types
 &amp;lt;/P&amp;gt;

 &amp;lt;P&amp;gt;&amp;lt;SELECT NAME=&amp;quot;number&amp;quot;&amp;gt;
     &amp;lt;OPTION VALUE=&amp;quot;ALL&amp;quot;&amp;gt;Show all
     &amp;lt;OPTION VALUE=&amp;quot;10&amp;quot;&amp;gt;Show top 10
     &amp;lt;OPTION VALUE=&amp;quot;20&amp;quot;&amp;gt;Show top 20
     &amp;lt;OPTION VALUE=&amp;quot;50&amp;quot;&amp;gt;Show top 50
 &amp;lt;/SELECT&amp;gt;&amp;lt;/P&amp;gt;

 &amp;lt;INPUT TYPE=submit VALUE=&amp;quot;Show report&amp;quot;&amp;gt;
    &amp;lt;/FORM&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Remember that you may need to change the URL!)&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re sending two different types of form item in this HTML page. One is a series of checkbox widgets, which set values for the form item &lt;code&gt;report&lt;/code&gt;. The other is a single drop-down list which will assign a single value to &lt;code&gt;number&lt;/code&gt;: either ALL, 10, 20 or 50.&lt;/p&gt;

&lt;p&gt;Take a look at the original HTTP log analyzer. We&amp;rsquo;ll start with two simple changes. First, the original program gets the filename of the usage log from a command-line argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      # We will use a command line argument to determine the log filename.
      $logfile = $ARGV[0];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We obviously can&amp;rsquo;t do that now, since the Web server won&amp;rsquo;t allow us to enter a command line for our CGI program! Instead, we&amp;rsquo;ll hard-code the value of &lt;code&gt;$logfile&lt;/code&gt;. I&amp;rsquo;ll use &amp;ldquo;/var/log/httpd/access_log&amp;rdquo; as a sample value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      $logfile = &amp;quot;/var/log/httpd/access_log&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Second, we must make sure that we output all the necessary headers to our Web server before we print anything else:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;      print header();
      print start_html( -title =&amp;gt; &amp;quot;HTTP Log report&amp;quot; );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now look at the &lt;code&gt;report()&lt;/code&gt; sub from our original program. It has one problem, relative to our new goals: It outputs all the reports instead of only the ones we&amp;rsquo;ve selected. We&amp;rsquo;ll rewrite &lt;code&gt;report()&lt;/code&gt; so that it will cycle through all the values of the &lt;code&gt;report&lt;/code&gt; form item and show the appropriate report for each.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sub report {
    for $i (param(&#39;report&#39;)) {
 if ($i eq &#39;url&#39;) {
     report_section(&amp;quot;URL requests&amp;quot;, %url_requests);
 } elsif ($i eq &#39;status&#39;) {
     report_section(&amp;quot;Status code requests&amp;quot;, %status_requests);
 } elsif ($i eq &#39;hour&#39;) {
     report_section(&amp;quot;Requests by hour&amp;quot;, %hour_requests);
 } elsif ($i eq &#39;type&#39;) {
     report_section(&amp;quot;Requests by file type&amp;quot;, %type_requests);
 }
    }
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we rewrite the &lt;code&gt;report_section()&lt;/code&gt; sub to output HTML instead of plain text. (We&amp;rsquo;ll discuss the new way we&amp;rsquo;re using &lt;code&gt;sort&lt;/code&gt; in a moment.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub report_section {
 my ($header, %type) = @_;
 my (@type_keys);

 # Are we sorting by the KEY, or by the NUMBER of accesses?
 if (param(&#39;number&#39;) ne &#39;ALL&#39;) {
     @type_keys = sort { $type{$b} &amp;lt;=&amp;gt; $type{$a}; } keys %type;

     # Chop the list if we have too many results
     if ($#type_keys &amp;gt; param(&#39;number&#39;) - 1) {
         $#type_keys = param(&#39;number&#39;) - 1;
     }
 } else {
     @type_keys = sort keys %type;
 }

 # Begin a HTML table
 print &amp;quot;&amp;lt;TABLE&amp;gt;\n&amp;quot;;

 # Print a table row containing a header for the table
 print &amp;quot;&amp;lt;TR&amp;gt;&amp;lt;TH COLSPAN=2&amp;gt;&amp;quot;, $header, &amp;quot;&amp;lt;/TH&amp;gt;&amp;lt;/TR&amp;gt;\n&amp;quot;;

 # Print a table row containing each item and its value
 for $i (@type_keys) {
     print &amp;quot;&amp;lt;TR&amp;gt;&amp;lt;TD&amp;gt;&amp;quot;, $i, &amp;quot;&amp;lt;/TD&amp;gt;&amp;lt;TD&amp;gt;&amp;quot;, $type{$i}, &amp;quot;&amp;lt;/TD&amp;gt;&amp;lt;/TR&amp;gt;\n&amp;quot;;
 }

 # Finish the table
 print &amp;quot;&amp;lt;/TABLE&amp;gt;\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-sorting-sorting-span&#34;&gt;&lt;span id=&#34;sorting&#34;&gt;Sorting&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl allows you to sort lists with the &lt;code&gt;sort&lt;/code&gt; keyword. By default, the sort will happen alphanumerically: numbers before letters, uppercase before lowercase. This is sufficient 99 percent of the time. The other 1 percent of the time, you can write a custom sorting routine for Perl to use.&lt;/p&gt;

&lt;p&gt;This sorting routine is just like a small sub. In it, you compare two special variables, &lt;code&gt;$a&lt;/code&gt; and &lt;code&gt;$b&lt;/code&gt;, and return one of three values depending on how you want them to show up in the list. Returning -1 means &amp;ldquo;&lt;code&gt;$a&lt;/code&gt; should come before &lt;code&gt;$b&lt;/code&gt; in the sorted list,&amp;rdquo; 1 means &amp;ldquo;&lt;code&gt;$b&lt;/code&gt; should come before &lt;code&gt;$a&lt;/code&gt; in the sorted list&amp;rdquo; and 0 means &amp;ldquo;they&amp;rsquo;re equal, so I don&amp;rsquo;t care which comes first.&amp;rdquo; Perl will run this routine to compare each pair of items in your list and produce the sorted result.&lt;/p&gt;

&lt;p&gt;For example, if you have a hash called &lt;code&gt;%type&lt;/code&gt;, here&amp;rsquo;s how you might sort its keys in descending order of their &lt;em&gt;values&lt;/em&gt; in the hash.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sort {
        if ($type{$b} &amp;gt; $type{$a}) { return 1; }
 if ($type{$b} &amp;lt; $type{$a}) { return -1; }
 return 0;
    } keys %type;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, numeric sorting happens so often, Perl gives you a convenient shorthand for it: the &amp;lt;=&amp;gt; operator. This operator will perform the above comparison between two values for you and return the appropriate value. That means we can rewrite that test as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sort { $type{$b} &amp;lt;=&amp;gt; $type{$a}; } keys %type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(And this, in fact, is what we use in our log analyzer.)&lt;/p&gt;

&lt;p&gt;You can also compare strings with &lt;code&gt;sort&lt;/code&gt;. The &lt;code&gt;lt&lt;/code&gt; and &lt;code&gt;gt&lt;/code&gt; operators are the string equivalents of &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt;, and &lt;code&gt;cmp&lt;/code&gt; will perform the same test as &lt;code&gt;&amp;lt;=&amp;gt;&lt;/code&gt;. (Remember, string comparisons will sort numbers before letters and uppercase before lowercase.)&lt;/p&gt;

&lt;p&gt;For example, you have a list of names and phone numbers in the format &amp;ldquo;John Doe 555-1212.&amp;rdquo; You want to sort this list by the person&amp;rsquo;s last name, and sort by first name when the last names are the same. This is a job made for &lt;code&gt;cmp&lt;/code&gt;!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     @sorted = sort {
         ($c) = ($a =~ / (\w+)/);
  ($d) = ($b =~ / (\w+)/);
  if ($c eq $d) {   # Last names are the same, sort on first name
      ($c) = ($a =~ /^(\w+)/);
      ($d) = ($b =~ /^(\w+)/);
      return $c cmp $d;
  } else {
      return $c cmp $d;
  }
     } @phone_numbers;
     for $i (@sorted) { print $i, &amp;quot;\n&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-trust-trust-no-one-span&#34;&gt;&lt;span id=&#34;trust&#34;&gt;Trust No One&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now that we know how CGI programs can do what you want, let&amp;rsquo;s make sure they won&amp;rsquo;t do what you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; want. This is harder than it looks, because you can&amp;rsquo;t trust anyone to do what you expect.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a simple example: You want to make sure the HTTP log analyzer will never show more than 50 items per report, because it takes too long to send larger reports to the user. The easy thing to do would be to eliminate the &amp;ldquo;ALL&amp;rdquo; line from our HTML form, so that the only remaining options are 10, 20 and 50. It would be very easy - and wrong.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_12_begperl4/httpsecured.pl&#34;&gt;Download the source code for the HTTP analyzer with security enhancements&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;We saw that you can modify HTML forms when we pasted the pizza-topping sample code into our backatcha page. You can also use the URL to pass form items to a script - try going to &lt;code&gt;http://www.perl.com/2000/12/backatcha.cgi?itemsource=URL&amp;amp;typedby=you&lt;/code&gt; in your browser. Obviously, if someone can do this with the backatcha script, they can also do it with your log analyzer and stick any value for &lt;code&gt;number&lt;/code&gt; in that they want: &amp;ldquo;ALL&amp;rdquo; or &amp;ldquo;25000&amp;rdquo;, or &amp;ldquo;four score and seven years ago.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Your form doesn&amp;rsquo;t allow this, you say. Who cares? People will write custom HTML forms to exploit weaknesses in your programs, or will just pass bad form items to your script directly. You cannot trust anything users or their browsers tell you.&lt;/p&gt;

&lt;p&gt;You eliminate these problems by knowing what you expect from the user, and &lt;em&gt;disallowing&lt;/em&gt; everything else. Whatever you do not expressly permit is totally forbidden. Secure CGI programs consider everything guilty until it is &lt;em&gt;made&lt;/em&gt; innocent.&lt;/p&gt;

&lt;p&gt;For example, we want to limit the size of reports from our HTTP log analyzer. We decide that means the &lt;code&gt;number&lt;/code&gt; form item must have a value that is between 10 and 50. We&amp;rsquo;ll verify it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # Make sure that the &amp;quot;number&amp;quot; form item has a reasonable value
    ($number) = (param(&#39;number&#39;) =~ /(\d+)/);
    if ($number &amp;lt; 10) {
        $number = 10;
    } elsif ($number &amp;gt; 50) {
        $number = 50;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, we also have to change the &lt;code&gt;report_section()&lt;/code&gt; sub so it uses the &lt;code&gt;$number&lt;/code&gt; variable. Now, whether your user tries to tell your log analyzer that the value of &lt;code&gt;number&lt;/code&gt; is &amp;ldquo;10,&amp;rdquo; &amp;ldquo;200,&amp;rdquo; &amp;ldquo;432023,&amp;rdquo; &amp;ldquo;ALL&amp;rdquo; or &amp;ldquo;redrum,&amp;rdquo; your program will restrict it to a reasonable value.&lt;/p&gt;

&lt;p&gt;We don&amp;rsquo;t need to do anything with &lt;code&gt;report&lt;/code&gt;, because we only act when one of its values is something we expected. If the user tries to enter something other than our expressly permitted values (&amp;ldquo;url,&amp;rdquo; &amp;ldquo;status,&amp;rdquo; &amp;ldquo;hour&amp;rdquo; or &amp;ldquo;type&amp;rdquo;), we just ignore it.&lt;/p&gt;

&lt;p&gt;Use this sort of logic everywhere you know what the user &lt;em&gt;should&lt;/em&gt; enter. You might use &lt;code&gt;s/\D//g&lt;/code&gt; to remove non-numeric characters from items that should be numbers (and then test to make sure what&amp;rsquo;s left is within your range of allowable numbers!), or &lt;code&gt;/^\w+$/&lt;/code&gt; to make sure that the user entered a single word.&lt;/p&gt;

&lt;p&gt;All of this has two significant benefits. First, you simplify your error-handling code, because you make sure as early in your program as possible that you&amp;rsquo;re working with valid data. Second, you increase security by reducing the number of &amp;ldquo;impossible&amp;rdquo; values that might help an attacker compromise your system or mess with other users of your Web server.&lt;/p&gt;

&lt;p&gt;Don&amp;rsquo;t just take my word for it, though. The &lt;a href=&#34;http://www.w3.org/Security/Faq/&#34;&gt;CGI Security FAQ&lt;/a&gt; has more information about safe CGI programming in Perl than you ever thought could possibly exist, including a section listing some &lt;a href=&#34;http://www.w3.org/Security/Faq/wwwsf4.html#Q35&#34;&gt;security holes&lt;/a&gt; in real CGI programs.&lt;/p&gt;

&lt;h3 id=&#34;span-id-play-around-play-around-span&#34;&gt;&lt;span id=&#34;play_around&#34;&gt;Play Around!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You should now know enough about CGI programming to write a useful Web application. (Oh, and you learned a little bit more about sorting and comparison.)&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Write the quintessential CGI program: a guestbook. Users enter their name, e-mail address and a short message, which is appended to an HTML file for all to see.&lt;/p&gt;

&lt;p&gt;Be careful! Never trust the user! A good beginning precaution is to &lt;em&gt;disallow all HTML&lt;/em&gt; by either removing &amp;lt; and &amp;gt; characters from all of the user&amp;rsquo;s information or replacing them with the &lt;code&gt;&amp;lt;&lt;/code&gt; and &lt;code&gt;&amp;gt;&lt;/code&gt; character entities.&lt;/p&gt;

&lt;p&gt;Use &lt;code&gt;substr()&lt;/code&gt;, too, to cut anything the user enters down to a reasonable size. Asking for a &amp;ldquo;short&amp;rdquo; message will do nothing to prevent the user dumping a 500k file into the message field!&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Write a program that plays tic-tac-toe against the user. Be sure that the computer AI is in a sub so it can be easily upgraded. (You&amp;rsquo;ll probably need to study HTML a bit to see how to output the tic-tac-toe board.)&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;
</description>
    </item>
    
    <item>
      <title>Beginner&#39;s Introduction to Perl - Part 3</title>
      <link>http://localhost:1313/pub/2000/11/begperl3.html/</link>
      <pubDate>Mon, 20 Nov 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/11/begperl3.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this venerable series is undergoing updates. You might be interested in the newer versions, available at:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Files and Strings with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/10/begperl1.html&#34;&gt;Part 1 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl2.html&#34;&gt;Part 2 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl4.html&#34;&gt;Part 4 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl5.html&#34;&gt;Part 5 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2001/01/begperl6.html&#34;&gt;Part 6 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;#simple%20matching&#34;&gt;Simple matching&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#metacharacters&#34;&gt;Metacharacters&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#character%20classes&#34;&gt;Character classes&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#flags&#34;&gt;Flags&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#subexpressions&#34;&gt;Subexpressions&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#watch%0Aout!&#34;&gt;Watch out!&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#search%20and%20replace&#34;&gt;Search and replace&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#play%20around!&#34;&gt;Play around!&lt;/a&gt;&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;We&amp;rsquo;ve covered flow control, math and string operations, and files in the first two articles in this series. Now we&amp;rsquo;ll look at Perl&amp;rsquo;s most powerful and interesting way of playing with strings, &lt;em&gt;regular expressions&lt;/em&gt;, or &lt;em&gt;regexes&lt;/em&gt; for short. (The rule is this: after the 50th time you type ``regular expression,&amp;rdquo; you find you type ``regexp&amp;rdquo; the next 50 times.)&lt;/p&gt;

&lt;p&gt;Regular expressions are complex enough that you could write a whole book on them (and, in fact, someone did - &lt;em&gt;Mastering Regular Expressions&lt;/em&gt; by Jeffrey Friedl).&lt;/p&gt;

&lt;h3 id=&#34;span-id-simple-matching-simple-matching-span&#34;&gt;&lt;span id=&#34;simple matching&#34;&gt;Simple matching&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The simplest regular expressions are &lt;em&gt;matching&lt;/em&gt; expressions. They perform tests using keywords like &lt;code&gt;if&lt;/code&gt;, &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;. Or, if you want to be really clever, tests that you can use with &lt;code&gt;and&lt;/code&gt; and &lt;code&gt;or&lt;/code&gt;. A matching regexp will return a true value if whatever you try to match occurs inside a string. When you want to use a regular expression to match against a string, you use the special &lt;code&gt;=~&lt;/code&gt; operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $user_location = &amp;quot;I see thirteen black cats under a ladder.&amp;quot;;
    if ($user_location =~ /thirteen/) {
        print &amp;quot;Eek, bad luck!\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice the syntax of a regular expression: a string within a pair of slashes. The code &lt;code&gt;$user_location =~ /thirteen/&lt;/code&gt; asks whether the literal string &lt;code&gt;thirteen&lt;/code&gt; occurs anywhere inside &lt;code&gt;$user_location&lt;/code&gt;. If it does, then the test evaluates true; otherwise, it evaluates false.&lt;/p&gt;

&lt;h3 id=&#34;span-id-metacharacters-metacharacters-span&#34;&gt;&lt;span id=&#34;metacharacters&#34;&gt;Metacharacters&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A &lt;em&gt;metacharacter&lt;/em&gt; is a character or sequence of characters that has special meaning. We&amp;rsquo;ve discussed metacharacters in the context of double-quoted strings, where the sequence &lt;code&gt;\n&lt;/code&gt; mean the newline character, not a backslash, and the character &lt;code&gt;n&lt;/code&gt; and &lt;code&gt;\t&lt;/code&gt; means the tab character.&lt;/p&gt;

&lt;p&gt;Regular expressions have a rich vocabulary of metacharacters that let you ask interesting questions such as, ``Does this expression occur at the end of a string?&amp;rdquo; or ``Does this string contain a series of numbers?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;The two simplest metacharacters are &lt;code&gt;^&lt;/code&gt; and &lt;code&gt;$&lt;/code&gt;. These indicate ``beginning of string&amp;rdquo; and ``end of string,&amp;rdquo; respectively. For example, the regexp &lt;code&gt;/^Bob/&lt;/code&gt; will match ``Bob was here,&amp;rdquo; ``Bob&amp;rdquo; and ``Bobby.&amp;rdquo; It won&amp;rsquo;t match ``It&amp;rsquo;s Bob and David,&amp;rdquo; because Bob doesn&amp;rsquo;t show up at the beginning of the string. The &lt;code&gt;$&lt;/code&gt; character, on the other hand, means that you are matching the end of a string. The regexp &lt;code&gt;/David$/&lt;/code&gt; will match ``Bob and David,&amp;rdquo; but not ``David and Bob.&amp;rdquo; Here&amp;rsquo;s a simple routine that will take lines from a file and only print URLs that seem to indicate HTML files:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;for $line (&amp;lt;URLLIST&amp;gt;) {
        # &amp;quot;If the line starts with http: and ends with html....&amp;quot;
        if (($line =~ /^http:/) and
            ($line =~ /html$/)) {
            print $line;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another useful set of metacharacters is called &lt;em&gt;wildcards&lt;/em&gt;. If you&amp;rsquo;ve ever used a Unix shell or the Windows DOS prompt, you&amp;rsquo;re familiar with wildcards characters like &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;?&lt;/code&gt;. For example when you type &lt;code&gt;ls a*.txt&lt;/code&gt;, you see all filenames that begin with the letter &lt;code&gt;a&lt;/code&gt; and end with &lt;code&gt;.txt&lt;/code&gt;. Perl is a bit more complex, but works on the same general principle.&lt;/p&gt;

&lt;p&gt;In Perl, the generic wildcard character is &lt;code&gt;.&lt;/code&gt;. A period inside a regular expression will match &lt;em&gt;any&lt;/em&gt; character, except a newline. For example, the regexp &lt;code&gt;/a.b/&lt;/code&gt; will match anything that contains &lt;code&gt;a&lt;/code&gt;, another character that&amp;rsquo;s not a newline, followed by &lt;code&gt;b&lt;/code&gt; - ``aab,&amp;rdquo; ``a3b,&amp;rdquo; ``a b,&amp;rdquo; and so forth.&lt;/p&gt;

&lt;p&gt;If you want to &lt;em&gt;literally&lt;/em&gt; match a metacharacter, you must escape it with a backslash. The regex &lt;code&gt;/Mr./&lt;/code&gt; matches anything that contains ``Mr&amp;rdquo; followed by another character. If you only want to match a string that actually contains ``Mr.,&amp;rdquo; you must use &lt;code&gt;/Mr\./&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;On its own, the &lt;code&gt;.&lt;/code&gt; metacharacter isn&amp;rsquo;t very useful, which is why Perl provides three wildcard &lt;em&gt;quantifiers&lt;/em&gt;: &lt;code&gt;+&lt;/code&gt;, &lt;code&gt;?&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;. Each quantifier means something different.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;+&lt;/code&gt; quantifier is the easiest to understand: It means to match the immediately preceding character or metacharacter &lt;em&gt;one or more times&lt;/em&gt;. The regular expression &lt;code&gt;/ab+c/&lt;/code&gt; will match ``abc,&amp;rdquo; ``abbc,&amp;rdquo; ``abbbc&amp;rdquo; and so on.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;*&lt;/code&gt; quantifier matches the immediately preceding character or metacharacter &lt;em&gt;zero or more times&lt;/em&gt;. This is different from the &lt;code&gt;+&lt;/code&gt; quantifier! &lt;code&gt;/ab*c/&lt;/code&gt; will match ``abc,&amp;rdquo; ``abbc,&amp;rdquo; and so on, just like &lt;code&gt;/ab+c/&lt;/code&gt; did, but it&amp;rsquo;ll also match ``ac,&amp;rdquo; because there are zero occurences of &lt;code&gt;b&lt;/code&gt; in that string.&lt;/p&gt;

&lt;p&gt;Finally, the &lt;code&gt;?&lt;/code&gt; quantifier will match the preceding character &lt;em&gt;zero or one times&lt;/em&gt;. The regex &lt;code&gt;/ab?c/&lt;/code&gt; will match ``ac&amp;rdquo; (zero occurences of &lt;code&gt;b&lt;/code&gt;) and ``abc&amp;rdquo; (one occurence of &lt;code&gt;b&lt;/code&gt;). It won&amp;rsquo;t match ``abbc,&amp;rdquo; ``abbbc&amp;rdquo; and so on.&lt;/p&gt;

&lt;p&gt;We can rewrite our URL-matching code to use these metacharacters. This&amp;rsquo;ll make it more concise. Instead of using two separate regular expressions (&lt;code&gt;/^http:/&lt;/code&gt; and &lt;code&gt;/html$/&lt;/code&gt;), we combine them into one regular expression: &lt;code&gt;/^http:.+html$/&lt;/code&gt;. To understand what this does, read from left to right: This regex will match any string that &lt;em&gt;starts with ``http:&amp;rdquo;&lt;/em&gt; followed by &lt;em&gt;one or more occurences of any character&lt;/em&gt;, and &lt;em&gt;ends with ``html&amp;rdquo;&lt;/em&gt;. Now, our routine is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; for $line (&amp;lt;URLLIST&amp;gt;) {
        if ($line =~ /^http:.+html$/) {
           print $line;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember the &lt;code&gt;/^something$/&lt;/code&gt; construction - it&amp;rsquo;s very useful!&lt;/p&gt;

&lt;h3 id=&#34;span-id-character-classes-character-classes-span&#34;&gt;&lt;span id=&#34;character classes&#34;&gt;Character classes&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We&amp;rsquo;ve already discussed one special metacharacter, &lt;code&gt;.&lt;/code&gt;, that matches any character except a newline. But you&amp;rsquo;ll often want to match only specific types of characters. Perl provides several metacharacters for this. &amp;lt;\d&amp;gt; will match a single digit, &lt;code&gt;\w&lt;/code&gt; will match any single ``word&amp;rdquo; character (which, to Perl, means a letter, digit or underscore), and &lt;code&gt;\s&lt;/code&gt; matches a whitespace character (space and tab, as well as the &lt;code&gt;\n&lt;/code&gt; and &lt;code&gt;\r&lt;/code&gt; characters).&lt;/p&gt;

&lt;p&gt;These metacharacters work like any other character: You can match against them, or you can use quantifiers like &lt;code&gt;+&lt;/code&gt; and &lt;code&gt;*&lt;/code&gt;. The regex &lt;code&gt;/^\s+/&lt;/code&gt; will match any string that begins with whitespace, and &lt;code&gt;/\w+/&lt;/code&gt; will match a string that contains at least one word. (But remember that Perl&amp;rsquo;s definition of ``word&amp;rdquo; characters includes digits and the underscore, so whether or not you think &lt;code&gt;_&lt;/code&gt; or &lt;code&gt;25&lt;/code&gt; are words, Perl does!)&lt;/p&gt;

&lt;p&gt;One good use for &lt;code&gt;\d&lt;/code&gt; is testing strings to see whether they contain numbers. For example, you might need to verify that a string contains an American-style phone number, which has the form &lt;code&gt;555-1212&lt;/code&gt;. You could use code like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; unless ($phone =~ /\d\d\d-\d\d\d\d/) {
 print &amp;quot;That&#39;s not a phone number!\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;All those &lt;code&gt;\d&lt;/code&gt; metacharacters make the regex hard to read. Fortunately, Perl allows us to improve on that. You can use numbers inside curly braces to indicate a &lt;em&gt;quantity&lt;/em&gt; you want to match, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; unless ($phone =~ /\d{3}-\d{4}/) {
 print &amp;quot;That&#39;s not a phone number!\n&amp;quot;;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The string &lt;code&gt;\d{3}&lt;/code&gt; means to match exactly three numbers, and &lt;code&gt;\d{4}&lt;/code&gt; matches exactly four digits. If you want to use a range of numbers, you can separate them with a comma; leaving out the second number makes the range open-ended. &lt;code&gt;\d{2,5}&lt;/code&gt; will match two to five digits, and &amp;lt;\w{3,}&amp;gt; will match a word that&amp;rsquo;s at least three characters long.&lt;/p&gt;

&lt;p&gt;You can also &lt;em&gt;invert&lt;/em&gt; the &lt;code&gt;\d&lt;/code&gt;, &lt;code&gt;\s&lt;/code&gt; and &lt;code&gt;\w&lt;/code&gt; metacharacters to refer to anything &lt;em&gt;but&lt;/em&gt; that type of character. &lt;code&gt;\D&lt;/code&gt; matches nondigits; &lt;code&gt;\W&lt;/code&gt; matches any character that &lt;em&gt;isn&amp;rsquo;t&lt;/em&gt; a letter, digit or underscore; and &lt;code&gt;\S&lt;/code&gt; matches anything that isn&amp;rsquo;t whitespace.&lt;/p&gt;

&lt;p&gt;If these metacharacters won&amp;rsquo;t do what you want, you can define your own. You define a character class by enclosing a list of the allowable characters in square brackets. For example, a class containing only the lowercase vowels is &lt;code&gt;[aeiou]&lt;/code&gt;. &lt;code&gt;/b[aeiou]g/&lt;/code&gt; will match any string that contains ``bag,&amp;rdquo; ``beg,&amp;rdquo; ``big,&amp;rdquo; ``bog&amp;rdquo; or ``bug&amp;rdquo;. You use dashes to indicate a range of characters, like &lt;code&gt;[a-f]&lt;/code&gt;. (If Perl didn&amp;rsquo;t give us the &lt;code&gt;\d&lt;/code&gt; metacharacter, we could do the same thing with &lt;code&gt;[0-9]&lt;/code&gt;.) You can combine character classes with quantifiers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; if ($string =~ /[aeiou]{2}/) {
 print &amp;quot;This string contains at least
        two vowels in a row.\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also invert character classes by beginning them with the &lt;code&gt;^&lt;/code&gt; character. An inverted character class will match anything you &lt;em&gt;don&amp;rsquo;t&lt;/em&gt; list. &lt;code&gt;[^aeiou]&lt;/code&gt; matches every character except the lowercase vowels. (Yes, &lt;code&gt;^&lt;/code&gt; can also mean ``beginning of string,&amp;rdquo; so be careful.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-flags-flags-span&#34;&gt;&lt;span id=&#34;flags&#34;&gt;Flags&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;By default, regular expression matches are case-sensitive (that is, &lt;code&gt;/bob/&lt;/code&gt; doesn&amp;rsquo;t match ``Bob&amp;rdquo;). You can place &lt;em&gt;flags&lt;/em&gt; after a regexp to modify their behaviour. The most commonly used flag is &lt;code&gt;i&lt;/code&gt;, which makes a match case-insensitive:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $greet = &amp;quot;Hey everybody, it&#39;s Bob and David!&amp;quot;;
    if ($greet =~ /bob/i) {
        print &amp;quot;Hi, Bob!\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll talk about more flags later.&lt;/p&gt;

&lt;h3 id=&#34;span-id-subexpressions-subexpressions-span&#34;&gt;&lt;span id=&#34;subexpressions&#34;&gt;Subexpressions&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You might want to check for more than one thing at a time. For example, you&amp;rsquo;re writing a ``mood meter&amp;rdquo; that you use to scan outgoing e-mail for potentially damaging phrases. You can use the pipe character &lt;code&gt;|&lt;/code&gt; to separate different things you are looking for:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # In reality, @email_lines would come from your email text, 
   # but here we&#39;ll just provide some convenient filler.
   @email_lines = (&amp;quot;Dear idiot:&amp;quot;,
                   &amp;quot;I hate you, you twit.  You&#39;re a dope.&amp;quot;,
                   &amp;quot;I bet you mistreat your llama.&amp;quot;,
                   &amp;quot;Signed, Doug&amp;quot;);

   for $check_line (@email_lines) {
       if ($check_line =~ /idiot|dope|twit|llama/) {
           print &amp;quot;Be careful!  This line might
              contain something offensive:\n&amp;quot;,
                 $check_line, &amp;quot;\n&amp;quot;;
       }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The matching expression &lt;code&gt;/idiot|dope|twit|llama/&lt;/code&gt; will be true if ``idiot,&amp;rdquo; ``dope,&amp;rdquo; ``twit&amp;rdquo; or ``llama&amp;rdquo; show up anywhere in the string.&lt;/p&gt;

&lt;p&gt;One of the more interesting things you can do with regular expressions is &lt;em&gt;subexpression matching&lt;/em&gt;, or grouping. A subexpression is like another, smaller regex buried inside your larger regexp, and is placed inside parentheses. The string that caused the subexpression to match will be stored in the special variable &lt;code&gt;$1&lt;/code&gt;. We can use this to make our mood meter more explicit about the problems with your e-mail:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; for $check_line (@email_lines) {
       if ($check_line =~ /(idiot|dope|twit|llama)/) {
           print &amp;quot;Be careful!  This line contains the
                  offensive word $1:\n&amp;quot;,
                 $check_line, &amp;quot;\n&amp;quot;;
       }
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, you can put matching expressions in your subexpression. Your mood watch program can be extended to prevent you from sending e-mail that contains more than three exclamation points in a row. We&amp;rsquo;ll use the special &lt;code&gt;{3,}&lt;/code&gt; quantifier to make sure we get &lt;em&gt;all&lt;/em&gt; the exclamation points.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; for $check_line (@email_lines) {
        if ($check_line =~ /(!{3,})/) {
            print &amp;quot;Using punctuation like &#39;$1&#39; 
                   is the sign of a sick mind:\n&amp;quot;,
                  $check_line, &amp;quot;\n&amp;quot;;
        }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If your regex contains more than one subexpression, the results will be stored in variables named &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, &lt;code&gt;$3&lt;/code&gt; and so on. Here&amp;rsquo;s some code that will change names in ``lastname, firstname&amp;rdquo; format back to normal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $name = &amp;quot;Wall, Larry&amp;quot;;
   $name =~ /(\w+), (\w+)/;
   # $1 contains last name, $2 contains first name

   $name = &amp;quot;$2 $1&amp;quot;;
   # $name now contains &amp;quot;Larry Wall&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can even nest subexpressions inside one another - they&amp;rsquo;re ordered as they open, from left to right. Here&amp;rsquo;s an example of how to retrieve the full time, hours, minutes and seconds separately from a string that contains a timestamp in &lt;code&gt;hh:mm:ss&lt;/code&gt; format. (Notice that we&amp;rsquo;re using the &lt;code&gt;{1,2}&lt;/code&gt; quantifier so that a timestamp like ``9:30:50&amp;rdquo; will be matched.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $string = &amp;quot;The time is 12:25:30 and I&#39;m hungry.&amp;quot;;
    $string =~ /((\d{1,2}):(\d{2}):(\d{2}))/;
    @time = ($1, $2, $3, $4);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s a hint that you might find useful: You can assign &lt;em&gt;to&lt;/em&gt; a list of scalar values whenever you&amp;rsquo;re assigning &lt;em&gt;from&lt;/em&gt; a list. If you prefer to have readable variable names instead of an array, try using this line instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ($time, $hours, $minutes, $seconds) = ($1, $2, $3, $4);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Assigning to a list of variables when you&amp;rsquo;re using subexpressions happens often enough that Perl gives you a handy shortcut:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; ($time, $hours, $minutes, $seconds) =
         ($string =~ /((\d{1,2}):(\d{2}):(\d{2}))/);
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-watch-out-watch-out-span&#34;&gt;&lt;span id=&#34;watch out!&#34;&gt;Watch out!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Regular expressions have two traps that generate bugs in your Perl programs: They always start at the beginning of the string, and quantifiers always match as much of the string as possible.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s some simple code for counting all the numbers in a string and showing them to the user. We&amp;rsquo;ll use &lt;code&gt;while&lt;/code&gt; to loop over the string, matching over and over until we&amp;rsquo;ve counted all the numbers.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $number = &amp;quot;Look, 200 5-sided, 4-colored pentagon maps.&amp;quot;;
    while ($number =~ /(\d+)/) {
        print &amp;quot;I found the number $1.\n&amp;quot;;
        $number_count++;
    }
    print &amp;quot;There are $number_count numbers here.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This code is actually so simple it doesn&amp;rsquo;t work! When you run it, Perl will print &lt;code&gt;I found the number 200&lt;/code&gt; over and over again. Perl always begins matching at the beginning of the string, so it will always find the 200, and never get to the following numbers.&lt;/p&gt;

&lt;p&gt;You can avoid this by using the &lt;code&gt;g&lt;/code&gt; flag with your regex. This flag will tell Perl to remember where it was in the string when it returns to it. When you insert the &lt;code&gt;g&lt;/code&gt; flag, our code looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $number = &amp;quot;Look, 200 5-sided, 4-colored pentagon maps.&amp;quot;;
    while ($number =~ /(\d+)/g) {
        print &amp;quot;I found the number $1.\n&amp;quot;;
        $number_count++;
    }
    print &amp;quot;There are $number_count numbers here.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we get the results we expected:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; I found the number 200.
    I found the number 5.
    I found the number 4.
    There are 3 numbers here.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The second trap is that a quantifier will always match as many characters as it can. Look at this example code, but don&amp;rsquo;t run it yet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $book_pref = &amp;quot;The cat in the hat is where it&#39;s at.\n&amp;quot;;
    $book_pref =~ /(cat.*at)/;
    print $1, &amp;quot;\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Take a guess: What&amp;rsquo;s in &lt;code&gt;$1&lt;/code&gt; right now? Now run the code. Does this seem counterintuitive?&lt;/p&gt;

&lt;p&gt;The matching expression &lt;code&gt;(cat.*at)&lt;/code&gt; is greedy. It contains &lt;code&gt;cat in the hat is where it&#39;s at&lt;/code&gt; because that&amp;rsquo;s the largest string that matches. Remember, read left to right: ``cat,&amp;rdquo; followed by any number of characters, followed by ``at.&amp;rdquo; If you want to match the string &lt;code&gt;cat in the hat&lt;/code&gt;, you have to rewrite your regexp so it isn&amp;rsquo;t as greedy. There are two ways to do this:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;p&gt;Make the match more precise (try &lt;code&gt;/(cat.*hat)/&lt;/code&gt; instead). Of course, this still might not work - try using this regexp against &lt;code&gt;The cat in the hat is who I hate&lt;/code&gt;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Use a &lt;code&gt;?&lt;/code&gt; character after a quantifier to specify nongreedy matching. &lt;code&gt;.*?&lt;/code&gt; instead of &lt;code&gt;.*&lt;/code&gt; means that Perl will try to match the &lt;em&gt;smallest&lt;/em&gt; string possible instead of the largest:&lt;/p&gt;

&lt;p&gt;# Now we get &amp;ldquo;cat in the hat&amp;rdquo; in $1.
  $book_pref =~ /(cat.*?at)/;&lt;/p&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;h3 id=&#34;span-id-search-and-replace-search-and-replace-span&#34;&gt;&lt;span id=&#34;search and replace&#34;&gt;Search and replace&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now that we&amp;rsquo;ve talked about &lt;em&gt;matching&lt;/em&gt;, there&amp;rsquo;s one other thing regular expressions can do for you: &lt;em&gt;replacing&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;ve ever used a text editor or word processor, you&amp;rsquo;re familiar with the search-and-replace function. Perl&amp;rsquo;s regexp facilities include something similar, the &lt;code&gt;s///&lt;/code&gt; operator, which has the following syntax: &lt;code&gt;s/regex/replacement string/&lt;/code&gt;. If the string you&amp;rsquo;re testing matches &lt;em&gt;regex&lt;/em&gt;, then whatever matched is replaced with the contents of &lt;em&gt;replacement string&lt;/em&gt;. For instance, this code will change a cat into a dog:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $pet = &amp;quot;I love my cat.\n&amp;quot;;
    $pet =~ s/cat/dog/;
    print $pet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use subexpressions in your matching expression, and use the variables &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt; and so on, that they create. The replacement string will substitute these, or any other variables, as if it were a double-quoted string. Remember our code for changing &lt;code&gt;Wall, Larry&lt;/code&gt; into &lt;code&gt;Larry Wall&lt;/code&gt;? We can rewrite it as a single &lt;code&gt;s///&lt;/code&gt; statement!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $name = &amp;quot;Wall, Larry&amp;quot;;
    $name =~ s/(\w+), (\w+)/$2 $1/;  # &amp;quot;Larry Wall&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;s///&lt;/code&gt; can take flags, just like matching expressions. The two most important flags are &lt;code&gt;g&lt;/code&gt; (global) and &lt;code&gt;i&lt;/code&gt; (case-insensitive). Normally, a substitution will only happen &lt;em&gt;once&lt;/em&gt;, but specifying the &lt;code&gt;g&lt;/code&gt; flag will make it happen as long as the regex matches the string. Try this code, and then remove the &lt;code&gt;g&lt;/code&gt; flag and try it again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $pet = &amp;quot;I love my cat Sylvester, and my other cat Bill.\n&amp;quot;;
   $pet =~ s/cat/dog/g;
   print $pet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that without the &lt;code&gt;g&lt;/code&gt; flag, Bill doesn&amp;rsquo;t turn into a dog.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;i&lt;/code&gt; flag works just as it did when we were only using matching expressions: It forces your matching search to be case-insensitive.&lt;/p&gt;

&lt;h3 id=&#34;span-id-putting-it-all-together-putting-it-all-together-span&#34;&gt;&lt;span id=&#34;putting it all together&#34;&gt;Putting it all together&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Regular expressions have many practical uses. We&amp;rsquo;ll look at a httpd log analyzer for an example. In our last article, one of the play-around items was to write a simple log analyzer. Now, let&amp;rsquo;s make it a bit more interesting: a log analyzer that will break down your log results by file type and give you a list of total requests by hour.&lt;/p&gt;

&lt;p&gt;(&lt;a href=&#34;http://localhost:1313/media/_pub_2000_11_begperl3/a3-httpd.pl&#34;&gt;Complete source code&lt;/a&gt;.)&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s look at a sample line from a httpd log:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 127.12.20.59 - - [01/Nov/2000:00:00:37 -0500] 
    &amp;quot;GET /gfx2/page/home.gif HTTP/1.1&amp;quot; 200 2285
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first thing we want to do is split this into fields. Remember that the &lt;code&gt;split()&lt;/code&gt; function takes a regular expression as its first argument. We&amp;rsquo;ll use &lt;code&gt;/\s/&lt;/code&gt; to split the line at each whitespace character:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; @fields = split(/\s/, $line);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This gives us 10 fields. The ones we&amp;rsquo;re concerned with are the fourth field (time and date of request), the seventh (the URL), and the ninth and 10th (HTTP status code and size in bytes of the server response).&lt;/p&gt;

&lt;p&gt;First, we&amp;rsquo;d like to make sure that we turn any request for a URL that ends in a slash (like &lt;code&gt;/about/&lt;/code&gt;) into a request for the index page from that directory (&lt;code&gt;/about/index.html&lt;/code&gt;). We&amp;rsquo;ll need to escape out the slashes so that Perl doesn&amp;rsquo;t mistake them for terminators in our &lt;code&gt;s///&lt;/code&gt; statement.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $fields[6] =~ s/\/$/\/index.html/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This line is difficult to read, because anytime we come across a literal slash character we need to escape it out. This problem is so common, it has acquired a name: &lt;em&gt;leaning-toothpick syndrome&lt;/em&gt;. Here&amp;rsquo;s a useful trick for avoiding the leaning-toothpick syndrome: You can replace the slashes that mark regular expressions and &lt;code&gt;s///&lt;/code&gt; statements with any other matching pair of characters, like &lt;code&gt;{&lt;/code&gt; and &lt;code&gt;}&lt;/code&gt;. This allows us to write a more legible regex where we don&amp;rsquo;t need to escape out the slashes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $fields[6] =~ s{/$}{/index.html};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(If you want to use this syntax with a matching expression, you&amp;rsquo;ll need to put a &lt;code&gt;m&lt;/code&gt; in front of it. &lt;code&gt;/foo/&lt;/code&gt; would be rewritten as &lt;code&gt;m{foo}&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;Now, we&amp;rsquo;ll assume that any URL request that returns a status code of 200 (request OK) is a request for the file type of the URL&amp;rsquo;s extension (a request for &lt;code&gt;/gfx/page/home.gif&lt;/code&gt; returns a GIF image). Any URL request without an extension returns a plain-text file. Remember that the period is a metacharacter, so we need to escape it out!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; if ($fields[8] eq &#39;200&#39;) {
           if ($fields[6] =~ /\.([a-z]+)$/i) {
               $type_requests{$1}++;
           } else {
               $type_requests{&#39;txt&#39;}++;
           }
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we want to retrieve the &lt;em&gt;hour&lt;/em&gt; each request took place. The hour is the first string in &lt;code&gt;$fields[3]&lt;/code&gt; that will be two digits surrounded by colons, so all we need to do is look for that. Remember that Perl will stop when it finds the first match in a string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; # Log the hour of this request
        $fields[3] =~ /:(\d{2}):/;
        $hour_requests{$1}++;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, let&amp;rsquo;s rewrite our original &lt;code&gt;report()&lt;/code&gt; sub. We&amp;rsquo;re doing the same thing over and over (printing a section header and the contents of that section), so we&amp;rsquo;ll break that out into a new sub. We&amp;rsquo;ll call the new sub &lt;code&gt;report_section()&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sub report {
    print ``Total bytes requested: &#39;&#39;, $bytes, ``\n&#39;&#39;; print &amp;quot;\n&amp;quot;;
    report_section(&amp;quot;URL requests:&amp;quot;, %url_requests);
    report_section(&amp;quot;Status code results:&amp;quot;, %status_requests);
    report_section(&amp;quot;Requests by hour:&amp;quot;, %hour_requests);
    report_section(&amp;quot;Requests by file type:&amp;quot;, %type_requests);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new &lt;code&gt;report_section()&lt;/code&gt; sub is very simple:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sub report_section {
    my ($header, %type) = @_; print $header, &amp;quot;\n&amp;quot;;
    for $i (sort keys %type) {
        print $i, &amp;quot;: &amp;quot;, $type{$i}, &amp;quot;\n&amp;quot;;
    }

    print &amp;quot;\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We use the &lt;code&gt;keys&lt;/code&gt; function to return a list of the keys in the &lt;code&gt;%type&lt;/code&gt; hash, and the &lt;code&gt;sort&lt;/code&gt; function to put it in alphabetic order. We&amp;rsquo;ll play with &lt;code&gt;sort&lt;/code&gt; a bit more in the next article.&lt;/p&gt;

&lt;h3 id=&#34;span-id-play-around-play-around-span&#34;&gt;&lt;span id=&#34;play around!&#34;&gt;Play around!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As usual, here are some sample exercises:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A rule of good writing is ``avoid the passive voice.&amp;rdquo; Instead of &lt;em&gt;The report was read by Carl&lt;/em&gt;, say &lt;em&gt;Carl read the report&lt;/em&gt;. Write a program that reads a file of sentences (one per line), detects and eliminates the passive voice, and prints the result. (Don&amp;rsquo;t worry about irregular verbs or capitalization, though.)&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_11_begperl3/a3-activate.pl&#34;&gt;Sample solution&lt;/a&gt;. &lt;a href=&#34;http://localhost:1313/media/_pub_2000_11_begperl3/a3-sentences.txt&#34;&gt;Sample test sentences&lt;/a&gt;.&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;You have a list of phone numbers. The list is messy, and the only thing you know is that there are either seven or 10 digits in each number (the area code is optional), and if there&amp;rsquo;s an extension, it will show up after an ``x&amp;rdquo; somewhere on the line. ``416 555-1212,&amp;rdquo; ``5551300X40&amp;rdquo; and ``(306) 555.5000 ext 40&amp;rdquo; are all possible. Write a &lt;code&gt;fix_phone()&lt;/code&gt; sub that will turn all of these numbers into the standard format ``(123) 555-1234&amp;rdquo; or ``(123) 555-1234 Ext 100,&amp;rdquo; if there is an extension. Assume that the default area code is ``123.&amp;rdquo;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_11_begperl3/a3-phone.pl&#34;&gt;Sample solution&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Beginner&#39;s Introduction to Perl - Part 2</title>
      <link>http://localhost:1313/pub/2000/11/begperl2.html/</link>
      <pubDate>Tue, 07 Nov 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/11/begperl2.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this venerable series is undergoing updates. You might be interested in the newer versions, available at:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Files and Strings with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/10/begperl1.html&#34;&gt;Part 1 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl3.html&#34;&gt;Part 3 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl4.html&#34;&gt;Part 4 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl5.html&#34;&gt;Part 5 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2001/01/begperl6.html&#34;&gt;Part 6 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;#comparison%20operators&#34;&gt;Comparison operators&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#while%20and%20until&#34;&gt;&lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt;&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#string%20comparisons&#34;&gt;String comparisons&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#more%20fun%20with%20strings&#34;&gt;More fun with strings&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#filehandles&#34;&gt;Filehandles&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#writing%20files&#34;&gt;Writing files&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#live%20free%20or%20die!&#34;&gt;Live free or die!&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#subs&#34;&gt;Subs&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#putting%20it%20all%20together&#34;&gt;Putting it all together&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#play%20around!&#34;&gt;Play around!&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;In our last article, we talked about the core elements of Perl: variables (scalars, arrays, and hashes), math operators and some basic flow control (the &lt;code&gt;for&lt;/code&gt; statement). Now it&amp;rsquo;s time to interact with the world.&lt;/p&gt;

&lt;p&gt;In this installment, we&amp;rsquo;re going to discuss how to slice and dice strings, how to play with files and how to define your own functions. But first, we&amp;rsquo;ll discuss one more core concept of the Perl language: conditions and comparisons.&lt;/p&gt;

&lt;h3 id=&#34;span-id-comparison-operators-comparison-operators-span&#34;&gt;&lt;span id=&#34;comparison operators&#34;&gt;Comparison operators&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s one important element of Perl that we skipped in the last article: &lt;em&gt;comparison operators&lt;/em&gt;. Like all good programming languages, Perl allows you ask questions such as ``Is this number greater than that number?&amp;rdquo; or ``Are these two strings the same?&amp;rdquo; and do different things depending on the answer.&lt;/p&gt;

&lt;p&gt;When you&amp;rsquo;re dealing with numbers, Perl has four important operators: &lt;code&gt;&amp;lt;&lt;/code&gt;, &lt;code&gt;&amp;gt;&lt;/code&gt;, &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;!=&lt;/code&gt;. These are the ``less than,&amp;rdquo; ``greater than,&amp;rdquo; ``equal to&amp;rdquo; and ``not equal to&amp;rdquo; operators. (You can also use &lt;code&gt;&amp;lt;=&lt;/code&gt;, ``less than or equal to,&amp;rdquo; and &lt;code&gt;&amp;gt;=&lt;/code&gt;, ``greater than or equal to.)&lt;/p&gt;

&lt;p&gt;You can use these operators along with one of Perl&amp;rsquo;s &lt;em&gt;conditional&lt;/em&gt; keywords, such as &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;. Both of these keywords take a condition that Perl will test, and a block of code in curly brackets that Perl will run if the test works. These two words work just like their English equivalents - an &lt;code&gt;if&lt;/code&gt; test succeeds if the condition turns out to be true, and an &lt;code&gt;unless&lt;/code&gt; test succeeds if the condition turns out to be false:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ($year_according_to_computer == 1900) {
        print &amp;quot;Y2K has doomed us all!  Everyone to the compound.\n&amp;quot;;
    }

    unless ($bank_account &amp;gt; 0) {
        print &amp;quot;I&#39;m broke!\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Be careful of the difference between &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;! One equals sign means ``assignment&amp;rdquo;, two means ``comparison for equality&amp;rdquo;. This is a common, evil bug:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ($a = 5) {
        print &amp;quot;This works - but doesn&#39;t do what you want!\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of testing whether &lt;code&gt;$a&lt;/code&gt; is equal to five, you&amp;rsquo;ve made &lt;code&gt;$a&lt;/code&gt; equal to five and clobbered its old value. (In a later article, we&amp;rsquo;ll discuss a way to make sure this bug won&amp;rsquo;t occur in running code.)&lt;/p&gt;

&lt;p&gt;Both &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt; can be followed by an &lt;code&gt;else&lt;/code&gt; statement and code block, which executes if your test failed. You can also use &lt;code&gt;elsif&lt;/code&gt; to chain together a bunch of &lt;code&gt;if&lt;/code&gt; statements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ($a == 5) {
        print &amp;quot;It&#39;s five!\n&amp;quot;;
    } elsif ($a == 6) {
        print &amp;quot;It&#39;s six!\n&amp;quot;;
    } else {
        print &amp;quot;It&#39;s something else.\n&amp;quot;;
    }

    unless ($pie eq &#39;apple&#39;) {
        print &amp;quot;Ew, I don&#39;t like $pie flavored pie.\n&amp;quot;;
    } else {
        print &amp;quot;Apple!  My favorite!\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-while-and-until-while-and-until-span&#34;&gt;&lt;span id=&#34;while and until&#34;&gt;&lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Two slightly more complex keywords are &lt;code&gt;while&lt;/code&gt; and &lt;code&gt;until&lt;/code&gt;. They both take a condition and a block of code, just like &lt;code&gt;if&lt;/code&gt; and &lt;code&gt;unless&lt;/code&gt;, but they act like loops similar to &lt;code&gt;for&lt;/code&gt;. Perl tests the condition, runs the block of code and runs it over and over again for as long as the condition is true (for a &lt;code&gt;while&lt;/code&gt; loop) or false (for a &lt;code&gt;until&lt;/code&gt; loop).&lt;/p&gt;

&lt;p&gt;Take a look at the following code and try to guess what it will do before reading further:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   $a = 0;

   while ($a != 3) {
       $a++;
       print &amp;quot;Counting up to $a...\n&amp;quot;;
   }

   until ($a == 0) {
       $a--;
       print &amp;quot;Counting down to $a...\n&amp;quot;;
   }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here&amp;rsquo;s what you see when you run this program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Counting up to 1...
    Counting up to 2...
    Counting up to 3...
    Counting down to 2...
    Counting down to 1...
    Counting down to 0...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-string-comparisons-string-comparisons-span&#34;&gt;&lt;span id=&#34;string comparisons&#34;&gt;String comparisons&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So that&amp;rsquo;s how you compare numbers. Now, what about strings? The most common string comparison operator is &lt;code&gt;eq&lt;/code&gt;, which tests for &lt;em&gt;string equality&lt;/em&gt; - that is, whether two strings have the same value.&lt;/p&gt;

&lt;p&gt;Remember the pain that is caused when you mix up &lt;code&gt;=&lt;/code&gt; and &lt;code&gt;==&lt;/code&gt;? Well, you can also mix up &lt;code&gt;==&lt;/code&gt; and &lt;code&gt;eq&lt;/code&gt;. This is one of the few cases where it &lt;em&gt;does&lt;/em&gt; matter whether Perl is treating a value as a string or a number. Try this code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $yes_no = &amp;quot;no&amp;quot;;
    if ($yes_no == &amp;quot;yes&amp;quot;) {
        print &amp;quot;You said yes!\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why does this code think you said yes? Remember that Perl automatically converts strings to numbers whenever it&amp;rsquo;s necessary; the &lt;code&gt;==&lt;/code&gt; operator implies that you&amp;rsquo;re using numbers, so Perl converts the value of &lt;code&gt;$yes_no&lt;/code&gt; (``no&amp;rdquo;) to the number 0, and ``yes&amp;rdquo; to the number 0 as well. Since this equality test works (0 is equal to 0), the &lt;code&gt;if&lt;/code&gt; block gets run. Change the condition to &lt;code&gt;$yes_no eq &amp;quot;yes&amp;quot;&lt;/code&gt;, and it&amp;rsquo;ll do what it should.&lt;/p&gt;

&lt;p&gt;Things can work the other way, too. The number five is &lt;em&gt;numerically&lt;/em&gt; equal to the string &lt;code&gt;&amp;quot; 5 &amp;quot;&lt;/code&gt;, so comparing them to &lt;code&gt;==&lt;/code&gt; works. But when you compare five and &lt;code&gt;&amp;quot; 5 &amp;quot;&lt;/code&gt; with &lt;code&gt;eq&lt;/code&gt;, Perl will convert the number to the string &lt;code&gt;&amp;quot;5&amp;quot;&lt;/code&gt; first, and then ask whether the two strings have the same value. Since they don&amp;rsquo;t, the &lt;code&gt;eq&lt;/code&gt; comparison fails. This code fragment will print &lt;code&gt;Numeric equality!&lt;/code&gt;, but not &lt;code&gt;String equality!&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a = 5;
    if ($a == &amp;quot; 5 &amp;quot;) { print &amp;quot;Numeric equality!\n&amp;quot;; }
    if ($a eq &amp;quot; 5 &amp;quot;) { print &amp;quot;String equality!\n&amp;quot;; }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-more-fun-with-strings-more-fun-with-strings-span&#34;&gt;&lt;span id=&#34;more fun with strings&#34;&gt;More fun with strings&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ll often want to manipulate strings: Break them into smaller pieces, put them together and change their contents. Perl offers three functions that make string manipulation easy and fun: &lt;code&gt;substr()&lt;/code&gt;, &lt;code&gt;split()&lt;/code&gt; and &lt;code&gt;join()&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;If you want to retrieve part of a string (say, the first four characters or a 10-character chunk from the middle), use the &lt;code&gt;substr()&lt;/code&gt; function. It takes either two or three parameters: the string you want to look at, the character position to start at (the first character is position 0) and the number of characters to retrieve. If you leave out the number of characters, you&amp;rsquo;ll retrieve everything up to the end of the string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a = &amp;quot;Welcome to Perl!\n&amp;quot;;
    print substr($a, 0, 7);     # &amp;quot;Welcome&amp;quot;
    print substr($a, 7);        # &amp;quot; to Perl!\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A neat and often-overlooked thing about &lt;code&gt;substr()&lt;/code&gt; is that you can use a &lt;em&gt;negative&lt;/em&gt; character position. This will retrieve a substring that begins with many characters from the &lt;em&gt;end&lt;/em&gt; of the string.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     $a = &amp;quot;Welcome to Perl!\n&amp;quot;;
     print substr($a, -6, 4);      # &amp;quot;Perl&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Remember that inside double quotes, &lt;code&gt;\n&lt;/code&gt; represents the single new-line character.)&lt;/p&gt;

&lt;p&gt;You can also manipulate the string by using &lt;code&gt;substr()&lt;/code&gt; to assign a new value to part of it. One useful trick is using a length of zero to &lt;em&gt;insert&lt;/em&gt; characters into a string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a = &amp;quot;Welcome to Java!\n&amp;quot;;
    substr($a, 11, 4) = &amp;quot;Perl&amp;quot;;   # $a is now &amp;quot;Welcome to Perl!\n&amp;quot;;
    substr($a, 7, 3) = &amp;quot;&amp;quot;;        #       ... &amp;quot;Welcome Perl!\n&amp;quot;;
    substr($a, 0, 0) = &amp;quot;Hello. &amp;quot;; #       ... &amp;quot;Hello. Welcome Perl!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, let&amp;rsquo;s look at &lt;code&gt;split()&lt;/code&gt;. This function breaks apart a string and returns a list of the pieces. &lt;code&gt;split()&lt;/code&gt; generally takes two parameters: a &lt;em&gt;regular expression&lt;/em&gt; to split the string with and the string you want to split. (We&amp;rsquo;ll discuss regular expressions in more detail in the next article; for the moment, we&amp;rsquo;re only going to use a space. Note the special syntax for a regular expression: &lt;code&gt;/ /&lt;/code&gt;.) The characters you split won&amp;rsquo;t show up in any of the list elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a = &amp;quot;Hello. Welcome Perl!\n&amp;quot;;
    @a = split(/ /, $a);   # Three items: &amp;quot;Hello.&amp;quot;, &amp;quot;Welcome&amp;quot;, &amp;quot;Perl!\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also specify a third parameter: the maximum number of items to put in your list. The splitting will stop as soon as your list contains that many items:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a = &amp;quot;Hello. Welcome Perl!\n&amp;quot;;
    @a = split(/ /, $a, 2);   # Two items: &amp;quot;Hello.&amp;quot;, &amp;quot;Welcome Perl!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, what you can split, you can also &lt;code&gt;join()&lt;/code&gt;. The &lt;code&gt;join()&lt;/code&gt; function takes a list of strings and attaches them together with a specified string between each element, which may be an empty string:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @a = (&amp;quot;Hello.&amp;quot;, &amp;quot;Welcome&amp;quot;, &amp;quot;Perl!\n&amp;quot;);
    $a = join(&#39; &#39;, @a);       # &amp;quot;Hello. Welcome Perl!\n&amp;quot;;
    $b = join(&#39; and &#39;, @a);   # &amp;quot;Hello. and Welcome and Perl!\n&amp;quot;;
    $c = join(&#39;&#39;, @a);        # &amp;quot;Hello.WelcomePerl!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-filehandles-filehandles-span&#34;&gt;&lt;span id=&#34;filehandles&#34;&gt;Filehandles&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Enough about strings. Let&amp;rsquo;s look at files - after all, what good is string manipulation if you can&amp;rsquo;t do it where it counts?&lt;/p&gt;

&lt;p&gt;To read from or write to a file, you have to &lt;em&gt;open&lt;/em&gt; it. When you open a file, Perl asks the operating system if the file can be accessed - does the file exist if you&amp;rsquo;re trying to read it (or can it be created if you&amp;rsquo;re trying to create a new file), and do you have the necessary file permissions to do what you want? If you&amp;rsquo;re allowed to use the file, the operating system will prepare it for you, and Perl will give you a &lt;em&gt;filehandle&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;You ask Perl to create a filehandle for you by using the &lt;code&gt;open()&lt;/code&gt; function, which takes two arguments: the filehandle you want to create and the file you want to work with. First, we&amp;rsquo;ll concentrate on reading files. The following statement opens the file &lt;code&gt;log.txt&lt;/code&gt; using the filehandle &lt;code&gt;LOGFILE&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    open (LOGFILE, &amp;quot;log.txt&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Opening a file involves several behind-the-scenes tasks that Perl and the operating system undertake together, such as checking that the file you want to open actually exists (or creating it if you&amp;rsquo;re trying to create a new file) and making sure you&amp;rsquo;re allowed to manipulate the file (do you have the necessary file permissions, for instance). Perl will do all of this for you, so in general you don&amp;rsquo;t need to worry about it.&lt;/p&gt;

&lt;p&gt;Once you&amp;rsquo;ve opened a file to read, you can retrieve lines from it by using the &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt; construct. Inside the angle brackets, place the name of your filehandle. What is returned by this depends on what you &lt;em&gt;want&lt;/em&gt; to get: in a scalar context (a more technical way of saying ``if you&amp;rsquo;re assigning it to a scalar&amp;rdquo;), you retrieve the next line from the file, but if you&amp;rsquo;re looking for a list, you get a list of all the remaining lines in the file. (One common trick is to use &lt;code&gt;for $lines (&amp;lt;FH&amp;gt;)&lt;/code&gt; to retrieve all the lines from a file - the &lt;code&gt;for&lt;/code&gt; means you&amp;rsquo;re asking a list.)&lt;/p&gt;

&lt;p&gt;You can, of course, &lt;code&gt;close&lt;/code&gt; a filehandle that you&amp;rsquo;ve opened. You don&amp;rsquo;t always have to do this, because Perl is clever enough to close a filehandle when your program ends or when you try to reuse an existing filehandle. It&amp;rsquo;s a good idea, though, to use the &lt;code&gt;close&lt;/code&gt; statement. Not only will it make your code more readable, but your operating system has built-in limits on the number of files that can be open at once, and each open filehandle will take up valuable memory.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a simple program that will display the contents of the file &lt;code&gt;log.txt&lt;/code&gt;, and assumes that the first line of the file is its title:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    open (LOGFILE, &amp;quot;log.txt&amp;quot;) or die &amp;quot;I couldn&#39;t get at log.txt&amp;quot;;
    # We&#39;ll discuss the &amp;quot;or die&amp;quot; in a moment.

    $title = &amp;lt;LOGFILE&amp;gt;;
    print &amp;quot;Report Title: $title&amp;quot;;
    for $line (&amp;lt;LOGFILE&amp;gt;) {
        print $line;
    }
    close LOGFILE;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-writing-files-writing-files-span&#34;&gt;&lt;span id=&#34;writing files&#34;&gt;Writing files&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You also use &lt;code&gt;open()&lt;/code&gt; when you are writing to a file. There are two ways to open a file for writing: &lt;em&gt;overwrite&lt;/em&gt; and &lt;em&gt;append&lt;/em&gt;. When you open a file in overwrite mode, you erase whatever it previously contained. In append mode, you attach your new data to the end of the existing file without erasing anything that was already there.&lt;/p&gt;

&lt;p&gt;To indicate that you want a filehandle for writing, you put a single &lt;code&gt;&amp;gt;&lt;/code&gt; character before the filename you want to use. This opens the file in overwrite mode. To open it in append mode, use two &lt;code&gt;&amp;gt;&lt;/code&gt; characters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     open (OVERWRITE, &amp;quot;&amp;gt;overwrite.txt&amp;quot;) or die &amp;quot;$! error trying to overwrite&amp;quot;;
     # The original contents are gone, wave goodbye.

     open (APPEND, &amp;quot;&amp;gt;&amp;gt;append.txt&amp;quot;) or die &amp;quot;$! error trying to append&amp;quot;;
     # Original contents still there, we&#39;re adding to the end of the file
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Once our filehandle is open, we can use the humble &lt;code&gt;print&lt;/code&gt; statement to write to it. Specify the filehandle you want to write to and a list of values you want to write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print OVERWRITE &amp;quot;This is the new content.\n&amp;quot;;
    print APPEND &amp;quot;We&#39;re adding to the end here.\n&amp;quot;, &amp;quot;And here too.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-live-free-or-die-live-free-or-die-span&#34;&gt;&lt;span id=&#34;live free or die!&#34;&gt;Live free or die!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You noticed that most of our &lt;code&gt;open()&lt;/code&gt; statements are followed by &lt;code&gt;or die &amp;quot;some sort of message&amp;quot;&lt;/code&gt;. This is because we live in an imperfect world, where programs don&amp;rsquo;t always behave exactly the way we want them to. It&amp;rsquo;s always possible for an &lt;code&gt;open()&lt;/code&gt; call to fail; maybe you&amp;rsquo;re trying to write to a file that you&amp;rsquo;re not allowed to write, or you&amp;rsquo;re trying to read from a file that doesn&amp;rsquo;t exist. In Perl, you can guard against these problems by using &lt;code&gt;or&lt;/code&gt; and &lt;code&gt;and&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;A series of statements separated by &lt;code&gt;or&lt;/code&gt; will continue until you hit one that works, or returns a true value. This line of code will either succeed at opening &lt;code&gt;OUTPUT&lt;/code&gt; in overwrite mode, or cause Perl to quit:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    open (OUTPUT, &amp;quot;&amp;gt;$outfile&amp;quot;) or die &amp;quot;Can&#39;t write to $outfile: $!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;die&lt;/code&gt; statement ends your program with an error message. The special variable &lt;code&gt;$!&lt;/code&gt; contains Perl&amp;rsquo;s explanation of the error. In this case, you might see something like this if you&amp;rsquo;re not allowed to write to the file. Note that you get both the actual error message (``Permission denied&amp;rdquo;) and the line where it happened:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Can&#39;t write to a2-die.txt: Permission denied at ./a2-die.pl line 1.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Defensive programming like this is useful for making your programs more error-resistant - you don&amp;rsquo;t want to write to a file that you haven&amp;rsquo;t successfully opened!&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s an example: As part of your job, you write a program that records its results in a file called &lt;code&gt;vitalreport.txt&lt;/code&gt;. You use the following code:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    open VITAL, &amp;quot;&amp;gt;vitalreport.txt&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If this &lt;code&gt;open()&lt;/code&gt; call fails (for instance, &lt;code&gt;vitalreport.txt&lt;/code&gt; is owned by another user who hasn&amp;rsquo;t given you write permission), you&amp;rsquo;ll never know it until someone looks at the file afterward and wonders why the vital report wasn&amp;rsquo;t written. (Just imagine the joy if that ``someone&amp;rdquo; is your boss, the day before your annual performance review.) When you use &lt;code&gt;or die&lt;/code&gt;, you avoid all this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    open VITAL, &amp;quot;&amp;gt;vitalreport.txt&amp;quot; or die &amp;quot;Can&#39;t write vital report: $!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of wondering whether your program wrote your vital report, you&amp;rsquo;ll immediately have an error message that both tells you what went wrong and on what line of your program the error occurred.&lt;/p&gt;

&lt;p&gt;You can use &lt;code&gt;or&lt;/code&gt; for more than just testing file operations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ($pie eq &#39;apple&#39;) or ($pie eq &#39;cherry&#39;) or ($pie eq &#39;blueberry&#39;)
        or print &amp;quot;But I wanted apple, cherry, or blueberry!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this sequence, if you have an appropriate pie, Perl skips the rest of the chain. Once one statement works, the rest are ignored. The &lt;code&gt;and&lt;/code&gt; operator does the opposite: It evaluates your chain of statements, but stops when one of them &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; work.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   open (LOG, &amp;quot;log.file&amp;quot;) and print &amp;quot;Logfile is open!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This statement will only show you the words &lt;em&gt;Logfile is open!&lt;/em&gt; if the &lt;code&gt;open()&lt;/code&gt; succeeds - do you see why?&lt;/p&gt;

&lt;h3 id=&#34;span-id-subs-subs-span&#34;&gt;&lt;span id=&#34;subs&#34;&gt;Subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So far, our Perl programs have been a bunch of statements in series. This is OK if you&amp;rsquo;re writing very small programs, but as your needs grow, you&amp;rsquo;ll find it&amp;rsquo;s limiting. This is why most modern programming languages allow you to define your own functions; in Perl, we call them &lt;em&gt;subs&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;A sub is defined with the &lt;code&gt;sub&lt;/code&gt; keyword, and adds a new function to your program&amp;rsquo;s capabilities. When you want to use this new function, you call it by name. For instance, here&amp;rsquo;s a short definition of a sub called &lt;code&gt;boo&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub boo {
        print &amp;quot;Boo!\n&amp;quot;;
    }

    boo();   # Eek!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Older versions of Perl required that you precede the name of a sub with the &lt;code&gt;&amp;amp;&lt;/code&gt; character when you call it. You no longer have to do this, but if you see code that looks like &lt;code&gt;&amp;amp;boo&lt;/code&gt; in other people&amp;rsquo;s Perl, that&amp;rsquo;s why.)&lt;/p&gt;

&lt;p&gt;Subs are useful because they allow you to break your program into small, reusable chunks. If you need to analyze a string in four different places in your program, it&amp;rsquo;s much easier to write one &lt;code&gt;&amp;amp;analyze_string&lt;/code&gt; sub and call it four times. This way, when you make an improvement to your string-analysis routine, you&amp;rsquo;ll only need to do it in one place, instead of four.&lt;/p&gt;

&lt;p&gt;In the same way that Perl&amp;rsquo;s built-in functions can take parameters and can return values, your subs can, too. Whenever you call a sub, any parameters you pass to it are placed in the special array &lt;code&gt;@_&lt;/code&gt;. You can also return a single value or a list by using the &lt;code&gt;return&lt;/code&gt; keyword.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub multiply {
        my (@ops) = @_;
        return $ops[0] * $ops[1];
    }

    for $i (1 .. 10) {
         print &amp;quot;$i squared is &amp;quot;, multiply($i, $i), &amp;quot;\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Why did we use the &lt;code&gt;my&lt;/code&gt; keyword? That indicates that the variables are private to that sub, so that any existing value for the &lt;code&gt;@ops&lt;/code&gt; array we&amp;rsquo;re using elsewhere in our program won&amp;rsquo;t get overwritten. This means that you&amp;rsquo;ll evade a whole class of hard-to-trace bugs in your programs. You don&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to use &lt;code&gt;my&lt;/code&gt;, but you also don&amp;rsquo;t &lt;em&gt;have&lt;/em&gt; to avoid smashing your thumb when you&amp;rsquo;re hammering nails into a board. They&amp;rsquo;re both just good ideas.&lt;/p&gt;

&lt;p&gt;You can also use &lt;code&gt;my&lt;/code&gt; to set up local variables in a sub without assigning them values right away. This can be useful for loop indexes or temporary variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub annoy {
        my ($i, $j);
        for $i (1 .. 100) {
            $j .= &amp;quot;Is this annoying yet?\n&amp;quot;;
        }
        print $j;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you don&amp;rsquo;t expressly use the &lt;code&gt;return&lt;/code&gt; statement, the sub returns the result of the last statement. This implicit return value can sometimes be useful, but it does reduce your program&amp;rsquo;s readability. Remember that you&amp;rsquo;ll read your code many more times than you write it!&lt;/p&gt;

&lt;h3 id=&#34;span-id-putting-it-all-together-putting-it-all-together-span&#34;&gt;&lt;span id=&#34;putting it all together&#34;&gt;Putting it all together&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;At the end of the first article we had a simple interest calculator. Now let&amp;rsquo;s make it a bit more interesting by writing our interest table to a file instead of to the screen. We&amp;rsquo;ll also break our code into subs to make it easier to read and maintain.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2000_11_begperl2/compound_interest_file.pl&#34;&gt;[Download this program]&lt;/a&gt;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        #!/usr/local/bin/perl -w



        # compound_interest_file.pl - the miracle of compound interest, part 2


        # First, we&#39;ll set up the variables we want to use.
        $outfile = &amp;quot;interest.txt&amp;quot;;  # This is the filename of our report.
        $nest_egg = 10000;          # $nest_egg is our starting amount
        $year = 2000;               # This is the starting year for our table.
        $duration = 10;             # How many years are we saving up?
        $apr = 9.5;                 # This is our annual percentage rate.


        &amp;amp;open_report;
        &amp;amp;print_headers;
        &amp;amp;interest_report($nest_egg, $year, $duration, $apr);
        &amp;amp;report_footer;


        sub open_report {
            open (REPORT, &amp;quot;&amp;gt;$outfile&amp;quot;) or die &amp;quot;Can&#39;t open report: $!&amp;quot;;
        }


        sub print_headers {
            # Print the headers for our report.
            print REPORT &amp;quot;Year&amp;quot;, &amp;quot;\t&amp;quot;, &amp;quot;Balance&amp;quot;, &amp;quot;\t&amp;quot;, &amp;quot;Interest&amp;quot;, &amp;quot;\t&amp;quot;,
                         &amp;quot;New balance&amp;quot;, &amp;quot;\n&amp;quot;;
        }


        sub calculate_interest {
            # Given a nest egg and an APR, how much interest do we collect?
            my ($nest_egg, $apr) = @_;


            return int (($apr / 100) * $nest_egg * 100) / 100;
        }


        sub interest_report {
            # Get our parameters.  Note that these variables won&#39;t clobber the
            # global variables with the same name.
            my ($nest_egg, $year, $duration, $apr) = @_;


            # We have two local variables, so we&#39;ll use my to declare them here.
            my ($i, $line);


            # Calculate interest for each year.
            for $i (1 .. $duration) {
                $year++;
                $interest = &amp;amp;calculate_interest($nest_egg, $apr);


                $line = join(&amp;quot;\t&amp;quot;, $year, $nest_egg, $interest,
                             $nest_egg + $interest) . &amp;quot;\n&amp;quot;;


                print REPORT $line;

                $nest_egg += $interest;
            }
        }

        sub report_footer {
            print REPORT &amp;quot;\n Our original assumptions:\n&amp;quot;;
            print REPORT &amp;quot;   Nest egg: $nest_egg\n&amp;quot;;
            print REPORT &amp;quot;   Number of years: $duration\n&amp;quot;;
            print REPORT &amp;quot;   Interest rate: $apr\n&amp;quot;;

            close REPORT;
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice how much clearer the program logic becomes when you break it down into subs. One nice quality of a program written as small, well-named subs is that it almost becomes &lt;em&gt;self-documenting&lt;/em&gt;. Take a look at these four lines from our program:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     open_report;
     print_headers;
     interest_report($nest_egg, $year, $duration, $apr);
     report_footer;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Code like this is invaluable when you come back to it six months later and need to figure out what it does - would you rather spend your time reading the entire program trying to figure it out or read four lines that tell you the program 1) opens a report file, 2) prints some headers, 3) generates an interest report, and 4) prints a report footer?&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll also notice we use &lt;code&gt;my&lt;/code&gt; to set up local variables in the &lt;code&gt;interest_report&lt;/code&gt; and &lt;code&gt;calculate_interest&lt;/code&gt; subs. The value of &lt;code&gt;$nest_egg&lt;/code&gt; in the main program never changes. This is useful at the end of the report, when we output a footer containing our original assumptions. Since we never specified a local &lt;code&gt;$nest_egg&lt;/code&gt; in &lt;code&gt;report_footer&lt;/code&gt;, we use the global value.&lt;/p&gt;

&lt;h3 id=&#34;span-id-play-around-play-around-span&#34;&gt;&lt;span id=&#34;play around!&#34;&gt;Play around!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In this article, we&amp;rsquo;ve looked at files (filehandles, &lt;code&gt;open()&lt;/code&gt;, &lt;code&gt;close()&lt;/code&gt;, and &lt;code&gt;&amp;lt;&amp;gt;&lt;/code&gt;), string manipulation (&lt;code&gt;substr()&lt;/code&gt;, &lt;code&gt;split()&lt;/code&gt; and &lt;code&gt;join()&lt;/code&gt;) and subs. Here&amp;rsquo;s a pair of exercises - again, one simple and one complex:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;p&gt;You have a file called &lt;code&gt;dictionary.txt&lt;/code&gt; that contains dictionary definitions, one per line, in the format ``word &lt;code&gt;space&lt;/code&gt; definition&amp;rdquo;. (&lt;a href=&#34;http://localhost:1313/media/_pub_2000_11_begperl2/dictionary.txt&#34;&gt;Here&amp;rsquo;s a sample&lt;/a&gt;.) Write a program that will look up a word from the command line. (Hints: &lt;code&gt;@ARGV&lt;/code&gt; is a special array that contains your command line arguments and you&amp;rsquo;ll need to use the three-argument form of &lt;code&gt;split()&lt;/code&gt;.) Try to enhance it so that your dictionary can also contain words with multiple definitions in the format ``word &lt;code&gt;space&lt;/code&gt; definition:alternate definition:alternate definition, etc&amp;hellip;&amp;ldquo;.&lt;/p&gt;&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Write an analyzer for your Apache logs. You can find a brief description of the common log format at &lt;a href=&#34;http://www.w3.org/Daemon/User/Config/Logging.html&#34;&gt;http://www.w3.org/Daemon/User/Config/Logging.html&lt;/a&gt;. Your analyzer should count the total number of requests for each URL, the total number of results for each status code and the total number of bytes output.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Beginner&#39;s Introduction to Perl</title>
      <link>http://localhost:1313/pub/2000/10/begperl1.html/</link>
      <pubDate>Mon, 16 Oct 2000 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2000/10/begperl1.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: this venerable series is undergoing updates. You might be interested in the newer versions, available at:&lt;/em&gt;&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/04/23/a-beginners-introduction-to-perl-510.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/pub/2008/05/07/beginners-introduction-to-perl-510-part-2.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Files and Strings with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://news.oreilly.com/2008/06/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Regular Expressions with Perl 5.10&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://broadcast.oreilly.com/2008/09/a-beginners-introduction-to-pe.html&#34;&gt;A Beginner&amp;rsquo;s Introduction to Perl Web Programming&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;span-id-first-a-little-sales-pitch-first-a-little-sales-pitch-span&#34;&gt;&lt;span id=&#34;first, a little sales pitch&#34;&gt;First, a Little Sales Pitch&lt;/span&gt;&lt;/h3&gt;

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl2.html&#34;&gt;Part 2 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/11/begperl3.html&#34;&gt;Part 3 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl4.html&#34;&gt;Part 4 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2000/12/begperl5.html&#34;&gt;Part 5 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;strong&gt;&lt;a href=&#34;http://localhost:1313/pub/2001/01/begperl6.html&#34;&gt;Part 6 of this series&lt;/a&gt;&lt;/strong&gt;&lt;br /&gt;
&lt;br /&gt;
&lt;a href=&#34;#a%20word%20about%20operating%20systems&#34;&gt;A Word About Operating Systems&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#your%20first%20perl%20program&#34;&gt;Your First Perl Program&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#functions%20and%20statements&#34;&gt;Functions and Statements&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#numbers,%20strings%20and%20quotes&#34;&gt;Numbers, Strings and Quotes&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#variables&#34;&gt;Variables&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#comments&#34;&gt;Comments&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#loops&#34;&gt;Loops&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#the%20miracle%20of%20compound%20interest&#34;&gt;The Miracle of Compound Interest&lt;/a&gt;&lt;br /&gt;
&lt;a href=&#34;#play%20around!&#34;&gt;Play Around!&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;p&gt;Welcome to Perl.&lt;/p&gt;

&lt;p&gt;Perl is the Swiss Army chainsaw of scripting languages: powerful and adaptable. It was first developed by Larry Wall, a linguist working as a systems administrator for NASA in the late 1980s, as a way to make report processing easier. Since then, it has moved into a large number of roles: automating system administration, acting as glue between different computer systems; and, of course, being one of the most popular languages for CGI programming on the Web.&lt;/p&gt;

&lt;p&gt;Why did Perl become so popular when the Web came along? Two reasons: First, most of what is being done on the Web happens with text, and is best done with a language that&amp;rsquo;s designed for text processing. More importantly, Perl was appreciably better than the alternatives at the time when people needed something to use. C is complex and can produce security problems (especially with untrusted data), Tcl can be awkward and Python didn&amp;rsquo;t really have a foothold.&lt;/p&gt;

&lt;p&gt;It also didn&amp;rsquo;t hurt that Perl is a friendly language. It plays well with your personal programming style. The Perl slogan is ``There&amp;rsquo;s more than one way to do it,&amp;rdquo; and that lends itself well to large and small problems alike.&lt;/p&gt;

&lt;p&gt;In this first part of our series, you&amp;rsquo;ll learn a few basics about Perl and see a small sample program.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-word-about-operating-systems-a-word-about-operating-systems-span&#34;&gt;&lt;span id=&#34;a word about operating systems&#34;&gt;A Word About Operating Systems&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In this series, I&amp;rsquo;m going to assume that you&amp;rsquo;re using a Unix system and that your Perl interpreter is located at &lt;code&gt;/usr/local/bin/perl&lt;/code&gt;. It&amp;rsquo;s OK if you&amp;rsquo;re running Windows; most Perl code is platform-independent.&lt;/p&gt;

&lt;h3 id=&#34;span-id-your-first-perl-program-your-first-perl-program-span&#34;&gt;&lt;span id=&#34;your first perl program&#34;&gt;Your First Perl Program&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Take the following text and put it into a file called &lt;code&gt;first.pl&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     #!/usr/local/bin/perl
     print &amp;quot;Hi there!\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Traditionally, first programs are supposed to say &lt;code&gt;Hello world!&lt;/code&gt;, but I&amp;rsquo;m an iconoclast.)&lt;/p&gt;

&lt;p&gt;Now, run it with your Perl interpreter. From a command line, go to the directory with this file and type &lt;code&gt;perl first.pl&lt;/code&gt;. You should see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     Hi there!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;\n&lt;/code&gt; indicates the ``newline&amp;rdquo; character; without it, Perl doesn&amp;rsquo;t skip to a new line of text on its own.&lt;/p&gt;

&lt;h3 id=&#34;span-id-functions-and-statements-functions-and-statements-span&#34;&gt;&lt;span id=&#34;functions and statements&#34;&gt;Functions and Statements&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl has a rich library of &lt;em&gt;functions&lt;/em&gt;. They&amp;rsquo;re the verbs of Perl, the commands that the interpreter runs. You can see a list of all the built-in functions on the perlfunc main page. Almost all functions can be given a list of &lt;em&gt;parameters&lt;/em&gt;, which are separated by commas.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;print&lt;/code&gt; function is one of the most frequently used parts of Perl. You use it to display things on the screen or to send information to a file (which we&amp;rsquo;ll discuss in the next article). It takes a list of things to output as its parameters.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   print &amp;quot;This is a single statement.&amp;quot;;
   print &amp;quot;Look, &amp;quot;, &amp;quot;a &amp;quot;, &amp;quot;list!&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A Perl program consists of &lt;em&gt;statements&lt;/em&gt;, each of which ends with a semicolon. Statements don&amp;rsquo;t need to be on separate lines; there may be multiple statements on one line or a single statement can be split across multiple lines.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;This is &amp;quot;; print &amp;quot;two statements.\n&amp;quot;; print &amp;quot;But this &amp;quot;,
          &amp;quot;is only one statement.\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-numbers-strings-and-quotes-numbers-strings-and-quotes-span&#34;&gt;&lt;span id=&#34;numbers, strings and quotes&#34;&gt;Numbers, Strings and Quotes&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are two basic data types in Perl: numbers and strings.&lt;/p&gt;

&lt;p&gt;Numbers are easy; we&amp;rsquo;ve all dealt with them. The only thing you need to know is that you never insert commas or spaces into numbers in Perl. always write 10000, not 10,000 or 10 000.&lt;/p&gt;

&lt;p&gt;Strings are a bit more complex. A string is a collection of characters in either single or double quotes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   &#39;This is a test.&#39;
   &amp;quot;Hi there!\n&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The difference between single quotes and double quotes is that single quotes mean that their contents should be taken &lt;em&gt;literally&lt;/em&gt;, while double quotes mean that their contents should be &lt;em&gt;interpreted&lt;/em&gt;. For example, the character sequence &lt;code&gt;\n&lt;/code&gt; is a newline character when it appears in a string with double quotes, but is literally the two characters, backslash and &lt;code&gt;n&lt;/code&gt;, when it appears in single quotes.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print &amp;quot;This string\nshows up on two lines.&amp;quot;;
    print &#39;This string \n shows up on only one.&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(Two other useful backslash sequences are &lt;code&gt;\t&lt;/code&gt; to insert a tab character, and &lt;code&gt;\\&lt;/code&gt; to insert a backslash into a double-quoted string.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-variables-variables-span&#34;&gt;&lt;span id=&#34;variables&#34;&gt;Variables&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If functions are Perl&amp;rsquo;s verbs, then variables are its nouns. Perl has three types of variables: &lt;em&gt;scalars&lt;/em&gt;, &lt;em&gt;arrays&lt;/em&gt; and &lt;em&gt;hashes&lt;/em&gt;. Think of them as ``things,&amp;rdquo; ``lists,&amp;rdquo; and ``dictionaries.&amp;rdquo; In Perl, all variable names are a punctuation character, a letter or underscore, and one or more alphanumeric characters or underscores.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Scalars&lt;/em&gt; are single things. This might be a number or a string. The name of a scalar begins with a dollar sign, such as &lt;code&gt;$i&lt;/code&gt; or &lt;code&gt;$abacus&lt;/code&gt;. You assign a value to a scalar by telling Perl what it equals, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $i = 5;
    $pie_flavor = &#39;apple&#39;;
    $constitution1776 = &amp;quot;We the People, etc.&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You don&amp;rsquo;t need to specify whether a scalar is a number or a string. It doesn&amp;rsquo;t matter, because when Perl needs to treat a scalar as a string, it does; when it needs to treat it as a number, it does. The conversion happens automatically. (This is different from many other languages, where strings and numbers are two separate data types.)&lt;/p&gt;

&lt;p&gt;If you use a double-quoted string, Perl will insert the value of any scalar variables you name in the string. This is often used to fill in strings on the fly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $apple_count = 5; 
    $count_report = &amp;quot;There are $apple_count apples.&amp;quot;;
    print &amp;quot;The report is: $count_report\n&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final output from this code is &lt;code&gt;The report is: There are 5 apples.&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Numbers in Perl can be manipulated with the usual mathematical operations: addition, multiplication, division and subtraction. (Multiplication and division are indicated in Perl with the &lt;code&gt;*&lt;/code&gt; and &lt;code&gt;/&lt;/code&gt; symbols, by the way.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a = 5;
    $b = $a + 10;       # $b is now equal to 15.
    $c = $b * 10;       # $c is now equal to 150.
    $a = $a - 1;        # $a is now 4, and algebra teachers are cringing.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can also use special operators like &lt;code&gt;++&lt;/code&gt;, &lt;code&gt;--&lt;/code&gt;, &lt;code&gt;+=&lt;/code&gt;, &lt;code&gt;-=&lt;/code&gt;, &lt;code&gt;/=&lt;/code&gt; and &lt;code&gt;*=&lt;/code&gt;. These manipulate a scalar&amp;rsquo;s value without needing two elements in an equation. Some people like them, some don&amp;rsquo;t. I like the fact that they can make code clearer.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   $a = 5;
   $a++;        # $a is now 6; we added 1 to it.
   $a += 10;    # Now it&#39;s 16; we added 10.
   $a /= 2;     # And divided it by 2, so it&#39;s 8.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Strings in Perl don&amp;rsquo;t have quite as much flexibility. About the only basic operator that you can use on strings is &lt;em&gt;concatenation&lt;/em&gt;, which is a $10 way of saying ``put together.&amp;rdquo; The concatenation operator is the period. Concatenation and addition are two different things:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   $a = &amp;quot;8&amp;quot;;    # Note the quotes.  $a is a string.
   $b = $a + &amp;quot;1&amp;quot;;   # &amp;quot;1&amp;quot; is a string too.
   $c = $a . &amp;quot;1&amp;quot;;   # But $b and $c have different values!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Remember that Perl converts strings to numbers transparently whenever it&amp;rsquo;s needed, so to get the value of &lt;code&gt;$b&lt;/code&gt;, the Perl interpreter converted the two strings &lt;code&gt;&amp;quot;8&amp;quot;&lt;/code&gt; and &lt;code&gt;&amp;quot;1&amp;quot;&lt;/code&gt; to numbers, then added them. The value of &lt;code&gt;$b&lt;/code&gt; is the number 9. However, &lt;code&gt;$c&lt;/code&gt; used concatenation, so its value is the string &lt;code&gt;&amp;quot;81&amp;quot;&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Just remember, the plus sign &lt;em&gt;adds numbers&lt;/em&gt; and the period &lt;em&gt;puts strings together&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Arrays&lt;/em&gt; are lists of scalars. Array names begin with &lt;code&gt;@&lt;/code&gt;. You define arrays by listing their contents in parentheses, separated by commas:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @lotto_numbers = (1, 2, 3, 4, 5, 6);  # Hey, it could happen.
    @months = (&amp;quot;July&amp;quot;, &amp;quot;August&amp;quot;, &amp;quot;September&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The contents of an array are &lt;em&gt;indexed&lt;/em&gt; beginning with 0. (Why not 1? Because. It&amp;rsquo;s a computer thing.) To retrieve the elements of an array, you replace the &lt;code&gt;@&lt;/code&gt; sign with a &lt;code&gt;$&lt;/code&gt; sign, and follow that with the index position of the element you want. (It begins with a dollar sign because you&amp;rsquo;re getting a scalar value.) You can also modify it in place, just like any other scalar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @months = (&amp;quot;July&amp;quot;, &amp;quot;August&amp;quot;, &amp;quot;September&amp;quot;);
    print $months[0];   # This prints &amp;quot;July&amp;quot;.
    $months[2] = &amp;quot;Smarch&amp;quot;;  # We just renamed September!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If an array doesn&amp;rsquo;t exist, by the way, you&amp;rsquo;ll create it when you try to assign a value to one of its elements.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $winter_months[0] = &amp;quot;December&amp;quot;;  # This implicitly creates @winter_months.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Arrays always return their contents in the same order; if you go through &lt;code&gt;@months&lt;/code&gt; from beginning to end, no matter how many times you do it, you&amp;rsquo;ll get back &lt;code&gt;July&lt;/code&gt;, &lt;code&gt;August&lt;/code&gt; and &lt;code&gt;September&lt;/code&gt; in that order. If you want to find the length of an array, use the value &lt;code&gt;$#array_name&lt;/code&gt;. This is one less than the number of elements in the array. If the array just doesn&amp;rsquo;t exist or is empty, &lt;code&gt;$#array_name&lt;/code&gt; is -1. If you want to resize an array, just change the value of &lt;code&gt;$#array_name&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @months = (&amp;quot;July&amp;quot;, &amp;quot;August&amp;quot;, &amp;quot;September&amp;quot;);
    print $#months;         # This prints 2.
    $a1 = $#autumn_months;  # We don&#39;t have an @autumn_months, so this is -1.
    $#months = 0;           # Now @months only contains &amp;quot;July&amp;quot;.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Hashes&lt;/em&gt; are called ``dictionaries&amp;rdquo; in some programming languages, and that&amp;rsquo;s what they are: a term and a definition, or in more correct language a &lt;em&gt;key&lt;/em&gt; and a &lt;em&gt;value&lt;/em&gt;. Each key in a hash has one and only one corresponding value. The name of a hash begins with a percentage sign, like &lt;code&gt;%parents&lt;/code&gt;. You define hashes by comma-separated pairs of key and value, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    %days_in_summer = ( &amp;quot;July&amp;quot; =&amp;gt; 31, &amp;quot;August&amp;quot; =&amp;gt; 31, &amp;quot;September&amp;quot; =&amp;gt; 30 );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can fetch any value from a hash by referring to &lt;code&gt;$hashname{key}&lt;/code&gt;, or modify it in place just like any other scalar.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print $days_in_summer{&amp;quot;September&amp;quot;}; # 30, of course.
    $days_in_summer{&amp;quot;February&amp;quot;} = 29;   # It&#39;s a leap year.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you want to see what keys are in a hash, you can use the &lt;code&gt;keys&lt;/code&gt; function with the name of the hash. This returns a list containing all of the keys in the hash. The list isn&amp;rsquo;t always in the same order, though; while we could count on &lt;code&gt;@months&lt;/code&gt; to always return &lt;code&gt;July&lt;/code&gt;, &lt;code&gt;August&lt;/code&gt;, &lt;code&gt;September&lt;/code&gt; in that order, &lt;code&gt;keys %days_in_summer&lt;/code&gt; might return them in any order whatsoever.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @month_list = keys %days_in_summer;
    # @month_list is now (&#39;July&#39;, &#39;September&#39;, &#39;August&#39;) !
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The three types of variables have three separate &lt;em&gt;namespaces&lt;/em&gt;. That means that &lt;code&gt;$abacus&lt;/code&gt; and &lt;code&gt;@abacus&lt;/code&gt; are two different variables, and &lt;code&gt;$abacus[0]&lt;/code&gt; (the first element of &lt;code&gt;@abacus&lt;/code&gt;) is not the same as &lt;code&gt;$abacus{0}&lt;/code&gt; (the value in &lt;code&gt;abacus&lt;/code&gt; that has the key &lt;code&gt;0&lt;/code&gt;).&lt;/p&gt;

&lt;h3 id=&#34;span-id-comments-comments-span&#34;&gt;&lt;span id=&#34;comments&#34;&gt;Comments&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Notice that in some of the code samples from the previous section, I&amp;rsquo;ve used code comments. These are useful for explaining what a particular piece of code does, and vital for any piece of code you plan to modify, enhance, fix, or just look at again. (That is to say, comments are vital for all code.)&lt;/p&gt;

&lt;p&gt;Anything in a line of Perl code that follows a # sign is a comment. (Except, of course, if the # sign appears in a string.)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;   print &amp;quot;Hello world!\n&amp;quot;;  # That&#39;s more like it.
   # This entire line is a comment.
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-loops-loops-span&#34;&gt;&lt;span id=&#34;loops&#34;&gt;Loops&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Almost every time you write a program, you&amp;rsquo;ll need to use a &lt;em&gt;loop&lt;/em&gt;. Loops allow you run a particular piece of code over and over again. This is part of a general concept in programming called &lt;em&gt;flow control&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Perl has several different functions that are useful for flow control, the most basic of which is &lt;code&gt;for&lt;/code&gt;. When you use the &lt;code&gt;for&lt;/code&gt; function, you specify a variable that will be used for the &lt;em&gt;loop index&lt;/em&gt;, and a list of values to loop over. Inside a pair of curly brackets, you put any code you want to run during the loop:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;     for $i (1, 2, 3, 4, 5) {
         print &amp;quot;$i\n&amp;quot;;
     }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This loop prints the numbers 1 through 5, each on a separate line.&lt;/p&gt;

&lt;p&gt;A handy shortcut for defining loops is using &lt;code&gt;..&lt;/code&gt; to specify a &lt;em&gt;range&lt;/em&gt; of numbers. You can write (1, 2, 3, 4, 5) as (1 .. 5). You can also use arrays and scalars in your loop list. Try this code and see what happens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @one_to_ten = (1 .. 10);
    $top_limit = 25;
    for $i (@one_to_ten, 15, 20 .. $top_limit) {
        print &amp;quot;$i\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The items in your loop list don&amp;rsquo;t have to be numbers; you can use strings just as easily. If the hash &lt;code&gt;%month&lt;/code&gt;_has contains names of months and the number of days in each month, you can use the keys function to step through them.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for $i (keys %month_has) {
        print &amp;quot;$i has $month_has{$i} days.\n&amp;quot;;
    }

    for $marx (&#39;Groucho&#39;, &#39;Harpo&#39;, &#39;Zeppo&#39;, &#39;Karl&#39;) {

        print &amp;quot;$marx is my favorite Marx brother.\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-the-miracle-of-compound-interest-the-miracle-of-compound-interest-span&#34;&gt;&lt;span id=&#34;the miracle of compound interest&#34;&gt;The Miracle of Compound Interest&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You now know enough about Perl - variables, print, and &lt;code&gt;for()&lt;/code&gt; - to write a small, useful program. Everyone loves money, so the first sample program is a compound-interest calculator. It will print a (somewhat) nicely formatted table showing the value of an investment over a number of years. (You can see the program at &lt;a href=&#34;http://localhost:1313/media/_pub_2000_10_begperl1/compound_interest.pl&#34;&gt;&lt;code&gt;compound_interest.pl&lt;/code&gt;&lt;/a&gt;)&lt;/p&gt;

&lt;p&gt;The single most complex line in the program is this one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $interest = int (($apr / 100) * $nest_egg * 100) / 100;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$apr / 100&lt;/code&gt; is the interest rate, and &lt;code&gt;($apr / 100) * $nest_egg&lt;/code&gt; is the amount of interest earned in one year. This line uses the &lt;code&gt;int()&lt;/code&gt; function, which returns the integer value of a scalar (its value after any fractional part has been stripped off). We use &lt;code&gt;int()&lt;/code&gt; here because when you multiply, for example, 10925 by 9.25%, the result is 1010.5625, which we must round off to 1010.56. To do this, we multiply by 100, yielding 101056.25, use &lt;code&gt;int()&lt;/code&gt; to throw away the leftover fraction, yielding 101056, and then divide by 100 again, so that the final result is 1010.56. Try stepping through this statement yourself to see just how we end up with the correct result, rounded to cents.&lt;/p&gt;

&lt;h3 id=&#34;span-id-play-around-play-around-span&#34;&gt;&lt;span id=&#34;play around!&#34;&gt;Play Around!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;At this point you have some basic knowledge of Perl syntax and a few simple toys to play with - &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;for()&lt;/code&gt;, &lt;code&gt;keys()&lt;/code&gt;, and &lt;code&gt;int()&lt;/code&gt;. Try writing some simple programs with them. Here are two suggestions, one simple and the other a little more complex:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A word frequency counter. How often does each word show up in an array of words? Print out a report. (Hint: Use a hash to count of the number of appearances of each word.)&lt;/li&gt;
&lt;li&gt;Given a month and the day of the week that&amp;rsquo;s the first of that month, print a calendar for the month. (Remember, you need &lt;code&gt;\n&lt;/code&gt; to go to a new line.)&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
  </channel>
</rss>

