<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Games on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/categories/games/</link>
    <description>Recent content in Games on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 30 Nov 2012 06:00:01 -0800</lastBuildDate>
    <atom:link href="/categories/games/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Designing Board Games With Perl</title>
      <link>http://localhost:1313/pub/2012/11/designing-board-games-with-perl.html/</link>
      <pubDate>Fri, 30 Nov 2012 06:00:01 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2012/11/designing-board-games-with-perl.html/</guid>
      <description>

&lt;p&gt;Board games are hotter than they&amp;rsquo;ve ever been. In fact, &lt;a href=&#34;http://www.icv2.com/articles/news/24066.html&#34;&gt;the board game market has grown 25% in the past year while the video game market shrank 20%&lt;/a&gt;. But you&amp;rsquo;re a Perl hacker, not an Adobe Illustrator, so how can you design a board game? Well, that&amp;rsquo;s exactly what I aim to show you in this article.&lt;/p&gt;

&lt;p&gt;First, you need an idea. You can turn literally anything into a game. &lt;a href=&#34;https://www.thegamecrafter.com/games/adventurelings&#34; title=&#34;Adventurelings&#34;&gt;Whether&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/plague-the-card-game&#34; title=&#34;Plague&#34;&gt;you&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/merc&#34; title=&#34;MERC&#34;&gt;just&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/the-decktet-firmament-&#34; title=&#34;The Decktet&#34;&gt;want&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/zombiezone&#34; title=&#34;ZombieZone&#34;&gt;to&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/surviving-design-projects&#34; title=&#34;Surviving Design Projects&#34;&gt;design&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/rejection-therapy-the-game&#34; title=&#34;Rejection Therapy&#34;&gt;your&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/hackers-agents&#34; title=&#34;Hackers
    and Agents&#34;&gt;own&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/the-tarat&#34; title=&#34;The
    TaRat&#34;&gt;custom&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/wild-pursuit-&#34; title=&#34;Wild
    Pursuit&#34;&gt;playing&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/jump-gate&#34; title=&#34;Jump
    Gate&#34;&gt;cards&lt;/a&gt;, &lt;a href=&#34;https://www.thegamecrafter.com/games/sandwich-city&#34; title=&#34;Sandwich
    City&#34;&gt;or&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/shake-out-&#34; title=&#34;Shake Out&#34;&gt;you&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/trade-fleet&#34; title=&#34;Trade
    Fleet&#34;&gt;want&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/diggity&#34; title=&#34;Diggity&#34;&gt;to&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/elemental-clash:-the-basic-set&#34; title=&#34;Elemental Clash&#34;&gt;make&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/black-and-red&#34; title=&#34;Black and
    Red Playing Cards&#34;&gt;a&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/frogs-&#34; title=&#34;Frogs!&#34;&gt;full&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/phytocats&#34; title=&#34;Phytocats&#34;&gt;on&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/city-of-gears&#34; title=&#34;City of
    Gears&#34;&gt;custom&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/gibs&#34; title=&#34;Gibs&#34;&gt;board&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/dr-pergias-race&#34; title=&#34;Doctor
    Pergaias&#39; Race Across The Continent&#34;&gt;or&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/goblin-warlord&#34; title=&#34;Goblin
    Warlord&#34;&gt;card&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/braaaaains-&#34; title=&#34;Braaaaains!&#34;&gt;game&lt;/a&gt;, &lt;a href=&#34;https://www.thegamecrafter.com/games/the-great-race1&#34; title=&#34;The
    Great Race&#34;&gt;the&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/road-to-magnate&#34; title=&#34;Road to
    Magnate&#34;&gt;options&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/zerpang-&#34; title=&#34;Zerpang!&#34;&gt;are&lt;/a&gt; &lt;a href=&#34;https://www.thegamecrafter.com/games/angels-elements&#34; title=&#34;Angels
    Elements&#34;&gt;limitless&lt;/a&gt;. (Full disclosure: I&amp;rsquo;m one of the owners of &lt;a href=&#34;https://www.thegamecrafter.com/&#34;&gt;The Game Crafter&lt;/a&gt;, which itself is written entirely in Perl. )&lt;/p&gt;

&lt;p&gt;For the purposes of this article, I&amp;rsquo;m going to make &lt;a href=&#34;https://www.thegamecrafter.com/games/lacuna-expanse:-a-new-empire&#34;&gt;a board game version&lt;/a&gt; of the popular Perl-based web game &lt;a href=&#34;http://www.lacunaexpanse.com&#34;&gt;The Lacuna Expanse&lt;/a&gt;. (I&amp;rsquo;m also one of the owners of Lacuna.) I chose this because I already have some artwork for it, albeit not in board game form. However, &lt;a href=&#34;https://community.thegamecrafter.com/publish/file-preparation/art-resources&#34;&gt;you can get free art from various sites around the web&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;My Lacuna-based board game will be a tile placement game where all the players work together cooperatively to fend off an alien invasion.&lt;/p&gt;

&lt;h2 id=&#34;let-s-get-to-the-perl-already&#34;&gt;Let&amp;rsquo;s Get To The Perl Already!&lt;/h2&gt;

&lt;p&gt;There are several great image manipulation libraries on the CPAN, but my personal favorite is &lt;a href=&#34;https://metacpan.org/pod/Image::Magick&#34;&gt;Image::Magick&lt;/a&gt;. I started by creating a base image which I could manipulate in any way that I wanted. (I based my choice off of &lt;a href=&#34;https://www.thegamecrafter.com/publish/pricing&#34;&gt;The Game Crafter&amp;rsquo;s list of component sizes and prices&lt;/a&gt;.) I decided to use &lt;a href=&#34;https://community.thegamecrafter.com/publish/templates/cards/mini-cards&#34;&gt;mini cards&lt;/a&gt;, because the table would fill up too quickly with full poker-sized cards; there&amp;rsquo;ll be a lot of cards on the table!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $card = Image::Magick-&amp;gt;new(size=&amp;gt;&#39;600x825&#39;);
 say $card-&amp;gt;ReadImage(&#39;canvas:white&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I used &lt;code&gt;say&lt;/code&gt; in front of the &lt;code&gt;ReadImage&lt;/code&gt; call. &lt;code&gt;Image::Magick&lt;/code&gt; will emit a textual exception on each call if anything goes wrong. I could easily wrap that with better error handling, but for now printing to the screen is sufficient for my needs.
When printing things (really &lt;em&gt;printing&lt;/em&gt; them, with ink and all) you also have to take into account something called &lt;a href=&#34;http://youtu.be/NqZSFpmS2dM&#34;&gt;bleed and cut lines&lt;/a&gt;. It&amp;rsquo;s easy to draw the cut line on the card in red as the boundary of the printable image content.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; say $card-&amp;gt;Draw(stroke=&amp;gt;&#39;red&#39;, fill =&amp;gt; &#39;none&#39;, strokewidth=&amp;gt;1, primitive=&amp;gt;&#39;rectangle&#39;, points=&amp;gt;&#39;38,38 562,787&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2012_11_designing-board-games-with-perl/blank.jpg&#34; alt=&#34;blank with cut lines&#34; /&gt;
So far so good. The next step is to give this card a background so that it starts to look like a card. For this I&amp;rsquo;ll take one of the planet surface images from the Lacuna Expanse and rotate it and stretch it to fit the shape of the card.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $surface = Image::Magick-&amp;gt;new;
 say $surface-&amp;gt;ReadImage(&#39;surface-p17.jpg&#39;);
 say $surface-&amp;gt;Rotate(90);
 say $surface-&amp;gt;Resize(&#39;600x825!&#39;);
 say $card-&amp;gt;Composite(compose =&amp;gt; &#39;over&#39;, image =&amp;gt; $surface, x =&amp;gt; 0, y =&amp;gt; 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note the exclamation point (&lt;strong&gt;!&lt;/strong&gt;) on the &lt;code&gt;Resize&lt;/code&gt; command. That tells &lt;code&gt;Image::Magick&lt;/code&gt; to distort the native aspect ratio of the image. In other words, stretch the image to fill the size I&amp;rsquo;ve specified.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2012_11_designing-board-games-with-perl/background.jpg&#34; alt=&#34;background&#34; /&gt;
You may have noticed that this image looks enormous. That&amp;rsquo;s because it&amp;rsquo;s for print (on paper!) rather than screens. Print has more &lt;a href=&#34;http://proshooter.com/article_whatisa300dpiJPeg.htm&#34;&gt;pixels per inch/centimeter&lt;/a&gt; than screens, thus the image looks bigger when you display it on a screen.&lt;/p&gt;

&lt;p&gt;Now the card needs a title. Adding text to the image is straightforward.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $card-&amp;gt;Annotate(text =&amp;gt; &#39;Mayhem Training&#39;, font =&amp;gt; &#39;ALIEN5.ttf&#39;, y =&amp;gt; -275, fill =&amp;gt; &#39;white&#39;, pointsize =&amp;gt; 70, gravity =&amp;gt; &#39;Center&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2012_11_designing-board-games-with-perl/title.jpg&#34; alt=&#34;title&#34; /&gt;
As you can see I&amp;rsquo;ve used a custom font. &lt;code&gt;Image::Magick&lt;/code&gt; is capable of using nearly any OpenType or TrueType font.&lt;/p&gt;

&lt;p&gt;With a background and a title, the next step is to overlay the card with a picture of the Mayhem Training building from the video game.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $image = Image::Magick-&amp;gt;new;
 say $image-&amp;gt;ReadImage(&#39;mayhemtraining9.png&#39;);
 say $card-&amp;gt;Composite(compose =&amp;gt; &#39;over&#39;, image =&amp;gt; $image, x =&amp;gt; 100, y =&amp;gt; 165);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2012_11_designing-board-games-with-perl/image.jpg&#34; alt=&#34;added image&#34; /&gt;
Now we&amp;rsquo;re finally getting somewhere! This is really starting to look like a card. Use the same technique to overlay an icon onto the card. As in so many games, these icons symbolize an ability that the card grants the player who uses it. You can get free icons from all over the web; one of my favorite libraries is &lt;a href=&#34;http://www.glyphish.com&#34;&gt;Glyphish&lt;/a&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $icon = Image::Magick-&amp;gt;new;
 say $icon-&amp;gt;ReadImage(&#39;target.png&#39;);
 say $card-&amp;gt;Composite(compose =&amp;gt; &#39;over&#39;, image =&amp;gt; $icon, x =&amp;gt; 100, y =&amp;gt; 570);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2012_11_designing-board-games-with-perl/icon.jpg&#34; alt=&#34;added icon&#34; /&gt;
You can&amp;rsquo;t get away with icons all the time; a little text will explain things to new players. Adding some explanation to the card would be really tricky, if it weren&amp;rsquo;t for &lt;a href=&#34;http://www.imagemagick.org/discourse-server/viewtopic.php?f=7&amp;amp;t=3708&#34;&gt;some really neat code that Gabe Schaffer contributed to the ImageMagick forums a long time ago&lt;/a&gt;. Basically without this code you&amp;rsquo;d have to make the text wrap at word boundaries yourself, but with it, you can just do a simple &lt;code&gt;Annotate&lt;/code&gt; call like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $card-&amp;gt;Set(font =&amp;gt; &#39;promethean.ttf&#39;, pointsize =&amp;gt; 35);
 my $text = &#39;Demolish one of your buildings to use this ability.&#39;;
 my $text_wrapped = wrap($text, $card, 400);
 say $card-&amp;gt;Annotate(text =&amp;gt; $text_wrapped, x =&amp;gt; 100, y =&amp;gt; 690, font =&amp;gt; &#39;promethean.ttf&#39;, fill =&amp;gt; &#39;white&#39;, pointsize =&amp;gt; 35);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2012_11_designing-board-games-with-perl/text.jpg&#34; alt=&#34;added text&#34; /&gt;
A game like this wouldn&amp;rsquo;t be very interesting if you could place any card anywhere you want. To solve this, I want to to add something to the card to indicate how other cards can connect to it. This is the most challenging part yet, because I want to make a half-circle/half-rectangle connector. Because this is a bit more complicated and I want to use it for drawing connection points on various sides of the card, I&amp;rsquo;ll turn it into a subroutine.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; sub draw_connection_point {
   my ($card, $color, $rotation, $x, $y) = @_;

   # draw a half circle, it&#39;s a half cuz we&#39;re drawing outide the image
   my $half_circle  = Image::Magick-&amp;gt;new(size=&amp;gt;&#39;70x35&#39;);
   say $half_circle-&amp;gt;ReadImage(&#39;canvas:transparent&#39;);
   say $half_circle-&amp;gt;Draw(stroke =&amp;gt; $color, fill =&amp;gt; $color, strokewidth=&amp;gt;1, primitive=&amp;gt;&#39;circle&#39;, points=&amp;gt;&#39;35,35, 35,70&#39;);

   # create the connection point image
   my $connection = Image::Magick-&amp;gt;new(size=&amp;gt;&#39;70x85&#39;);
   say $connection-&amp;gt;ReadImage(&#39;canvas:transparent&#39;);

   # add the half circle to the connection point
   say $connection-&amp;gt;Composite(compose =&amp;gt; &#39;over&#39;, image =&amp;gt; $half_circle, x =&amp;gt; 0, y =&amp;gt; 0);

   # extend the connection point the the edge
   say $connection-&amp;gt;Draw(stroke=&amp;gt;$color, fill =&amp;gt; $color, strokewidth=&amp;gt;1, primitive=&amp;gt;&#39;rectangle&#39;, points=&amp;gt;&#39;0,35 70,85&#39;);

   # orient the connection point for its position
   say $connection-&amp;gt;Rotate($rotation);

   # apply the connection point to the image
   say $card-&amp;gt;Composite(compose =&amp;gt; &#39;over&#39;, image =&amp;gt; $connection, x =&amp;gt; $x, y =&amp;gt; $y);
 }

 draw_connection_point($card, &#39;purple&#39;, 0, 265, 740);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2012_11_designing-board-games-with-perl/connection.jpg&#34; alt=&#34;connection added&#34; /&gt;
Sometimes it&amp;rsquo;s nice to give players hints about stuff so they can form better strategies. To that end, I added a series of pips above the title to indicate how many copies of this card are in the deck. In this case, this card is unique.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; my $quantity = 1;
 my $pips = &#39;.&#39; x $quantity;
 say $card-&amp;gt;Annotate(text =&amp;gt; $pips, y =&amp;gt; -340, fill =&amp;gt; &#39;white&#39;, pointsize =&amp;gt; 70, gravity =&amp;gt; &#39;Center&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2012_11_designing-board-games-with-perl/finished.jpg&#34; alt=&#34;finished&#34; /&gt;
Remember to remove the cut line before you save the file.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; #say $card-&amp;gt;Draw(stroke=&amp;gt;&#39;red&#39;, fill =&amp;gt; &#39;none&#39;, strokewidth=&amp;gt;1, primitive=&amp;gt;&#39;rectangle&#39;, points=&amp;gt;&#39;38,38 562,787&#39;);
 say $card-&amp;gt;Write(&#39;mayhem.png&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2012_11_designing-board-games-with-perl/cut-line-removed.jpg&#34; alt=&#34;cut lines removed&#34; /&gt;&lt;/p&gt;

&lt;h2 id=&#34;rationale&#34;&gt;Rationale&lt;/h2&gt;

&lt;p&gt;Now that I&amp;rsquo;ve shown you how to create a card, you may have one question. Why would you go through the work of coding it rather than just using Photoshop or the Gimp? There are lots of reasons to code it including things like you don&amp;rsquo;t know how to use image editors. However the really important reason is the same reason you write code to do anything&amp;hellip; automation! A game isn&amp;rsquo;t made of just one card. Likewise, games aren&amp;rsquo;t designed in just one try. It takes lots of play testing and revisions. If you design your board game using code you can whip out a new revision as easily as changing a config file.&lt;/p&gt;

&lt;p&gt;Of course, automatic image generation isn&amp;rsquo;t only for games&amp;hellip;.&lt;/p&gt;

&lt;h2 id=&#34;next-time&#34;&gt;Next Time&lt;/h2&gt;

&lt;p&gt;I&amp;rsquo;ve shown you how to create the images for a game. If you&amp;rsquo;re like me, the next thing you want to do is print your game. You could do this at home, but it will cost you a lot of time and money (ink jet ink costs more than human blood). You could take it to Kinkos, but you won&amp;rsquo;t get a nice quality product because they don&amp;rsquo;t specialize in making games. Instead, you can upload your files to &lt;a href=&#34;https://www.thegamecrafter.com&#34;&gt;The Game Crafter&lt;/a&gt;, where you&amp;rsquo;ll get a custom game that looks like it game from the game store. There&amp;rsquo;s a nice easy to use web interface to do this, but you&amp;rsquo;re a Perl programmer. Why do something manually if you can automate it?&lt;/p&gt;

&lt;p&gt;Besides that, it&amp;rsquo;s a real-world example of interacting with a web service written completely in Perlâ€”on both sides. Who wouldn&amp;rsquo;t be interested in that?&lt;/p&gt;

&lt;h2 id=&#34;for-the-impatient&#34;&gt;For The Impatient&lt;/h2&gt;

&lt;p&gt;&lt;a href=&#34;https://www.thegamecrafter.com/games/lacuna-expanse:-a-new-empire&#34;&gt;The Lacuna Expanse Board Game&lt;/a&gt; is available for purchase now if you&amp;rsquo;re interested. Also, I&amp;rsquo;ve &lt;a href=&#34;https://github.com/plainblack/Lacuna-Board-Game&#34;&gt;released the code I wrote to develop it via this public GitHub repository&lt;/a&gt;.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Colonizing the Lacuna Expanse with Perl</title>
      <link>http://localhost:1313/pub/2010/10/colonizing-the-lacuna-expanse-with-perl.html/</link>
      <pubDate>Fri, 22 Oct 2010 10:42:40 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2010/10/colonizing-the-lacuna-expanse-with-perl.html/</guid>
      <description>&lt;p&gt;&lt;em&gt;Perl productivity has suffered this month with JT Smith&amp;rsquo;s announcement of &lt;a href=&#34;http://lacunaexpanse.com/&#34;&gt;The Lacuna Expanse&lt;/a&gt;, a web-based space empire strategy game. As with most of Smith&amp;rsquo;s projects, TLE uses Perl extensively. Perl.com recently conducted an email interview to explore the world behind the game world.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You&amp;rsquo;re a successful serial entrepreneur. How&amp;rsquo;d you get into Perl?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I started my professional career as an Engineer at a TV station. As the web started to get popular in the early 90&amp;rsquo;s I started picking up web development for the TV station, and then eventually went to work at an ISP as a web developer and system administrator. That&amp;rsquo;s when I first picked up Perl, as it was already installed on the DEC Unix boxes they were running. I realized how easy it was to use it to automate a lot of my job (deploying sites, running backups, collecting statistics, munging logs), and a little web stuff here and there too (processing forms, writing message boards and polls). Since then I&amp;rsquo;ve used several other languages (PHP, Java, and Ruby mostly), but I always come back to Perl because it solves the most problems for me with the littlest amount of fuss.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What&amp;rsquo;s your business background?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I have no formal business training, but I&amp;rsquo;ve worked at lots of companies big and small, and either started or helped start about a dozen companies now, four of which I still own. So I&amp;rsquo;ve really picked up a lot of my business expertise through trial and error, and through watching the successes and failures of other businesses.&lt;/p&gt;

&lt;p&gt;Some people follow sports and can quote you the scores and statistics of their favorite teams. For me, I prefer to watch businesses and business leaders. And when I read for entertainment, it&amp;rsquo;s almost never fiction. Instead I like to read about things that can give me ideas to apply. For instance, I just finished &amp;ldquo;The Viral Loop,&amp;rdquo; which covers viral marketing history from Tupperware through Facebook. I know all this sounds pretty nerdy/geeky/dorky, but so be it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How did you decide to do a browser-based game?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Actually long before I built &lt;a href=&#34;http://webgui.org/&#34;&gt;WebGUI&lt;/a&gt;, in the CGI era, I built one of the very first web-based RPG systems. It was called Survival of the Fittest. And back about that time I had the idea for The Lacuna Expanse (it was called Star Games back then), but the technology wasn&amp;rsquo;t there to pull off what I really wanted to do.&lt;/p&gt;

&lt;p&gt;Then last year (released July 14, 2009) I built a new business called &lt;a href=&#34;http://thegamecrafter.com/&#34;&gt;The Game Crafter&lt;/a&gt;. It is a web to print company, where people design board games and card games using their web browser (plus some offline image editing) and when they&amp;rsquo;re done, they can order a copy for themselves, or put it up in our online store to sell to potential customers. It&amp;rsquo;s sort of like &lt;a href=&#34;http://lulu.com/&#34;&gt;Lulu&lt;/a&gt; or &lt;a href=&#34;http://cafepress.com&#34;&gt;CafePress&lt;/a&gt;, but for traditional board and card games. Here we are just over a year later and that business has really taken off, with over 1,500 people making custom games, and 70% of customers returning for more than one order. I should mention that TGC is built with 100% pure Perl as well.&lt;/p&gt;

&lt;p&gt;About the time that The Game Crafter launched, another business that I had created four years earlier started actually making some good money. That business is &lt;a href=&#34;http://cmsmatrix.org/&#34;&gt;CMS Matrix&lt;/a&gt;, and yes it&amp;rsquo;s 100% pure Perl as well.&lt;/p&gt;

&lt;p&gt;After about 6 months of seeing how well The Game Crafter and CMS Matrix were doing, and knowing that I had a solid team in place to keep WebGUI marching forward, my business partners and I decided we should take a chance with yet another business. But this time we decided we wanted to tackle something much more ambitious and risky.&lt;/p&gt;

&lt;p&gt;One of my business partners reminded me of the Star Games idea. And there&amp;rsquo;s hardly anything more risky than making a video game. It has a large up front cost of both time and money, and video games pretty much either make a lot of money, or none at all. There&amp;rsquo;s not much of a middle of the road. With Star Games as our foundation, we started designing game mechanics. We didn&amp;rsquo;t want to build yet another war game (too many of those) so we settled on espionage as our conflict mechanism. And until WoW and The Sims came around, there was one game that dominated the landscape as far as revenue goes, SimCity. So we knew the game had to have a city building element. And everything else was stuff we either made up, or ideas we borrowed from our favorite games.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What did you have to invent and what did you reuse?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Luckily CPAN came to the rescue as it has on basically every Perl project I&amp;rsquo;ve ever tackled. So I was able to not have to reinvent the wheel on basically any foundational level. Here&amp;rsquo;s the list of Perl modules I used:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Data::Validate::Email&#34;&gt;Data::Validate::Email&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Text::CSV_XS&#34;&gt;Text::CSV_XS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Log::Log4perl&#34;&gt;Log::Log4perl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/UUID::Tiny&#34;&gt;UUID::Tiny&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/DateTime::Format::MySQL&#34;&gt;DateTime::Format::MySQL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/DBIx::Class::TimeStamp&#34;&gt;DBIx::Class::TimeStamp&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/JSON::XS&#34;&gt;JSON::XS&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/JSON&#34;&gt;JSON&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Config::JSON&#34;&gt;Config::JSON&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Starman&#34;&gt;Starman&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/JSON::RPC::Dispatcher&#34;&gt;JSON::RPC::Dispatcher&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Log::Any::Adapter&#34;&gt;Log::Any::Adapter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Log::Any::Adapter::Log4perl&#34;&gt;Log::Any::Adapter::Log4perl&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/String::Random&#34;&gt;String::Random&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/List::Util::WeightedChoice&#34;&gt;List::Util::WeightedChoice&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/List::Util&#34;&gt;List::Util&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/List::MoreUtils&#34;&gt;List::MoreUtils&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/DateTime&#34;&gt;DateTime&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Regexp::Common&#34;&gt;Regexp::Common&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Pod::Simple::HTML&#34;&gt;Pod::Simple::HTML&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/File::Copy&#34;&gt;File::Copy&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/DateTime::Format::Duration&#34;&gt;DateTime::Format::Duration&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/XML::FeedPP&#34;&gt;XML::FeedPP&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/SOAP::Amazon::S3&#34;&gt;SOAP::Amazon::S3&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/DBD::mysql&#34;&gt;DBD::mysql&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/DBIx::Class&#34;&gt;DBIx::Class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/JSON::Any&#34;&gt;JSON::Any&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/DBIx::Class::InflateColumn::Serializer&#34;&gt;DBIx::Class::InflateColumn::Serializer&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/DBIx::Class::DynamicSubclass&#34;&gt;DBIx::Class::DynamicSubclass&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Memcached::libmemcached&#34;&gt;Memcached::libmemcached&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Server::Starter&#34;&gt;Server::Starter&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/IO::Socket::SSL&#34;&gt;IO::Socket::SSL&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Net::Server::SS::PreFork&#34;&gt;Net::Server::SS::PreFork&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Email::Stuff&#34;&gt;Email::Stuff&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Facebook::Graph&#34;&gt;Facebook::Graph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/File::Path&#34;&gt;File::Path&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/namespace::autoclean&#34;&gt;namespace::autoclean&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Clone&#34;&gt;Clone&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Plack::Middleware::CrossOrigin&#34;&gt;Plack::Middleware::CrossOrigin&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Net::Amazon::S3&#34;&gt;Net::Amazon::S3&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;When I first started development I was convinced that to be massively parallel I was going to have to go with an async server like Coro or POE, and a NoSQL database.&lt;/p&gt;

&lt;p&gt;I quickly realized that writing this system to be completely async was going to be a nightmare that would take more than double the time. Part of the problem was that while I was familiar with developing async applications, I had only done it on a small scale in the past. The other problem was that I kept running into modules I wanted to use that weren&amp;rsquo;t async compatible. Ultimately I ditched the idea of going async within the first month.&lt;/p&gt;

&lt;p&gt;Unfortunately I wasn&amp;rsquo;t so quick to ditch the idea of NoSQL. I started with MongoDB and CouchDB, but had trouble compiling them with the Perl bindings. I planned on hosting on &lt;a href=&#34;http://aws.amazon.com./&#34;&gt;Amazon&lt;/a&gt; at that point, so I decided to give SimpleDB a go. The downside there was that there were no decent Perl bindings for SimpleDB, that weren&amp;rsquo;t entirely bare bones. So with that I created &lt;a href=&#34;https://metacpan.org/pod/SimpleDB::Class&#34;&gt;SimpleDB::Class&lt;/a&gt; (based loosely on &lt;a href=&#34;https://metacpan.org/pod/DBIx::Class&#34;&gt;DBIx::Class&lt;/a&gt;). The module works great. Unfortunately SimpleDB doesn&amp;rsquo;t. It&amp;rsquo;s super slow. So four months into development, with a whimper, I had to ditch my beloved &lt;a href=&#34;https://metacpan.org/pod/SimpleDB::Class&#34;&gt;SimpleDB::Class&lt;/a&gt; module. I&amp;rsquo;m glad I did. Development has been much faster and easier since then, and a good amount of thanks goes to &lt;a href=&#34;https://metacpan.org/pod/DBIx::Class&#34;&gt;DBIx::Class&lt;/a&gt; for that.&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;https://metacpan.org/pod/WWW::Facebook::API&#34;&gt;WWW::Facebook::API&lt;/a&gt; has been largely abandoned by its author. He told me he doesn&amp;rsquo;t have time to maintain it anymore. And I was having a hard time getting it to work anyway. As luck would have it Facebook just announced their Graph API, so I decided to take on that project, and build a Perl wrapper around it. And &lt;a href=&#34;https://metacpan.org/pod/Facebook::Graph&#34;&gt;Facebook::Graph&lt;/a&gt; was born. This enabled me to allow Facebook users to Single Sign On into the web site, the game, and also interact with their accounts.&lt;/p&gt;

&lt;p&gt;About the only other non-game piece that I had to invent of any consequence was &lt;a href=&#34;https://metacpan.org/pod/JSON::RPC::Dispatcher&#34;&gt;JSON::RPC::Dispatcher&lt;/a&gt;, which is a Plack enabled web service generator. There are some other JSON-RPC modules on CPAN, but for one reason or another I found them all completely insufficient. Mostly because of one or more of four reasons:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;It didn&amp;rsquo;t support JSON-RPC 2.0.&lt;/li&gt;
&lt;li&gt;Its documentation was so poor that I couldn&amp;rsquo;t make it work.&lt;/li&gt;
&lt;li&gt;It made me write a ton of code to simply expose a web service.&lt;/li&gt;
&lt;li&gt;It wasn&amp;rsquo;t PSGI/Plack compatible.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;With &lt;a href=&#34;https://metacpan.org/pod/JSON::RPC::Dispatcher&#34;&gt;JSON::RPC::Dispatcher&lt;/a&gt;, I can expose object-oriented code as web services with a single line of code.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m not very happy with the Perl modules that are out there for S3 right now. Right now we&amp;rsquo;re using a combination of &lt;a href=&#34;https://metacpan.org/pod/SOAP::Amazon::S3&#34;&gt;SOAP::Amazon::S3&lt;/a&gt;, and &lt;a href=&#34;https://metacpan.org/pod/Net::Amazon::S3&#34;&gt;Net::Amazon::S3&lt;/a&gt;, and neither are particularly good, at least for our purposes. They both work, but only for fairly basic purposes. Sometime in the near future I&amp;rsquo;ll either take on a massive overhaul of one of those modules, or write my own from scratch. Which remains to be seen depending on how open the authors of those modules are to patches.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What did you need from SimpleDB besides more speed?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;What I was hoping I&amp;rsquo;d get out of SimpleDB was three things: massive parallelism, hierarchical data structure storage, and schema-less storage to make my upgrade path easier. It provided all of those things.&lt;/p&gt;

&lt;p&gt;What I hadn&amp;rsquo;t anticipated was all the limitations it would place on me. Speed was just the nail in the coffin. It also puts pretty harsh limits on the amount of data per record, the amount of data returned per result set, and the complexity of queries. In addition, like most NoSQL databases it&amp;rsquo;s eventually consistent, which provides its own host of problems. I had worked my way around pretty much all that, and then finally hit the performance bottleneck.&lt;/p&gt;

&lt;p&gt;At that point I knew I had to make a change, because I wouldn&amp;rsquo;t be able to make up the difference in parallelism. For example, in order to process functions on a building, I would need planet data, and empire data in addition to the building data. But I wouldn&amp;rsquo;t know what empire or planet to fetch until I fetched the building, which meant I&amp;rsquo;d have to do serial processing. And I couldn&amp;rsquo;t cache all the data for the empire and the planet in the building (or vice versa) because of the limits on the amount of data allowed to be stored per record. My two options were: 1) Bring everything forward into memcached, which has its own problems because I&amp;rsquo;d have to create an indexing system; 2) Move to a relational database.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;When did you start using &lt;a href=&#34;http://plackperl.org/&#34;&gt;Plack&lt;/a&gt;?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;I first heard about Plack late last year when one of the contributors to WebGUI did an initial test implementation (&lt;a href=&#34;http://blog.patspam.com/2009/plebgui-webgui-meets-plack&#34;&gt;PlebGUI&lt;/a&gt;) to see if we could use it in WebGUI. After seeing how cool it was I knew that WebGUI 8 had to have it, and all my future projects would also use it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What&amp;rsquo;s been the biggest benefit for you?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The benefits are so huge that they are hard to enumerate, so I&amp;rsquo;ll pick the top 3 or 4. For the Lacuna Expanse, the main benefit was ease of development. There were no longer any hoops to jump through (the mod_perl landscape can be tricky to navigate). Sometime later Starman came out and that gave me an instant boost to performance, which was also nice. For WebGUI the middleware components were instrumental. They allowed us to eliminate a lot of code we previously had to write ourselves rather than using shared libraries. In addition, just switching from mod_perl 2 to Starman (no other changes), gave us a 300% performance boost.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You seem to be comfortable using a lot of new technologies with a reasonable amount of traffic. How do you see the risks and the rewards?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;First and foremost Miyagawa, who wrote Starman and much of Plack, is my personal Perl hero. It seems like everything he writes is absolute gold. So the fact that he wrote it adds some confidence.&lt;/p&gt;

&lt;p&gt;But you&amp;rsquo;re right, in general I&amp;rsquo;m not averse to using new technologies. The problem with &amp;ldquo;tried and true&amp;rdquo; is that it&amp;rsquo;s often &amp;ldquo;old and stale&amp;rdquo;. So from my perspective, there are just as many risks choosing proven technologies as there are new ones. That doesn&amp;rsquo;t mean you can blindly adopt new technologies, but you should be on the lookout for them. The rest of the risk/reward decision comes from my business experience: Change is inevitable. If you try something and it doesn&amp;rsquo;t work out, so what? Sure it&amp;rsquo;s going to cost you some time/money, but maintaining antiquated systems costs a lot of money too. These days the pace of technology moves too quickly to rest on tried and true alone.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Are you comfortable with the risk that you&amp;rsquo;ll run into maturity problems and can patch them or work around them, or do you think that despite their relative youth, they&amp;rsquo;re very capable for your purposes?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the thing. When you&amp;rsquo;re running a technology based business, the only thing you can plan for is that things will change.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s use scalability as an example. If you try to build a system that will infinitely scale before you have any users then you&amp;rsquo;ll spend a lot of time and money on something that may never get any users. At the same time, if you put no time into planning for some amount of scaling, then you won&amp;rsquo;t have enough breathing room to keep your users happy while you refactor.&lt;/p&gt;

&lt;p&gt;Likewise you can&amp;rsquo;t anticipate all the features you&amp;rsquo;ll ever need, because user&amp;rsquo;s desires are hard to predict. And because of this, at some point you&amp;rsquo;ll likely make a fundamental flaw in your architecture that will require at least a partial rewrite of your software. This is very much a business decision. Most developers I know cry when I say that, because most believe that it&amp;rsquo;s both possible and desirable to reach design/implementation nirvana. The fact is that users don&amp;rsquo;t care if your APIs are perfect. They care if your software does what they need it to do. From a business perspective it&amp;rsquo;s often more profitable to build something quickly and then continually refactor or even rewrite it to match demand.&lt;/p&gt;

&lt;p&gt;I say all of this to make the point that if a particular new technology doesn&amp;rsquo;t work out like we expected it to, then we&amp;rsquo;ll simply replace it in the next iteration. If you go into the project with that mentality you&amp;rsquo;ll likely be more successful.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What&amp;rsquo;s the basic architecture of The Lacuna Expanse?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;The basic software architecture looks like:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2010_10_colonizing-the-lacuna-expanse-with-perl/arch.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2010_10_colonizing-the-lacuna-expanse-with-perl/arch_small.png&#34; alt=&#34;basic architecture of The Lacuna Expanse&#34; /&gt;&lt;/a&gt;
Basically per server configurable game rules go into various &lt;a href=&#34;https://metacpan.org/pod/Config::JSON&#34;&gt;Config::JSON&lt;/a&gt; config files. &lt;a href=&#34;https://metacpan.org/pod/DBIx::Class&#34;&gt;DBIx::Class&lt;/a&gt; and MySQL handle all of the game data storage and querying. Memcached sits off to the side and handles lock contentions, limit contentions, session management, and other server coordination communication. Unfortunately, not much can actually be cached due to the dynamic nature of the game, unless I was willing to cache basically everything, which I&amp;rsquo;m not. And all the static stuff, like images, JavaScript, and CSS files get served up from CloudFront. We also push our RSS feeds and other semi-static game content out to S3.&lt;/p&gt;

&lt;p&gt;The game engine itself is basically an MVC setup built with Moose. &lt;a href=&#34;https://metacpan.org/pod/DBIx::Class&#34;&gt;DBIx::Class&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/Config::JSON&#34;&gt;Config::JSON&lt;/a&gt; act as the model. Some custom Moose objects tied to &lt;a href=&#34;https://metacpan.org/pod/Memcached::libmemcached&#34;&gt;Memcached::libmemcached&lt;/a&gt; act as the controller handling session management, privileges, etc. And &lt;a href=&#34;https://metacpan.org/pod/JSON::RPC::Dispatcher&#34;&gt;JSON::RPC::Dispatcher&lt;/a&gt; acts as the view.&lt;/p&gt;

&lt;p&gt;The basic server architecture looks like this:&lt;/p&gt;

&lt;p&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2010_10_colonizing-the-lacuna-expanse-with-perl/server.png&#34;&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2010_10_colonizing-the-lacuna-expanse-with-perl/server_small.png&#34; alt=&#34;server architecture of The Lacuna Expanse&#34; /&gt;&lt;/a&gt;
Any of the server nodes can be set up in either a clustered or load balanced formation to handle traffic growth.&lt;/p&gt;

&lt;p&gt;And finally we use &lt;a href=&#34;http://github.com/&#34;&gt;Github&lt;/a&gt; as our deployment system. We use its service hooks feature to trigger pushing new content to S3/Cloudfront and code to the game servers.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How many people are working on this?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Six, plus a bunch of play testers. One artist named &lt;a href=&#34;http://ryanknope.com/&#34;&gt;Ryan Knope&lt;/a&gt;; plus a part time helper, Keegan Runde, who is the son of one of the other developers. One on iPhone development, named Kevin Runde. Two on Web Client development John Rozeske and Graham Knop. Myself on server development. And myself and my business partner Jamie Vrbsky on game mechanics development.&lt;/p&gt;

&lt;p&gt;We started development in January 2010, and officially launched the game on October 4, 2010. Now that we&amp;rsquo;ve launched, I&amp;rsquo;ve brought in one of my other business partners, Tavis Parker, to help out with marketing the game. And we&amp;rsquo;re still pushing forward on new releases. We hope to have our first expansion for the game, called &amp;ldquo;Enemy Within&amp;rdquo;, out sometime in Q1 2011.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How do you manage your development process?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re very loose on management.&lt;/p&gt;

&lt;p&gt;We basically have a strategy meeting every 2 weeks at a local pub, where we discuss whatever needs to be discussed in person. Beyond that we have a play testers mailing list, a developers mailing list, and a defect tracking system that we use internally. And other than that communicate through Skype and email.&lt;/p&gt;

&lt;p&gt;We manage all of our code and content through various public and private github repositories. We share documents and art mockups using &lt;a href=&#34;http://dropbox.com/&#34;&gt;Dropbox&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;I publish all the JSON-RPC APIs out using POD (nicely formatted using &lt;a href=&#34;https://metacpan.org/pod/Pod::Simple::HTML&#34;&gt;Pod::Simple::HTML&lt;/a&gt;) to our play testers server, which is what the client guys develop against. And then ultimately once vetted and implemented by our client guys, the APIs are pushed out to the public server here at &lt;a href=&#34;http://us1.lacunaexpanse.com/api/&#34;&gt;http://us1.lacunaexpanse.com/api/&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;What little project management and coordination we need is handled by me emailing back and forth.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;How often are your releases? What&amp;rsquo;s the breakdown between bugfixes and new development?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;For the Lacuna Expanse we&amp;rsquo;re doing releases about 4 or 5 times a week. 1 or 2 of them contain some new features, and the rest are bug fixes. However, TLE is very new. In the beginning it&amp;rsquo;s very important to react quickly to your users needs because they often find bugs you didn&amp;rsquo;t, or have feature ideas that are almost fundamental after you hear them, but you never thought of them during the development process. By the end of the year our development cycle will slow down quite a bit, probably to once per week.&lt;/p&gt;

&lt;p&gt;For WebGUI we release approximately once per week, and those releases are primarily bug fixes. We generally do about 2 major releases per year that are primarily new features.&lt;/p&gt;

&lt;p&gt;For The Game Crafter we&amp;rsquo;ve stopped doing releases, except for the occasional bug fix because we&amp;rsquo;re coming into the holiday season. Starting in January we&amp;rsquo;re going to get going on a complete rewrite (about a six month process), which will quadruple our feature set, give us about a 700% performance gain, and allow us to scale with the growing demands our customers are placing on us.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Recruit existing Perl developers in your area, work with people you&amp;rsquo;ve worked with before, or hire good people and train them?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;All of the above. When you&amp;rsquo;re looking to hire someone you should hire the best person you can afford to hire. In our case this means we&amp;rsquo;ve decided to design our businesses around telecommuting. We still maintain a small office, and still hire locally when we can, and we even provide incentives for our employees to move to Madison if they so desire, but we never throw out a resume based upon location, what schools they attended, or whether or not they&amp;rsquo;ve happened to work with the particular modules and technologies we&amp;rsquo;re working with.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I keep an eye on one of the alliances in the game populated by a lot of well- known Perl developers, and they seem to be pushing the limits of the public API. I know you made this API public for a reason (and increased the call limit)&amp;ndash;but do you foresee an endgame where the best client automation wins, or do you expect that the game strategy will be malleable such that clever players have an edge over automation?&lt;/strong&gt;&lt;/p&gt;

&lt;p&gt;Automation has its advantages certainly. It&amp;rsquo;s great for getting the mundane crap out of the way.&lt;/p&gt;

&lt;p&gt;Most games spend a lot of time and effort doing everything they can to prevent people from automating their game. The trouble is that you end up wasting a lot of effort trying to stop smart people from being smart. If they really want to automate something they will find a way around your restrictions. It&amp;rsquo;s a never ending arms race.&lt;/p&gt;

&lt;p&gt;In our case we decided to embrace these people. Better and better tools will come along and ultimately that means these people are adding features to our game that we didn&amp;rsquo;t have to write. Because eventually the tools will get simple enough that your average Joe can run them.&lt;/p&gt;

&lt;p&gt;As far as the game is concerned it doesn&amp;rsquo;t make a bit of difference that you can use a tool to push a button in the game, rather than pushing the button yourself. You still have to follow the same rules. It takes a certain amount of time to happen, you have to spend a certain amount of resources, etc. When it comes right down to it, someone still has to make all of the important decisions, and that&amp;rsquo;s not likely going to be a tool anytime soon. You have to decide what buildings to upgrade in what order, what ships to build, who to attack, how to defend, etc. And once the next expansion comes out, you&amp;rsquo;ll have to work with your team mates to build a space station, enact laws, and defend your federation of planets. It will be very much a social endeavor.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building a 3D Engine in Perl, Part 4</title>
      <link>http://localhost:1313/pub/2005/08/04/3d_engine.html/</link>
      <pubDate>Thu, 04 Aug 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/08/04/3d_engine.html/</guid>
      <description>

&lt;p&gt;This article is the fourth in a series aimed at &lt;a href=&#34;http://localhost:1313/authors/geoff-broadwell&#34;&gt;building a full 3D engine in Perl&lt;/a&gt;. The &lt;a href=&#34;http://localhost:1313/pub/2004/12/01/3d_engine.html&#34;&gt;first article&lt;/a&gt; started with basic program structure and worked up to displaying a simple depth-buffered scene in an OpenGL window. The &lt;a href=&#34;http://localhost:1313/pub/2004/12/29/3d_engine.html&#34;&gt;second article&lt;/a&gt; followed with a discussion of time, view animation, SDL events, keyboard handling, and a nice chunk of refactoring. The &lt;a href=&#34;http://localhost:1313/pub/2005/02/17/3d_engine.html&#34;&gt;third article&lt;/a&gt; continued with screenshots, movement of the viewpoint, simple OpenGL lighting, and subdivided box faces.&lt;/p&gt;

&lt;p&gt;At the end of the last article, the engine was quite slow. This article shows how to locate the performance problem and what to do about it. Then it demonstrates how to apply the same new OpenGL technique a different way to create an on-screen frame rate counter. As usual, you can follow along with the code by downloading the &lt;a href=&#34;http://localhost:1313/media/_pub_2005_08_04_3d_engine/perl_opengl_examples_4.tar.gz&#34;&gt;sample code&lt;/a&gt;.&lt;/p&gt;

&lt;h3 id=&#34;sdl-perl-developments&#34;&gt;SDL_perl Developments&lt;/h3&gt;

&lt;p&gt;First, there is some good news&amp;ndash;Win32 users are no longer left out in the cold. Thanks to Wayne Keenan, SDL_perl 1.x now fully supports OpenGL on Win32, and prebuilt binaries are available. There are more details at the new &lt;a href=&#34;http://www.broadwell.org/graphics/sdl-perl/&#34;&gt;SDL_perl 1.x page&lt;/a&gt; on my site; browse the Subversion repository at &lt;a href=&#34;http://svn.openfoundry.org/sdlperl1/&#34;&gt;svn.openfoundry.org/sdlperl1&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;If you&amp;rsquo;d like to help in the efforts to improve SDL_perl 1.x, please come visit the &lt;a href=&#34;http://www.broadwell.org/graphics/sdl-perl/&#34;&gt;SDL_perl 1.x page&lt;/a&gt;, check out the &lt;a href=&#34;http://svn.openfoundry.org/sdlperl1/&#34;&gt;code&lt;/a&gt; and send me comments or patches, or ping me in &lt;code&gt;#sdlperl&lt;/code&gt; on &lt;code&gt;irc.freenode.net&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;benchmarking-the-engine&#34;&gt;Benchmarking the Engine&lt;/h3&gt;

&lt;p&gt;As I mentioned in the introduction, when last I left off, the engine pretty much crawled. It&amp;rsquo;s time to figure out why and figure out what to do about it. The right tool for the first job is a &lt;em&gt;profiler&lt;/em&gt;, which watches a running program and keeps track of the performance of each part of it. Perl&amp;rsquo;s native profiler is &lt;code&gt;dprofpp&lt;/code&gt;, which tracks time spent and call count for every subroutine in the program. Examining these numbers will reveal if the engine spends most of its time in one routine, which will then be the focus for optimization.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s best if these numbers are relatively repeatable from run to run, making it easy to compare profiles before and after a change. For a rendering engine, the easiest solution is a benchmark mode. In benchmark mode, the engine runs for a set period of time or number of frames, displaying a predefined scene or sequence. I chose to enable benchmark mode with a new setting in &lt;code&gt;init_conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;benchmark =&amp;gt; 1,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The engine already displays a constant scene as long as the user doesn&amp;rsquo;t press any keys; the remaining requirement is to quit after a set period.&lt;/p&gt;

&lt;p&gt;In previous articles I&amp;rsquo;ve simply hardcoded an out-of-time check into the rendering loop, but this time I opted for a more general approach, using &lt;em&gt;triggered events&lt;/em&gt;. Engine events so far have always come from SDL in response to external input, such as key presses and window close events. In contrast, the engine itself produces triggered events in response to changes in the state of the simulated world, such as a player attempting to open a door or attack an enemy.&lt;/p&gt;

&lt;p&gt;To gather these events, I added two new lines to the beginning of &lt;code&gt;do_events&lt;/code&gt;; the opening lines are now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub do_events
{
    my $self = shift;

    my $queue     = $self-&amp;gt;process_events;
    my $triggered = $self-&amp;gt;triggered_events;
    push @$queue, @$triggered;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After processing the SDL events with &lt;code&gt;process_events&lt;/code&gt; and stuffing the resulting commands into the &lt;code&gt;$queue&lt;/code&gt;, &lt;code&gt;do_events&lt;/code&gt; calls &lt;code&gt;triggered_events&lt;/code&gt; to gather commands from any pending internally generated events and adds them to the &lt;code&gt;$queue&lt;/code&gt;. &lt;code&gt;triggered_events&lt;/code&gt; can be pretty simple for now:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub triggered_events
{
    my $self = shift;

    my @queue;
    push @queue, &#39;quit&#39; if $self-&amp;gt;{conf}{benchmark} and
                           $self-&amp;gt;{world}{time} &amp;gt;= 5;
    return \@queue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty much a direct translation of the old hardcoded timeout code to the command queue concept. Normally &lt;code&gt;triggered_events&lt;/code&gt; simply returns an empty arrayref, indicating no events were triggered, and therefore no commands generated. Benchmark mode adds a quit command to the queue as soon as the world time reaches 5 seconds. Normal command processing in &lt;code&gt;do_events&lt;/code&gt; will take care of the rest.&lt;/p&gt;

&lt;h3 id=&#34;dprofpp-is-your-obtuse-friend&#34;&gt;&lt;code&gt;dprofpp&lt;/code&gt; is Your (Obtuse) Friend&lt;/h3&gt;

&lt;p&gt;With benchmark mode enabled, the engine runs under &lt;code&gt;dprofpp&lt;/code&gt;. The first step is to collect the profile data:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;dprofpp -Q -p step065
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;-p step065&lt;/code&gt; tells &lt;code&gt;dprofpp&lt;/code&gt; to *p*rofile the program named &lt;code&gt;step065&lt;/code&gt;, and &lt;code&gt;-Q&lt;/code&gt; tells it to *q*uit after collecting the data. &lt;code&gt;dprofpp&lt;/code&gt; ran &lt;code&gt;step065&lt;/code&gt;, collected the profile data, and stored it in a specially formatted text file named &lt;em&gt;tmon.out&lt;/em&gt; in the current directory.&lt;/p&gt;

&lt;p&gt;To turn the profile data into human-readable output, I used &lt;code&gt;dprofpp&lt;/code&gt; without any arguments. It crunched the collected data for a while and finally produced this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dprofpp
Exporter::Heavy::heavy_export_to_level has 4 unstacked calls in outer
Exporter::export_to_level has -4 unstacked calls in outer
Exporter::export has -12 unstacked calls in outer
Exporter::Heavy::heavy_export has 12 unstacked calls in outer
Total Elapsed Time = 4.838377 Seconds
  User+System Time = 1.498377 Seconds
Exclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 88.1   1.320  1.320      1   1.3200 1.3200  SDL::SetVideoMode
 38.1   0.571  0.774    294   0.0019 0.0026  main::draw_quad_face
 16.0   0.240  0.341      8   0.0300 0.0426  SDL::OpenGL::BEGIN
 13.0   0.195  0.195  64722   0.0000 0.0000  SDL::OpenGL::Vertex
 11.3   0.170  0.170      1   0.1700 0.1700  DynaLoader::dl_load_file
 9.34   0.140  0.020     12   0.0116 0.0017  Exporter::export
 6.67   0.100  0.100   1001   0.0001 0.0001  SDL::in
 4.00   0.060  0.060      1   0.0600 0.0600  SDL::Init
 3.34   0.050  0.847      8   0.0062 0.1059  main::BEGIN
 2.00   0.030  0.040      5   0.0060 0.0080  SDL::Event::BEGIN
 1.80   0.027  0.801     49   0.0005 0.0163  main::draw_cube
 1.47   0.022  0.022   2947   0.0000 0.0000  SDL::OpenGL::End
 1.33   0.020  0.020      1   0.0200 0.0200  warnings::BEGIN
 1.33   0.020  0.020     16   0.0012 0.0012  Exporter::as_heavy
 1.33   0.020  0.209      5   0.0040 0.0418  SDL::BEGIN
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;There are several problems with this output. The numbers are clearly silly (88 percent of its time spent in &lt;code&gt;SDL::SetVideoMode&lt;/code&gt;?), the statistics for the various &lt;code&gt;BEGIN&lt;/code&gt; blocks are inconsequential to the task and in the way, and the error messages at the top are rather disconcerting. To fix these issues, &lt;code&gt;dprofpp&lt;/code&gt; has the &lt;code&gt;-g&lt;/code&gt; option, which tells &lt;code&gt;dprofpp&lt;/code&gt; to only display statistics for a particular routine and its descendants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dprofpp -g main::main_loop
Total Elapsed Time = 4.952042 Seconds
  User+System Time = 0.812051 Seconds
Exclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 70.3   0.571  0.774    294   0.0019 0.0026  main::draw_quad_face
 24.0   0.195  0.195  64722   0.0000 0.0000  SDL::OpenGL::Vertex
 3.32   0.027  0.801     49   0.0005 0.0163  main::draw_cube
 2.71   0.022  0.022   2947   0.0000 0.0000  SDL::OpenGL::End
 1.23   0.010  0.010     49   0.0002 0.0002  SDL::OpenGL::Rotate
 1.11   0.009  0.009      7   0.0013 0.0013  main::prep_frame
 1.11   0.009  0.009     70   0.0001 0.0001  SDL::OpenGL::Color
 0.25   0.002  0.002   2947   0.0000 0.0000  SDL::OpenGL::Begin
 0.00       - -0.000      1        -      -  main::action_quit
 0.00       - -0.000      2        -      -  SDL::EventType
 0.00       - -0.000      2        -      -  SDL::Event::type
 0.00       - -0.000      7        -      -  SDL::GetTicks
 0.00       - -0.000      7        -      -  SDL::OpenGL::Clear
 0.00       - -0.000      7        -      -  SDL::OpenGL::GL_NORMALIZE
 0.00       - -0.000      7        -      -  SDL::OpenGL::GL_SPOT_EXPONENT
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You may have noticed that I specified &lt;code&gt;main::main_loop&lt;/code&gt; instead of just &lt;code&gt;main_loop&lt;/code&gt;. &lt;code&gt;dprofpp&lt;/code&gt; always uses fully qualified names and will give empty results if you use &lt;code&gt;main_loop&lt;/code&gt; without the &lt;code&gt;main::&lt;/code&gt; package qualifier.&lt;/p&gt;

&lt;p&gt;In this exclusive times view, the percentages in the first column and the row order depend only on the runtime of each routine, without respect to its children. Using just this view, I might have tried to optimize &lt;code&gt;draw_quad_face&lt;/code&gt; somehow, as it appears to be the most expensive routine by a large margin. That&amp;rsquo;s not the best approach, however, as an inclusive view (&lt;code&gt;-I&lt;/code&gt;) shows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dprofpp -I -g main::main_loop
Total Elapsed Time = 4.952042 Seconds
  User+System Time = 0.812051 Seconds
Inclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 100.       -  0.814      7        - 0.1163  main::do_frame
 99.9       -  0.812      1        - 0.8121  main::main_loop
 99.7       -  0.810      7        - 0.1158  main::draw_view
 99.2       -  0.806      7        - 0.1151  main::draw_frame
 98.6   0.027  0.801     49   0.0005 0.0163  main::draw_cube
 95.3   0.571  0.774    294   0.0019 0.0026  main::draw_quad_face
 24.0   0.195  0.195  64722   0.0000 0.0000  SDL::OpenGL::Vertex
 2.71   0.022  0.022   2947   0.0000 0.0000  SDL::OpenGL::End
 1.23   0.010  0.010     49   0.0002 0.0002  SDL::OpenGL::Rotate
 1.11   0.009  0.009     70   0.0001 0.0001  SDL::OpenGL::Color
 1.11   0.009  0.009      7   0.0013 0.0013  main::prep_frame
 0.25   0.002  0.002   2947   0.0000 0.0000  SDL::OpenGL::Begin
 0.00       - -0.000      1        -      -  main::action_quit
 0.00       - -0.000      2        -      -  SDL::EventType
 0.00       - -0.000      2        -      -  SDL::Event::type
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this view, &lt;code&gt;draw_quad_face&lt;/code&gt; looks even worse, because the first column now includes the time taken by all of the OpenGL calls inside of it, including tens of thousands of &lt;code&gt;glVertex&lt;/code&gt; calls. It seems that I should do something to speed it up, but at this point it&amp;rsquo;s not entirely clear how to simplify it or reduce the number of OpenGL calls it makes (other than reducing the subdivision level of each face, which would reduce rendering quality).&lt;/p&gt;

&lt;p&gt;Actually, there&amp;rsquo;s a better option. The real problem is that &lt;code&gt;draw_cube&lt;/code&gt; dominates the execution time, and &lt;code&gt;draw_quad_face&lt;/code&gt; dominates that. How about not calling &lt;code&gt;draw_cube&lt;/code&gt; (and therefore &lt;code&gt;draw_quad_face&lt;/code&gt;) &lt;em&gt;at all&lt;/em&gt; during normal rendering? It seems extremely wasteful to have to tell OpenGL how to render a cube face dozens of times each frame. If only there were a way to tell OpenGL to remember the cube definition once, and just refer to that definition each time the engine needs to draw it.&lt;/p&gt;

&lt;h3 id=&#34;display-lists&#34;&gt;Display Lists&lt;/h3&gt;

&lt;p&gt;I expect no one will find it surprising that OpenGL provides exactly this function, with the &lt;em&gt;display lists&lt;/em&gt; facility. A display list is a list of OpenGL commands to execute to perform some function. The OpenGL driver stores it (sometimes in a mildly optimized format) and further code refers to it by number. Later, the program can request that OpenGL run the commands in some particular list as many times as desired. Lists can even call other lists; a bicycle model might call a wheel display list twice, and the wheel display list might itself call a spoke display list dozens of times.&lt;/p&gt;

&lt;p&gt;I added &lt;code&gt;init_models&lt;/code&gt; to create display lists for each shape I want to model:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_models
{
    my $self = shift;

    my %models = (
        cube =&amp;gt; \&amp;amp;draw_cube,
    );
    my $count  = keys %models;
    my $base   = glGenLists($count);
    my %display_lists;

    foreach my $model (keys %models) {
        glNewList($base, GL_COMPILE);
        $models{$model}-&amp;gt;();
        glEndList;

        $display_lists{$model} = $base++;
    }

    $self-&amp;gt;{models}{dls} = \%display_lists;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;%models&lt;/code&gt; associates each model with the code needed to draw it. Because the engine already knows how to draw a cube, I simply reused &lt;code&gt;draw_cube&lt;/code&gt; here. The next two lines begin the work of building the display lists. The code first determines how many display lists it needs and then calls &lt;code&gt;glGenLists&lt;/code&gt; to allocate them. OpenGL numbers the allocated lists in sequence, returning the first number in the sequence (the &lt;em&gt;list base&lt;/em&gt;). For example, if the code had requested four lists, OpenGL might have numbered them 1051, 1052, 1053, and 1054, and would then return 1051 as the list base.&lt;/p&gt;

&lt;p&gt;For each defined model, &lt;code&gt;init_models&lt;/code&gt; calls &lt;code&gt;glNewList&lt;/code&gt; to tell OpenGL that it is ready to compile a new display list at the number &lt;code&gt;$base&lt;/code&gt;. OpenGL then prepares to convert any subsequent OpenGL calls to entries in the list, rather than rendering them immediately. If I had chosen &lt;code&gt;GL_COMPILE_AND_EXECUTE&lt;/code&gt; instead of &lt;code&gt;GL_COMPILE&lt;/code&gt;, OpenGL would perform the rendering and save the calls in the display list at the same time. &lt;code&gt;GL_COMPILE_AND_EXECUTE&lt;/code&gt; is useful for on-the-fly caching when code needs active rendering anyway. Because &lt;code&gt;init_models&lt;/code&gt; is simply precaching the rendering commands and nothing should render while this occurs, &lt;code&gt;GL_COMPILE&lt;/code&gt; is the better choice.&lt;/p&gt;

&lt;p&gt;The code then calls the drawing routine, which conveniently submits all of the OpenGL calls needed for the new list. The call to &lt;code&gt;glEndList&lt;/code&gt; then tells OpenGL to stop recording entries in the display list and return to normal operation. The model loop then records the display list number used by the current model in the &lt;code&gt;%display_lists&lt;/code&gt; hash, and increments &lt;code&gt;$base&lt;/code&gt; for the next iteration. After processing all of the models, &lt;code&gt;init_models&lt;/code&gt; saves &lt;code&gt;%display_lists&lt;/code&gt; into a new structure in the engine object.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;init&lt;/code&gt; calls &lt;code&gt;init_models&lt;/code&gt; just before &lt;code&gt;init_objects&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;init_models;
$self-&amp;gt;init_objects;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this initialization in place, the next step was to change &lt;code&gt;draw_view&lt;/code&gt; to draw from either a model or a draw routine. To do this, I replaced the &lt;code&gt;$o-&amp;gt;{draw}-&amp;gt;()&lt;/code&gt; call with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if ($o-&amp;gt;{model}) {
        my $dl = $self-&amp;gt;{models}{dls}{$o-&amp;gt;{model}};
        glCallList($dl);
    }
    else {
        $o-&amp;gt;{draw}-&amp;gt;();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If the object has an associated model, &lt;code&gt;draw_view&lt;/code&gt; looks up the display list in the hash created by &lt;code&gt;init_models&lt;/code&gt;, and then calls the list using &lt;code&gt;glCallList&lt;/code&gt;. Otherwise, &lt;code&gt;draw_view&lt;/code&gt; falls back to calling the object&amp;rsquo;s draw routine as before. A quick run confirmed that the fallback works and adding &lt;code&gt;init_models&lt;/code&gt; didn&amp;rsquo;t break anything, so it was safe to change &lt;code&gt;init_objects&lt;/code&gt; to use models instead of draw routines for the cubes. This involved replacement of just three lines&amp;ndash;I changed each copy of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        draw        =&amp;amp; \&amp;amp;draw_cube,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        model       =&amp;amp; &#39;cube&#39;,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Suddenly, the engine was &lt;em&gt;much&lt;/em&gt; faster and more responsive. A &lt;code&gt;dprofpp&lt;/code&gt; run confirmed this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dprofpp -Q -p step068

Done.
$ dprofpp -I -g main::main_loop
Total Elapsed Time = 4.053240 Seconds
  User+System Time = 0.973250 Seconds
Inclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 99.9       -  0.973      1        - 0.9733  main::main_loop
 86.5   0.024  0.842    413   0.0001 0.0020  main::do_frame
 58.1   0.203  0.566    413   0.0005 0.0014  main::draw_view
 56.9   0.016  0.554    413   0.0000 0.0013  main::draw_frame
 20.1   0.196  0.196    413   0.0005 0.0005  SDL::GLSwapBuffers
 19.3       -  0.188    413        - 0.0005  SDL::App::sync
 18.4       -  0.180    413        - 0.0004  main::end_frame
 16.7   0.163  0.163   2891   0.0001 0.0001  SDL::OpenGL::CallList
 9.14   0.028  0.089    413   0.0001 0.0002  main::do_events
 8.53   0.035  0.083    413   0.0001 0.0002  main::prep_frame
 6.68   0.008  0.065    413   0.0000 0.0002  main::process_events
 5.03   0.049  0.049   3304   0.0000 0.0000  SDL::OpenGL::GL_LIGHTING
 4.93   0.002  0.048    413   0.0000 0.0001  SDL::Event::pump
 4.73   0.046  0.046    413   0.0001 0.0001  SDL::PumpEvents
 4.11   0.012  0.040    413   0.0000 0.0001  main::update_time
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that I had to run &lt;code&gt;dprofpp -Q -p&lt;/code&gt; again with the new code before doing the analysis, or &lt;code&gt;dprofpp&lt;/code&gt; would have just reused the old &lt;code&gt;tmon.out&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The first thing to note in this report is that previously the engine only managed seven frames (calls to &lt;code&gt;do_frame&lt;/code&gt;) before timing out, but now managed 413 in the same time! Secondly, as intended, &lt;code&gt;main_loop&lt;/code&gt; never calls &lt;code&gt;draw_cube&lt;/code&gt;, having replaced all such calls with calls to &lt;code&gt;glCallList&lt;/code&gt;. Because of this it is no longer necessary to do many thousands of low-level OpenGL calls to draw the scene each frame, with the attendant Perl and XS overhead. Instead, the OpenGL driver handles all of those calls internally, with minimal overhead.&lt;/p&gt;

&lt;p&gt;This has the added advantage that it is now feasible to run the engine on one computer and display the window on another, as the OpenGL driver on the displaying computer saves the display lists. Once &lt;code&gt;init_models&lt;/code&gt; compiles the display lists, they are loaded into the display driver, and future frames require minimal network traffic to handle &lt;code&gt;glCallList&lt;/code&gt;. (Adventurous users running X can do this by logging in locally to the display computer, &lt;code&gt;ssh&lt;/code&gt;ing to the computer that has the engine and SDL_perl on it, and running the program there. If your &lt;code&gt;ssh&lt;/code&gt; has X11 forwarding turned on, your reward should be a local window. And there was much rejoicing.)&lt;/p&gt;

&lt;h3 id=&#34;an-fps-counter&#34;&gt;An FPS Counter&lt;/h3&gt;

&lt;p&gt;The measurements that &lt;code&gt;dprofpp&lt;/code&gt; performs have enough overhead to significantly reduce the engine&amp;rsquo;s apparent performance. (Even old hardware can do better than 80-100 FPS with this simple scene.) The overhead is necessary to get a detailed analysis, but when it comes time to show off, most users want to have a nice frame rate display showing the performance of the engine running as fast as it can.&lt;/p&gt;

&lt;p&gt;Making a frame rate display requires the ability to render text in front of the scene. The necessary pieces of that are:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;A font containing glyphs for the characters to display (at least 0 through 9).&lt;/li&gt;
&lt;li&gt;A font reader to load the font from a file into memory as bitmaps.&lt;/li&gt;
&lt;li&gt;A converter from raw bitmaps to a format that OpenGL can readily display.&lt;/li&gt;
&lt;li&gt;A way to render the proper bitmaps for a given string.&lt;/li&gt;
&lt;li&gt;A way to calculate the current frame rate.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;the-numbers-font&#34;&gt;The Numbers Font&lt;/h4&gt;

&lt;p&gt;There are hundreds of freely available fonts, but most of them are available only in fairly complex font formats such as TrueType and Type 1. Some versions of SDL_perl support these complex font formats, but this support has historically been frustratingly buggy or incomplete.&lt;/p&gt;

&lt;p&gt;Given the relatively simple requirement (render a single integer), I chose instead to create a very simple bitmapped font format just for this article. The font file is &lt;em&gt;numbers-7x11.txt&lt;/em&gt; in the examples tarball. It begins as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;7x11

30
..000..
.0...0.
.0...0.
0.....0
0.....0
0.....0
0.....0
0.....0
.0...0.
.0...0.
..000..

31
...0...
..00...
00.0...
...0...
...0...
...0...
...0...
...0...
...0...
...0...
0000000
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first line indicates the size of each character cell in the font; in this case, seven columns and 11 rows. The remaining chunks each consist of the character&amp;rsquo;s codepoint in hex followed by a bitmap represented as text&amp;ndash;&lt;code&gt;.&lt;/code&gt; represents a transparent pixel, and &lt;code&gt;0&lt;/code&gt; represents a rendered pixel. Empty lines separate chunks.&lt;/p&gt;

&lt;h4 id=&#34;the-font-reader&#34;&gt;The Font Reader&lt;/h4&gt;

&lt;p&gt;To read the glyph definitions into bitmaps, I first added &lt;code&gt;read_font_file&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub read_font_file
{
    my $self = shift;
    my $file = shift;

    open my $defs, &#39;&amp;lt;&#39;, $file
        or die &amp;quot;Could not open &#39;$file&#39;: $!&amp;quot;;
    local $/ = &#39;&#39;;

    my $header  = &amp;lt;$defs&amp;gt;;
    chomp($header);
    my ($w, $h) = split /x/ =&amp;amp; $header;

    my %bitmaps;
    while (my $def = &amp;lt;$defs&amp;gt;) {
        my ($hex, @rows) = grep /\S/ =&amp;amp; split /\n/ =&amp;amp; $def;

        @rows = map {tr/.0/01/; pack &#39;B*&#39; =&amp;amp; $_} @rows;

        my $bitmap           = join &#39;&#39; =&amp;amp; reverse @rows;
        my $codepoint        = hex $hex;

        $bitmaps{$codepoint} = $bitmap;
    }

    return (\%bitmaps, $w, $h);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;read_font_file&lt;/code&gt; begins by opening the font file for reading. It next requests paragraph slurping mode by setting &lt;code&gt;$/&lt;/code&gt; to &lt;code&gt;&#39;&#39;&lt;/code&gt;. In this mode, Perl automatically breaks up the font file at empty lines, with the header first followed by each complete glyph definition as a single chunk. Next, the routine reads the header, chomps it, and splits the cell size definition into width and height.&lt;/p&gt;

&lt;p&gt;With the preliminaries out of the way, &lt;code&gt;read_font_file&lt;/code&gt; creates a hash to store the finished bitmaps and enters a &lt;code&gt;while&lt;/code&gt; loop over the remaining chunks of the font file. Each glyph definition is split into a hex number and an array of bitmap rows; using &lt;code&gt;grep /\S/ =&amp;amp;&lt;/code&gt; ignores any trailing blank lines.&lt;/p&gt;

&lt;p&gt;The next line converts textual rows to real bitstrings. First, each transparent pixel (&lt;code&gt;.&lt;/code&gt;) becomes &lt;code&gt;0&lt;/code&gt;, and each rendered pixel (&lt;code&gt;0&lt;/code&gt;) turns into a &lt;code&gt;1&lt;/code&gt;. Feeding the resulting binary text string to &lt;code&gt;pack &#39;B*&#39;&lt;/code&gt; converts the binary into an actual bitstring, with the bits packed in starting from the high bit of each byte (as OpenGL prefers). The resulting bitstrings are stored back in &lt;code&gt;@rows&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Because OpenGL prefers bitmaps to start at the bottom and go up, the code reverses &lt;code&gt;@rows&lt;/code&gt; before &lt;code&gt;join&lt;/code&gt;ing to create the finished bitmap. The &lt;code&gt;hex&lt;/code&gt; operator converts the hex number to decimal to be the key for the newly created bitmap in the &lt;code&gt;%bitmaps&lt;/code&gt; hash.&lt;/p&gt;

&lt;p&gt;After parsing the whole font file, the function returns the bitmaps to the caller, along with the cell size metrics.&lt;/p&gt;

&lt;h4 id=&#34;speaking-opengl-s-language&#34;&gt;Speaking OpenGL&amp;rsquo;s Language&lt;/h4&gt;

&lt;p&gt;The bitmaps produced by &lt;code&gt;read_font_file&lt;/code&gt; are simply packed bitstrings, in this case 11 bytes long (one byte per seven-pixel row). Before using them to render strings, the engine must first load these bitmaps into OpenGL. This happens in the main &lt;code&gt;init_fonts&lt;/code&gt; routine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_fonts
{
    my $self  = shift;

    my %fonts = (
        numbers =&amp;amp; &#39;numbers-7x11.txt&#39;,
    );

    glPixelStore(GL_UNPACK_ALIGNMENT, 1);

    foreach my $font (keys %fonts) {
        my ($bitmaps, $w, $h) = 
            $self-&amp;gt;read_font_file($fonts{$font});

        my @cps    = sort {$a &amp;lt;=&amp;amp; $b} keys %$bitmaps;
        my $max_cp = $cps[-1];
        my $base   = glGenLists($max_cp + 1);

        foreach my $codepoint (@cps) {
            glNewList($base + $codepoint, GL_COMPILE);
            glBitmap($w, $h, 0, 0, $w + 2, 0,
                     $bitmaps-&amp;gt;{$codepoint});
            glEndList;
        }

        $self-&amp;gt;{fonts}{$font}{base} = $base;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;init_fonts&lt;/code&gt; opens with a hash associating each known font with a font file; at the moment, only the &lt;code&gt;numbers&lt;/code&gt; font is defined. The real work begins with the &lt;code&gt;glPixelStore&lt;/code&gt; call, which tells OpenGL that the rows for all bitmaps are tightly packed (along one-byte boundaries) rather than being padded, so that each row begins at even two-, four-, or eight-byte memory locations.&lt;/p&gt;

&lt;p&gt;The main font loop starts by calling &lt;code&gt;read_font_file&lt;/code&gt; to load the bitmaps for the current font into memory. The next line sorts the codepoints into &lt;code&gt;@cps&lt;/code&gt;, and the following line finds the maximum codepoint by simply taking the last one in &lt;code&gt;@cps&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;glGenLists&lt;/code&gt; call allocates display lists for codepoints 0 through &lt;code&gt;$max_cp&lt;/code&gt;, which will have numbers from &lt;code&gt;$base&lt;/code&gt; through &lt;code&gt;$base + $max_cp&lt;/code&gt;. For each codepoint defined by the font, the inner loop uses &lt;code&gt;glNewList&lt;/code&gt; to start compiling the appropriate list, &lt;code&gt;glBitmap&lt;/code&gt; to load the bitmap into OpenGL, and finally, &lt;code&gt;glEndList&lt;/code&gt; to finish compiling the list.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;glBitmap&lt;/code&gt; call has six parameters aside from the bitmap data itself (&lt;code&gt;$bitmaps-&amp;gt;{$codepoint}&lt;/code&gt;). The first two are the width and height of the bitmap in pixels, which &lt;code&gt;read_font_file&lt;/code&gt; conveniently provides. The next two define the &lt;em&gt;origin&lt;/em&gt; for the bitmap, counted from the lower-left corner. Bitmap fonts use a non-zero origin for several purposes, generally when the glyph extends farther left or below the &amp;ldquo;normal&amp;rdquo; lower-left corner. This may be because the glyph has a &lt;em&gt;descender&lt;/em&gt; (a part of the glyph that descends below the general line of text, as with the lowercase letters &amp;ldquo;p&amp;rdquo; and &amp;ldquo;y&amp;rdquo;), or perhaps because the font leans to the left. The simple code in &lt;code&gt;init_fonts&lt;/code&gt; assumes none of these special cases apply and sets the origin to (0,0).&lt;/p&gt;

&lt;p&gt;The last two parameters are the X and Y &lt;em&gt;increments&lt;/em&gt;, the distances that OpenGL should move along the X and Y axes before drawing the next character. Left-to-right languages use fonts with positive X and zero Y increments; right-to-left languages use negative X and zero Y. Top-to-bottom languages use zero X and negative Y. The increments must include both the width/height of the character itself and any additional distance needed to provide proper spacing. In this case, the rendering will be left to right. I wanted two extra pixels for spacing, so I set the X increment to width plus two, and the Y increment to zero.&lt;/p&gt;

&lt;p&gt;The last line of the outer loop simply saves the list base for the font to make it available later during rendering.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;init&lt;/code&gt; calls &lt;code&gt;init_fonts&lt;/code&gt; as usual, just after the call to &lt;code&gt;init_time&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;init_fonts;
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;text-rendering&#34;&gt;Text Rendering&lt;/h4&gt;

&lt;p&gt;The hard part is now done: parsing the font file and loading the bitmaps into OpenGL. The new &lt;code&gt;draw_fps&lt;/code&gt; routine calculates and renders the frame rate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_fps
{
    my $self   = shift;

    my $base   = $self-&amp;gt;{fonts}{numbers}{base};
    my $d_time = $self-&amp;gt;{world}{d_time} || 0.001;
    my $fps    = int(1 / $d_time);

    glColor(1, 1, 1);
    glRasterPos(10, 10, 0);
    glListBase($base);
    glCallListsScalar($fps);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The routine starts by retrieving the list base for the &lt;code&gt;numbers&lt;/code&gt; font, retrieving the world time delta for this frame, and calculating the current frames per second as one frame in &lt;code&gt;$d_time&lt;/code&gt; seconds. It takes a little care to make sure &lt;code&gt;$d_time&lt;/code&gt; is non-zero, even if the engine is running so fast that it renders a frame in less than a millisecond (the precision of SDL time handling); otherwise, the &lt;code&gt;$fps&lt;/code&gt; calculation would die with a divide-by-zero error.&lt;/p&gt;

&lt;p&gt;The OpenGL section begins by setting the current drawing color to white with a call to &lt;code&gt;glColor&lt;/code&gt;. The next line sets the &lt;em&gt;raster position&lt;/em&gt;, the window coordinates at which to place the origin of the next bitmap. After rendering each bitmap, the raster position is automatically updated using the bitmap&amp;rsquo;s X and Y increments so that the bitmaps will not overlap each other. In this case, &lt;code&gt;(10, 10, 0)&lt;/code&gt; sets the raster position ten pixels up and right from the lower-left corner of the window, with &lt;code&gt;Z=0&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The next two lines together actually call the appropriate display list in our bitmap font for each character in the &lt;code&gt;$fps&lt;/code&gt; string. &lt;code&gt;glCallListsScalar&lt;/code&gt; breaks the string into individual characters and calls the display list with the same number as the codepoint of the character. For example, for the &amp;ldquo;5&amp;rdquo; character (at codepoint 53 decimal), &lt;code&gt;glCallListsScalar&lt;/code&gt; calls display list 53. Unfortunately, there&amp;rsquo;s no guarantee that display list 53 actually will display a &amp;ldquo;5,&amp;rdquo; because the font&amp;rsquo;s list base may not be 0. If the font had a list base of 1500, for example, the code would need to call display list 1500+53=1553 to display the &amp;ldquo;5.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Rather than make the programmer do this calculation manually every time, OpenGL provides the &lt;code&gt;glListBase&lt;/code&gt; function, which sets the list base to use with &lt;code&gt;glCallLists&lt;/code&gt;. After the &lt;code&gt;glListBase&lt;/code&gt; call above, OpenGL will automatically offset every display list number specified with &lt;code&gt;glCallLists&lt;/code&gt; by &lt;code&gt;$base&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You may have noticed that in the code I use &lt;code&gt;glCallListsScalar&lt;/code&gt;, but the previous paragraph referred to &lt;code&gt;glCallLists&lt;/code&gt; instead. &lt;code&gt;glCallListsScalar&lt;/code&gt; is actually an SDL_perl extension (not part of core OpenGL) that provides an alternate calling convention for &lt;code&gt;glCallLists&lt;/code&gt; in Perl. Internally, SDL_perl implements both Perl routines using the same underlying C function in OpenGL (&lt;code&gt;glCallLists&lt;/code&gt;). SDL_perl provides two different calling conventions because Perl treats a string and an array of numbers as two different things, while C treats them as essentially the same.&lt;/p&gt;

&lt;p&gt;If you want to render a string, and all of the characters in the string have codepoints &amp;lt;= 255 decimal (single-byte character sets, and the ASCII subset of most variable-width character sets), you can use &lt;code&gt;glCallListsScalar&lt;/code&gt;, and it will do the right thing for you:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;glCallListsScalar($string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you simply want to render several display lists with a single call, and you&amp;rsquo;re not trying to render a string, use the standard version of &lt;code&gt;glCallLists&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;glCallLists(@lists);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you need to render a string, but it contains characters above codepoint 255, you have to use a more complex workaround:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;glCallLists(map ord($_) =&amp;amp; split // =&amp;amp; $string);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because the FPS counter merely renders ASCII digits, the first option works fine.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;draw_frame&lt;/code&gt; now ends with a call to &lt;code&gt;draw_fps&lt;/code&gt;, like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_frame
{
    my $self = shift;

    $self-&amp;gt;set_projection_3d;
    $self-&amp;gt;set_eye_lights;
    $self-&amp;gt;set_view_3d;
    $self-&amp;gt;set_world_lights;
    $self-&amp;gt;draw_view;
    $self-&amp;gt;draw_fps;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For now, I decided to turn off benchmark mode by changing the config setting in &lt;code&gt;init_config&lt;/code&gt; to &lt;code&gt;0&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    benchmark =&amp;amp; 0,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the font handling in place, and &lt;code&gt;draw_fps&lt;/code&gt; called each frame to display the frame rate in white in the lower-left corner, everything should be grand, as Figure 1 shows.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_04_3d_engine/step070.gif&#34; alt=&#34;drawing frame rate, take one&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;
&lt;em&gt;Figure 1. Drawing the frame rate&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Oops. There&amp;rsquo;s no frame rate display. Actually, it&amp;rsquo;s there, just &lt;em&gt;very&lt;/em&gt; faint. If you look very carefully (or turn your video card&amp;rsquo;s gamma up very high), you can just make out the frame rate display near the top of the window, above the big white box on the right. There are (at least) two problems&amp;ndash;the text is too dark and it&amp;rsquo;s in the wrong place.&lt;/p&gt;

&lt;p&gt;The first problem is reminiscent of the dark scene in the &lt;a href=&#34;http://localhost:1313/pub/2005/02/17/3d_engine.html&#34;&gt;last article&lt;/a&gt;, after enabling lighting but no lights. Come to think of it, there&amp;rsquo;s not much reason to have lighting enabled just to display stats, but the last object rendered by &lt;code&gt;draw_view&lt;/code&gt; left it on. To make sure lighting is off, I added a &lt;code&gt;set_lighting_2d&lt;/code&gt; routine, which &lt;code&gt;draw_frame&lt;/code&gt; now calls just before calling &lt;code&gt;draw_fps&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_lighting_2d
{
    glDisable(GL_LIGHTING);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_04_3d_engine/step071.gif&#34; alt=&#34;the unlit frame rate&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;
&lt;em&gt;Figure 2. The unlit frame rate&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Figure 2 is much better! With lighting turned off, the frame rate now renders in bright white as intended. The next problem is the incorrect position. Moving and rotating the viewpoint shows that while the digits always face the screen, their apparent position moves around (Figure 3).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_04_3d_engine/step071a.gif&#34; alt=&#34;moving frame rate&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;
&lt;em&gt;Figure 3. A moving frame rate&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It turns out that the current modelview and projection matrices transform the raster position set by &lt;code&gt;glRasterPos&lt;/code&gt;, just like the coordinates from a &lt;code&gt;glVertex&lt;/code&gt; call. That means OpenGL reuses whatever state the modelview and projection matrices are in.&lt;/p&gt;

&lt;p&gt;To get unaltered window coordinates, I need to use an orthographic projection (no foreshortening or other non-linear effects) matching the window dimensions. I also need to set an identity modelview matrix (so that the modelview matrix won&amp;rsquo;t transform the coordinates at all). All of this happens in &lt;code&gt;set_projection_2d&lt;/code&gt;, called just before &lt;code&gt;set_lighting_2d&lt;/code&gt; in &lt;code&gt;draw_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_projection_2d
{
    my $self = shift;

    my $w    = $self-&amp;gt;{conf}{width};
    my $h    = $self-&amp;gt;{conf}{height};

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity;
    gluOrtho2D(0, $w, 0, $h);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This routine first gathers the window width and height from the configuration hash. It then switches to the projection matrix (&lt;code&gt;GL_PROJECTION&lt;/code&gt;) and restores the identity state before calling &lt;code&gt;gluOrtho2D&lt;/code&gt; to create an orthographic projection matching the window dimensions. Finally, it switches back to the modelview matrix (&lt;code&gt;GL_MODELVIEW&lt;/code&gt;) and restores its identity state as well. The frame rate now renders at the intended spot near the lower-left corner (Figure 4).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_04_3d_engine/step072.gif&#34; alt=&#34;frame rate in the right spot&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;
&lt;em&gt;Figure 4. The frame rate in the correct position&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;There is another more subtle rendering problem, however, which you can see by moving the viewpoint forward a bit (Figure 5).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_04_3d_engine/step072a.gif&#34; alt=&#34;frame rate depth problems&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;
&lt;em&gt;Figure 5. Frame rate depth problems&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Notice how the &amp;ldquo;5&amp;rdquo; is partially cut off. The problem is that OpenGL compares the depth of the pixels in the thin yellow box to the depth of the pixels in the frame rate display, and finds that some of the pixels in the 5 are farther away than the pixels in the box. In effect, part of the 5 draws &lt;em&gt;inside&lt;/em&gt; the box. In fact, moving the viewpoint slightly to the left from this point will make the frame rate disappear altogether, hidden by the near face of the yellow box.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s not very good behavior from a statistics display that should appear to hover in front of the scene. The solution is to turn off OpenGL&amp;rsquo;s depth testing, using a new line at the end of &lt;code&gt;set_projection_2d&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;glDisable(GL_DEPTH_TEST);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this change, you can move the view anywhere without fear that the frame rate will be cut off or disappear entirely (Figure 6).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_04_3d_engine/step073.gif&#34; alt=&#34;position-independent frame rate&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;
&lt;em&gt;Figure 6. Position-independent frame rate&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;too-fast&#34;&gt;Too Fast&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s yet another problem; this time, one that will require a change to the frame rate calculations. The frame rate shown in the above screenshots is either 333 or 500, but nothing else. On this system, the frames take between two and three milliseconds to render, but because SDL can only provide one-millisecond resolution, the time delta for a single frame will appear to be &lt;em&gt;exactly&lt;/em&gt; either .002 second or .003 second. 1/.002=500, and 1/.003=333, so the display is a blur, flashing back and forth between the two possible values.&lt;/p&gt;

&lt;p&gt;To get a more representative (and easier-to-read) value, the code must average frame rate over a number of frames. Doing this will allow the total measured time to be long enough to drown out the resolution deficiency of SDL&amp;rsquo;s clock.&lt;/p&gt;

&lt;p&gt;The first thing I needed was a routine to initialize the frame rate data to carry over multiple frames:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_fps
{
    my $self = shift;

    $self-&amp;gt;{stats}{fps}{cur_fps}    = 0;
    $self-&amp;gt;{stats}{fps}{last_frame} = 0;
    $self-&amp;gt;{stats}{fps}{last_time}  = $self-&amp;gt;{world}{time};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new &lt;code&gt;stats&lt;/code&gt; structure in the engine object will hold any statistics that the engine gathers about itself. To calculate FPS, the engine needs to remember the last frame for which it took a timestamp, as well as the timestamp for that frame. Because the engine calculates the frame rate only every few frames, it also saves the last calculated FPS value so that it can render it as needed. The &lt;code&gt;init_fps&lt;/code&gt; call, as usual, goes at the end of &lt;code&gt;init&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;init_fps;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new &lt;code&gt;update_fps&lt;/code&gt; routine now calculates the frame rate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_fps
{
    my $self      = shift;

    my $frame     = $self-&amp;gt;{state}{frame};
    my $time      = $self-&amp;gt;{world}{time};

    my $d_frames  = $frame - $self-&amp;gt;{stats}{fps}{last_frame};
    my $d_time    = $time  - $self-&amp;gt;{stats}{fps}{last_time};
    $d_time     ||= 0.001;

    if ($d_time &amp;gt;= .2) {
        $self-&amp;gt;{stats}{fps}{last_frame} = $frame;
        $self-&amp;gt;{stats}{fps}{last_time}  = $time;
        $self-&amp;gt;{stats}{fps}{cur_fps}    = int($d_frames / $d_time);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;update_fps&lt;/code&gt; starts by gathering the current frame number and timestamp, and calculating the deltas from the saved values. Again, &lt;code&gt;$d_time&lt;/code&gt; must default to 0.001 second to avoid possible divide-by-zero errors later on.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;if&lt;/code&gt; statement checks to see if enough time has gone by to result in a reasonably accurate frame rate calculation. If so, it sets the last frame number and timestamp to the current values and the current frame rate to &lt;code&gt;$d_frames / $d_time&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;update_fps&lt;/code&gt; call must occur early in the &lt;code&gt;main_loop&lt;/code&gt;, but after the engine has determined the new frame number and timestamp. &lt;code&gt;main_loop&lt;/code&gt; now looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub main_loop
{
    my $self = shift;

    while (not $self-&amp;gt;{state}{done}) {
        $self-&amp;gt;{state}{frame}++;
        $self-&amp;gt;update_time;
        $self-&amp;gt;update_fps;
        $self-&amp;gt;do_events;
        $self-&amp;gt;update_view;
        $self-&amp;gt;do_frame;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final change needed to enable the new more accurate display is in &lt;code&gt;draw_fps&lt;/code&gt;; the &lt;code&gt;$d_time&lt;/code&gt; lookup goes away and the &lt;code&gt;$fps&lt;/code&gt; calculation turns into a simple retrieval of the current value from the &lt;code&gt;stats&lt;/code&gt; structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $fps  = $self-&amp;gt;{stats}{fps}{cur_fps};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The more accurate calculation now makes it easy to see the difference between the frame rate for a simple view (Figure 7):&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_04_3d_engine/step074.gif&#34; alt=&#34;frame rate for a simple view&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;
&lt;em&gt;Figure 7. Frame rate for a simple view&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;and the frame rate for a more complex view (Figure 8).&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_08_04_3d_engine/step074a.gif&#34; alt=&#34;frame rate for a complex view&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;
&lt;em&gt;Figure 8. Frame rate for a complex view&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;is-the-new-display-a-bottleneck&#34;&gt;Is the New Display a Bottleneck?&lt;/h4&gt;

&lt;p&gt;The last thing to do is to check that the shiny new frame rate display is not itself a major bottleneck. The easiest way to do that is to turn benchmark mode back on in &lt;code&gt;init_conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    benchmark =&amp;amp; 1,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After doing that, I ran the engine under &lt;code&gt;dprofpp&lt;/code&gt; again, and then analyzed the results, just as I had earlier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ dprofpp -Q -p step075

Done.
$ dprofpp -I -g main::main_loop
Total Elapsed Time = 3.943764 Seconds
  User+System Time = 1.063773 Seconds
Inclusive Times
%Time ExclSec CumulS #Calls sec/call Csec/c  Name
 100.       -  1.064      1        - 1.0638  main::main_loop
 94.6   0.006  1.007    384   0.0000 0.0026  main::do_frame
 85.2   0.019  0.907    384   0.0000 0.0024  main::draw_frame
 50.7   0.205  0.540    384   0.0005 0.0014  main::draw_view
 16.8   0.073  0.179    384   0.0002 0.0005  main::draw_fps
 15.4   0.095  0.164    384   0.0002 0.0004  main::set_projection_2d
 11.6   0.045  0.124    384   0.0001 0.0003  main::draw_axes
 10.9   0.116  0.116   2688   0.0000 0.0000  SDL::OpenGL::CallList
 8.74   0.013  0.093    384   0.0000 0.0002  main::end_frame
 7.52   0.003  0.080    384   0.0000 0.0002  SDL::App::sync
 7.24   0.077  0.077    384   0.0002 0.0002  SDL::GLSwapBuffers
 4.89   0.052  0.052   3072   0.0000 0.0000  SDL::OpenGL::PopMatrix
 4.70   0.023  0.050    384   0.0001 0.0001  main::update_view
 3.67   0.039  0.039   3456   0.0000 0.0000  SDL::OpenGL::GL_LIGHTING
 3.48   0.037  0.037    384   0.0001 0.0001  SDL::OpenGL::Begin
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As it currently stands, &lt;code&gt;draw_view&lt;/code&gt; takes half of the run time of &lt;code&gt;main_loop&lt;/code&gt;, and the combination of &lt;code&gt;set_projection_2d&lt;/code&gt; and &lt;code&gt;draw_fps&lt;/code&gt; takes about a third of the &lt;code&gt;main_loop&lt;/code&gt; time together. Is that good or bad news?&lt;/p&gt;

&lt;p&gt;&lt;code&gt;draw_view&lt;/code&gt; is so quick now because I&amp;rsquo;ve just optimized it. Now that it&amp;rsquo;s running so fast again, I can afford to add more features and perhaps make a more complex scene, either of which will make &lt;code&gt;draw_view&lt;/code&gt; take a larger percentage of the time again. Also, &lt;code&gt;set_projection_2d&lt;/code&gt; is necessary for any in-window statistics, debugging, or HUD (heads up display) anyway, so the time spent there will not go to waste.&lt;/p&gt;

&lt;p&gt;That leaves &lt;code&gt;draw_fps&lt;/code&gt;, taking about one sixth of &lt;code&gt;main_loop&lt;/code&gt;&amp;rsquo;s run time. That&amp;rsquo;s perhaps a bit larger than I&amp;rsquo;d like, but not large enough to warrant additional effort yet. I&amp;rsquo;ll save my energy for the next set of features.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;During this article, I covered several concepts relating to engine performance: adding a benchmark mode; profiling with &lt;code&gt;dprofpp&lt;/code&gt;; using display lists to optimize slow, repetitive rendering tasks; and using display lists, bitmapped fonts, and averaging to produce a smooth frame rate display. I also added a stub for a triggered events subsystem, which I&amp;rsquo;ll come back to in a future article.&lt;/p&gt;

&lt;p&gt;With these performance improvements, the engine is ready for the next new feature, textured surfaces, which will be the main topic for the next article.&lt;/p&gt;

&lt;p&gt;Until then, enjoy yourself and have fun hacking!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building a 3D Engine in Perl, Part 3</title>
      <link>http://localhost:1313/pub/2005/02/17/3d_engine.html/</link>
      <pubDate>Thu, 17 Feb 2005 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2005/02/17/3d_engine.html/</guid>
      <description>

&lt;p&gt;This article is the third in a series aimed at &lt;a href=&#34;http://localhost:1313/authors/geoff-broadwell&#34;&gt;building a full 3D engine in Perl&lt;/a&gt;. The &lt;a href=&#34;http://localhost:1313/pub/2004/12/01/3d_engine.html&#34;&gt;first article&lt;/a&gt; started with basic program structure and worked up to displaying a simple depth-buffered scene in an OpenGL window. The &lt;a href=&#34;http://localhost:1313/pub/2004/12/29/3d_engine.html&#34;&gt;second article&lt;/a&gt; followed with a discussion of time, view animation, SDL events, keyboard handling, and a nice chunk of refactoring.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: see also the next article in the series, &lt;a href=&#34;http://localhost:1313/pub/2005/08/04/3d_engine.html&#34;&gt;profiling your application&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Later in this article, I&amp;rsquo;ll discuss movement of the view position, continue the refactoring work by cleaning up &lt;code&gt;draw_view&lt;/code&gt;, and begin to improve the look of our scene using OpenGL lighting and materials. Before I cover that, your feedback to the previous articles has included a couple of common requests: screenshots and help with porting issues. If you&amp;rsquo;re having problems running SDL_Perl and the &lt;a href=&#34;http://localhost:1313/media/_pub_2005_02_17_3d_engine/perl_opengl_3_examples.tar.gz&#34;&gt;sample code&lt;/a&gt; from these articles on your system, or might be able to help the Mac OS X and Win32 readers, take a look at the next section. Otherwise, skip down to the &lt;a href=&#34;#Screenshots&#34;&gt;Screenshots&lt;/a&gt; section, where the main article begins.&lt;/p&gt;

&lt;h3 id=&#34;known-porting-issues&#34;&gt;Known Porting Issues&lt;/h3&gt;

&lt;h4 id=&#34;general&#34;&gt;General&lt;/h4&gt;

&lt;p&gt;Some versions of SDL_Perl require that the program load SDL::Constants to recognize &lt;code&gt;SDL_QUIT&lt;/code&gt; and other constants. As this change should be transparent to other users, I have merged that into the latest version of the sample code, retroactive to the first use of an SDL constant.&lt;/p&gt;

&lt;h4 id=&#34;freebsd&#34;&gt;FreeBSD&lt;/h4&gt;

&lt;p&gt;See the suggestions at the beginning of the &lt;a href=&#34;http://localhost:1313/pub/2004/12/29/3d_engine.html&#34;&gt;second article&lt;/a&gt;.&lt;/p&gt;

&lt;h4 id=&#34;mac-os-x&#34;&gt;Mac OS X&lt;/h4&gt;

&lt;p&gt;I spent some time research the porting issues on Mac OS X but am as yet unable to figure out a simple procedure for building SDL_Perl from scratch. Recent emails on the &lt;em&gt;sdl-devel&lt;/em&gt; mailing list seem to indicate that Mac OS X builds for recent SDL_Perl sources are problematic right now, but older releases seem to be even worse. There have been some packaging attempts in the past, but none that I have found so far install a fully configured set of SDL_Perl libraries into the system &lt;code&gt;perl&lt;/code&gt;. I&amp;rsquo;m no Mac porting expert, so I appreciate any help on this; please post a comment in this month&amp;rsquo;s article discussion if you have a suggestion or solution.&lt;/p&gt;

&lt;h4 id=&#34;slackware&#34;&gt;Slackware&lt;/h4&gt;

&lt;p&gt;According to comments by Federico (&lt;code&gt;ironfede&lt;/code&gt;) in last month&amp;rsquo;s &lt;a href=&#34;http://localhost:1313/pub/2004/12/29/3d_engine.html?page=last#thread&#34;&gt;article discussion&lt;/a&gt;, Slackware ships with a version of SDL_Perl that requires SDL::Constants. This is not an issue for the current version of the sample code, which I fixed as mentioned above in the &lt;a href=&#34;#General&#34;&gt;General&lt;/a&gt; issues paragraph.&lt;/p&gt;

&lt;h4 id=&#34;win32&#34;&gt;Win32&lt;/h4&gt;

&lt;p&gt;Win32 porting went as did Mac OS X porting. I was quite excited when chromatic pointed me to some old Win32 PPM packages, but sadly they don&amp;rsquo;t include a working version of SDL::OpenGL. Building manually was &amp;ldquo;interesting&amp;rdquo; at best, as I have no access to a Microsoft compiler and precious little experience using &lt;code&gt;gcc&lt;/code&gt; under Win32. As with the Mac folks, I appreciate any help from the readers. Please post a comment in this month&amp;rsquo;s article discussion if you have a suggestion or solution for your fellows.&lt;/p&gt;

&lt;h3 id=&#34;screenshots&#34;&gt;Screenshots&lt;/h3&gt;

&lt;p&gt;Thankfully, screenshots are much easier to handle than porting issues. I&amp;rsquo;d like the user to be able to take a screenshot whenever desired. The obvious way to accomplish that is to bind the screenshot action to a key; I chose function key &lt;code&gt;F4&lt;/code&gt; at random. First I added it to the &lt;code&gt;bind&lt;/code&gt; hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        bind   =&amp;gt; {
            escape =&amp;gt; &#39;quit&#39;,
            f4     =&amp;gt; &#39;screenshot&#39;,
            left   =&amp;gt; &#39;+yaw_left&#39;,
            right  =&amp;gt; &#39;+yaw_right&#39;,
            tab    =&amp;gt; &#39;+look_behind&#39;,
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new key must have an action routine, so I altered that lookup hash as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $self-&amp;gt;{lookup}{command_action} = {
          quit         =&amp;gt; \&amp;amp;action_quit,
          screenshot   =&amp;gt; \&amp;amp;action_screenshot,
        &#39;+yaw_left&#39;    =&amp;gt; \&amp;amp;action_move,
        &#39;+yaw_right&#39;   =&amp;gt; \&amp;amp;action_move,
        &#39;+look_behind&#39; =&amp;gt; \&amp;amp;action_move,
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I need to wait until drawing completes for the entire scene before I can take a snapshot, but event processing happens before drawing begins. To work around this, I set a state variable marking that the user has requested a screenshot, rather than perform the screenshot immediately:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub action_screenshot
{
    my $self = shift;

    $self-&amp;gt;{state}{need_screenshot} = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code checks this state variable in a new line at the end of &lt;code&gt;end_frame&lt;/code&gt;, after the drawing has completed and it has synced the screen with the image written into OpenGL&amp;rsquo;s color buffer:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub end_frame
{
    my $self = shift;

    $self-&amp;gt;{resource}{sdl_app}-&amp;gt;sync;
    $self-&amp;gt;screenshot if $self-&amp;gt;{state}{need_screenshot};
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;screenshot&lt;/code&gt; routine is surprisingly short but dense:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub screenshot
{
    my $self = shift;

    my $file = &#39;screenshot.bmp&#39;;
    my $w    = $self-&amp;gt;{conf}{width};
    my $h    = $self-&amp;gt;{conf}{height};

    glReadBuffer(GL_FRONT);
    my $data = glReadPixels(0, 0, $w, $h, GL_BGR,
                            GL_UNSIGNED_BYTE);
    SDL::OpenGL::SaveBMP($file, $w, $h, 24, $data);

    $self-&amp;gt;{state}{need_screenshot} = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The routine starts by specifying a filename for the screenshot and gathering the width and height of the screen. The real work begins with the call to &lt;code&gt;glReadBuffer&lt;/code&gt;. Depending on the OpenGL driver, the hardware, and a number of advanced settings, OpenGL may have provided &lt;em&gt;several&lt;/em&gt; color buffers in which to draw and read images. In fact, the default behavior on most systems is to draw onto one buffer, known as the &lt;em&gt;back buffer&lt;/em&gt;, and display a separate buffer, known as the &lt;em&gt;front buffer&lt;/em&gt;. After completing the drawing for each frame, the &lt;code&gt;SDL::App::sync&lt;/code&gt; call moves the image from the back buffer to the front buffer so the user can see it. Behind the scenes, OpenGL generally handles this in one of two different ways, depending on the underlying implementation. Software OpenGL implementations, such as Mesa, copy the data from the back buffer to the front buffer. Hardware-accelerated systems can swap internal pointers so that the back buffer becomes the front buffer and vice versa. As you can imagine, this is much faster.&lt;/p&gt;

&lt;p&gt;This extra work brings a great benefit. Without double buffering, as soon as one frame completes, the next frame immediately clears the screen to black and starts drawing again from scratch. Depending on the relative speed difference between the user&amp;rsquo;s monitor and the application, this would probably appear to the user as a flickering, dark, perpetually half-drawn scene. With double buffering, this problem is almost gone. The front buffer shows a solid stable image while all of the drawing is done on the back buffer. Once the drawing completes, it takes at most a few milliseconds to sync up and start displaying the new frame. To the human eye, the animation appears solid, bright, and (hopefully) smooth.&lt;/p&gt;

&lt;p&gt;In this case, I want to make sure that I take a screenshot of exactly the same image the user sees, so I tell OpenGL that I want to read the image in the front buffer (&lt;code&gt;GL_FRONT&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;At this point, it&amp;rsquo;s safe to read the image data into a Perl buffer in the proper format. The first four arguments to &lt;code&gt;glReadPixels&lt;/code&gt; specify the lower-left corner and size of the sub-image to read. The next two arguments together tell OpenGL what format I would like for the data. I specify that I want to read the entire window and that I want the data in the correct format for a BMP file&amp;ndash;one unsigned byte for each of the red, green, and blue color channels for each pixel, but in reverse order.&lt;/p&gt;

&lt;p&gt;Once I have the data from OpenGL I use the SDL_Perl utility routine &lt;code&gt;SaveBMP&lt;/code&gt; to save the image into a file. The arguments are the filename, image width, image height, color depth (24 bits per pixel), and data buffer. Finally, the routine resets the &lt;code&gt;need_screenshot&lt;/code&gt; state flag and returns.&lt;/p&gt;

&lt;p&gt;At this point you should be able to take a screenshot each time you press the &lt;code&gt;F4&lt;/code&gt; key. Of course, I&amp;rsquo;d like to show several screenshots during this article as the code progresses. The current code overwrites the previous screenshot file every time I request a new one. Because I number each runnable version of the code, I used a quick workaround resulting in a different screenshot filename for each code step. I first load one of the core Perl modules to strip directories from a path:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use File::Basename;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I use the filename of the script itself as part of my screenshot filename:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $file = basename($0) . &#39;.bmp&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This may be all you need for your application, or you may want to add some code to number each file uniquely. This code is enough to fix my problem, so I&amp;rsquo;ve left the more powerful version as an exercise for the reader.&lt;/p&gt;

&lt;p&gt;Here then is the first screenshot:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step042.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The observant reader will notice that this image is not a BMP file; it&amp;rsquo;s a PNG image, which is both much smaller than a BMP and more friendly to web standards. There are many tools available that can perform this conversion. Any good image editor can do it. In this case that&amp;rsquo;s overkill&amp;ndash;I instead used the &lt;code&gt;convert&lt;/code&gt; program from the &lt;a href=&#34;http://www.imagemagick.org/&#34;&gt;ImageMagick&lt;/a&gt; suite of utilities:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;convert step042.bmp step042.png
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;moving-the-viewpoint&#34;&gt;Moving the Viewpoint&lt;/h3&gt;

&lt;p&gt;That view is more than a tad overplayed. The user can&amp;rsquo;t even move the viewpoint to see the back or sides of the scene. It&amp;rsquo;s time to change that. I started by defining some new key bindings:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        bind   =&amp;gt; {
            escape =&amp;gt; &#39;quit&#39;,
            f4     =&amp;gt; &#39;screenshot&#39;,
            a      =&amp;gt; &#39;+move_left&#39;,
            d      =&amp;gt; &#39;+move_right&#39;,
            w      =&amp;gt; &#39;+move_forward&#39;,
            s      =&amp;gt; &#39;+move_back&#39;,
            left   =&amp;gt; &#39;+yaw_left&#39;,
            right  =&amp;gt; &#39;+yaw_right&#39;,
            tab    =&amp;gt; &#39;+look_behind&#39;,
        }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then updated the &lt;code&gt;command_action&lt;/code&gt; &lt;code&gt;lookup&lt;/code&gt; hash to handle these as movement keys:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $self-&amp;gt;{lookup}{command_action} = {
          quit          =&amp;gt; \&amp;amp;action_quit,
          screenshot    =&amp;gt; \&amp;amp;action_screenshot,
        &#39;+move_left&#39;    =&amp;gt; \&amp;amp;action_move,
        &#39;+move_right&#39;   =&amp;gt; \&amp;amp;action_move,
        &#39;+move_forward&#39; =&amp;gt; \&amp;amp;action_move,
        &#39;+move_back&#39;    =&amp;gt; \&amp;amp;action_move,
        &#39;+yaw_left&#39;     =&amp;gt; \&amp;amp;action_move,
        &#39;+yaw_right&#39;    =&amp;gt; \&amp;amp;action_move,
        &#39;+look_behind&#39;  =&amp;gt; \&amp;amp;action_move,
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;init_view&lt;/code&gt; needs to initialize two more velocity components and matching deltas:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $self-&amp;gt;{world}{view} = {
        position    =&amp;gt; [6, 2, 10],
        orientation =&amp;gt; [0, 0, 1, 0],
        d_yaw       =&amp;gt; 0,
        v_yaw       =&amp;gt; 0,
        v_forward   =&amp;gt; 0,
        v_right     =&amp;gt; 0,
        dv_yaw      =&amp;gt; 0,
        dv_forward  =&amp;gt; 0,
        dv_right    =&amp;gt; 0,
    };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;action_move&lt;/code&gt; needs a new movement speed to match the existing yaw speed and some additions to &lt;code&gt;%move_update&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $speed_move       = 5;
    my %move_update      = (
        &#39;+yaw_left&#39;     =&amp;gt; [dv_yaw     =&amp;gt;  $speed_yaw ],
        &#39;+yaw_right&#39;    =&amp;gt; [dv_yaw     =&amp;gt; -$speed_yaw ],
        &#39;+move_right&#39;   =&amp;gt; [dv_right   =&amp;gt;  $speed_move],
        &#39;+move_left&#39;    =&amp;gt; [dv_right   =&amp;gt; -$speed_move],
        &#39;+move_forward&#39; =&amp;gt; [dv_forward =&amp;gt;  $speed_move],
        &#39;+move_back&#39;    =&amp;gt; [dv_forward =&amp;gt; -$speed_move],
        &#39;+look_behind&#39;  =&amp;gt; [d_yaw      =&amp;gt;  180        ],
    );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So far, the changes are mostly hash updates instead of procedural code; that&amp;rsquo;s a good sign that the existing code design has some more life left. When conceptually simple changes require significant code modification, especially special cases or repetitive blocks of code, it&amp;rsquo;s time to look for a refactoring opportunity. Thankfully, these changes are in initialization and configuration rather than special cases.&lt;/p&gt;

&lt;p&gt;One routine that requires a good bit of new code is &lt;code&gt;update_view&lt;/code&gt;. I added these lines to the end:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $view-&amp;gt;{v_right}        += $view-&amp;gt;{dv_right};
    $view-&amp;gt;{dv_right}        = 0;
    $view-&amp;gt;{v_forward}      += $view-&amp;gt;{dv_forward};
    $view-&amp;gt;{dv_forward}      = 0;

    my $vx                   =  $view-&amp;gt;{v_right};
    my $vz                   = -$view-&amp;gt;{v_forward};
    $view-&amp;gt;{position}[0]    += $vx * $d_time;
    $view-&amp;gt;{position}[2]    += $vz * $d_time;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That routine is beginning to look a bit repetitious and has several copies of very similar lines of code, so it goes on the list of places to refactor in the future. There are not yet enough cases to make the best solution obvious, so I&amp;rsquo;ll hold off for a bit.&lt;/p&gt;

&lt;p&gt;The new code starts by applying the new velocity deltas in the same way that it updates &lt;code&gt;v_yaw&lt;/code&gt; earlier in the routine. It converts the right and forward velocities to velocities along the world axes by noting that the view starts out with &amp;ldquo;forward&amp;rdquo; parallel to the negative Z axis and &amp;ldquo;right&amp;rdquo; parallel to the positive X axis. It then multiplies the X and Z velocities by the time delta to arrive at a position change, which it adds into the current view position.&lt;/p&gt;

&lt;p&gt;This version of the code works fine as long as the user doesn&amp;rsquo;t rotate the view. When the view rotates, &amp;ldquo;forward&amp;rdquo; and &amp;ldquo;right&amp;rdquo; don&amp;rsquo;t match the new view directions. They still point down the -Z and +X axes respectively, which can prove very disorienting for high rotations. The solution is a bit of trigonometry. The idea is treat the initial X and Z velocities as components of the total velocity vector, and rotate that vector through the same angle that the user rotated the view:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $vx                   =  $view-&amp;gt;{v_right};
    my $vz                   = -$view-&amp;gt;{v_forward};
    my $angle                = $view-&amp;gt;{orientation}[0];
    ($vx, $vz)               = rotate_xz($angle, $vx, $vz);
    $view-&amp;gt;{position}[0]    += $vx * $d_time;
    $view-&amp;gt;{position}[2]    += $vz * $d_time;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The two middle lines are the new ones. They call &lt;code&gt;rotate_xz&lt;/code&gt; to do the vector rotation work and then set &lt;code&gt;$vx&lt;/code&gt; and &lt;code&gt;$vz&lt;/code&gt; to the returned components of the rotated velocity vector. &lt;code&gt;rotate_xz&lt;/code&gt; is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub rotate_xz
{
    my ($angle, $x, $z) = @_;

    my $radians = $angle * PI / 180;
    my $cos     = cos($radians);
    my $sin     = sin($radians);
    my $rot_x   =  $cos * $x + $sin * $z;
    my $rot_z   = -$sin * $x + $cos * $z;

    return ($rot_x, $rot_z);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After converting the angle from degrees to radians, the code calculates and saves the sine and cosine of the angle. It then calculates the rotated velocity components given the original unrotated components. Finally, it returns the rotated components to the caller.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll skip the derivation here (you&amp;rsquo;re welcome), but if you&amp;rsquo;re curious about how and why this calculation performs a rotation, there are numerous books that explain the wonders of vector mathematics in amazing detail. O&amp;rsquo;Reilly&amp;rsquo;s &lt;a href=&#34;http://www.oreilly.com/catalog/physicsgame/&#34;&gt;Physics for Game Developers&lt;/a&gt;, by David M. Bourg, includes a high-level discussion of rotation. Charles River Media&amp;rsquo;s &lt;a href=&#34;http://www.charlesriver.com/titles/lengyelmath2.html&#34;&gt;Mathematics for 3D Game Programming &amp;amp; Computer Graphics&lt;/a&gt;, by Eric Lengyel, includes a deeper discussion though I, for one, have college math flashbacks every time I read it. Speaking of which, any college textbook on linear algebra should include as much detail as you desire.&lt;/p&gt;

&lt;p&gt;This code requires a definition for &lt;code&gt;PI&lt;/code&gt;, provided by the following line near the top of the program, right after requesting warnings from Perl:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use constant PI =&amp;gt; 4 * atan2(1, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;constant&lt;/code&gt; module evaluates possibly complex calculations during the compile phase and then converts them into constants at runtime. The above calculation takes advantage of a standard trig identity to derive a value for &lt;code&gt;PI&lt;/code&gt; accurate to as many digits as the system can deliver.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;update_view&lt;/code&gt; now does the right thing, no matter what angle the view is facing. It doesn&amp;rsquo;t take long to find a more interesting view:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step044.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;let-there-be-lighting&#34;&gt;Let There Be Lighting!&lt;/h3&gt;

&lt;p&gt;Okay, so maybe that&amp;rsquo;s not &lt;em&gt;much&lt;/em&gt; more interesting, admittedly. This scene needs a little mood lighting instead of the flat colors I&amp;rsquo;ve used so far (especially because they make it hard to see the shape of each object clearly). As a first step, I turned on OpenGL&amp;rsquo;s lighting system with a new line at the end of &lt;code&gt;prep_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glEnable(GL_LIGHTING);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step045.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Far from lighting the scene, the view is now almost black. If you look very carefully and your monitor and room lighting are forgiving, you should be able to just make out the objects, which are very dark gray on the black background. In order to see anything, I must enable both &lt;code&gt;GL_LIGHTING&lt;/code&gt; and one or more lights to provide light to the scene. Without a light, the objects are dark gray instead of true black because OpenGL, by default, applies a very small amount of light to the entire scene, known as &lt;em&gt;ambient&lt;/em&gt; light. To show the objects more brightly, I turned on the first OpenGL light with another new line at the end of &lt;code&gt;prep_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glEnable(GL_LIGHT0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step046.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Now the objects are brighter, but they&amp;rsquo;re still just gray. When calculating colors with lighting enabled, OpenGL uses a completely different set of parameters from the colors used when lighting is disabled. Together these new parameters make up a &lt;em&gt;material&lt;/em&gt;. Complex interactions between the parameters that make up a material can result in very interesting color effects, but in this case, I&amp;rsquo;m not trying to create a complex effect. I want my objects to have their old colors back without worrying about the full complexity that materials provide. Thankfully, OpenGL provides a way to state that the current material should default to the current color. To do this, I add yet another line to the end of &lt;code&gt;prep_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glEnable(GL_COLOR_MATERIAL);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step047.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;At this point, the objects once again have color, but each of the faces is still the same shade rather than appearing to be lit by a single light source somewhere. The problem is that OpenGL does not know whether each face points toward or away from the light and, if so, by how much. The angle between the face and the light determines how much light falls on the surface and, therefore, how bright it should appear. It is possible to calculate the angle of each face in my scene from the location of its vertices, but this is not always the right thing to do (especially when dealing with curved surfaces), so OpenGL does not calculate this internally. Instead, the program needs to do the direction calculations and tell OpenGL the result, known as the &lt;em&gt;normal vector&lt;/em&gt;.&lt;/p&gt;

&lt;p&gt;Luckily, in &lt;code&gt;draw_cube&lt;/code&gt; the faces align with the coordinate axes so that each face points down one of them (positive or negative X, Y, or Z). I don&amp;rsquo;t have to do any calculation here, just tell OpenGL which normal vector to associate with each face:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_cube
{
    # A simple cube
    my @indices = qw( 4 5 6 7   1 2 6 5   0 1 5 4
                      0 3 2 1   0 4 7 3   2 3 7 6 );
    my @vertices = ([-1, -1, -1], [ 1, -1, -1],
                    [ 1,  1, -1], [-1,  1, -1],
                    [-1, -1,  1], [ 1, -1,  1],
                    [ 1,  1,  1], [-1,  1,  1]);
    my @normals = ([0, 0,  1], [ 1, 0, 0], [0, -1, 0],
                   [0, 0, -1], [-1, 0, 0], [0,  1, 0]);

    glBegin(GL_QUADS);

    foreach my $face (0 .. 5) {
        my $normal = $normals[$face];
        glNormal(@$normal);

        foreach my $vertex (0 .. 3) {
            my $index  = $indices[4 * $face + $vertex];
            my $coords = $vertices[$index];
            glVertex(@$coords);
        }
    }
    glEnd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new lines are the definition of the &lt;code&gt;@normals&lt;/code&gt; array and the two lines at the top of the &lt;code&gt;$face&lt;/code&gt; loop that select the correct normal for each face and pass it to OpenGL using &lt;code&gt;glNormal&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The boxes are now shaded reasonably and it&amp;rsquo;s clear that the light is coming from somewhere behind the viewer; the front faces are brighter than the sides. Unfortunately, the axes are now dark again:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step048.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;I did not specify any normal for the axis lines because the concept doesn&amp;rsquo;t make a whole lot of sense for lines or points. However, with lighting enabled, OpenGL needs a set of normals for every lit object, so it goes back to the current state and uses the most recently defined normal. For the very first frame this is the default normal, which happens to point towards the default first light, but for succeeding frames it will be the last normal set in &lt;code&gt;draw_cube&lt;/code&gt;. The latter definitely does not point toward the light, and the axes end up dark.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d rather the axis lines didn&amp;rsquo;t take part in lighting calculations at all and kept their original bright colors, regardless of any lighting (or lack thereof) in the scene. To do this, I removed the line that enables &lt;code&gt;GL_LIGHTING&lt;/code&gt; in &lt;code&gt;prep_frame&lt;/code&gt; and inserted two new lines near the top of &lt;code&gt;draw_view&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    glDisable(GL_LIGHTING);

    draw_axes();

    glEnable(GL_LIGHTING);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now lighting is off before drawing the axis lines and back on afterward. The axis lines have bright colors again, but rotating the view exposes a new problem. When the view rotates, the direction of the light changes as well:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step049.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Because of the way that OpenGL calculates light position and direction, any lights defined before the view is set are fixed to the viewer like the light on a miner&amp;rsquo;s helmet. To fix a light relative to the simulated world, define the light instead after setting the view. I removed the line enabling &lt;code&gt;GL_LIGHT0&lt;/code&gt; in &lt;code&gt;prep_frame&lt;/code&gt; and moved it to the new routine &lt;code&gt;set_world_lights&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_world_lights
{
    glEnable(GL_LIGHT0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I then updated &lt;code&gt;draw_frame&lt;/code&gt; to call the new routine after setting the view:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_frame
{
    my $self = shift;

    $self-&amp;gt;set_projection_3d;
    $self-&amp;gt;set_view_3d;
    $self-&amp;gt;set_world_lights;
    $self-&amp;gt;draw_view;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Unfortunately, this doesn&amp;rsquo;t work. OpenGL only updates its internal state with the light&amp;rsquo;s position and direction when they change explicitly, not when the light is enabled or disabled. I&amp;rsquo;ve never set the light&amp;rsquo;s parameters explicitly, so the original default still stands. This issue is easy to fix with another line in &lt;code&gt;set_world_lights&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_world_lights
{
    glLight(GL_LIGHT0, GL_POSITION, 0.0, 0.0, 1.0, 0.0);

    glEnable(GL_LIGHT0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In one of the few OpenGL interface decisions that actively annoys me, the new line sets the &lt;em&gt;direction&lt;/em&gt; of the light, not its position. OpenGL defines all lights as one of two types: &lt;em&gt;directional&lt;/em&gt; or &lt;em&gt;positional&lt;/em&gt;. OpenGL assumes directional lights are very far away so that anywhere in the scene the direction from the light to each object is effectively the same. Positional lights are nearer and OpenGL must calculate the direction from the light to every vertex of every object in the scene independently. As you can imagine, this is much slower, but produces more interesting lighting effects.&lt;/p&gt;

&lt;p&gt;The key to choosing between these two types is the last parameter of the &lt;code&gt;glLight&lt;/code&gt; call above. If this parameter is &lt;code&gt;0&lt;/code&gt;, the light is directional and the other three coordinates specify the direction from which the light comes. In this case, I&amp;rsquo;ve specified that the light should come &lt;em&gt;from&lt;/em&gt; the +Z direction. If the last parameter is &lt;code&gt;1&lt;/code&gt;, then OpenGL makes the light positional and uses the other three coordinates to set the light&amp;rsquo;s position within the scene. For now, I&amp;rsquo;ll skip the gory details of what happens when a value other than &lt;code&gt;0&lt;/code&gt; or &lt;code&gt;1&lt;/code&gt; is used, but in short, the light will be positional and extra calculations determine the actual position used. Most of the time it&amp;rsquo;s best to ignore that case.&lt;/p&gt;

&lt;p&gt;You may wonder why I explicitly specified &lt;code&gt;0.0&lt;/code&gt; and &lt;code&gt;1.0&lt;/code&gt; instead of &lt;code&gt;0&lt;/code&gt; and &lt;code&gt;1&lt;/code&gt;. This is a workaround for a bug in &lt;code&gt;glLight&lt;/code&gt; in some versions of SDL_Perl when it is presented with integer arguments instead of floating-point arguments.&lt;/p&gt;

&lt;p&gt;With this line added, the light now stays fixed in the world, even when the user moves and rotates the view:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step051.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;h3 id=&#34;a-lantern&#34;&gt;A Lantern&lt;/h3&gt;

&lt;p&gt;Of course, sometimes a light connected to the viewer is exactly the intention. For example, perhaps the desired effect is for the player to hold a lantern or flashlight to light dark places. Both of these are localized light sources that light nearby objects quite a bit, but distant objects only a little. The primary difference between them is that a flashlight and certain types of lanterns cast light primarily in one direction, often in a cone. Most lanterns, torches, and similar light sources cast light in all directions (barring shadows from handles, fuel tins, and the like).&lt;/p&gt;

&lt;p&gt;Non-directed light is a little simpler to implement, so I&amp;rsquo;ll start with lantern light. I wanted the light rooted at the viewer&amp;rsquo;s position, so I defined the light before setting the view:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_frame
{
    my $self = shift;

    $self-&amp;gt;set_projection_3d;
    $self-&amp;gt;set_eye_lights;
    $self-&amp;gt;set_view_3d;
    $self-&amp;gt;set_world_lights;
    $self-&amp;gt;draw_view;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I refer to viewer-fixed lights as &lt;em&gt;eye lights&lt;/em&gt; because OpenGL refers to the coordinate system it uses for lights as &lt;em&gt;eye coordinates&lt;/em&gt;, and a light defined this way as maintaining a particular position &amp;ldquo;relative to the eye.&amp;rdquo; Here&amp;rsquo;s &lt;code&gt;set_eye_lights&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_eye_lights
{
    glLight(GL_LIGHT1, GL_POSITION, 0.0, 0.0, 1.0, 0.0);

    glEnable(GL_LIGHT1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Here I set the second light exactly the same way I set the first. Note that it doesn&amp;rsquo;t matter that I actually define the second light in my program before the first. Each OpenGL light is independently numbered and always keeps the same number, rather than acting like a stack or queue numbered by order of use.&lt;/p&gt;

&lt;p&gt;Sadly, the new code doesn&amp;rsquo;t seem to have any effect at all. In reality, there really is a new light shining on the scene&amp;ndash;unlike &lt;code&gt;GL_LIGHT0&lt;/code&gt;, which defaults to shining bright white, all of the other lights default to black and provide no new light to the scene. The solution is to set another parameter of the light:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_eye_lights
{
    glLight(GL_LIGHT1, GL_POSITION, 0.0, 0.0, 1.0, 0.0);
    glLight(GL_LIGHT1, GL_DIFFUSE,  1.0, 1.0, 1.0, 1.0);

    glEnable(GL_LIGHT1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The front faces of each object should appear considerably brighter. Moving around the scene shows that the eye light brightens a surface only dimly lit by the world light:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step053.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;If you watch carefully, however, you&amp;rsquo;ll notice that the lighting varies by the view rotation&amp;ndash;not position. I defined the light as directional with the light coming from behind the viewer, rather than positional, with the light coming from the viewer directly. I hinted at the fix earlier&amp;ndash;changing the &lt;code&gt;GL_POSITION&lt;/code&gt; parameter as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glLight(GL_LIGHT1, GL_POSITION, 0.0, 0.0, 0.0, 1.0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The light now comes from &lt;code&gt;(0, 0, 0)&lt;/code&gt; in eye coordinates, right at the viewpoint. Moving around and rotating shows that this version has the intended effect.&lt;/p&gt;

&lt;p&gt;The simulated lantern still shines as brightly on far-away objects as it does on near ones. A real lantern&amp;rsquo;s light falls off rapidly with distance from the lantern. OpenGL can do this with another setting:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_eye_lights
{
    glLight(GL_LIGHT1, GL_POSITION, 0.0, 0.0, 0.0, 1.0);
    glLight(GL_LIGHT1, GL_DIFFUSE,  1.0, 1.0, 1.0, 1.0);
    glLight(GL_LIGHT1, GL_LINEAR_ATTENUATION, 0.5);

    glEnable(GL_LIGHT1);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This case tells OpenGL to include a dimming term in its equations proportional to the distance between the light and the object. Physics-minded readers will point out that physically accurate dimming is proportional to the square of the distance, and OpenGL does allow this using &lt;code&gt;GL_QUADRATIC_ATTENUATION&lt;/code&gt;. However, a host of factors (including the lighting equations that OpenGL uses and the non-linear effects of the graphics hardware, monitor, and human eye) make this more accurate dimming look rather odd. Linear dimming turns out to look better in many cases, so that&amp;rsquo;s what I used here. It is also possible to combine different dimming types, so that the dimming appears linear for nearby objects and quadratic for distant ones, which you may find a better tradeoff. The &lt;code&gt;0.5&lt;/code&gt; setting tells OpenGL how strong the linear dimming effect should be for my scene.&lt;/p&gt;

&lt;p&gt;Moving around the scene, you should be able to see the relatively subtle dimming effect in action. Don&amp;rsquo;t be afraid to leave it subtle instead of turning the dimming effect way up. Some moods call for striking lighting effects, while others call for lighting effects that the viewer notices only subconsciously. In some visualization applications, lighting subtlety is a great virtue, allowing the human visual system&amp;rsquo;s amazing processing power to come to grips with a complex scene without being overwhelmed.&lt;/p&gt;

&lt;h3 id=&#34;a-flashlight&#34;&gt;A Flashlight&lt;/h3&gt;

&lt;p&gt;I really happen to like the way a flashlight casts its cone of light, so I converted the omnidirectional light of the lantern to a directed cone. OpenGL refers to this type of light as a &lt;em&gt;spotlight&lt;/em&gt; and includes several light parameters to define them. The first change is a new setting in &lt;code&gt;set_eye_lights&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glLight(GL_LIGHT1, GL_SPOT_CUTOFF, 15.0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This sets the angle between the center of the light beam and the edges of the cone. OpenGL accepts either 180 degrees (omnidirectional) or any value between 0 and 90 degrees (from a laser beam to a hemisphere of light). In this case, I chose a centerline-to-edge angle of 15 degrees, making a nice 30-degree-wide cone of light.&lt;/p&gt;

&lt;p&gt;This change indeed limits the cone of light, but also reveals an ugly artifact. Move to a point just in front of the left front corner of the white cube and rotate the view to pan the light across the yellow box. You&amp;rsquo;ll see the light jump nastily from corner to corner, even disappearing entirely in between. Even when a corner is lit, the shape of the light is not very conelike:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step056.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;OpenGL&amp;rsquo;s standard lighting model only performs the lighting calculations at each vertex, interpolating the results in between. For models that have many small faces and a resulting high density of vertices, this works relatively well. It breaks down nastily in scenes containing objects with large faces and few vertices, especially when a positional light is close to an object. Spotlights make the problem even more apparent, as they can easily shine &lt;em&gt;between&lt;/em&gt; two vertices without lighting either of them; the polygon then appears uniformly dark.&lt;/p&gt;

&lt;h3 id=&#34;ode-to-rush&#34;&gt;Ode to Rush&lt;/h3&gt;

&lt;p&gt;Advanced OpenGL functionality paired with recent hardware can solve this problem with per-pixel lighting calculations. Older hardware can fake it with light maps and similar tricks. Rather than using advanced functionality, I&amp;rsquo;ll use a simpler method for improving the lighting, known as &lt;em&gt;subdivisions&lt;/em&gt;. (Those of you scratching your heads over the Rush reference can now breathe a collective sigh of relief.) Subdivisions have their own problems, as I&amp;rsquo;ll show later, but those issues explain a lot about the design of graphics APIs, so they&amp;rsquo;re worth a look.&lt;/p&gt;

&lt;p&gt;As the name implies, the basic idea is to subdivide each face into many smaller faces, each with its own set of vertices. For curved objects such as spheres and cylinders, this is essential so that nearby objects appear to curve smoothly. For objects with large flat faces, such as boxes and pyramids, this merely has the side effect of forcing the per-vertex lighting calculations to be done many times across each face.&lt;/p&gt;

&lt;p&gt;Before I can use subdivided faces, I need to prepare by refactoring &lt;code&gt;draw_cube&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_cube
{
    # A simple cube
    my @indices = qw( 4 5 6 7   1 2 6 5   0 1 5 4
                      0 3 2 1   0 4 7 3   2 3 7 6 );
    my @vertices = ([-1, -1, -1], [ 1, -1, -1],
                    [ 1,  1, -1], [-1,  1, -1],
                    [-1, -1,  1], [ 1, -1,  1],
                    [ 1,  1,  1], [-1,  1,  1]);
    my @normals = ([0, 0,  1], [ 1, 0, 0], [0, -1, 0],
                   [0, 0, -1], [-1, 0, 0], [0,  1, 0]);

    foreach my $face (0 .. 5) {
        my $normal = $normals[$face];
        my @corners;

        foreach my $vertex (0 .. 3) {
            my $index  = $indices[4 * $face + $vertex];
            my $coords = $vertices[$index];
            push @corners, $coords;
        }
        draw_quad_face(normal    =&amp;gt; $normal,
                       corners   =&amp;gt; \@corners);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Instead of performing the OpenGL calls directly in &lt;code&gt;draw_cube&lt;/code&gt;, it now calls &lt;code&gt;draw_quad_face&lt;/code&gt;. For each large face it creates a new &lt;code&gt;@corners&lt;/code&gt; array filled with the vertex coordinates of the corners of that face. It then passes that array and the face normal to &lt;code&gt;draw_quad_face&lt;/code&gt;, defined as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_quad_face
{
    my %args    = @_;
    my $normal  = $args{normal};
    my $corners = $args{corners};

    glBegin(GL_QUADS);
    glNormal(@$normal);

    foreach my $coords (@$corners) {
        glVertex(@$coords);
    }
    glEnd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This function performs exactly the OpenGL operations that &lt;code&gt;draw_cube&lt;/code&gt; used to do. I&amp;rsquo;ve also used a different argument-passing style for this routine than I have previously. In this case, I pass named arguments because I know that I will add at least one more argument very soon and that there&amp;rsquo;s a pretty good chance I&amp;rsquo;ll want to add more later. When the arguments to a routine are likely to change over time, and especially when callers might want to specify only a few arguments and allow the rest to take on reasonable defaults, named arguments are usually a better choice. The arguments can either be a hashref or a list stuffed into a hash. This time, I chose the latter method.&lt;/p&gt;

&lt;p&gt;After refactoring comes testing, and a quick run showed that everything worked as expected. Safe in that knowledge, I rewrote &lt;code&gt;draw_quad_face&lt;/code&gt; to subdivide each face:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_quad_face
{
    my %args    = @_;
    my $normal  = $args{normal};
    my $corners = $args{corners};
    my $div     = $args{divisions} || 10;
    my ($a, $b, $c, $d) = @$corners;

    # NOTE: ASSUMES FACE IS A PARALLELOGRAM

    my $s_ab = calc_vector_step($a, $b, $div);
    my $s_ad = calc_vector_step($a, $d, $div);

    glNormal(@$normal);
    for my $strip (0 .. $div - 1) {
        my @v = ($a-&amp;gt;[0] + $strip * $s_ab-&amp;gt;[0],
                 $a-&amp;gt;[1] + $strip * $s_ab-&amp;gt;[1],
                 $a-&amp;gt;[2] + $strip * $s_ab-&amp;gt;[2]);

        glBegin(GL_QUAD_STRIP);
        for my $quad (0 .. $div) {
            glVertex(@v);
            glVertex($v[0] + $s_ab-&amp;gt;[0],
                     $v[1] + $s_ab-&amp;gt;[1],
                     $v[2] + $s_ab-&amp;gt;[2]);

            $v[0] += $s_ad-&amp;gt;[0];
            $v[1] += $s_ad-&amp;gt;[1];
            $v[2] += $s_ad-&amp;gt;[2];
        }
        glEnd;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new routine starts by adding the new optional argument &lt;code&gt;divisions&lt;/code&gt;, which defaults to 10. This specifies how many subdivisions the face should have both &amp;ldquo;down&amp;rdquo; and &amp;ldquo;across&amp;rdquo;; the actual number of sub-faces is the square of this number. For the default 10 divisions, that comes to 100 sub-faces for each large face, so each cube has 600 sub-faces.&lt;/p&gt;

&lt;p&gt;The next line labels the corners in counterclockwise order. This puts corner A diagonally across from corner C, with B on one side and D on the other.&lt;/p&gt;

&lt;p&gt;As the comment on the next line indicates, I&amp;rsquo;ve simplified the math considerably by assuming that the face is at least a parallelogram. With this simplification, I can calculate the steps for one division along sides AB and AD and use these steps to position every sub-face across the entire large face.&lt;/p&gt;

&lt;p&gt;I can&amp;rsquo;t just calculate the step as a simple distance to move, because I have no idea which direction each edge is pointing and wouldn&amp;rsquo;t know which way to move for each step. Instead, I calculate the vector difference between the vertices at each end of the edge and divide that by the number of divisions. The code does the same calculation twice, so I&amp;rsquo;ve extracted it into a separate routine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub calc_vector_step
{
    my ($v1, $v2, $div) = @_;

    return [($v2-&amp;gt;[0] - $v1-&amp;gt;[0]) / $div,
            ($v2-&amp;gt;[1] - $v1-&amp;gt;[1]) / $div,
            ($v2-&amp;gt;[2] - $v1-&amp;gt;[2]) / $div];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Returning to &lt;code&gt;draw_quad_face&lt;/code&gt;, it stores the vector steps in &lt;code&gt;$s_ab&lt;/code&gt; (the step along the AB side) and &lt;code&gt;$s_ad&lt;/code&gt; (the step along the AD side). Next it sets the current normal, which for a flat face remains the same across its entirety.&lt;/p&gt;

&lt;p&gt;Finally, I can begin to define the sub-faces themselves. I&amp;rsquo;ve taken advantage of the OpenGL quad strip primitive to draw the sub-faces as a series of parallel strips extending from the AB edge to the CD edge. For each strip, I first need to calculate the location of its starting vertex. I know this is on the AB edge, so the code starts at A and adds an AB step for each completed strip. For the first strip, this puts the starting vertex at A. For the last strip, the starting vertex will be one step (one strip width) away from B. It initializes the current vertex &lt;code&gt;@v&lt;/code&gt; with the starting vertex and will keep it updated as it moves along each strip.&lt;/p&gt;

&lt;p&gt;It then begins a strip of quads with &lt;code&gt;glBegin(GL_QUAD_STRIP)&lt;/code&gt;. To define the strip, I&amp;rsquo;ve specified the locations of each pair of vertices across from each other along its length. For each pair, it uses the current vertex and a calculated vertex one step further along the AB direction. The code then moves the current vertex one step along the length of the strip (the AD direction). Once the strip is complete, it ends it with &lt;code&gt;glEnd&lt;/code&gt; and loops again for the next strip.&lt;/p&gt;

&lt;p&gt;All of this complexity makes quite a visual difference:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step058.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s clear that the light has a definite shape to it, but the lighting is so jagged that it&amp;rsquo;s distracting. One way to fix this is to increase the number of divisions, making smaller sub-faces. This requires a simple addition to the &lt;code&gt;draw_quad_face&lt;/code&gt; call in &lt;code&gt;draw_cube&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        draw_quad_face(normal    =&amp;gt; $normal,
                       corners   =&amp;gt; \@corners,
                       divisions =&amp;gt; 30);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The result is quite a bit less jagged:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step059.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Unfortunately, the jaggies are smaller but still obviously there&amp;ndash;and the closer the viewer is to an object the bigger they appear. There are also nine times as many sub-faces to draw (&lt;sup&gt;30&lt;/sup&gt;&amp;frasl;&lt;sub&gt;10&lt;/sub&gt; squared) and the program now runs considerably slower. If you&amp;rsquo;re lucky enough to have a recent system with fast video hardware and don&amp;rsquo;t notice the slowdown, use 100 or so for the number of divisions. You&amp;rsquo;ll probably see it.&lt;/p&gt;

&lt;h3 id=&#34;softening-the-edges&#34;&gt;Softening the Edges&lt;/h3&gt;

&lt;p&gt;Clearly, increasing the number of subdivisions only goes so far to improve the rendering, while simultaneously costing dearly in performance. I&amp;rsquo;ll try a different tack and go back to what I know about a flashlight. Most flashlights cast a beam that is brighter in the center than at the edge. (Some have a dark circle in the very center, but I&amp;rsquo;m ignoring that for now.) I can take advantage of this to create a more accurate image and also soften the large jaggies considerably. First, I backed out my change to the &lt;code&gt;draw_quad_face&lt;/code&gt; call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        draw_quad_face(normal    =&amp;gt; $normal,
                       corners   =&amp;gt; \@corners);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then I changed one spotlight parameter for the flashlight in &lt;code&gt;set_eye_lights&lt;/code&gt; and added another:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glLight(GL_LIGHT1, GL_SPOT_CUTOFF,   30.0);
    glLight(GL_LIGHT1, GL_SPOT_EXPONENT, 80.0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With the change to &lt;code&gt;GL_SPOT_CUTOFF&lt;/code&gt;, I&amp;rsquo;ve widened the beam to twice its original angle. At the same time, I&amp;rsquo;ve told OpenGL to make it quite a bit dimmer at the edges using &lt;code&gt;GL_SPOT_EXPONENT&lt;/code&gt;, hopefully hiding any jaggies. The new parameter has a somewhat confusing name that refers to the details of the equation that determines the strength of the off-center dimming effect. In a theme seen throughout the mathematics of computer graphics, the dimming is a function of the cosine of the angle between the center line and the vertex being lit. In fact, the dimming factor is the cosine raised to the exponent specified by &lt;code&gt;GL_SPOT_EXPONENT&lt;/code&gt;. Why use the cosine of the angle? It turns out to be cheap to calculate&amp;ndash;cheaper than calculating the angle itself&amp;ndash;and also gives a nice smooth effect.&lt;/p&gt;

&lt;p&gt;With luck, the new beam will appear about the same width to the eye as the old one:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step060.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;Good enough. The image looks better without the massive performance strain of high subdivision levels.&lt;/p&gt;

&lt;h3 id=&#34;refactoring-drawing&#34;&gt;Refactoring Drawing&lt;/h3&gt;

&lt;p&gt;There&amp;rsquo;s still something not right, but it will take a few more objects in the scene to show it. &lt;code&gt;draw_view&lt;/code&gt; is already a repetitive hardcoded mess and it&amp;rsquo;s been on the &amp;ldquo;to be refactored&amp;rdquo; list for a while, so now seems a good time to clean it up before I add to the mess.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;draw_view&lt;/code&gt; performs a series of transformations and state settings for each object drawn. I want to move to a more data-driven design, with each object in the simulated world represented by a data structure specifying the needed transformations and settings. Eventually, these structures may become full-fledged blessed objects, but I&amp;rsquo;ll start simple for now.&lt;/p&gt;

&lt;p&gt;I initialized the data structures in &lt;code&gt;init_objects&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_objects
{
    my $self = shift;

    my @objects = (
        {
            draw        =&amp;gt; \&amp;amp;draw_axes,
        },
        {
            lit         =&amp;gt; 1,
            color       =&amp;gt; [ 1, 1,  1],
            position    =&amp;gt; [12, 0, -4],
            scale       =&amp;gt; [ 2, 2,  2],
            draw        =&amp;gt; \&amp;amp;draw_cube,
        },
        {
            lit         =&amp;gt; 1,
            color       =&amp;gt; [ 1, 1, 0],
            position    =&amp;gt; [ 4, 0, 0],
            orientation =&amp;gt; [40, 0, 0, 1],
            scale       =&amp;gt; [.2, 1, 2],
            draw        =&amp;gt; \&amp;amp;draw_cube,
        },
    );

    $self-&amp;gt;{world}{objects} = \@objects;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Each hash includes the arguments to the various transformations to apply to it, along with a reference to the routine that actually draws the object and a flag indicating whether the object should be subject to OpenGL lighting. The object array then becomes a new part of the world hash for easy access later.&lt;/p&gt;

&lt;p&gt;I called this routine at the end of &lt;code&gt;init&lt;/code&gt; as usual:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $self-&amp;gt;init_objects;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also replaced &lt;code&gt;draw_view&lt;/code&gt; with a version that interprets the data into a series of OpenGL calls:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    my $self    = shift;

    my $objects = $self-&amp;gt;{world}{objects};

    foreach my $o (@$objects) {
        $o-&amp;gt;{lit} ? glEnable (GL_LIGHTING)
                  : glDisable(GL_LIGHTING);

        glColor(@{$o-&amp;gt;{color}})        if $o-&amp;gt;{color};

        glPushMatrix;

        glTranslate(@{$o-&amp;gt;{position}}) if $o-&amp;gt;{position};
        glRotate(@{$o-&amp;gt;{orientation}}) if $o-&amp;gt;{orientation};
        glScale(@{$o-&amp;gt;{scale}})        if $o-&amp;gt;{scale};

        $o-&amp;gt;{draw}-&amp;gt;();

        glPopMatrix;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new routine iterates over the world object array, performing each requested operation. It either skips or defaults any unspecified values. First up is the choice to enable or disable &lt;code&gt;GL_LIGHTING&lt;/code&gt;, followed by setting the current color if requested. The code next checks for and applies the usual transformations and finally, calls the object draw routine.&lt;/p&gt;

&lt;p&gt;For simplicity and robustness, I&amp;rsquo;ve unconditionally wrapped the transformations and draw routine in a matrix push/pop pair rather than trying to detect whether they need the push and pop. OpenGL implementations tend to be highly optimized with native code, and any detection I did would be Perl. Chances are good that such an &amp;ldquo;optimization&amp;rdquo; would instead slow things down. This way, my code stays cleaner and even a misbehaving draw routine that performed transformations internally without cleaning up afterwards will not affect the next object drawn.&lt;/p&gt;

&lt;p&gt;A quick test showed that this refactored version still worked. Now I could add a few more objects to demonstrate the remaining lighting issue. I specified several more boxes programmatically by inserting a new loop before the end of &lt;code&gt;init_objects&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    foreach my $num (1 .. 5) {
        my $scale =   $num * $num / 15;
        my $pos   = - $num * 2;
        push @objects, {
            lit         =&amp;gt; 1,
            color       =&amp;gt; [ 1, 1,  1],
            position    =&amp;gt; [$pos, 2.5, 0],
            orientation =&amp;gt; [30, 1, 0, 0],
            scale       =&amp;gt; [1, 1, $scale],
            draw        =&amp;gt; \&amp;amp;draw_cube,
        };
    }

    $self-&amp;gt;{world}{objects} = \@objects;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For each box, just two parameters vary: position and Z scale. I chose the position to set each box next to the last, progressing along the -X axis. The scale is set so that the height and width of each box remains the same, but the depths vary from very shallow for the first box to fairly deep for the last.&lt;/p&gt;

&lt;p&gt;The loop specifies five boxes in total and begins by calculating the X position and Z scaling (depth) for the current box. The next few lines simply create a new hash for the new box and push it onto the object array.&lt;/p&gt;

&lt;p&gt;Finally, there was one last change&amp;ndash;the bright world light overwhelms the problematic effect from the flashlight. This is an easy fix; I commented out the line that enables it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_world_lights
{
    glLight(GL_LIGHT0, GL_POSITION, 0.0, 0.0, 1.0, 0.0);

#     glEnable(GL_LIGHT0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By panning to the left across the scene until the viewpoint is in front of the new boxes, the problem becomes obvious:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step062.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The brightness of the lighting varies immensely depending on the depth of the box! This rather unintuitive outcome is an unfortunate side effect of how OpenGL must handle normals. A normal specifies the direction of the surface associated with a vertex. If a rigid object rotates, its surfaces rotate, so all of its normals must rotate as well. OpenGL handles this by transforming normal coordinates as it would vertex coordinates. This runs into trouble with any transformations other than translation and rotation. OpenGL calculations assume that normals are normalized (have unit length). Scaling the normal breaks this assumption and results in the effect seen above.&lt;/p&gt;

&lt;p&gt;To fix this, I told OpenGL that normals may not have unit length and that OpenGL must normalize them before other calculations are performed. This is not the default behavior because of the performance cost of normalizing each vector. An application that can ensure normals are always unit length after transformation can keep the default and run a little faster. I want to allow arbitrary scaling of objects, so I enabled automatic normalization with another line at the end of &lt;code&gt;prep_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glEnable(GL_NORMALIZE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That fixed the problem:&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2005_02_17_3d_engine/step063.png&#34; width=&#34;400&#34; height=&#34;400&#34; /&gt;&lt;/p&gt;

&lt;p&gt;With that bug killed, I reenabled the world light by uncommenting the &lt;code&gt;glEnable&lt;/code&gt; line in &lt;code&gt;set_world_lights&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_world_lights
{
    glLight(GL_LIGHT0, GL_POSITION, 0.0, 0.0, 1.0, 0.0);

    glEnable(GL_LIGHT0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;During this article I&amp;rsquo;ve moved pretty quickly, covering screenshots, movement of the viewpoint, the beginnings of lighting in OpenGL, and subdivided faces for the boxes. Along the way, I took the chance to refactor &lt;code&gt;draw_view&lt;/code&gt; into a more data-driven design and made the scene a little more interesting.&lt;/p&gt;

&lt;p&gt;Unfortunately, these new changes have slowed things down quite a bit. OpenGL has several features that can improve performance considerably. Next time, I&amp;rsquo;ll talk about one of the most powerful of these: display lists. I&amp;rsquo;ll also introduce basic font handling and run with the performance theme by adding an FPS display to the engine.&lt;/p&gt;

&lt;p&gt;Until next time, have fun and keep hacking!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building a 3D Engine in Perl, Part 2</title>
      <link>http://localhost:1313/pub/2004/12/29/3d_engine.html/</link>
      <pubDate>Wed, 29 Dec 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/12/29/3d_engine.html/</guid>
      <description>

&lt;p&gt;This article is the second in a &lt;a href=&#34;http://localhost:1313/authors/geoff-broadwell&#34;&gt;series&lt;/a&gt; aimed at building a full 3D engine in Perl. The first article, &lt;a href=&#34;http://localhost:1313/pub/2004/12/01/3d_engine.html&#34;&gt;Building a 3D Engine in Perl&lt;/a&gt;, covered basic program structure, opening an OpenGL window using SDL, basic projection and viewing setup, simple object rendering, object transformations, and depth ordering using the OpenGL depth buffer.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: see also the rest of the series, &lt;a href=&#34;http://localhost:1313/pub/2005/02/17/3d_engine.html&#34;&gt;lighting and movement&lt;/a&gt;, and &lt;a href=&#34;http://localhost:1313/pub/2005/08/04/3d_engine.html&#34;&gt;profiling your application&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This time, I&amp;rsquo;ll discuss rotating and animating the view, SDL event and keyboard handling, and compensating for frame rate variations. As a bonus, I&amp;rsquo;ll demonstrate some real-world refactoring, including a conversion from procedural to (weakly) object-oriented code. Before I start, however, there were a couple of issues discovered since the first article went live:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;In the first article, I wrote &amp;ldquo;orthogonal projection.&amp;rdquo; This should be &amp;ldquo;orthographic projection,&amp;rdquo; which reminds me again that no matter how many times you proofread, you can still miss the bug&amp;ndash;in code or in prose. Unfortunately, prose is a bit harder to write tests for.&lt;/li&gt;

&lt;li&gt;&lt;p&gt;Todd Ross discovered a problem with SDL on FreeBSD 5.3, which caused the code to die immediately with &amp;ldquo;Bad system call (core dumped).&amp;rdquo; A short while later, he reported the workaround. He set his &lt;code&gt;LD_PRELOAD&lt;/code&gt; environment variable with a little magic, and everything worked fine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;setenv LD_PRELOAD /usr/lib/libc_r.so
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;His research method is a good one to follow if you should encounter a similar problem. He installed another SDL_Perl application, in this case Frozen Bubble. Once he was sure it worked, he checked the code in the launcher script and found the magic shown above. A quick test confirmed that this worked for his code as well.&lt;/p&gt;

&lt;p&gt;Frozen Bubble is a 2D application, so if it works fine but your OpenGL programs don&amp;rsquo;t, check to make sure that OpenGL works at all. Unix variants should supply the &lt;code&gt;glxinfo&lt;/code&gt; and &lt;code&gt;glxgears&lt;/code&gt; programs. Use &lt;code&gt;glxinfo&lt;/code&gt; to gather details on your OpenGL driver; it serves as both a sanity check and a good addition to bug reports. &lt;code&gt;glxgears&lt;/code&gt; does a simple animated rendering of meshing gears. This tells you whether OpenGL works correctly (at least for basic stuff) and what performance your OpenGL driver and hardware can provide. Both programs work under X on Apple&amp;rsquo;s OS X 10.3 as well.&lt;/p&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Keep your comments, questions, and bug reports coming! I&amp;rsquo;d like to recognize your contribution in the next article, but if you&amp;rsquo;d rather remain anonymous, that&amp;rsquo;s fine too.&lt;/p&gt;

&lt;p&gt;Without further ado, let&amp;rsquo;s start. If you want try the code at each stage without all the typing, &lt;a href=&#34;http://localhost:1313/media/_pub_2004_12_29_3d_engine/perl_opengl_2_examples.tar.gz&#34;&gt;download the example source code&lt;/a&gt;. It includes a &lt;em&gt;README.steps&lt;/em&gt; file that should help you follow along more easily.&lt;/p&gt;

&lt;h3 id=&#34;moving-the-viewpoint&#34;&gt;Moving the Viewpoint&lt;/h3&gt;

&lt;p&gt;At the end of the last article, our scene had a set of axis lines roughly in the center of the screen, with a big white cube behind them and a rotated flat yellow box to the right:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    draw_axes();

    glColor(1, 1, 1);
    glPushMatrix;
    glTranslate( 0, 0, -4);
    glScale( 2, 2, 2);
    draw_cube();
    glPopMatrix;

    glColor(1, 1, 0);
    glPushMatrix;
    glTranslate( 4, 0, 0);
    glRotate( 40, 0, 0, 1);
    glScale(.2, 1, 2);
    draw_cube();
    glPopMatrix;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s move that white cube to the right by changing the first &lt;code&gt;glTranslate&lt;/code&gt; call as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;glTranslate( 12, 0, -4);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the right side of the window cuts off the white box. If I wanted to fix that while maintaining the relative positions of all the objects, there are a few possible changes I could make:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Use a wider projection (FOV) angle to see more of the scene at once. Unfortunately, it&amp;rsquo;s already at 90 degrees, which is fairly wide. The perspective effect is already very strong; much wider, and the rendering will look too distorted.&lt;/li&gt;
&lt;li&gt;Individually move all objects in the scene the same distance to the left. This would certainly work, but is a lot of effort, especially when there are many objects in the scene.&lt;/li&gt;
&lt;li&gt;Move the viewpoint right to recenter the view. This is my preference.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I want to move the viewpoint to the right, a positive X direction, so I add +6 to the X component of the viewing translation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glTranslate(6, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the scene is even &lt;em&gt;farther&lt;/em&gt; to the right. The problem is that OpenGL combines the transformations used to modify the view (&lt;em&gt;viewing&lt;/em&gt; transformations) with those used to transform objects in the scene (&lt;em&gt;modeling&lt;/em&gt; transformations) in the &lt;em&gt;modelview&lt;/em&gt; matrix. OpenGL has no way to know whether I intend any given modelview transformation to alter the view or the objects in the scene; it treats all of them as altering the objects. By translating +6 X, I effectively moved every object 6 units to the right, rather than moving my viewpoint right as intended.&lt;/p&gt;

&lt;p&gt;I hinted at the solution before: moving the viewpoint right is equivalent to moving all objects in the scene to the left. The solution to this problem is to reverse the sign of the translation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glTranslate(-6, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This puts the viewpoint at (6, 2, 10) where I wanted it, roughly recentering the scene. Now you can see why the viewing translation from the first article moved the viewpoint to a point slightly above (+Y) and some distance closer to the user (+Z) than the origin. I simply reversed the signs of the viewpoint coordinates I wanted, (0, 2, 10).&lt;/p&gt;

&lt;p&gt;The scene is now centered, but with this static view, it&amp;rsquo;s difficult to tell the true location and relative sizes of the objects in the scene. Perhaps I can rotate the view a bit to see this. I&amp;rsquo;ll rotate it 90 degrees counterclockwise (positive rotation) around the Y axis:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glTranslate(-6, -2, -10);
    glRotate(90, 0, 1, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Well, that certainly rotated things, but it&amp;rsquo;s still hard to see where the objects really are. Why did the scene end up all over on the left like that and with the axis lines in front?&lt;/p&gt;

&lt;h3 id=&#34;animating-the-view&#34;&gt;Animating the View&lt;/h3&gt;

&lt;p&gt;To understand what&amp;rsquo;s really going on with an odd transformation, it helps me to turn it into a short animation. I start the animation with a very small transformation and keep increasing it until well past the intended level. This way, I can see the effect of both smaller and larger changes.&lt;/p&gt;

&lt;p&gt;To do this, I need a few more frames in the animation. I can do this by changing the last line in &lt;code&gt;draw_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$done = 1 if $frame == 10;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I also want the rotation to animate with each frame:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glTranslate(-6, -2, -10);
    glRotate(18 * $frame, 0, 1, 0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This chops the rotation into 18 degree increments, starting at frame 1 with an 18 degree rotation and ending at frame 10 with a 180 degree rotation.&lt;/p&gt;

&lt;p&gt;Running this program shows what is happening. The scene rotates counterclockwise around its origin, the intersection point of the axis lines. I wanted to rotate the viewpoint, but I rotated the objects instead. Just reversing the sign won&amp;rsquo;t do the trick. That will rotate the scene the other direction (clockwise), but it won&amp;rsquo;t rotate around the viewpoint&amp;ndash;it will still rotate around the scene origin.&lt;/p&gt;

&lt;p&gt;In the first article, I described how to visualize a series of transforms by thinking about transforming the local coordinate system of the objects in a series of steps. Looking at the code above, you can see that it first translates the scene origin away and then rotates around that new origin. To rotate around the viewpoint, I need to rotate first and then translate the scene away:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glRotate(18 * $frame, 0, 1, 0);
    glTranslate(-6, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This now rotates around the viewpoint, but because it rotates 180 degrees starting from dead ahead, the scene ends up behind the viewpoint. To start the view so that the scene is on one side and then rotates to be on the other, I simply offset the angle:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glRotate(-90 + 18 * $frame, 0, 1, 0);
    glTranslate(-6, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At frame 1, the rotation angle is -90 + 18 * 1 = -72 degrees. At frame 10, the angle is -90 + 18 * 10 = 90 degrees. Perfect.&lt;/p&gt;

&lt;h4 id=&#34;stop-and-turn-around&#34;&gt;Stop and Turn Around&lt;/h4&gt;

&lt;p&gt;There&amp;rsquo;s only one little problem: it&amp;rsquo;s going the wrong way! I wanted to do a counterclockwise rotation of the view, but that should make the scene appear to rotate &lt;em&gt;clockwise&lt;/em&gt; around the viewpoint. Imagine standing in front of a landmark, taking a picture. Looking through the viewfinder, you might notice that the landmark is a bit left of center. To center it, turn slightly left (counterclockwise as seen from above, or around +Y in the default OpenGL coordinate system). This would make the landmark appear to move clockwise around you (again as seen from above), moving it from the left side of the viewfinder to the center.&lt;/p&gt;

&lt;p&gt;In this case, reverse the angle&amp;rsquo;s sign:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glRotate(90 - 18 * $frame, 0, 1, 0);
    glTranslate(-6, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, every transformation of the view is equivalent to the opposite transformation of every object in the scene. You must reverse the sign of the coordinates in a translation, reverse the sign of the angle in a rotation, or take the inverse of the factors in a scaling (shrinking the viewer to half size makes everything appear twice as big). As we saw before, you must reverse the order of rotation and translation as well.&lt;/p&gt;

&lt;p&gt;Scaling is a special case. Inverting the factors works, but you must still do the scaling after the translation to achieve the expected effect, rather than following the rule for rotation and translation and reversing the transformation order completely. The reason is that scaling before the translation scales the translation also. Scaling by (2, 2, 2) would double the size of all of the objects in the scene, but it would also put them twice as far away, making them appear the same size. I&amp;rsquo;ll skip the code for this and leave it as an exercise for the reader. Go ahead, have fun.&lt;/p&gt;

&lt;p&gt;If you decide to give view scaling a try, remember that all distances will change. This affects some non-obvious things such as the third and fourth arguments to &lt;code&gt;gluPerspective&lt;/code&gt; (the distance to the nearest and farthest objects OpenGL will render).&lt;/p&gt;

&lt;h3 id=&#34;smoothing-it-out&#34;&gt;Smoothing It Out&lt;/h3&gt;

&lt;p&gt;After watching these animations for a while, the jerkiness really begins to bother me, and because I doubled the number of animation frames, it takes twice as long to finish a run. Both of these problems relate to the second-long sleep at the end of &lt;code&gt;draw_frame&lt;/code&gt;. I should be able to fix them by shortening the sleep to half a second:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sleep .5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Chances are, that doesn&amp;rsquo;t yield quite the respected result. On my system, there&amp;rsquo;s a blur for a fraction of a second, and the whole run is done. Unfortunately, the builtin Perl &lt;code&gt;sleep&lt;/code&gt; function only handles integer seconds, so .5 truncates to 0 and the &lt;code&gt;sleep&lt;/code&gt; returns almost instantly.&lt;/p&gt;

&lt;p&gt;Luckily, SDL provides a millisecond-resolution delay function, &lt;code&gt;SDL::Delay&lt;/code&gt;. To use it, I add another subroutine to handle the delay, translating between seconds and milliseconds:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub delay
{
    my $seconds = shift;

    SDL::Delay($seconds * 1000);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, changing the &lt;code&gt;sleep&lt;/code&gt; call to &lt;code&gt;delay&lt;/code&gt; fixes it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;delay(.5);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The movement is faster and it only takes five seconds to complete the entire animation again, but this code still wastes the available performance of the system. I want the animation to be as smooth as the system allows, while keeping the rotation speed (and total time) constant. To implement this, I need to give the code a sense of time. First, I add another global to keep the current time:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ($time);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, my editor likely just sprayed his screen with whatever he&amp;rsquo;s drinking and coughed &amp;ldquo;Another global?!?&amp;rdquo; I&amp;rsquo;ll address that later in this article during the refactoring.&lt;/p&gt;

&lt;p&gt;To update the time, I need a couple more functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_time
{
    $time = now();
}

sub now
{
    return SDL::GetTicks() / 1000;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;now&lt;/code&gt; calls SDL&amp;rsquo;s &lt;code&gt;GetTicks&lt;/code&gt; function, which returns the time since SDL initialization in milliseconds. It converts the result back to seconds for convenience elsewhere. &lt;code&gt;update_time&lt;/code&gt; uses &lt;code&gt;now&lt;/code&gt; to keep the global &lt;code&gt;$time&lt;/code&gt; up to date.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;main_loop&lt;/code&gt; uses this to update the time before rendering the frame:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub main_loop
{
    while (not $done) {
        $frame++;
        update_time();
        do_frame();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Because this version won&amp;rsquo;t artificially slow the animation, I make two changes to &lt;code&gt;draw_frame&lt;/code&gt;. I remove the &lt;code&gt;delay&lt;/code&gt; call and change the animation end test to check whether the time has reached five seconds, instead of whether frame ten has been drawn.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_frame
{
    set_projection_3d();
    set_view_3d();
    draw_view();

    print &#39;.&#39;;
    $done = 1 if $time &amp;gt;= 5;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, &lt;code&gt;set_view_3d&lt;/code&gt; must base its animation on the current time instead of the current frame. Our current rotation speed is 18 degrees per frame. With 2 frames per second, that comes to 36 degrees per second:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    glRotate(90 - 36 * $time, 0, 1, 0);
    glTranslate(-6, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This version should appear much smoother. On my system, the dots printed for each frame scroll up the terminal window. If you run this program multiple times, you&amp;rsquo;ll notice the number of frames (and hence dots) varies. Small variations in timing from numerous sources cause a frame now and then to take more or less time. Over the course of a run, this adds up to being able to complete a few frames more or less before hitting the five second deadline. Visually, the rotation speed should appear nearly constant because it calculates the current angle from the current time, whatever that may be, rather than the frame number.&lt;/p&gt;

&lt;h3 id=&#34;refactoring-for-fun-and-clarity&#34;&gt;Refactoring for Fun and Clarity&lt;/h3&gt;

&lt;p&gt;Now that the animation is smooth, I&amp;rsquo;m almost ready to add some manual control using SDL events. That&amp;rsquo;s a big topic and involves a lot of code. It&amp;rsquo;s always a good idea before a big change to step back, take a look at the exisiting code, and see if it needs a clean up.&lt;/p&gt;

&lt;p&gt;The basic procedure is as follows:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Find one obvious bit of ugliness.&lt;/li&gt;
&lt;li&gt;Make a small atomic change to clean it up.&lt;/li&gt;
&lt;li&gt;Test to make sure everything still works.&lt;/li&gt;
&lt;li&gt;Lather, rinse, repeat until satisfied.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Unfortunately, it&amp;rsquo;s occasionally necessary to make one part of the code a little uglier while cleaning up something else. The trick is eventually to clean up the freshly uglified piece.&lt;/p&gt;

&lt;h4 id=&#34;refactoring-the-view&#34;&gt;Refactoring the View&lt;/h4&gt;

&lt;p&gt;And on that note, let&amp;rsquo;s add another global! I don&amp;rsquo;t like the hardcoding of &lt;code&gt;set_view_3d&lt;/code&gt;. I&amp;rsquo;d like to convert that into a data structure of some kind, so I define a view object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ($view);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This needs an update routine, so here&amp;rsquo;s a simple one:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_view
{
    $view = {
        position    =&amp;gt; [6, 2, 10],
        orientation =&amp;gt; [-90 + 36 * $time, 0, 1, 0],
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is simply the position and orientation of the virtual viewer (before the sign reversal needed by the viewing transformations). I need to call this in the main loop, just before calling &lt;code&gt;do_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub main_loop
{
    while (not $done) {
        $frame++;
        update_time();
        update_view();
        do_frame();
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, running the program should show that nothing much changed because I haven&amp;rsquo;t actually changed the viewing code&amp;ndash;the new code runs in parallel with the old code. Using the new code requires replacement of &lt;code&gt;set_view_3d&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    my ($angle, @axis) = @{$view-&amp;gt;{orientation}};
    my ($x, $y, $z)    = @{$view-&amp;gt;{position}};

    glRotate(-$angle, @axis);
    glTranslate(-$x, -$y, -$z);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running the program should again show that nothing visually changed, indicating a successful refactoring. At this point, you may wonder what this has gained; there&amp;rsquo;s a new global and a dozen or so more lines of code. The new code has several benefits:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The concepts of animating the view parameters and setting the current view in OpenGL are now separate, as they should be.&lt;/li&gt;
&lt;li&gt;Hoisting the &lt;code&gt;update_view&lt;/code&gt; call up to &lt;code&gt;main_loop&lt;/code&gt; next to the &lt;code&gt;update_time&lt;/code&gt; call begins to collect all updates together, cleaning up the overall design.&lt;/li&gt;
&lt;li&gt;The new code hints at further refactoring opportunities.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In fact, I can see several problem places to refactor next, along with some reasons to fix them:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;The mess of globals, since I just added one.&lt;/li&gt;
&lt;li&gt;Updating &lt;code&gt;$done&lt;/code&gt; in &lt;code&gt;draw_view&lt;/code&gt; (mixing updates and OpenGL work again) to continue collecting all updates together.&lt;/li&gt;
&lt;li&gt;Pervasive hardcoding in &lt;code&gt;draw_view&lt;/code&gt;, for all the same reasons I refactored &lt;code&gt;set_view_3d&lt;/code&gt;.&lt;/li&gt;
&lt;/ol&gt;

&lt;h4 id=&#34;the-great-global-smashing&#34;&gt;The Great Global Smashing&lt;/h4&gt;

&lt;p&gt;The globals situation is out of hand, so now seems a good time to fix that and check off the first item of the new &amp;ldquo;pending refactoring&amp;rdquo; list. First, I need to decide how to address the problem.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s the current globals list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ($done, $frame);
my ($conf, $sdl_app);
my ($time);
my ($view);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this mess, I see several different concepts:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Configuration: &lt;code&gt;$conf&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Resource object: &lt;code&gt;$sdl_app&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Engine state: &lt;code&gt;$done&lt;/code&gt;, &lt;code&gt;$frame&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Simulated world: &lt;code&gt;$time&lt;/code&gt;, &lt;code&gt;$view&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;I&amp;rsquo;ll create from these groupings a single engine object laid out like so (variables show where the data from the old globals goes):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;{
    conf     =&amp;gt; $conf,
    resource =&amp;gt; {
        sdl_app =&amp;gt; $sdl_app,
    },
    state    =&amp;gt; {
        done    =&amp;gt; $done,
        frame   =&amp;gt; $frame,
    },
    world    =&amp;gt; {
        time    =&amp;gt; $time,
        view    =&amp;gt; $view,
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a fairly radical change from the current code, so to be safe, I&amp;rsquo;ll do it in several small pieces, testing after each version that everything still works.&lt;/p&gt;

&lt;p&gt;The first step is to add a constructor for my object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub new
{
    my $class = shift;
    my $self  = bless {}, $class;

    return $self;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is pretty much the garden variety trivial constructor in Perl 5. It blesses a hash reference into the specified class and then returns it. I also need to change my &lt;code&gt;START&lt;/code&gt; code to use this new constructor to create an object and call &lt;code&gt;main&lt;/code&gt; as a method on it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;START: __PACKAGE__-&amp;gt;new-&amp;gt;main;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This snippet constructs a new object, using the current package as the class name, and immediately calls the &lt;code&gt;main&lt;/code&gt; method on the returned object. &lt;code&gt;main&lt;/code&gt; doesn&amp;rsquo;t have any parameters, so calling it as a method won&amp;rsquo;t affect it (there are no existing parameters that would be shifted right by a new invocant parameter). I never store the object in a variable as a form of self-imposed stricture. Because the object only exists as the invocant of &lt;code&gt;main&lt;/code&gt;, I must convert every routine that accesses the information in the object to a method and change all calls to those routines as well.&lt;/p&gt;

&lt;h5 id=&#34;let-it-flow&#34;&gt;Let It Flow&lt;/h5&gt;

&lt;p&gt;Testing at this point shows all still works, so the next change is to make &lt;code&gt;main&lt;/code&gt; flow the object reference through to its children by calling them as methods:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub main
{
    my $self = shift;

    $self-&amp;gt;init;
    $self-&amp;gt;main_loop;
    $self-&amp;gt;cleanup;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Testing this shows that, again, all is fine, as expected. &lt;code&gt;init&lt;/code&gt; and &lt;code&gt;main_loop&lt;/code&gt; are changed in the obvious fashion (&lt;code&gt;cleanup&lt;/code&gt; doesn&amp;rsquo;t do much, so it doesn&amp;rsquo;t need to change now):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init
{
    my $self = shift;

    $| = 1;

    $self-&amp;gt;init_conf;
    $self-&amp;gt;init_window;
}

sub main_loop
{
    my $self = shift;

    while (not $done) {
        $frame++;
        $self-&amp;gt;update_time;
        $self-&amp;gt;update_view;
        $self-&amp;gt;do_frame;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that I have not changed the references to &lt;code&gt;$done&lt;/code&gt; and &lt;code&gt;$frame&lt;/code&gt; in &lt;code&gt;main&lt;/code&gt;. It&amp;rsquo;s important to make only a single conceptual change at a time during refactoring, to minimize the chance of making an error and not being able to figure out which change caused the problem. I&amp;rsquo;ll return to these references in a bit. Testing this version shows that all is well, so I continue:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub do_frame
{
    my $self = shift;

    $self-&amp;gt;prep_frame;
    $self-&amp;gt;draw_frame;
    $self-&amp;gt;end_frame;
}

sub draw_frame
{
    my $self = shift;

    $self-&amp;gt;set_projection_3d;
    $self-&amp;gt;set_view_3d;
    $self-&amp;gt;draw_view;

    print &#39;.&#39;;
    $done = 1 if $time &amp;gt;= 5;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Again, for this pass, I ignore &lt;code&gt;$done&lt;/code&gt; and &lt;code&gt;$time&lt;/code&gt; in &lt;code&gt;draw_frame&lt;/code&gt;. At this point, I&amp;rsquo;ve pretty much exhausted all of the changes that amount to simply turning subroutine calls into method calls and the code still works as advertised.&lt;/p&gt;

&lt;h5 id=&#34;replacing-the-globals&#34;&gt;Replacing the Globals&lt;/h5&gt;

&lt;p&gt;With this working, I start into more interesting territory. It&amp;rsquo;s time to move the globals into their proper place in the object. First up are the state variables &lt;code&gt;$done&lt;/code&gt; and &lt;code&gt;$frame&lt;/code&gt; in &lt;code&gt;main_loop&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub main_loop
{
    my $self = shift;

    while (not $self-&amp;gt;{state}{done}) {
        $self-&amp;gt;{state}{frame}++;
        $self-&amp;gt;update_time;
        $self-&amp;gt;update_view;
        $self-&amp;gt;do_frame;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the last line of &lt;code&gt;draw_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;{state}{done} = 1 if $time &amp;gt;= 5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As they are no longer globals, I remove their declarations as well. I will have to come back to &lt;code&gt;draw_frame&lt;/code&gt; again when cleaning up &lt;code&gt;$time&lt;/code&gt;. One change per pass&amp;ndash;it&amp;rsquo;s very easy to follow a long chain of related changes before doing a test run and find out you made a mistake. Somewhere. Argh. In this case, I resist the urge to keep changing the code and do another test run immediately to find that indeed all still works.&lt;/p&gt;

&lt;p&gt;Next up is the world attribute &lt;code&gt;$view&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_view
{
    my $self = shift;

    $self-&amp;gt;{world}{view} = {
        position    =&amp;gt; [6, 2, 10],
        orientation =&amp;gt; [-90 + 36 * $time, 0, 1, 0],
    };
}

sub set_view_3d
{
    my $self = shift;

    my $view           = $self-&amp;gt;{world}{view};
    my ($angle, @axis) = @{$view-&amp;gt;{orientation}};
    my ($x, $y, $z)    = @{$view-&amp;gt;{position}};

    glRotate(-$angle, @axis);
    glTranslate(-$x, -$y, -$z);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;set_view_3d&lt;/code&gt;, it seemed clearest to make a lexical &lt;code&gt;$view&lt;/code&gt; loaded from the object. This allowed me to leave the rest of the function clean and unchanged. Testing after the above changes and removing the global declaration for &lt;code&gt;$view&lt;/code&gt; shows that all is good.&lt;/p&gt;

&lt;p&gt;Next up are &lt;code&gt;$conf&lt;/code&gt; and the resource object &lt;code&gt;$sdl_app&lt;/code&gt;, following much the same pattern as before:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_conf
{
    my $self = shift;

    $self-&amp;gt;{conf} = {
        title  =&amp;gt; &#39;Camel 3D&#39;,
        width  =&amp;gt; 400,
        height =&amp;gt; 400,
        fovy   =&amp;gt; 90,
    };
}

sub init_window
{
    my $self = shift;

    my $title = $self-&amp;gt;{conf}{title};
    my $w     = $self-&amp;gt;{conf}{width};
    my $h     = $self-&amp;gt;{conf}{height};

    $self-&amp;gt;{resource}{sdl_app}
        = SDL::App-&amp;gt;new(-title  =&amp;gt; $title,
                        -width  =&amp;gt; $w,
                        -height =&amp;gt; $h,
                        -gl     =&amp;gt; 1,
                       );
    SDL::ShowCursor(0);
}

sub set_projection_3d
{
    my $self   = shift;

    my $fovy   = $self-&amp;gt;{conf}{fovy};
    my $w      = $self-&amp;gt;{conf}{width};
    my $h      = $self-&amp;gt;{conf}{height};
    my $aspect = $w / $h;

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity;
    gluPerspective($fovy, $aspect, 1, 1000);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity;
}

sub end_frame
{
    my $self = shift;

    $self-&amp;gt;{resource}{sdl_app}-&amp;gt;sync;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first time I did this, it broke. I had forgotten to make the changes to &lt;code&gt;set_projection_3d&lt;/code&gt;. Thanks to &lt;code&gt;use strict&lt;/code&gt;, the error was obvious, and a quick fix later, everything worked again.&lt;/p&gt;

&lt;p&gt;Last but not least, it&amp;rsquo;s time to fix the remaining world attribute &lt;code&gt;$time&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_time
{
    my $self = shift;

    $self-&amp;gt;{world}{time} = now();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In &lt;code&gt;update_view&lt;/code&gt;, I continue with my tactic of creating lexicals and leaving the remaining code alone:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $time = $self-&amp;gt;{world}{time};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, the last line of &lt;code&gt;draw_frame&lt;/code&gt; changes again:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;{state}{done} = 1
    if $self-&amp;gt;{world}{time} &amp;gt;= 5;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first test run of the completed refactoring uncovered a typo that gave an obscure warning. Thankfully, I only had to check the few changed lines since the last test, and the typo was easily found. With things working again, The Great Global Smashing is complete. The once completely procedural program is now on its way to claiming object orientation. (Boy will I be happy to switch to Perl 6 OO syntax! Perl 6 OO keeps the visual clarity of pure procedural code while gaining several powerful benefits not available in Perl 5. I could fake the clearer syntax with judicious use of source filtering, but that&amp;rsquo;s another article.)&lt;/p&gt;

&lt;p&gt;This seems to me like enough refactoring for now, so it&amp;rsquo;s back to the main thrust of development: keyboard control.&lt;/p&gt;

&lt;h3 id=&#34;the-big-event&#34;&gt;The Big Event&lt;/h3&gt;

&lt;p&gt;Keyboard handling is a special case of SDL event handling, and not an entirely trivial case at that. I&amp;rsquo;ll start with the basic structure for processing SDL events and handle a much simpler event first. To access SDL events, I need to load the &lt;code&gt;SDL::Event&lt;/code&gt; module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use SDL::Event;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Like &lt;code&gt;SDL::App&lt;/code&gt;, the code needs to keep track of an &lt;code&gt;SDL::Event&lt;/code&gt; resource object to access the event queue. In addition, I need to keep track of which routine I&amp;rsquo;ll use to process each event type. This is a new kind of data, so I add a new branch to the engine object for various lookup tables. To set up both of these, I add a new initialization function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_event_processing
{
    my $self = shift;

    $self-&amp;gt;{resource}{sdl_event} = SDL::Event-&amp;gt;new;
    $self-&amp;gt;{lookup}{event_processor} = {
        &amp;amp;SDL_QUIT    =&amp;gt; \&amp;amp;process_quit,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;SDL event types are constants in the general SDL constant convention (UPPERCASE with a leading &lt;code&gt;SDL_&lt;/code&gt; marker). The event type for quit events is &lt;code&gt;SDL_QUIT&lt;/code&gt;, which I associate with the &lt;code&gt;process_quit&lt;/code&gt; routine using a subroutine reference.&lt;/p&gt;

&lt;p&gt;A new line at the end of &lt;code&gt;init&lt;/code&gt; calls the initialization routine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;init_event_processing;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Every time through, the main loop should process events before updating the view (after I add keyboard control, the view should update using the latest user input). The contents of the loop in &lt;code&gt;main_loop&lt;/code&gt; are now as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;{state}{frame}++;
$self-&amp;gt;update_time;
$self-&amp;gt;do_events;
$self-&amp;gt;update_view;
$self-&amp;gt;do_frame;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;do_events&lt;/code&gt; is very simple at this stage, just calling &lt;code&gt;process_events&lt;/code&gt; to, er, process pending SDL events:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub do_events
{
    my $self = shift;

    my $queue = $self-&amp;gt;process_events;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;the-event-processing-loop&#34;&gt;The Event Processing Loop&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;process_events&lt;/code&gt; is where all the magic happens:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub process_events
{
    my $self = shift;

    my $event  = $self-&amp;gt;{resource}{sdl_event};
    my $lookup = $self-&amp;gt;{lookup}{event_processor};
    my ($process, $command, @queue);

    $event-&amp;gt;pump;
    while (not $self-&amp;gt;{state}{done} and $event-&amp;gt;poll) {
        $process = $lookup-&amp;gt;{$event-&amp;gt;type} or next;
        $command = $self-&amp;gt;$process($event);
        push @queue, $command if $command;
    }

    return \@queue;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first couple of lines provide shorter names for the previously stored &lt;code&gt;SDL::Event&lt;/code&gt; object and event processor lookup table. The rest of the variables respectively store:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A reference to the processing routine for the current event&lt;/li&gt;
&lt;li&gt;The internal command to convert the event into&lt;/li&gt;
&lt;li&gt;The queue of commands collected from incoming events&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;The core of the code starts by telling the &lt;code&gt;SDL::Event&lt;/code&gt; object to gather any pending operating system events in preparation for the processing loop, using the &lt;code&gt;pump&lt;/code&gt; method. The processing loop checks to make sure that a previous event has not flagged the &lt;code&gt;done&lt;/code&gt; state, which helps to improve responsiveness to quit events. Assuming that this has not happened, the loop requests the next SDL event using &lt;code&gt;SDL::Event::poll&lt;/code&gt;. &lt;code&gt;poll&lt;/code&gt; returns a false value when there are no events ready for pickup, thereby exiting the loop.&lt;/p&gt;

&lt;p&gt;The first line inside the loop uses the event type to look up the proper event processing routine. If there is none, I use &lt;code&gt;next&lt;/code&gt; to loop again and check the next event. Otherwise, the next line calls the processing routine as a dynamically chosen method to handle the event. If the processing routine determines that the event requires additional work, it should return a command packet to be queued. If the event should be ignored, the processor should simply return a false value.&lt;/p&gt;

&lt;p&gt;The last line within the loop adds the command packet (if any) to the queue awaiting further processing. Once the loop processes all available SDL events, &lt;code&gt;process_events&lt;/code&gt; returns the queue so that &lt;code&gt;do_events&lt;/code&gt; can perform the next stage of processing.&lt;/p&gt;

&lt;p&gt;It may seem confusing that each time through the loop the code reuses the same &lt;code&gt;$event&lt;/code&gt;. You might expect &lt;code&gt;SDL::Event::poll&lt;/code&gt; to return the next waiting event (and perhaps &lt;code&gt;undef&lt;/code&gt; when none remain). Instead, the SDL API specifies that &lt;code&gt;poll&lt;/code&gt; copies the data from the next entry in the event queue into the event object, returning a true or false status indicating whether this operation succeeded. As with some of the OpenGL quirks, SDL_Perl copies this odd interface directly, easing the transition for programmers used to the C API.&lt;/p&gt;

&lt;p&gt;A consequence of this interface decision is that the event processing routine must make a copy of any data from the SDL event object needed for later. The call to &lt;code&gt;SDL::Event::poll&lt;/code&gt; in the next iteration of the processing loop will overwrite any data left in the SDL event object, so simply storing the object reference won&amp;rsquo;t work.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;process_quit&lt;/code&gt; routine doesn&amp;rsquo;t need to save any data; it only matters that an &lt;code&gt;SDL_QUIT&lt;/code&gt; event occurred:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub process_quit
{
    my $self = shift;

    $self-&amp;gt;{state}{done} = 1;
    return &#39;quit&#39;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;process_quit&lt;/code&gt; first sets the &lt;code&gt;done&lt;/code&gt; state flag, which causes the loop in &lt;code&gt;process_events&lt;/code&gt; to exit early and, more importantly, exits &lt;code&gt;main_loop&lt;/code&gt;. It returns the simplest type of command packet, a string indicating the &lt;code&gt;quit&lt;/code&gt; command. At this point, there&amp;rsquo;s no code to process this command further, but this keeps things parallel with the keyboard version I&amp;rsquo;ll show next.&lt;/p&gt;

&lt;p&gt;What does all this buy us? For starters, we can now (finally) quit the program using the window manager before the animation runs its course. On my system, that means clicking the &amp;lsquo;X&amp;rsquo; on the window&amp;rsquo;s title bar. Still, that&amp;rsquo;s not the same as having a quit key (which I find much more convenient).&lt;/p&gt;

&lt;h3 id=&#34;key-binding&#34;&gt;Key Binding&lt;/h3&gt;

&lt;p&gt;To add a quit key, I first need to decide &lt;em&gt;which&lt;/em&gt; key should quit the program. I&amp;rsquo;d choose the Escape key because that makes mnemonic sense to me, but everyone has their favorite, so I&amp;rsquo;ll allow that to be a configuration setting. To do this, I extend the configuration hash with a new &lt;code&gt;bind&lt;/code&gt; section:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_conf
{
    my $self = shift;

    $self-&amp;gt;{conf} = {
        title  =&amp;gt; &#39;Camel 3D&#39;,
        width  =&amp;gt; 400,
        height =&amp;gt; 400,
        fovy   =&amp;gt; 90,
        bind   =&amp;gt; {
            escape =&amp;gt; &#39;quit&#39;,
        }
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now anyone who wants to choose a different quit key can simply change the keyboard bindings hash. In fact, several keys could be associated with the same command, so that either the Escape key or &amp;lsquo;q&amp;rsquo; would exit the program. The hash value corresponding to each specified key is the command packet issued when the user presses that key. This one matches the command packet I&amp;rsquo;d chosen for the window manager quit message earlier.&lt;/p&gt;

&lt;p&gt;Next, I need to process keypress events, which have the event type &lt;code&gt;SDL_KEYDOWN&lt;/code&gt;. I add another entry to the &lt;code&gt;event_processor&lt;/code&gt; hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_event_processing
{
    my $self = shift;

    $self-&amp;gt;{resource}{sdl_event} = SDL::Event-&amp;gt;new;
    $self-&amp;gt;{lookup}{event_processor} = {
        &amp;amp;SDL_QUIT    =&amp;gt; \&amp;amp;process_quit,
        &amp;amp;SDL_KEYDOWN =&amp;gt; \&amp;amp;process_key,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and define the key processor as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub process_key
{
    my $self = shift;

    my $event   = shift;
    my $symbol  = $event-&amp;gt;key_sym;
    my $name    = SDL::GetKeyName($symbol);
    my $command = $self-&amp;gt;{conf}{bind}{$name} || &#39;&#39;;

    return $command;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;process_key&lt;/code&gt; starts by extracting the key symbol from the SDL event. Key symbols are rather opaque for our purposes, so I request the key name matching the extracted key symbol using &lt;code&gt;SDL::GetKeyName&lt;/code&gt;. This produces a friendly key name that I look up in the key bindings hash to find the appropriate command packet. If there is none, no matter; that key isn&amp;rsquo;t bound yet so it yields an empty command packet. &lt;code&gt;process_key&lt;/code&gt; then returns the command packet to add to the queue for further processing.&lt;/p&gt;

&lt;h4 id=&#34;handling-command-packets&#34;&gt;Handling Command Packets&lt;/h4&gt;

&lt;p&gt;At this point, the code converts a press of the Escape key into a quit command packet, but &lt;code&gt;do_events&lt;/code&gt; ignores that packet because it does not process the command queue it receives from &lt;code&gt;process_events&lt;/code&gt;. To make something happen, I first need to associate each known command with an action routine. I create a new lookup hash for this association, initialized in &lt;code&gt;init_command_actions&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_command_actions
{
    my $self = shift;

    $self-&amp;gt;{lookup}{command_action} = {
        quit      =&amp;gt; \&amp;amp;action_quit,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As usual, I call this at the end of &lt;code&gt;init&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;init_command_actions;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s now time to fill out &lt;code&gt;do_events&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub do_events
{
    my $self   = shift;

    my $queue  = $self-&amp;gt;process_events;
    my $lookup = $self-&amp;gt;{lookup}{command_action};
    my ($command, $action);

    while (not $self-&amp;gt;{state}{done} and @$queue) {
        $command = shift @$queue;
        $action  = $lookup-&amp;gt;{$command} or next;
        $self-&amp;gt;$action($command);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is similar in form to &lt;code&gt;process_events&lt;/code&gt;. Instead of processing events from SDL&amp;rsquo;s internal queue to create a queue of command packets, it processes queued command packets into actions to perform. The loop starts as usual by checking that the &lt;code&gt;done&lt;/code&gt; is not true and that there are still commands pending in the queue.&lt;/p&gt;

&lt;p&gt;Within the loop, it shifts the next command off the front of the queue. The next line determines the action routine associated with the command. If it cannot find one, it uses &lt;code&gt;next&lt;/code&gt; to skip to the next command. Otherwise, it calls the action routine as a dynamically chosen method with the command packet as a parameter. This allows a single action routine to process several similar commands while still being able to tell the difference between them. I&amp;rsquo;ll need this later for processing movement keys.&lt;/p&gt;

&lt;p&gt;For all of that, &lt;code&gt;action_quit&lt;/code&gt; is very simple; it just flags &lt;code&gt;done&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub action_quit
{
    my $self = shift;

    $self-&amp;gt;{state}{done} = 1;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, the Escape key really will quit the program early, and the window manager quit still works as well.&lt;/p&gt;

&lt;p&gt;Now that the user can quit whenever desired, I can finally remove the incongruous end of &lt;code&gt;draw_frame&lt;/code&gt;. It&amp;rsquo;s no longer necessary to force the program to end after five seconds, and the dots printed each frame have outlived their usefulness. The routine now looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_frame
{
    my $self = shift;

    $self-&amp;gt;set_projection_3d;
    $self-&amp;gt;set_view_3d;
    $self-&amp;gt;draw_view;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, if you wait long enough after the objects disappear on the right, the view rotates all the way around, and the scene appears again on the left. This version of the routine is much cleaner and incidently closes the next open refactoring issue (changing engine state within a drawing routine) for free.&lt;/p&gt;

&lt;h3 id=&#34;controlling-the-view&#34;&gt;Controlling the View&lt;/h3&gt;

&lt;p&gt;Now that the code can handle keypress events, it&amp;rsquo;s time to control the view using the keyboard.&lt;/p&gt;

&lt;p&gt;Instead of having the view completely recalculated every frame, I&amp;rsquo;d rather have each keypress modify the existing view state. To specify the initial state, I add another initialization routine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_view
{
    my $self = shift;

    $self-&amp;gt;{world}{view} = {
        position    =&amp;gt; [6, 2, 10],
        orientation =&amp;gt; [0, 0, 1, 0],
        d_yaw       =&amp;gt; 0,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new entry, &lt;code&gt;d_yaw&lt;/code&gt;, tells &lt;code&gt;update_view&lt;/code&gt; if there is a pending change (aka delta, hence the leading &lt;code&gt;d_&lt;/code&gt;) in facing. The code so far can only handle yaw (left and right rotation), so that&amp;rsquo;s the only delta key needed right now.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;init&lt;/code&gt; calls this routine as usual in its new last line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;init_view;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;update_view&lt;/code&gt; applies the yaw delta to the view orientation, then zeroes out &lt;code&gt;d_yaw&lt;/code&gt; so that it won&amp;rsquo;t continue to affect the rotation in succeeding frames (without the user pressing the rotation keys again):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_view
{
    my $self   = shift;

    my $view   = $self-&amp;gt;{world}{view};

    $view-&amp;gt;{orientation}[0] += $view-&amp;gt;{d_yaw};
    $view-&amp;gt;{d_yaw}           = 0;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A command action assigned to the &lt;code&gt;yaw_left&lt;/code&gt; and &lt;code&gt;yaw_right&lt;/code&gt; commands updates &lt;code&gt;d_yaw&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_command_actions
{
    my $self = shift;

    $self-&amp;gt;{lookup}{command_action} = {
        quit      =&amp;gt; \&amp;amp;action_quit,
        yaw_left  =&amp;gt; \&amp;amp;action_move,
        yaw_right =&amp;gt; \&amp;amp;action_move,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To assign keys for these commands, I update the &lt;code&gt;bind&lt;/code&gt; hash in &lt;code&gt;init_conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind   =&amp;gt; {
    escape =&amp;gt; &#39;quit&#39;,
    left   =&amp;gt; &#39;yaw_left&#39;,
    right  =&amp;gt; &#39;yaw_right&#39;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The big change is the new command action routine &lt;code&gt;action_move&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub action_move
{
    my $self = shift;

    my $command     = shift;
    my $view        = $self-&amp;gt;{world}{view};
    my $speed_yaw   = 10;
    my %move_update = (
        yaw_left  =&amp;gt; [d_yaw =&amp;gt;  $speed_yaw],
        yaw_right =&amp;gt; [d_yaw =&amp;gt; -$speed_yaw],
    );
    my $update = $move_update{$command} or return;

    $view-&amp;gt;{$update-&amp;gt;[0]} += $update-&amp;gt;[1];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;action_move&lt;/code&gt; starts by grabbing the command parameter and current view. It then sets the basic rotation speed, measured in degrees per key press. Next, the &lt;code&gt;%move_update&lt;/code&gt; hash defines the view update associated with each known command. If it knows the command, it retrieves the corresponding update. If not, &lt;code&gt;action_move&lt;/code&gt; returns.&lt;/p&gt;

&lt;p&gt;The last line interprets the update. The view key specified by the first element of the update array is incremented by the amount specified by the second element. In other words, receiving a &lt;code&gt;yaw_left&lt;/code&gt; command causes the routine to add &lt;code&gt;$speed_yaw&lt;/code&gt; to &lt;code&gt;$view-&amp;gt;{d_yaw}&lt;/code&gt;; a &lt;code&gt;yaw_right&lt;/code&gt; command adds &lt;code&gt;-$speed_yaw&lt;/code&gt; to &lt;code&gt;$view-&amp;gt;{d_yaw}&lt;/code&gt;, effectively turning the view the opposite direction.&lt;/p&gt;

&lt;p&gt;With these changes in place, the program starts up looking directly at the scene as it appeared near the beginning of this article. Each press of the left or right arrow keys turns the view ten degrees in the appropriate direction (remember that the scene appears to turn the opposite direction around the view). Holding the keys down does nothing; only a change from unpressed to pressed does anything, and it only rotates the view one increment. This, as they say, is suboptimal.&lt;/p&gt;

&lt;h4 id=&#34;angular-velocity&#34;&gt;Angular Velocity&lt;/h4&gt;

&lt;p&gt;In order to solve this, the code has to change from working purely in terms of angular &lt;em&gt;position&lt;/em&gt; to working in terms of angular &lt;em&gt;velocity&lt;/em&gt;. Pressing a key should start the view rotating at a constant speed, and it should stay that way until the key is released.&lt;/p&gt;

&lt;p&gt;Velocity goes hand in hand with time. In particular, for each frame, &lt;code&gt;update_view&lt;/code&gt; needs to know how much time has passed since the last frame to determine the change in angle matching the rotation speed. To compute this time delta, the first change is to make sure the code always has a valid world time by initializing it at program start:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_time
{
    my $self             = shift;

    $self-&amp;gt;{world}{time} = now();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, this requires another line at the end of &lt;code&gt;init&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$self-&amp;gt;init_time;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With this in place, I can change &lt;code&gt;update_time&lt;/code&gt; to record the time delta for each frame:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_time
{
    my $self = shift;

    my $now  = now();

    $self-&amp;gt;{world}{d_time} = $now - $self-&amp;gt;{world}{time};
    $self-&amp;gt;{world}{time}   = $now;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve made a few changes that shouldn&amp;rsquo;t affect the behavior of the program, and I&amp;rsquo;m about to make several more that definitely will change the behavior, so now is a good time for a quick sanity test. All is fine, so it&amp;rsquo;s time to contemplate the design for the remaining code.&lt;/p&gt;

&lt;h5 id=&#34;continuing-commands&#34;&gt;Continuing Commands&lt;/h5&gt;

&lt;p&gt;There are really two classes of keyboard commands that I want to handle:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Single-shots like &lt;code&gt;quit&lt;/code&gt;, &lt;code&gt;drop_object&lt;/code&gt;, and &lt;code&gt;pull_pin&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;Continuing commands like &lt;code&gt;yaw_left&lt;/code&gt; and &lt;code&gt;scream_head_off&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;To differentiate them, I borrow an existing game convention and use a leading &lt;code&gt;+&lt;/code&gt; to indicate a continuing command. This changes the bind mapping in &lt;code&gt;init_conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind   =&amp;gt; {
    escape =&amp;gt; &#39;quit&#39;,
    left   =&amp;gt; &#39;+yaw_left&#39;,
    right  =&amp;gt; &#39;+yaw_right&#39;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and the &lt;code&gt;command_action&lt;/code&gt; lookup:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_command_actions
{
    my $self = shift;

    $self-&amp;gt;{lookup}{command_action} = {
          quit       =&amp;gt; \&amp;amp;action_quit,
        &#39;+yaw_left&#39;  =&amp;gt; \&amp;amp;action_move,
        &#39;+yaw_right&#39; =&amp;gt; \&amp;amp;action_move,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To process the key release events, I need to assign an event processor for the &lt;code&gt;SDL_KEYUP&lt;/code&gt; event. I&amp;rsquo;ll reuse the existing &lt;code&gt;process_key&lt;/code&gt; routine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_event_processing
{
    my $self = shift;

    $self-&amp;gt;{resource}{sdl_event} = SDL::Event-&amp;gt;new;
    $self-&amp;gt;{lookup}{event_processor} = {
        &amp;amp;SDL_QUIT    =&amp;gt; \&amp;amp;process_quit,
        &amp;amp;SDL_KEYUP   =&amp;gt; \&amp;amp;process_key,
        &amp;amp;SDL_KEYDOWN =&amp;gt; \&amp;amp;process_key,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;process_key&lt;/code&gt; needs some training to be able to differentiate the two types of events:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub process_key
{
    my $self    = shift;

    my $event   = shift;
    my $symbol  = $event-&amp;gt;key_sym;
    my $name    = SDL::GetKeyName($symbol);
    my $command = $self-&amp;gt;{conf}{bind}{$name} || &#39;&#39;;
    my $down    = $event-&amp;gt;type == SDL_KEYDOWN;

    if ($command =~ /^\+/) {
        return [$command, $down];
    }
    else {
        return $down ? $command : &#39;&#39;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new code (everything after the &lt;code&gt;my $command&lt;/code&gt; line) first sets &lt;code&gt;$down&lt;/code&gt; to true if the key is being pressed or to false if the key is being released. The remaining changes replace the old &lt;code&gt;return $command&lt;/code&gt; line. For continuing commands (those that start with a &lt;code&gt;+&lt;/code&gt;), there&amp;rsquo;s a new class of command packet, containing both the &lt;code&gt;$command&lt;/code&gt; and the &lt;code&gt;$down&lt;/code&gt; boolean to indicate whether the command should begin or end. Single-shot commands (those without a leading &lt;code&gt;+&lt;/code&gt;), send a simple command packet only for keypresses; they ignore key releases.&lt;/p&gt;

&lt;p&gt;To handle the new class of command packets, I update &lt;code&gt;do_events&lt;/code&gt; as well:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub do_events
{
    my $self   = shift;

    my $queue  = $self-&amp;gt;process_events;
    my $lookup = $self-&amp;gt;{lookup}{command_action};
    my ($command, $action);

    while (not $self-&amp;gt;{state}{done} and @$queue) {
        my @args;
        $command          = shift @$queue;
        ($command, @args) = @$command if ref $command;

        $action = $lookup-&amp;gt;{$command} or next;
        $self-&amp;gt;$action($command, @args);
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The only new code is inside the loop. It starts off by assuming that the command packet is a simple one, with no arguments. If the command turns out to be a reference instead of a string, it unpacks it into a command string and some arguments. The &lt;code&gt;$action&lt;/code&gt; lookup remains unchanged, but the last line changes slightly to add &lt;code&gt;@args&lt;/code&gt; to the parameters of the action routine. If there are no arguments, this has no effect, so a single-shot action routine such as &lt;code&gt;action_quit&lt;/code&gt; can remain unchanged.&lt;/p&gt;

&lt;h5 id=&#34;view-meet-velocity&#34;&gt;View, Meet Velocity&lt;/h5&gt;

&lt;p&gt;The view needs to keep track of the current yaw velocity and the velocity delta when the user presses or releases a key; I initialize them to 0 in &lt;code&gt;init_view&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_view
{
    my $self = shift;

    $self-&amp;gt;{world}{view} = {
        position    =&amp;gt; [6, 2, 10],
        orientation =&amp;gt; [0, 0, 1, 0],
        d_yaw       =&amp;gt; 0,
        v_yaw       =&amp;gt; 0,
        dv_yaw      =&amp;gt; 0,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;update_view&lt;/code&gt; needs a few more lines to handle the new variables:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub update_view
{
    my $self   = shift;

    my $view   = $self-&amp;gt;{world}{view};
    my $d_time = $self-&amp;gt;{world}{d_time};

    $view-&amp;gt;{orientation}[0] += $view-&amp;gt;{d_yaw};
    $view-&amp;gt;{d_yaw}           = 0;

    $view-&amp;gt;{v_yaw}          += $view-&amp;gt;{dv_yaw};
    $view-&amp;gt;{dv_yaw}          = 0;
    $view-&amp;gt;{orientation}[0] += $view-&amp;gt;{v_yaw} * $d_time;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After adding any velocity delta to the current yaw velocity, this method multiples the total yaw velocity by the time delta for this frame to determine the change in orientation. This is accumulated with the current orientation and any other facing change for this frame.&lt;/p&gt;

&lt;p&gt;Finally, I update &lt;code&gt;action_move&lt;/code&gt; to handle the new semantics:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub action_move
{
    my $self = shift;

    my ($command, $down) = @_;
    my $sign             = $down ? 1 : -1;
    my $view             = $self-&amp;gt;{world}{view};
    my $speed_yaw        = 36;
    my %move_update      = (
        &#39;+yaw_left&#39;  =&amp;gt; [dv_yaw =&amp;gt;  $speed_yaw],
        &#39;+yaw_right&#39; =&amp;gt; [dv_yaw =&amp;gt; -$speed_yaw],
    );
    my $update = $move_update{$command} or return;

    $view-&amp;gt;{$update-&amp;gt;[0]} += $update-&amp;gt;[1] * $sign;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$sign&lt;/code&gt; variable converts the &lt;code&gt;$down&lt;/code&gt; parameter from &lt;sup&gt;1&lt;/sup&gt;&amp;frasl;&lt;sub&gt;0&lt;/sub&gt; to +1/-1. I changed the last line of the routine to multiply the delta by this sign before updating the value. Adding a negated value is the same as subtracting the original value; this means that pressing a key requires adding the update, and releasing it will subtract it back out.&lt;/p&gt;

&lt;p&gt;To make sure the new yaw commands update velocity, I also fixed up the &lt;code&gt;%move_update&lt;/code&gt; hash to update &lt;code&gt;dv_yaw&lt;/code&gt; instead of &lt;code&gt;d_yaw&lt;/code&gt; and used the &lt;code&gt;+&lt;/code&gt; versions of the command names. Finally, to bring back the old rotation rate, I set &lt;code&gt;$speed_yaw&lt;/code&gt; to 36 degrees per second.&lt;/p&gt;

&lt;p&gt;This version responds the way most people expect. Holding down a key turns the proper direction until the key is released. What about when the user presses multiple keys at once? This is why I was careful always to accumulate updates and deltas by using &lt;code&gt;+=&lt;/code&gt; instead of plain old &lt;code&gt;=&lt;/code&gt;. If the user holds both the right and left arrow keys down at the same time, the view remains motionless because they&amp;rsquo;ve added in equal and opposite values to &lt;code&gt;dv_yaw&lt;/code&gt;. If the user releases just one of the keys, the view rotates in the proper direction for the key that is still held down because the opposing update has now been subtracted back out. Press the released key back down while still holding the other, and the rotation stops again as expected.&lt;/p&gt;

&lt;p&gt;Of course, there&amp;rsquo;s no requirement that the speeds for yawing left and right must be the same. In fact, for an airplane or spaceship simulation, the game engine might set these differently to represent damage to the control surfaces or maneuvering thrusters. It may even be part of the gameplay to hold both direction keys down at the same time to compensate partially for this damage, perhaps tapping one key while holding the other steady.&lt;/p&gt;

&lt;p&gt;One thing that &lt;em&gt;doesn&amp;rsquo;t&lt;/em&gt; magically work is making sure that if several keys map to the same command, pressing them all won&amp;rsquo;t make the command take effect several times over. As it stands, the user could map five keys to the same movement command and move five times as fast. You might try fixing this on your own as a quick puzzle; I&amp;rsquo;ll try to address it in a later installment.&lt;/p&gt;

&lt;h5 id=&#34;eyes-in-the-back-of-your-head&#34;&gt;Eyes in the Back of Your Head&lt;/h5&gt;

&lt;p&gt;You might be curious why I left &lt;code&gt;d_yaw&lt;/code&gt; hanging around, since nothing uses it now. I could use it in the above-mentioned space simulation to simulate a thruster stuck on&amp;ndash;continuously trying to veer the ship off course. In a first-person game, it allows one of my favorite commands, &lt;code&gt;+look_behind&lt;/code&gt;. Holding down the appropriate key rotates the view 180 degrees. Releasing the key snaps the view back forward. To implement this, I need to add another entry to the &lt;code&gt;bind&lt;/code&gt; hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;bind   =&amp;gt; {
    escape =&amp;gt; &#39;quit&#39;,
    left   =&amp;gt; &#39;+yaw_left&#39;,
    right  =&amp;gt; &#39;+yaw_right&#39;,
    tab    =&amp;gt; &#39;+look_behind&#39;,
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then another &lt;code&gt;command_action&lt;/code&gt; entry:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init_command_actions
{
    my $self = shift;

    $self-&amp;gt;{lookup}{command_action} = {
          quit         =&amp;gt; \&amp;amp;action_quit,
        &#39;+yaw_left&#39;    =&amp;gt; \&amp;amp;action_move,
        &#39;+yaw_right&#39;   =&amp;gt; \&amp;amp;action_move,
        &#39;+look_behind&#39; =&amp;gt; \&amp;amp;action_move,
    };
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Last but not least, another entry in &lt;code&gt;%move_update&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my %move_update      = (
    &#39;+yaw_left&#39;    =&amp;gt; [dv_yaw =&amp;gt;  $speed_yaw],
    &#39;+yaw_right&#39;   =&amp;gt; [dv_yaw =&amp;gt; -$speed_yaw],
    &#39;+look_behind&#39; =&amp;gt; [d_yaw  =&amp;gt;  180       ],
);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it: a whopping three lines, all of which were entries in lookup hashes.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;That&amp;rsquo;s it for this article; it&amp;rsquo;s already quite long. I started where I left off in the last article. From there, I talked about translation and rotation of the view; millisecond resolution SDL time; animation from jerky beginnings to smooth movement; basic SDL event and keyboard handling; single-shot and continuing commands; and a whole lot of refactoring.&lt;/p&gt;

&lt;p&gt;Next time, I&amp;rsquo;ll talk about moving the &lt;em&gt;position&lt;/em&gt; of the viewpoint, clean up &lt;code&gt;draw_view&lt;/code&gt;, and spend some more time on the OpenGL side of things with the basics of lighting and materials. In the meantime, I&amp;rsquo;ve covered quite a lot in this article, so go forth and experiment!&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Building a 3D Engine in Perl</title>
      <link>http://localhost:1313/pub/2004/12/01/3d_engine.html/</link>
      <pubDate>Wed, 01 Dec 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/12/01/3d_engine.html/</guid>
      <description>

&lt;p&gt;This article is the first in a series aimed at building a full 3D engine. It could be the underlying technology for a video game, the visualization system for a scientific application, the walkthrough program for an architectural design suite, or whatever.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s note: see also the rest of the series, &lt;a href=&#34;http://localhost:1313/pub/2004/12/29/3d_engine.html&#34;&gt;events and keyboard handling&lt;/a&gt;, &lt;a href=&#34;http://localhost:1313/pub/2005/02/17/3d_engine.html&#34;&gt;lighting and movement&lt;/a&gt;, and &lt;a href=&#34;http://localhost:1313/pub/2005/08/04/3d_engine.html&#34;&gt;profiling your application&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;First, I&amp;rsquo;ll set some goals and ground rules to help guide the design. I&amp;rsquo;m all for agile programming, but even the most agile development process needs some basic goals at the outset:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;I&amp;rsquo;m not going to make little demos. Early on, the engine won&amp;rsquo;t have much functionality, but it should always be a good foundation for future growth.&lt;/li&gt;
&lt;li&gt;The engine must be portable across architectures and operating systems. I will use OpenGL for 3D rendering and SDL for general, operating system interaction, such as input handling and window creation. The engine itself should contain almost no OS-specific code.&lt;/li&gt;
&lt;li&gt;The engine should be operational at every step of the way, from the very beginning. I will flesh it out over time, and there may be some complex concepts that take some time to work through, but at the very least, every article should end with the whole engine working again.&lt;/li&gt;
&lt;li&gt;I&amp;rsquo;ll leave out most error checking to save space and make the central concepts more clear. For the same reasons, there is no included test library. In your own engine, you will want to have both!&lt;/li&gt;
&lt;li&gt;Don&amp;rsquo;t be afraid to experiment. The best way to learn this stuff is to play with it. Start with what&amp;rsquo;s in the articles and add to it. Any time you spend now will repay itself many times over later, because it&amp;rsquo;s easier to understand advanced topics when you have a solid understanding of the earlier topics.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;As a final note before we begin, some versions of SDL_Perl have bugs that will affect the engine. If I know of any issues to watch out for, I&amp;rsquo;ll let you know; conversely, if you find any bugs, let me know, and I&amp;rsquo;ll include a note in a following article.&lt;/p&gt;

&lt;h3 id=&#34;span-id-getting-started-getting-started-span&#34;&gt;&lt;span id=&#34;Getting Started&#34;&gt;Getting Started&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The first step is to rough out a simple structure and make a runnable program right off. Bear with me; there&amp;rsquo;s a fair bit of code here for what it does, but that will simplify things later on. Here&amp;rsquo;s my starting point:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;#!/usr/bin/perl

use strict;
use warnings;

my ($done, $frame);

START: main();

sub main
{
    init();
    main_loop();
    cleanup();
}

sub init
{
    $| = 1;
}

sub main_loop
{
    while (not $done) {
        $frame++;
        do_frame();
    }
}

sub do_frame
{
    print &#39;.&#39;;
    sleep 1;
    $done = 1 if $frame == 5;
}

sub cleanup
{
    print &amp;quot;\nDone.\n&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The first few lines are the usual strict boilerplate, especially important since I&amp;rsquo;m working without a net (a test library). Then I declare a couple of state variables (a &amp;ldquo;done&amp;rdquo; flag and a frame counter), and jump to the main program.&lt;/p&gt;

&lt;p&gt;The main program is pretty simple &amp;ndash; initialize, run the main loop for a while, and then clean up. It&amp;rsquo;s typical of how I structure a potentially complex program. The top-level routines should be very simple, clear, and self-documenting. Each conceptual piece is a separate routine, wherein reside all the gritty bits that actually do the real work. I&amp;rsquo;ve seen huge programs (hundreds of thousands of lines) where the main procedures started with several hundred lines of initialization before finally branching to the &amp;ldquo;real&amp;rdquo; main body at the end. That style is hard to debug, hard to profile, and just plain hard to understand. I avoid it religiously.&lt;/p&gt;

&lt;p&gt;Back to the program at hand. &lt;code&gt;init&lt;/code&gt; sets autoflush on &lt;code&gt;STDOUT&lt;/code&gt; so that partial lines print immediately, which I use later in &lt;code&gt;do_frame&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;main_loop&lt;/code&gt; simply loops until &lt;code&gt;$done&lt;/code&gt; is true, producing one finished animation frame per loop. Each loop increments the frame counter and calls the actual routine that does the work, &lt;code&gt;do_frame&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;do_frame&lt;/code&gt; prints a single dot to indicate a frame has begun, and sleeps for a second. When it wakes up, it checks if five frames have completed, flagging &lt;code&gt;$done&lt;/code&gt; if so.&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;$done&lt;/code&gt; set, &lt;code&gt;main_loop&lt;/code&gt; ends and control returns to &lt;code&gt;main&lt;/code&gt;, which calls the final &lt;code&gt;cleanup&lt;/code&gt;. &lt;code&gt;cleanup&lt;/code&gt; just notifies the user of a clean exit and ends.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s a fair amount of code to print two lines of text (over the course of five seconds) and exit; it doesn&amp;rsquo;t even open a rendering window! I&amp;rsquo;ll do that next.&lt;/p&gt;

&lt;h3 id=&#34;span-id-creating-a-window-creating-a-window-span&#34;&gt;&lt;span id=&#34;Creating a Window&#34;&gt;Creating a Window&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;First, I need to pull in the SDL and OpenGL libraries:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use SDL::App;
use SDL::OpenGL; 
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and add a couple more state variables (a config hash and an &lt;code&gt;SDL::App&lt;/code&gt; object):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my ($conf, $sdl_app); 
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-initialization-initialization-span&#34;&gt;&lt;span id=&#34;Initialization&#34;&gt;Initialization&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;I&amp;rsquo;m going to do two new types of initialization, so I create routines for them and call them from &lt;code&gt;init&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub init
{
    $| = 1;
    init_conf();
    init_window();
}

sub init_conf
{
    $conf = {
        title  =&amp;gt; &#39;Camel 3D&#39;,
        width  =&amp;gt; 400,
        height =&amp;gt; 400,
    };
}

sub init_window
{
    my ($title, $w, $h) = @$conf{qw( title width height )};

    $sdl_app = SDL::App-&amp;gt;new(-title  =&amp;gt; $title,
                             -width  =&amp;gt; $w,
                             -height =&amp;gt; $h,
                             -gl     =&amp;gt; 1,
                            );
    SDL::ShowCursor(0);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, &lt;code&gt;init_conf&lt;/code&gt; just defines some configuration properties used immediately in &lt;code&gt;init_window&lt;/code&gt;, which contains the first real SDL meat.&lt;/p&gt;

&lt;p&gt;&lt;code&gt;init_window&lt;/code&gt; performs two important actions. First, it asks &lt;code&gt;SDL::App&lt;/code&gt; to create a new window, with the appropriate title, width, and height. The &lt;em&gt;-gl&lt;/em&gt; option tells &lt;code&gt;SDL::App&lt;/code&gt; to attach an OpenGL 3D-rendering context to this window instead of the default 2D-rendering context. Second, it hides the mouse cursor (while it&amp;rsquo;s within the new window&amp;rsquo;s border) using &lt;code&gt;SDL::ShowCursor(0)&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;span-id-three-phases-of-drawing-three-phases-of-drawing-span&#34;&gt;&lt;span id=&#34;Three Phases of Drawing&#34;&gt;Three Phases of Drawing&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Now that I have a nice new window, I&amp;rsquo;d like &lt;code&gt;do_frame&lt;/code&gt; to do something with it. I&amp;rsquo;ll start by breaking the rendering into three phases: prepare, draw, and finish.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub do_frame
{
    prep_frame();
    draw_frame();
    end_frame();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For now, &lt;code&gt;draw_frame&lt;/code&gt; contains exactly what &lt;code&gt;do_frame&lt;/code&gt; used to contain:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_frame
{
    print &#39;.&#39;;
    sleep 1;
    $done = 1 if $frame == 5;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The new code is in &lt;code&gt;prep_frame&lt;/code&gt; and &lt;code&gt;end_frame&lt;/code&gt;; let&amp;rsquo;s look at &lt;code&gt;prep_frame&lt;/code&gt; first:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub prep_frame
{
    glClear(GL_COLOR_BUFFER_BIT);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the first actual OpenGL call. Before I explain the details, it&amp;rsquo;s worth pointing out the OpenGL naming conventions. OpenGL&amp;rsquo;s design allows it to work with programming languages that have no concept of namespaces or packages. In order to work around this, all OpenGL routine names look like &lt;code&gt;glFooBar&lt;/code&gt; (CamelCase, no underscores, &lt;code&gt;gl&lt;/code&gt; prepended), and all OpenGL constant names look like &lt;code&gt;GL_FOO_BAR&lt;/code&gt; (UPPERCASE, underscores between words, &lt;code&gt;GL_&lt;/code&gt; prepended). In older languages, this prevents the OpenGL names from colliding with names used in other libraries. In the Perl world, this isn&amp;rsquo;t an issue for object-oriented modules. Because OpenGL is not object-oriented, SDL_Perl takes advantage of this convention and simply imports all of the names into the current package when you write &lt;code&gt;use SDL::OpenGL&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note: If you read OpenGL code written in C, you may notice a short string of characters appended to the routine names, such as &lt;code&gt;3fv&lt;/code&gt;. This convention differentiates variants that have different numbers of parameters or whose parameters are different types. In Perl, values know their own type and a function&amp;rsquo;s parameters can vary in number, so this is unnecessary. The Perl bindings simply drop these extra characters and &lt;code&gt;SDL::OpenGL&lt;/code&gt; do the right thing for you.&lt;/p&gt;

&lt;p&gt;The OpenGL call in &lt;code&gt;prep_frame&lt;/code&gt; clears the rendering area to black by calling &lt;code&gt;glClear&lt;/code&gt; &amp;ndash; the general OpenGL &amp;ldquo;clear a buffer&amp;rdquo; routine &amp;ndash; with a constant that indicates it should clear the &lt;em&gt;color buffer&lt;/em&gt;. As the name indicates, the color buffer stores the color for each pixel and is what the user sees. Several other OpenGL buffers exist; I&amp;rsquo;ll describe those later.&lt;/p&gt;

&lt;p&gt;The alert reader may wonder why the code clears the color buffer to black as opposed to white or some other color. OpenGL relies heavily on the concept of &lt;em&gt;current state&lt;/em&gt;. Many OpenGL routines do not actually request any rendering, instead altering one or more variables in the current state so that the next rendering command will perform its action differently. When a program prepares to use OpenGL, which &lt;code&gt;SDL::App::new&lt;/code&gt; does for us, the current state is set to (mostly) reasonable defaults. One of these state variables is the color to use when clearing the color buffer. Its default is black, which I haven&amp;rsquo;t bothered to override.&lt;/p&gt;

&lt;p&gt;The remaining routine is &lt;code&gt;end_frame&lt;/code&gt; :&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub end_frame
{
    $sdl_app-&amp;gt;sync;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This asks the SDL::App object to synchronize the window contents with those held in OpenGL&amp;rsquo;s color buffer, so that the user can see the rendered image. In this case, it&amp;rsquo;s a black window for five seconds.&lt;/p&gt;

&lt;h3 id=&#34;span-id-something-to-see-something-to-see-span&#34;&gt;&lt;span id=&#34;Something to See&#34;&gt;Something to See&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s time to draw something in that window. To do so, I need to do three things:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;Choose a projection, so that OpenGL knows how I want to look at the scene.&lt;/li&gt;
&lt;li&gt;Set the view, so OpenGL knows from which direction to view the scene (the &lt;em&gt;viewpoint&lt;/em&gt;) and in which direction I wish to look.&lt;/li&gt;
&lt;li&gt;Define an object in the scene, placed where the viewpoint can see it.&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;To start, I need another config setting, so I&amp;rsquo;ll add another line to the &lt;code&gt;$conf&lt;/code&gt; hash in &lt;code&gt;init_conf&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        fovy   =&amp;gt; 90,
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, for my three new functions, I add three new calls at the top of &lt;code&gt;draw_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_frame
{
    set_projection_3d();
    set_view_3d();
    draw_view();
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-choose-a-projection-choose-a-projection-span&#34;&gt;&lt;span id=&#34;Choose a Projection&#34;&gt;Choose a Projection&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;&lt;code&gt;set_projection_3d&lt;/code&gt; is as follows:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_projection_3d
{
    my ($fovy, $w, $h) = @$conf{qw( fovy width height )};
    my $aspect = $w / $h;

    glMatrixMode(GL_PROJECTION);
    glLoadIdentity;
    gluPerspective($fovy, $aspect, 1, 1000);

    glMatrixMode(GL_MODELVIEW);
    glLoadIdentity;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the first place you can see an indication of the hard part of 3D graphics simmering below the surface &amp;ndash; math, and lots of it. 3D-rendering code often includes a fairly hefty load of linear algebra (matrix math, for those blocking out their high school and college years) and trigonometry. Thankfully, OpenGL does a lot of that math under the covers. I&amp;rsquo;ve also defined a fairly simple projection and view, so this hides a lot of the complexity for now (aside from some of the OpenGL function names).&lt;/p&gt;

&lt;p&gt;The first section of the routine defines the viewing projection. In the simplest case, that means choosing whether to use an &lt;em&gt;orthogonal&lt;/em&gt; projection or a &lt;em&gt;perspective&lt;/em&gt; projection. Orthogonal projections have no foreshortening. They commonly appear in architectural and engineering drawings, because parts that are the same size also appear the same size, no matter where they are in the scene.&lt;/p&gt;

&lt;p&gt;Perspective projections are what we see in the real world with our own eyes or with a camera; distant objects appear smaller than near objects. It&amp;rsquo;s also what you learn in a perspective drawing art class, in which the first assignment is commonly train tracks going off to the horizon. Tracks farther from the viewer appear closer together as does the spacing between the ties. To replicate the real world, I&amp;rsquo;ve chosen a perspective projection.&lt;/p&gt;

&lt;p&gt;In OpenGL, you not only have to decide between an orthogonal or perspective projection, you have to define its basic dimensions. In other words, how much can you see? For a perspective projection, you define the vertical &lt;em&gt;field of view&lt;/em&gt; (FOV), the &lt;em&gt;aspect ratio&lt;/em&gt; of the view, and the distance to the nearest and farthest things visible.&lt;/p&gt;

&lt;p&gt;The vertical FOV (&lt;code&gt;$fovy&lt;/code&gt; in the code) defines the angle from the viewpoint to the lowest and highest visible parts of the scene. If you imagine drawing what someone would see if she were standing with her eyes at the viewpoint, this represents her vertical peripheral vision. If you imagine a camera instead, this depends on the focal length of the lens. A telephoto lens has a very small FOV because the angle from the camera to the top and bottom visible objects is very small. Conversely, a wide-angle lens has a large FOV, and the FOV for a fisheye lens is even larger, approaching 180 degrees.&lt;/p&gt;

&lt;p&gt;The aspect ratio comes directly from the dimensions of the drawing area (width/height). This allows OpenGL to compensate for the stretching effect of a non-square window. In this case, the drawing area is square, so the aspect ratio is 1.&lt;/p&gt;

&lt;p&gt;After calculating the window&amp;rsquo;s aspect ratio, I tell OpenGL that I want to modify the projection and to start from a blank slate, using &lt;code&gt;glMatrixMode(GL_PROJECTION)&lt;/code&gt; and &lt;code&gt;glLoadIdentity&lt;/code&gt;. I then call &lt;code&gt;gluPerspective&lt;/code&gt; to define the desired perspective. You probably noticed that &lt;code&gt;gluPerspective&lt;/code&gt; begins with &lt;code&gt;glu&lt;/code&gt; instead of &lt;code&gt;gl&lt;/code&gt;, like all of the other calls we&amp;rsquo;ve seen. This is because I&amp;rsquo;m using one of the GLU (OpenGL Utility) routines to cover up some complexity in the equivalent raw OpenGL sequence.&lt;/p&gt;

&lt;p&gt;Finally, I switch back to model/view mode, and once again start with a blank slate, using &lt;code&gt;glMatrixMode(GL_MODELVIEW)&lt;/code&gt; and &lt;code&gt;glLoadIdentity&lt;/code&gt;. You may wonder why I don&amp;rsquo;t include this in the next routine instead of doing it here. I like to make sure routines that change a commonly used OpenGL state, simply as a side effect of their main purpose, return that state to the way they found it, especially if there is no net performance effect to doing so. In this case, I switch temporarily to projection mode and then switch back to the default model/view mode.&lt;/p&gt;

&lt;h4 id=&#34;span-id-set-the-view-set-the-view-span&#34;&gt;&lt;span id=&#34;Set the View&#34;&gt;Set the View&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The next step is to move the viewpoint to somewhere we can see the scene:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub set_view_3d
{
    # Move the viewpoint so we can see the origin
    glTranslate(0, -2, -10);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;m going to skip the detailed explanation for now, but in short the &lt;code&gt;glTranslate&lt;/code&gt; call leaves the viewpoint a few units away from (and above) the origin of the scene, where I&amp;rsquo;ll place my objects. I keep the default viewing direction, because it happens to point right where I want it to.&lt;/p&gt;

&lt;h4 id=&#34;span-id-define-an-object-define-an-object-span&#34;&gt;&lt;span id=&#34;Define an Object&#34;&gt;Define an Object&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;I&amp;rsquo;m going to start with a pretty simple scene &amp;ndash; just one object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    draw_axes();
}

sub draw_axes
{
    # Lines from origin along positive axes, for orientation
    # X axis = red, Y axis = green, Z axis = blue
    glBegin(GL_LINES);
    glColor(1, 0, 0);
    glVertex(0, 0, 0);
    glVertex(1, 0, 0);

    glColor(0, 1, 0);
    glVertex(0, 0, 0);
    glVertex(0, 1, 0);

    glColor(0, 0, 1);
    glVertex(0, 0, 0);
    glVertex(0, 0, 1);
    glEnd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The lone object is itself quite simple, just three short lines extending from the origin along the X, Y, and Z axes. (I&amp;rsquo;m using &amp;ldquo;line&amp;rdquo; in the OpenGL sense, as a line segment, not the infinite line of rigorous mathematics.)&lt;/p&gt;

&lt;p&gt;In OpenGL, when you want to define something to render, you must notify OpenGL when you begin and end the definition; these are the &lt;code&gt;glBegin&lt;/code&gt; and &lt;code&gt;glEnd&lt;/code&gt; calls. In addition, you must tell OpenGL what type of &lt;em&gt;primitive&lt;/em&gt; you will use to create your object. There are several types of primitives, including points, lines, and triangles. In addition, each primitive type has variants based on how several primitives in a sequence connect (independently, connected in a strip, and so on). In this case, I use &lt;code&gt;GL_LINES&lt;/code&gt;, indicating independently placed line segments.&lt;/p&gt;

&lt;p&gt;I want each line to be a different color to make it easier to tell which is which. To set the current drawing color, I call &lt;code&gt;glColor&lt;/code&gt; with an RGB (Red, Green, Blue) triplet. In OpenGL, each color component can range from 0 (none) to 1 (full). Therefore, (1, 0, 0) indicates pure red, (0, 1, 0) is pure green, and so on. A medium gray is (.5, .5, .5). For further mnemonic value, I assign the colors so that the RGB triplets match the coordinates of the endpoints of the lines &amp;ndash; red for the X axis, green for Y, and blue for Z.&lt;/p&gt;

&lt;p&gt;For each line, after defining the color, I define the endpoints of the line using &lt;code&gt;glVertex&lt;/code&gt;. Each line begins at the origin and extends one unit along the appropriate axis. In other words, this sequence defines a red line from (0, 0, 0) to (1, 0, 0):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glColor(1, 0, 0);
    glVertex(0, 0, 0);
    glVertex(1, 0, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With these routines in place, we finally have something to look at! As you can see, the X axis points to the right, the Y axis points up, and the Z axis points out of the screen toward the viewer (with OpenGL foreshortening it). Note the delay before the object first appears; that&amp;rsquo;s because the sleep at the end of &lt;code&gt;draw_frame&lt;/code&gt; creates a pause before &lt;code&gt;end_frame&lt;/code&gt; syncs the screen with the drawing area.&lt;/p&gt;

&lt;h3 id=&#34;span-id-moving-boxes-around-moving-boxes-around-span&#34;&gt;&lt;span id=&#34;Moving Boxes Around&#34;&gt;Moving Boxes Around&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Next, let&amp;rsquo;s try a box. Anyone who&amp;rsquo;s played a First Person Shooter game knows that their worlds have a surplus of boxes (a.k.a. &amp;ldquo;crates,&amp;rdquo; &amp;ldquo;storage containers,&amp;rdquo; and so on ï¿½- oddly, for &lt;em&gt;storage&lt;/em&gt; containers, the larger they are, the less they seem to contain). I&amp;rsquo;ll start with a simple cube and add another call for it to the end of &lt;code&gt;draw_view&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    draw_axes();
    draw_cube();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-defining-the-cube-defining-the-cube-span&#34;&gt;&lt;span id=&#34;Defining the Cube&#34;&gt;Defining the Cube&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Here&amp;rsquo;s the code that actually draws the cube:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_cube
{
    # A simple cube
    my @indices = qw( 4 5 6 7   1 2 6 5   0 1 5 4
                      0 3 2 1   0 4 7 3   2 3 7 6 );
    my @vertices = ([-1, -1, -1], [ 1, -1, -1],
                    [ 1,  1, -1], [-1,  1, -1],
                    [-1, -1,  1], [ 1, -1,  1],
                    [ 1,  1,  1], [-1,  1,  1]);

    glBegin(GL_QUADS);
    foreach my $face (0 .. 5) {
        foreach my $vertex (0 .. 3) {
            my $index  = $indices[4 * $face + $vertex];
            my $coords = $vertices[$index];
            glVertex(@$coords);
        }
    }
    glEnd;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That looks pretty hairy, but it&amp;rsquo;s actually not bad. The &lt;code&gt;@vertices&lt;/code&gt; array contains the coordinates for a cube two units on a side, centered at the origin, with its sides aligned with the X, Y, and Z axes. The &lt;code&gt;@indices&lt;/code&gt; array defines which four vertices belong to each of the six faces of the cube and in what order to send them to OpenGL. The order is very important; I&amp;rsquo;ve arranged it so that, as seen from the outside, the vertices of each face draw in counterclockwise order. Using a consistent order helps OpenGL to determine the front and back side of each polygon; I&amp;rsquo;ve chosen to use the default counterclockwise order.&lt;/p&gt;

&lt;p&gt;After defining those arrays, I mark the beginning of a series of independent quadrilateral primitives using &lt;code&gt;glBegin(GL_QUADS)&lt;/code&gt;. I then iterate through each vertex of each face, finding the correct set of coordinates and sending them to OpenGL using &lt;code&gt;glVertex&lt;/code&gt;. Finally, I mark the end of this series of primitives using &lt;code&gt;glEnd&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Colloquial Perl purists will no doubt wonder why I have chosen C-style loops (with the attendant index math, yuck), rather than making &lt;code&gt;@indices&lt;/code&gt; an array of arrays. Mostly I&amp;rsquo;m just showing that it&amp;rsquo;s not too hard to deal with this type of input data. When the engine reads object descriptions from files, rather than hand-coded routines, the natural output of the file parser may be flattened. It&amp;rsquo;s often easier to do a little index math than to force the parser to output more structured data (and possibly more efficient too, but that&amp;rsquo;s a clear call for benchmarking).&lt;/p&gt;

&lt;p&gt;The result is one blue cube. Why blue? Since I never specified a new color to use, OpenGL went back to the current state and looked up the current drawing color. The last line in the axes was drawn in blue and that&amp;rsquo;s still the current color. Hence one blue cube.&lt;/p&gt;

&lt;h4 id=&#34;span-id-two-colored-boxes-two-colored-boxes-span&#34;&gt;&lt;span id=&#34;Two Colored Boxes&#34;&gt;Two Colored Boxes&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Let&amp;rsquo;s fix that. At the same time, we can move the new cube out of the way of the axes so we can see them again. Heck, I&amp;rsquo;ll go all out and have two cubes &amp;ndash; one to the left of the axis lines, and one to the right. The nice thing is that because I&amp;rsquo;m just drawing more of something I&amp;rsquo;ve already described, I just need to change &lt;code&gt;draw_view&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    draw_axes();

    glColor(1, 1, 1);
    glTranslate(-2, 0, 0);
    draw_cube();

    glColor(1, 1, 0);
    glTranslate( 2, 0, 0);
    draw_cube();
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I set the current color to white using &lt;code&gt;glColor(1, 1, 1)&lt;/code&gt; before drawing the first cube, and to yellow using &lt;code&gt;glColor(1, 1, 0)&lt;/code&gt; before drawing the second cube. The &lt;code&gt;glTranslate&lt;/code&gt; calls should place the first cube two units to the left (along the negative X axis) and the second cube two units to the right (along the positive X axis).&lt;/p&gt;

&lt;h4 id=&#34;span-id-cumulative-transformations-cumulative-transformations-span&#34;&gt;&lt;span id=&#34;Cumulative Transformations&#34;&gt;Cumulative Transformations&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Unfortunately, no dice. The white cube is two units to the left, but the yellow cube is right on top of the axis lines again, not two units to the right as intended. This happened because &lt;code&gt;glTranslate&lt;/code&gt; calls (and the other transformation calls I&amp;rsquo;ll show later) are cumulative. Unlike routines such as &lt;code&gt;glColor&lt;/code&gt; that simply set the current state, most transformation calls instead modify the current state in a certain way. Because of this, the first cube starts at (-2, 0, 0), and the second starts at (-2, 0, 0) + (2, 0, 0) = (0, 0, 0) &amp;ndash; right back at the origin again.&lt;/p&gt;

&lt;p&gt;The solution to this problem requires peeking under the covers a little bit. OpenGL transformation calls really just set up a special matrix representing the effect that the requested transformation has on coordinates. OpenGL then multiplies the current matrix by this new transformation matrix and replaces the current matrix with the results of the multiplication.&lt;/p&gt;

&lt;p&gt;What I need to fix this problem is some way to save the current matrix before performing a transformation, and then restore it after I&amp;rsquo;m done with it. Thankfully, OpenGL actually maintains a stack of matrices of each type. I just need to push a copy of the current matrix onto the stack before drawing the white cube, and pop that copy off again afterwards to get back to the state before I did my translation. I&amp;rsquo;m going to do this for both cubes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    draw_axes();

    glColor(1, 1, 1);
    glPushMatrix;
    glTranslate(-2, 0, 0);
    draw_cube();
    glPopMatrix;

    glColor(1, 1, 0);
    glPushMatrix;
    glTranslate( 2, 0, 0);
    draw_cube();
    glPopMatrix;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s a bit better. The yellow cube now has its origin at (2, 0, 0), just as intended.&lt;/p&gt;

&lt;h3 id=&#34;span-id-other-transformations-other-transformations-span&#34;&gt;&lt;span id=&#34;Other Transformations&#34;&gt;Other Transformations&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Earlier I referred to other transformation calls; let&amp;rsquo;s take a look at a few of them. First, I&amp;rsquo;ll scale the boxes (change their size). I&amp;rsquo;m going to scale the left (white) box uniformly &amp;ndash; in other words, scaling each of its dimensions by the same amount. To show the difference, I&amp;rsquo;ll scale the right (yellow) box non-uniformly, with each dimension scaled differently. Here&amp;rsquo;s the new &lt;code&gt;draw_view&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub draw_view
{
    draw_axes();

    glColor(1, 1, 1);
    glPushMatrix;
    glTranslate(-4, 0, 0);
    glScale( 2, 2, 2);
    draw_cube();
    glPopMatrix;

    glColor(1, 1, 0);
    glPushMatrix;
    glTranslate( 4, 0, 0);
    glScale(.2, 1, 2);
    draw_cube();
    glPopMatrix;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For the white box, I just doubled each dimension; the parameters to &lt;code&gt;glScale&lt;/code&gt; are X, Y, and Z multipliers. For the yellow box, I shrunk the X dimension by a factor of 5 (multiplied by .2), left Y alone, and doubled the Z dimension. The boxes are now big enough that I&amp;rsquo;ve also pushed them farther apart, hence the updated values for &lt;code&gt;glTranslate&lt;/code&gt; that place them four units on either side of the scene origin.&lt;/p&gt;

&lt;h4 id=&#34;span-id-watch-the-rotation-watch-the-rotation-span&#34;&gt;&lt;span id=&#34;Watch the Rotation&#34;&gt;Watch the Rotation&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;I&amp;rsquo;ve done translation and scaling; next up is rotation. To save space here, I&amp;rsquo;ll demonstrate on the yellow cube alone. Here&amp;rsquo;s the new code snippet:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glColor(1, 1, 0);
    glPushMatrix;
    glRotate( 40, 0, 0, 1);
    glTranslate( 4, 0, 0);
    glScale(.2, 1, 2);
    draw_cube();
    glPopMatrix;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The parameters to &lt;code&gt;glRotate&lt;/code&gt; are the number of degrees to rotate and the axis around which to do the rotation. In this case, I chose to rotate 40 degrees around the Z axis (0, 0, 1). The direction of rotation follows the general pattern in OpenGL &amp;ndash; a positive value means counterclockwise when looking down the rotation axis toward the origin.&lt;/p&gt;

&lt;h4 id=&#34;span-id-order-of-transforms-order-of-transforms-span&#34;&gt;&lt;span id=&#34;Order of Transforms&#34;&gt;Order of Transforms&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This produces a flying yellow box in the upper-right quadrant. Remember when I said that each new transformation is cumulative? The order matters. To understand why, I like to imagine each transformation as moving, rotating, or scaling the coordinate system in which I draw my objects. In this case, by rotating first, I certainly rotated the box, but I really rotated the entire coordinate system in which I defined the box. This meant the &lt;code&gt;glTranslate&lt;/code&gt; call that immediately follows the rotation translated out along a rotated X axis, 40 degrees above the scene&amp;rsquo;s X axis, to be precise.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll move the rotation after the other two transformations to fix that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glTranslate( 4, 0, 0);
    glScale(.2, 1, 2);
    glRotate( 40, 0, 0, 1);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now the box isn&amp;rsquo;t flying, but it does appear squashed in an odd way. The problem here is that because the nifty, non-uniform scaling happens before the rotation, I&amp;rsquo;m now trying to rotate through a space where the dimensions are different sizes. Putting the rotation in the middle fixes it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glTranslate( 4, 0, 0);
    glRotate( 40, 0, 0, 1);
    glScale(.2, 1, 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you compare this rendering from this version with the program with no &lt;code&gt;glRotate&lt;/code&gt; call, you should see that it does the right thing now.&lt;/p&gt;

&lt;h3 id=&#34;span-id-whoa-deep-whoa-deep-span&#34;&gt;&lt;span id=&#34;Whoa, Deep!&#34;&gt;Whoa, Deep!&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The last item I wanted to bring up is what to do when something near the back draws after something near the front. To see what I mean, I&amp;rsquo;ll move the white box so that instead of being four units to the left of the scene origin, it is four units behind it (along the negative Z axis). That merely involves changing the white box&amp;rsquo;s &lt;code&gt;glTranslate&lt;/code&gt; call from this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glTranslate(-4, 0, 0);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    glTranslate( 0, 0, -4);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As you can see, even though the white box should appear behind the axis lines, it instead appears in front because OpenGL drew it after the axis lines. By default, OpenGL assumes you intended to do this (it is more efficient to make this assumption), but I didn&amp;rsquo;t. To fix this, I need to tell OpenGL to pay attention to the depth of the various objects in the scene and not to overwrite near objects with far ones.&lt;/p&gt;

&lt;p&gt;To do this, I need to enable OpenGL&amp;rsquo;s &lt;em&gt;depth buffer&lt;/em&gt;. This is similar to the color buffer, which stores the color of every pixel drawn. Instead of storing the color, however, it stores the depth (distance from the viewpoint along the viewing direction) of every pixel. Just like the color buffer, I need to clear the depth buffer each frame. Instead of clearing it to black, OpenGL clears it to the maximum depth value, so that any later rendering within the visible scene will be closer.&lt;/p&gt;

&lt;p&gt;I also need to tell OpenGL that it should perform a test each time it wants to draw a pixel, comparing the depth of the new pixel with what&amp;rsquo;s already in the depth buffer. If the new pixel is farther from the viewer than the pixel it is about to replace, it&amp;rsquo;s safe to ignore the new pixel and to leave alone the old color. Here&amp;rsquo;s the updated &lt;code&gt;prep_frame&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub prep_frame
{
    glClear(GL_COLOR_BUFFER_BIT |
            GL_DEPTH_BUFFER_BIT );

    glEnable(GL_DEPTH_TEST);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this version, I tell &lt;code&gt;glClear&lt;/code&gt; to clear both the color buffer and the depth buffer. You can now see why the constant names end with &lt;code&gt;_BIT&lt;/code&gt;; they are, in fact, bit masks. The reason for this odd interface is purely efficiency &amp;ndash; some OpenGL implementations can very rapidly clear all requested buffers simultaneously, and making the request for all needed buffers in just one call allows this optimization. As for the choice of bit mask rather than a list of constants, SDL_Perl reflects the underlying C interface, so that people comfortable with that can more easily cross over to using OpenGL under Perl.&lt;/p&gt;

&lt;p&gt;The second routine I call, &lt;code&gt;glEnable&lt;/code&gt;, is actually one of the most commonly used OpenGL routines, despite the fact that this is the first we&amp;rsquo;ve seen of it. Much of the OpenGL current state is a set of flags that tell OpenGL when to do (or not do) certain things. &lt;code&gt;glEnable&lt;/code&gt; and the corresponding &lt;code&gt;glDisable&lt;/code&gt; set these flags as desired. In this case, I turn on the flag that tells OpenGL to perform the depth test, throwing away pixels drawn in the wrong order.&lt;/p&gt;

&lt;p&gt;With these changes, we can now once again see the axis lines, this time in front of the white box where they belong.&lt;/p&gt;

&lt;h3 id=&#34;span-id-conclusion-conclusion-span&#34;&gt;&lt;span id=&#34;Conclusion&#34;&gt;Conclusion&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The final results may look simple, but we&amp;rsquo;ve come a long way. I started with some basic boilerplate and a simple main loop. I didn&amp;rsquo;t even load SDL or OpenGL or open a window. By the end, I&amp;rsquo;d added a window to draw on; projection and viewing setup; multiple objects of different types, built using different OpenGL primitives, drawn in different colors, and transformed several different ways; and correct handling of out-of-order drawing.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s a lot for now, but we&amp;rsquo;re just starting. Next time I&amp;rsquo;ll cover moving the viewpoint, SDL keyboard handling, and compensating for frame rate variations. I&amp;rsquo;ll build on the &lt;a href=&#34;http://localhost:1313/media/_pub_2004_12_01_3d_engine/perl_opengl_examples.tar.gz&#34;&gt;example source code&lt;/a&gt; built in this article, so feel free to download it and use it for your own applications.&lt;/p&gt;

&lt;p&gt;In the meantime, if you&amp;rsquo;d like to learn more visit the &lt;a href=&#34;http://www.opengl.org/&#34;&gt;OpenGL&lt;/a&gt; and &lt;a href=&#34;http://www.libsdl.org/&#34;&gt;SDL&lt;/a&gt; websites; each contains (and links to) mountains of information.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Autopilots in Perl</title>
      <link>http://localhost:1313/pub/2004/07/09/xplane.html/</link>
      <pubDate>Mon, 12 Jul 2004 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2004/07/09/xplane.html/</guid>
      <description>

&lt;p&gt;&lt;a href=&#34;http://www.x-plane.com&#34;&gt;X-Plane&lt;/a&gt; is an ultra-realistic flight simulator used by aviation pioneers like Burt Rutan, who uses it in his &lt;a href=&#34;http://www.popsci.com/popsci/aviation/article/0,12543,463052%2D3,00.html&#34;&gt;simulator&lt;/a&gt; for SpaceShipOne. The latest revision sports a flight model so accurate that the FAA has decided that your time spent in the simulator can count toward a pilot&amp;rsquo;s license.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll learn how to monitor and control our virtual plane, and display our virtual aircraft&amp;rsquo;s status in real-time in a &lt;code&gt;Curses&lt;/code&gt; window. Our display will be data-driven so that adding a single entry to a hash reference is all you need to display a new data element.&lt;/p&gt;

&lt;h3 id=&#34;span-id-software-requirements-software-requirements-span&#34;&gt;&lt;span id=&#34;Software_Requirements&#34;&gt;Software Requirements&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-curses-on-os-x-curses-on-os-x-span&#34;&gt;&lt;span id=&#34;Curses_on_OS_X&#34;&gt;Curses on OS X&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Curses v1.06 seems to have some issues building on the author&amp;rsquo;s machine running OS X 10.3. Replacing &lt;code&gt;Perl_sv_isa&lt;/code&gt; with &lt;code&gt;sv_isa&lt;/code&gt; on line 275 of &lt;code&gt;Curses.c&lt;/code&gt;, along with commenting out &lt;code&gt;#define    C_LONGNAME&lt;/code&gt; and &lt;code&gt;#define C_TOUCHLINE&lt;/code&gt; in &lt;code&gt;c-config.h&lt;/code&gt; lets &lt;code&gt;Curses&lt;/code&gt; compile with enough functionality to run the monitor program.&lt;/p&gt;

&lt;h4 id=&#34;span-id-configuring-the-sim-configuring-the-sim-span&#34;&gt;&lt;span id=&#34;Configuring_the_Sim&#34;&gt;Configuring the Sim&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Throughout this article, we assume that you&amp;rsquo;re using X-Plane version 7.41 or higher (the demo version has all the functionality we need), and you&amp;rsquo;re flying the standard Boeing 777. This has retractable landing gears and brakes, two features we&amp;rsquo;ll eventually control from inside the monitor program, &lt;a href=&#34;http://localhost:1313/media/_pub_2004_07_09_xplane/X-Plane.pl&#34;&gt;&lt;em&gt;X-Plane.pl&lt;/em&gt;&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Once you&amp;rsquo;re settled in your airplane&amp;rsquo;s cockpit, choose the Settings menu at the top of the screen and choose Data Input &amp;amp; Output under that menu. A window should open to the default tab, Data Set. This is where we tell the simulator which channels of data to transmit over the network where our monitor can listen for them.&lt;/p&gt;

&lt;p&gt;Currently, &lt;em&gt;X-Plane.pl&lt;/em&gt; displays gear up/down status, throttle percentage, latitude and longitude, pitch and roll, and the simulation frame rate. To enable these channels for display, click the checkboxes just to the right of rows 12, 23, 18, 16, and 0 (respectively).&lt;/p&gt;

&lt;p&gt;If you like, you can also click the checkboxes on the far right of each column to display the channel data on the plane&amp;rsquo;s windshield, as well. This is handy for debugging, especially if you&amp;rsquo;re attempting to monitor new data and don&amp;rsquo;t know what the values look like. Also, the channel numbers seem to change version to version, and if you&amp;rsquo;re using a version other than 7.41, you may need to change the code to correspond to the simulator.&lt;/p&gt;

&lt;p&gt;Finally, the simulator has to be told where to send the monitoring packets. Choose the Inet2 tab, and click on the checkbox next to IP address of data receiver. Fill in the left-hand box with the IP address of the machine you&amp;rsquo;re running &lt;em&gt;X-Plane.pl&lt;/em&gt; on, and fill in the right-hand box with 49999, the UDP port on which &lt;em&gt;X-Plane.pl&lt;/em&gt; listens.&lt;/p&gt;

&lt;p&gt;Incidentally, even though the monitor program acts as an instruction console, you don&amp;rsquo;t need to turn on the Instructor Console option listed here. It may be necessary, should you want to deal with more advanced communication such as triggering system failures, but for current purposes all we need to configure is the data receiver.&lt;/p&gt;

&lt;p&gt;By default, &lt;em&gt;X-Plane.pl&lt;/em&gt; listens to packets sent to 127.0.0.1 over port 49999, and sends packets to the same host on port 49000. Passing command-line parameters to &lt;em&gt;X-Plane.pl&lt;/em&gt; can override these settings, but the documentation for the simulator seems to indicate that it&amp;rsquo;s hardcoded to listen on port 49000 for its commands, so be warned if you try to change this particular default.&lt;/p&gt;

&lt;h3 id=&#34;span-id-running-the-monitor-running-the-monitor-span&#34;&gt;&lt;span id=&#34;Running_the_monitor&#34;&gt;Running the Monitor&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Communicating at the UDP layer is a different, and much simpler, world than dealing with a full TCP/IP packet. The main differences here are that we don&amp;rsquo;t get any acknowledgement that a UDP packet is sent, and can&amp;rsquo;t even guarantee that the packet was sent at all. The practical upshot of this is that we can start and stop &lt;em&gt;X-Plane.pl&lt;/em&gt; at any time, without the need for fancy socket tear-down protocols, and we don&amp;rsquo;t need to stop the simulator every time we change &lt;em&gt;X-Plane.pl&lt;/em&gt;&amp;rsquo;s code.&lt;/p&gt;

&lt;p&gt;Once we&amp;rsquo;ve started the simulator and &lt;em&gt;X-Plane.pl&lt;/em&gt; it should start displaying the plane&amp;rsquo;s position (longitude/latitude), orientation (pitch/roll), speed, and current throttle settings. If it doesn&amp;rsquo;t, switch back to the simulator window and make sure the cockpit is being displayed. The gear display mimics an indicator lamp, with &lt;code&gt;[#]&lt;/code&gt; representing a lit lamp, and &lt;code&gt;[ ]&lt;/code&gt; being a dark lamp.&lt;/p&gt;

&lt;p&gt;The simulator will only send out UDP packets when the cockpit is being displayed, and if you&amp;rsquo;re running in demo mode, it decides to interrupt your flight six minutes in with two dialog boxes that effectively stop packet transmission. If it&amp;rsquo;s still displaying the cockpit, make sure that the simulator is transmitting data to the right port on the right machine, and if all else fails, watch the network with a utility such as &lt;code&gt;tcpdump&lt;/code&gt; to make sure UDP packets are being sent out. Press the &lt;code&gt;G&lt;/code&gt; key to raise and lower the gear and the &lt;code&gt;I&lt;/code&gt; and &lt;code&gt;K&lt;/code&gt; keys to advance and retard the throttles, even on the runway. Note that the gear indicator lamp on the monitor will change before the gear handle does. Also, if running the simulator on the same machine as the monitor, you may need to bring the window with the simulator to the foreground before changes are registered.&lt;/p&gt;

&lt;p&gt;By the way, the Boeing 777 is equipped with thrust reversers, so negative throttle settings actually make sense. Also, the flight profile dictates running the engines up to 110% of rated power on takeoff, so throttle settings beyond 100% are also legitimate.&lt;/p&gt;

&lt;h3 id=&#34;span-id-talking-to-x-plane-talking-to-x-plane-span&#34;&gt;&lt;span id=&#34;Talking_to_X-Plane&#34;&gt;Talking to X-Plane&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Communicating with the simulator is done entirely via UDP packets. While the simulator can send and receive various types of packets, we&amp;rsquo;ll focus on one type of packet in particular, the &lt;code&gt;DATA&lt;/code&gt; packet. The simulator communicates using packets like that described in Figure 1. The first 4 bytes of the header are the ASCII characters naming the type of packet, and the actual data is surrounded by a zero byte on both ends.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_07_09_xplane/Figure_1.jpg&#34; width=&#34;311&#34; height=&#34;104&#34; /&gt;&lt;/p&gt;

&lt;p&gt;In between the zero bytes, we get one 36-byte chunk for every channel the simulator sends out. Each 36-byte chunk is broken down into two sections. The first section is a four-byte index corresponding to the channel number on the &amp;ldquo;Data Set&amp;rdquo; screen, and the rest of the chunk contains eight four-byte elements.&lt;/p&gt;

&lt;p&gt;&lt;img src=&#34;http://localhost:1313/images/_pub_2004_07_09_xplane/Figure_2.jpg&#34; width=&#34;401&#34; height=&#34;248&#34; /&gt;&lt;/p&gt;

&lt;p&gt;The actual data types of the individual elements has changed from version to version, but 7.41 seems to have settled on one layout for inbound, and a different one for outbound. When transmitting data, the simulator sends all elements as floating-point types, but receives a mixture of floating-point and long integers.&lt;/p&gt;

&lt;h4 id=&#34;span-id-sending-data-sending-data-span&#34;&gt;&lt;span id=&#34;Sending_data&#34;&gt;Sending Data&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Handling the mixture of data types is largely the job of the core data structure in &lt;em&gt;X-Plane.pl&lt;/em&gt;, the &lt;code&gt;$DATA_packet&lt;/code&gt; hash reference. Starting on line 92, this data structure encapsulates everything we want to know about the simulator packet.&lt;/p&gt;

&lt;p&gt;Given that there are currently 113 channels of data that the simulator can send out, and that the author is lazy, we&amp;rsquo;re not going to type in all 113 channels&amp;rsquo; worth of data. Instead, we&amp;rsquo;ll store just the channels we want to display in what computer scientists call a &amp;ldquo;sparse array,&amp;rdquo; but Perl programmers call it a &amp;ldquo;hash reference.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;One useful feature the monitoring program doesn&amp;rsquo;t have is controlling the brakes. In the simulator, brakes can be applied with a variable pressure, but for our purposes they only have two settings: &amp;ldquo;Screeching halt&amp;rdquo; and &amp;ldquo;Let it roll.&amp;rdquo; The first order of business is to find out what channel brakes are displayed on.&lt;/p&gt;

&lt;p&gt;Going back to the &amp;ldquo;Data Set&amp;rdquo; tab in the simulator, we look for &amp;ldquo;brakes&amp;rdquo; on the list. In version 7.41 they&amp;rsquo;re on channel 12, &amp;ldquo;gear/brakes.&amp;rdquo; Conveniently enough, we&amp;rsquo;re already displaying the gear setting, so it shouldn&amp;rsquo;t be much work to add brakes to the list.&lt;/p&gt;

&lt;p&gt;Now that we know what channel brakes are on, we need to know where in the channel they&amp;rsquo;re stored. After all, we have eight elements to look through. So, click on the checkbox on the far right of row 12 to display that channel&amp;rsquo;s contents on the windshield and close the window.&lt;/p&gt;

&lt;p&gt;At the upper right-hand corner we should see the channel contents being displayed. We&amp;rsquo;re mostly curious about the &lt;code&gt;wbrak&lt;/code&gt; setting, which is element number 1 (counting from zero, of course.) The simulator also tells us that it&amp;rsquo;s of &lt;code&gt;part&lt;/code&gt; type, which means that it&amp;rsquo;s a floating point value.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll first need to display the brake setting. We do this at line 112, duplicating the block for the gear status and creating the following entry, which specifies that element 1 of channel 12 is a floating-point number representing brakes:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1 =&amp;gt; { type =&amp;gt; &#39;f&#39;, label =&amp;gt; &#39;Brakes&#39;,
           label_x =&amp;gt; 0, label_y =&amp;gt; 4,
           x =&amp;gt; 7, y =&amp;gt; 4 },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Restart the monitor program, and you should have a new entry for &amp;ldquo;Brakes&amp;rdquo; followed by a 0 or 1. Clicking on the &amp;ldquo;BRAKES&amp;rdquo; light in the cockpit should toggle the value. Once you&amp;rsquo;ve verified that the new brake display works, it&amp;rsquo;s time to add the code that actually sets/releases the brakes. On line 270, insert the code that transmits the new brake status to the simulator, that looks roughly like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  elsif($ch eq &#39;b&#39;) {
    transmit_DATA(
          $socket,
          12,
          -999,
          $DATA_buffer-&amp;gt;{12}{1} ? 0 : 1,
          (-999) x 6);
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since the gear and brakes are on the same channel, we have to tell the simulator to ignore the gear while letting us set the brake value, so we use the placeholder value of -999. The old brake value is saved in &lt;code&gt;$DATA_buffer-&lt;/code&gt;{12}{1}&amp;gt;, so we set the opposite of whatever was there before.&lt;/p&gt;

&lt;p&gt;Rerun the monitor program, and pressing &amp;ldquo;b&amp;rdquo; should clear and set the &amp;ldquo;brake&amp;rdquo; light on the simulator&amp;rsquo;s indicator panel. When the light is out, the aircraft should naturally start rolling, and the simulated light on the &lt;code&gt;Curses&lt;/code&gt; window should go out.&lt;/p&gt;

&lt;p&gt;Of course, not all types of variable are as simple to deal with as the brakes and gears. The throttle settings should give you an idea of how to work with more advanced data types, and of course you&amp;rsquo;re not restricted to a &lt;code&gt;Curses&lt;/code&gt; display. It just happens that &lt;code&gt;Curses&lt;/code&gt; is fairly convenient and low-bandwidth, but nothing is preventing you from transplanting the code into a &lt;code&gt;GTK&lt;/code&gt; event loop.&lt;/p&gt;

&lt;p&gt;While you can change values in every channel, the simulator may not react to those changes. For instance, you can&amp;rsquo;t change the latitude and longitude of the plane and expect it to teleport to the new location.&lt;/p&gt;

&lt;p&gt;The values for latitude and longitude are actually computed from the values in channel 19, the X, Y and Z coordinates. Changing these will actually affect the plane&amp;rsquo;s position in space. However, there doesn&amp;rsquo;t appear to be a simple reference that will describe what values are considered read-only.&lt;/p&gt;

&lt;p&gt;The official UDP documentation doesn&amp;rsquo;t contain this, and the only UDP FAQ on the &amp;lsquo;net for X-Plane appears not to have been updated since version 6. Of course, some of the channels make no sense on certain aircraft. For instance, the Cessna 172 (which the author has several hours&amp;rsquo; experience in) doesn&amp;rsquo;t have retractable gear.&lt;/p&gt;

&lt;h4 id=&#34;span-id-receiving-data-receiving-data-span&#34;&gt;&lt;span id=&#34;Receiving_data&#34;&gt;Receiving Data&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Receiving data is also done through the &lt;code&gt;$DATA_packet&lt;/code&gt; sparse array. In this case, the element type is just used for display purposes, as the channel is transmitted in floating point, and not the mixed format. The entry for &amp;ldquo;True Speed&amp;rdquo;, which is displayed in miles per hour, looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 104 2 =&amp;gt; {
 105   0 =&amp;gt; { type =&amp;gt; &#39;mph&#39;, label =&amp;gt; &#39;True Speed&#39;,
 106          label_x =&amp;gt; 0, label_y =&amp;gt; 1,
 107          x =&amp;gt; 12, y =&amp;gt; 1 },
 108 },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When time comes to walk the &lt;code&gt;DATA&lt;/code&gt; packet, this entry tells us to see if we&amp;rsquo;ve received data channel 2 (line 104). If we have, look at element 0, and display the element at (12,1) in the window (line 107.) Since the type is &amp;ldquo;mph&amp;rdquo; (line 105), we know that we have to format that specially.&lt;/p&gt;

&lt;p&gt;Special types like &amp;ldquo;mph&amp;rdquo; and &amp;ldquo;deg&amp;rdquo; are stored in another hash reference, back on lines 81-85. When the time comes to display the actual data, we look into this hash reference to pull out the format string to use when &lt;code&gt;sprintf()&lt;/code&gt;&amp;lsquo;ing the data. The &lt;code&gt;len&lt;/code&gt; hash key gets used as well at this time, to create a mask of space characters that we use to erase the old value completely before displaying the new value.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  81 my $typedef = {
  82   deg =&amp;gt; { format =&amp;gt; &amp;quot;%+03.3f&amp;quot;, len =&amp;gt; 8 },
  83   mph =&amp;gt; { format =&amp;gt; &amp;quot;%03.3f&amp;quot;, len =&amp;gt; 7 },
  84   pct =&amp;gt; { format =&amp;gt; &amp;quot;%+01.3f&amp;quot;, len =&amp;gt; 6 },
  85 };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A special type &lt;code&gt;bool&lt;/code&gt; is used for indicator lamps (since indicator lamps are either on or off), but is handled specially. The pseudo-types &lt;code&gt;l&lt;/code&gt; and &lt;code&gt;f&lt;/code&gt; aren&amp;rsquo;t represented here, but are used when we need to return data to the simulator. While the simulator sends out only floating-point numbers, it receives a mixture of floating-point and integer values, and the mixture changes on a per-channel basis.&lt;/p&gt;

&lt;p&gt;Instead of making the programmer create the format strings that we&amp;rsquo;ll use later on to &lt;code&gt;pack()&lt;/code&gt; and &lt;code&gt;unpack()&lt;/code&gt; packets, we pre-compute them in the function &lt;code&gt;create_pack_strings()&lt;/code&gt;. Since the individual elements may occur anywhere in the eight-element array, we may need to skip over elements, and that&amp;rsquo;s done with liberal use of &lt;code&gt;x4&lt;/code&gt; in the format, which tells &lt;code&gt;pack()&lt;/code&gt; and &lt;code&gt;unpack()&lt;/code&gt; to ignore 4 bytes&amp;rsquo; worth of data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; 164 sub create_pack_strings {
 165   for my $row (values %$DATA_packet) {
 166     $row-&amp;gt;{unpack} = &#39;x4&#39;;
 167     $row-&amp;gt;{pack} = &#39;l&#39;;
 168     for my $j (0..DATA_max_element) {
 169       if(exists $row-&amp;gt;{$j}) {
 170         my $col = $row-&amp;gt;{$j};
 171         $row-&amp;gt;{pack} .=
 172           (grep { $col-&amp;gt;{type} eq $_ } @float_formats) ? &#39;f&#39; : &#39;l&#39;;
 173         $row-&amp;gt;{unpack} .= &#39;f&#39;;
 174       }
 175       else {
 176         $row-&amp;gt;{pack} .= &#39;f&#39;;
 177         $row-&amp;gt;{unpack} .= &#39;x4&#39;;
 ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Starting at line 164, &lt;code&gt;create_pack_strings()&lt;/code&gt; handles this tedious job for us, by walking the two-dimensional hash reference &lt;code&gt;$DATA_packet&lt;/code&gt;. Line 166 starts the unpack() string with &lt;code&gt;x4&lt;/code&gt;, which tells the &lt;code&gt;unpack()&lt;/code&gt; function to skip over the index long in the packet. We have to unpack the index beforehand in order to know how to deal with the data, so we just ignore that.&lt;/p&gt;

&lt;p&gt;Line 167 starts the &lt;code&gt;pack()&lt;/code&gt; string with a long, &lt;code&gt;l&lt;/code&gt; for the inbound index. Lines 168 onward create the individual elements. The &lt;code&gt;unpack()&lt;/code&gt; strings are &lt;code&gt;f&lt;/code&gt; if the element is in use, &lt;code&gt;x4&lt;/code&gt; if it&amp;rsquo;s not. This means that the format strings only extract the data we need, which makes it easier later on when time comes to actually call &lt;code&gt;unpack()&lt;/code&gt; on the actual data.&lt;/p&gt;

&lt;p&gt;Lines 171-2 and 176 create the &lt;code&gt;pack()&lt;/code&gt; format string, using &lt;code&gt;f&lt;/code&gt; for floating-point formats and &lt;code&gt;l&lt;/code&gt; for integer types. Since there&amp;rsquo;s no special way to tell the simulator what elements we&amp;rsquo;re updating, we have to send back every element. Unused elements are filled with a sentinel value of -999 to say &amp;ldquo;Do not update this value.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;In the end, we&amp;rsquo;ve added &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; hash keys to every channel in our &lt;code&gt;$DATA_packet&lt;/code&gt; structure. Unpacking a channel structure with this format returns to us only the data we&amp;rsquo;re interested in, and skips over unused elements so we don&amp;rsquo;t have to account for empty elements in the array that &lt;code&gt;pack()&lt;/code&gt; returns to us.&lt;/p&gt;

&lt;p&gt;Likewise, the &lt;code&gt;pack&lt;/code&gt; hash key gives us a string to create an entire channel&amp;rsquo;s worth of data, with the proper data types. This is important, even in what should be a simple channel like the gear and brake display. While gears get set to an integer 1 or 0, brakes have to be set to a float from 0 through 1, to account for variable pressure.&lt;/p&gt;

&lt;h4 id=&#34;span-id-pulling-apart-the-packet-pulling-apart-the-packet-span&#34;&gt;&lt;span id=&#34;Pulling_apart_the_packet&#34;&gt;Pulling Apart the Packet&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;All of the heavy lifting gets done in the &lt;code&gt;receive_DATA()&lt;/code&gt; function, from lines 193-234. This function accepts the message sent over the UDP port and breaks it into individual channel-sized packets. The adventure starts on line 196, after clearing a small internal buffer we use to record the last packet received.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  196   for (my $i = 0;
  197        $i &amp;lt; (length($message)-&amp;amp;DATA_header_size-1) / DATA_element_size;
  198        $i++) {
  199    my $channel = substr($message,
  200                         $i * DATA_element_size + DATA_header_size,
  201                         DATA_element_size);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Line 197 computes the number of channels this particular message contains (we&amp;rsquo;re doing this on-the-fly in case you want to change the channel selection while the simulator is running.) The &lt;code&gt;substr()&lt;/code&gt; call breaks the message into chunks of &lt;code&gt;DATA_element_size&lt;/code&gt; bytes, and gives us back a channel&amp;rsquo;s worth of data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  203    my $index = unpack &amp;quot;l&amp;quot;, $channel;
  204    next unless exists $DATA_packet-&amp;gt;{$index};
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we extract the index (the first byte) of the channel so that we can unpack the data appropriately. If we don&amp;rsquo;t know anything about this channel (i.e., if it isn&amp;rsquo;t present in the &lt;code&gt;$DATA_packet&lt;/code&gt; hashref), we reject it and move on. This makes us somewhat immune to changes in format.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  206    my $row = $DATA_packet-&amp;gt;{$index};
  207    my @element = unpack $row-&amp;gt;{unpack}, $channel;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, we get back the elements we&amp;rsquo;re interested in here by &lt;code&gt;unpack&lt;/code&gt;ing with the format string that got calculated in &lt;code&gt;create_pack_strings()&lt;/code&gt;. The format string skips the index and unpacks just the elements we wanted. So, now we walk our proffered hash and extract the individual elements:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  208     my $ctr = 0;
  209     for my $j (0..DATA_max_element) {
  210       next unless exists $row-&amp;gt;{$j};
  211       my $col = $row-&amp;gt;{$j};
  212       $DATA_buffer-&amp;gt;{$index}{$j} = $element[$ctr];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Line 208 initializes a counter so that we can keep track of which element we&amp;rsquo;ve extracted. Line 209 loops through each possible element in order, so we take into account the possibility that we haven&amp;rsquo;t used a data element.&lt;/p&gt;

&lt;p&gt;Lines 210-212 skip unused elements in the sparse array, and saves the content in &lt;code&gt;$DATA_buffer&lt;/code&gt;, so we can have keys like &lt;code&gt;g&lt;/code&gt; toggle the gear setting, rather than having one key to raise the gear and one key to lower them.&lt;/p&gt;

&lt;p&gt;Finally, we display each element based on its type. Boolean types are displayed as either &lt;code&gt;[#]&lt;/code&gt; or &lt;code&gt;[ ]&lt;/code&gt; depending upon whether the element is a floating one or zero. They&amp;rsquo;re still written out as an integer, but displayed as floating.&lt;/p&gt;

&lt;p&gt;Types such as &lt;code&gt;deg&lt;/code&gt; and &lt;code&gt;mph&lt;/code&gt; with a registered format are handled specially. We first wipe out the old data completely by overwriting with spaces. This prevents a potential issue with the old value being &amp;ldquo;3.14159&amp;rdquo;, and the new value being &amp;ldquo;2.7&amp;rdquo;. If we didn&amp;rsquo;t overwrite the old value, it would be displayed as &amp;ldquo;2.74159&amp;rdquo;, with the extra digits remaining from the old display.&lt;/p&gt;

&lt;p&gt;If we&amp;rsquo;ve not been told what to do with this (which is the case with Frame Rate), simply print the value and go onward.&lt;/p&gt;

&lt;h3 id=&#34;span-id-data-driven-design-data-driven-design-span&#34;&gt;&lt;span id=&#34;Data-Driven_design&#34;&gt;Data-Driven Design&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;In the current monitor program, each channel in a &lt;code&gt;DATA&lt;/code&gt; packet corresponds to a set of fields onscreen. Instead of creating a function to display the onscreen labels and another one to extract the information from the packets, we&amp;rsquo;ve elected to combine the label information with the channel and field, in one easy-to-use format.&lt;/p&gt;

&lt;p&gt;Since the number of channels and their layout varies between versions of the simulator, we&amp;rsquo;ve chosen to represent the channels in a two-tiered hash reference. The outer tier represents a channel, and the inner tier represents the fields inside that channel.&lt;/p&gt;

&lt;p&gt;This means that if a channel changes index number (as the pitch and roll channel did from version 7.1 to 7.4), we simply update the channel number in the hashref rather than cutting out a block of code and repositioning it in an array, making maintenance easier.&lt;/p&gt;

&lt;p&gt;Since this data likely won&amp;rsquo;t change over the lifetime of the program, we&amp;rsquo;ll store it in a global hash reference, &lt;code&gt;$DATA_packet&lt;/code&gt; starting at line 92. We can reference a given element in an arbitrary channel with the code fragment &lt;code&gt;$DATA_packet-&lt;/code&gt;{$channel}{$element}&amp;gt;, but the code usually ends up iterating by channel and by element.&lt;/p&gt;

&lt;p&gt;The sample for the gear display starts at line 109, and the entire channel/element reference looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  109  12 =&amp;gt; {
  110    0 =&amp;gt; { type =&amp;gt; &#39;bool&#39;, label =&amp;gt; &#39;Gear&#39;,
  111           label_x =&amp;gt; 0, label_y =&amp;gt; 3,
  112           x =&amp;gt; 6, y =&amp;gt; 3 },
  113  },
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is the only element in channel 12, and sits at element 0. Boolean types are displayed with &lt;code&gt;[#]&lt;/code&gt; and &lt;code&gt;[ ]&lt;/code&gt; representing indicator lamps, and it specifies the screen coordinates of the label (&lt;code&gt;label_x&lt;/code&gt; and &lt;code&gt;label_y&lt;/code&gt;) and where the actual indicator goes (&lt;code&gt;x&lt;/code&gt; and &lt;code&gt;y&lt;/code&gt;).&lt;/p&gt;

&lt;p&gt;After &lt;code&gt;Curses&lt;/code&gt; initializes, the &lt;code&gt;setup_display()&lt;/code&gt; function iterates over this two-tiered hash and draws the label strings that won&amp;rsquo;t change. Lines 148-156 take care of this, and show how to iterate over the data structure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  148 sub setup_display {
  149   for my $channel (values %$DATA_packet) {
  150     for my $element (values %$channel) {
  151       $win-&amp;gt;addstr($element-&amp;gt;{label_y},
  152                    $element-&amp;gt;{label_x},
  153                    $element-&amp;gt;{label}) if $element-&amp;gt;{label};
  ...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;$win-&lt;/code&gt;addstr()&amp;gt; takes the Y coordinate followed by the X coordinate, in accordance with long-standing tradition. Later on, we&amp;rsquo;ll use the &lt;code&gt;type&lt;/code&gt; hash key to tell us how to display this data, but that&amp;rsquo;s handled when we receive a message.&lt;/p&gt;

&lt;h3 id=&#34;span-id-initialization-and-shutdown-initialization-and-shutdown-span&#34;&gt;&lt;span id=&#34;Initialization_and_Shutdown&#34;&gt;Initialization and Shutdown&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;We start by handling the usual command-line options on lines 24-32, including a &lt;code&gt;-h&lt;/code&gt; option to display usage. &lt;code&gt;-x&lt;/code&gt; sets the X-Plane IP address to something other than the default of &amp;ldquo;127.0.0.1,&amp;rdquo; &lt;code&gt;-r&lt;/code&gt; changes the port the monitor listens on from 49999 to something else.&lt;/p&gt;

&lt;p&gt;Incidentally, the listening port cannot be 49000, as that&amp;rsquo;s where the simulator listens for its commands. &lt;code&gt;-t&lt;/code&gt; tells the monitor to transmit on a different port than 49000, although the simulator is documented to listen to only port 49000. &lt;code&gt;-d&lt;/code&gt; is there in case this gets run with earlier versions than 7.4, where the packet format varied depending upon the operating system the simulator was running on.&lt;/p&gt;

&lt;p&gt;After command-line configuration is processed and defaults overridden, we create the UDP sockets, on lines 48-65. Instead of the usual TCP protocol, we open UDP ports as that&amp;rsquo;s what the simulator communicates with. If we did this after initializing &lt;code&gt;Curses&lt;/code&gt;, our error text would be eaten by the terminal, so we place this first.&lt;/p&gt;

&lt;h4 id=&#34;span-id-startup-and-shutdown-of-curses-startup-and-shutdown-of-curses-span&#34;&gt;&lt;span id=&#34;Startup_and_shutdown_of_Curses&#34;&gt;Startup and Shutdown of Curses&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The Curses startup proceeds fairly normally starting on line 314, with the call to &lt;code&gt;noecho()&lt;/code&gt; and &lt;code&gt;cbreak()&lt;/code&gt; stopping the terminal from echoing key presses and suppressing carriage returns. &lt;code&gt;$win-&amp;gt;timeout(1);&lt;/code&gt; lets us read key presses without blocking, so we can display packets as they come in real-time without having to wait for key presses.&lt;/p&gt;

&lt;h4 id=&#34;span-id-displaying-text-displaying-text-span&#34;&gt;&lt;span id=&#34;Displaying_text&#34;&gt;Displaying Text&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Since Curses implementations vary widely in functionality, we limit ourselves to making &lt;code&gt;addstr()&lt;/code&gt; and &lt;code&gt;getch()&lt;/code&gt; calls to ensure maximum compatibility across platforms. Inside &lt;code&gt;setup_display()&lt;/code&gt; we draw the static labels such as &amp;ldquo;Gear&amp;rdquo; and &amp;ldquo;Pitch,&amp;rdquo; and do the job of displaying the actual values inside &lt;code&gt;receive_DATA()&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-main-loop-the-main-loop-span&#34;&gt;&lt;span id=&#34;The_main_loop&#34;&gt;The Main Loop&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This makes the main loop on lines 301-311 pretty straightforward. We poll the keyboard, and display the latest data packet if there isn&amp;rsquo;t one. Otherwise, check to see if the user pressed &amp;ldquo;q&amp;rdquo;, in which case we quit. UDP sockets don&amp;rsquo;t require any special tear down, so all that&amp;rsquo;s left is to call &lt;code&gt;endwin();&lt;/code&gt;. If the user pressed a command key, create an appropriate packet and send that out.&lt;/p&gt;

&lt;p&gt;With just the &lt;code&gt;DATA&lt;/code&gt; packet, you can create your own customized cockpit display, even take this sample source and turn it into a &lt;code&gt;Gtk&lt;/code&gt; application that lets you monitor your plane graphically. The &lt;code&gt;VEHA&lt;/code&gt; packet type adds even more possibilities. You could read a friend&amp;rsquo;s virtual location and add his plane as traffic in your virtual world.&lt;/p&gt;

&lt;p&gt;Even better, scrape HTML from a flight-tracker service and add real traffic to your virtual world! The &lt;code&gt;FAIL&lt;/code&gt; and &lt;code&gt;RECO&lt;/code&gt; packet types can cause simulated system failures, so you can create your own in-flight emergencies in Perl! You can even go all the way, and use the &lt;code&gt;SNAP&lt;/code&gt; packet type to completely override X-Plane&amp;rsquo;s flight model, telling X-Plane how you think the aircraft should fly.&lt;/p&gt;

&lt;p&gt;Hopefully now that I&amp;rsquo;ve demystified some of X-Plane&amp;rsquo;s internal workings you&amp;rsquo;ll be inspired to create your own tools, maybe even design and build your own fly-by-wire plane, all in Perl.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Solving Puzzles with LM-Solve</title>
      <link>http://localhost:1313/pub/2003/11/17/lmsolve.html/</link>
      <pubDate>Mon, 17 Nov 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/11/17/lmsolve.html/</guid>
      <description>

&lt;p&gt;Suppose you encounter a (single-player) riddle or a puzzle that you don&amp;rsquo;t know how to solve. Let&amp;rsquo;s also suppose that this puzzle involves moving between several states of the board with an enumerable number of moves emerging from one state. In this case, &lt;a href=&#34;http://vipe.technion.ac.il/~shlomif/lm-solve/&#34;&gt;LM-Solve&lt;/a&gt; (or Games::LMSolve on CPAN) may be of help.&lt;/p&gt;

&lt;p&gt;LM-Solve was originally written to tackle various types of the so-called &lt;a href=&#34;http://www.logicmazes.com/&#34;&gt;logic mazes&lt;/a&gt; that can be found online. Nevertheless, it can be extended to support many other types of single-player puzzles.&lt;/p&gt;

&lt;p&gt;In this article, I will demonstrate how to use LM-Solve to solve a type of puzzle that it does not know yet to solve.&lt;/p&gt;

&lt;h2 id=&#34;installation&#34;&gt;Installation&lt;/h2&gt;

&lt;p&gt;Use the CPAN.pm module &lt;code&gt;install Games::LMSolve&lt;/code&gt; command to install LM-Solve. For instance, invoke the following command on the command line:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl -MCPAN -e &#39;install Games::LMSolve&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s it! (LM-Solve does not require any non-base modules, and should run on all recent versions of Perl.)&lt;/p&gt;

&lt;h2 id=&#34;the-puzzle-in-question&#34;&gt;The Puzzle in Question&lt;/h2&gt;

&lt;p&gt;The puzzle in question is called &amp;ldquo;Jumping Cards&amp;rdquo; and is taken from the &lt;a href=&#34;http://mathforum.org/wagon/spring02/p949.html&#34;&gt;Macalester College Problem of the Week No. 949&lt;/a&gt;. In this puzzle, we start with eight cards in a row (labeled 1 to 8). We have to transform it into the 8 to 1 sequence, by swapping two cards at a time, as long as the following condition is met: at any time, two neighboring cards must be in one, two, or three spaces of each other.&lt;/p&gt;

&lt;p&gt;Let&amp;rsquo;s experience with this puzzle a bit. We start with the following formation:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;1 2 3 4 5 6 7 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Let&amp;rsquo;s swap 1 and 3, and see what it gives us:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 2 1 4 5 6 7 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now, we cannot exchange 1 and 4, because then, 1 would be close to the 5, and 5-1 is 4, which is more than 3. So let&amp;rsquo;s exchange 2 and 1:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 1 2 4 5 6 7 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we can exchange 2 and 4:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;3 1 4 2 5 6 7 8
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And so on.&lt;/p&gt;

&lt;h2 id=&#34;let-s-start-coding&#34;&gt;Let&amp;rsquo;s Start &amp;hellip; Coding!&lt;/h2&gt;

&lt;p&gt;The &lt;code&gt;Games::LMSolve::Base&lt;/code&gt; class tries to solve a game by iterating through its various positions, recording every one it passes through, and trying to reach the solution. However, it does not know in advance what the games rules are, and what the meaning of the positions and moves are. In order for it to know that, we need to inherit it and code several methods that are abstract in the base class.&lt;/p&gt;

&lt;p&gt;We will code a derived class that will implement the logic specific to the Jumping Cards game. It will implement the following methods, which, together with the methods of the base class, enable the solver to solve the game:&lt;/p&gt;

&lt;ol&gt;
&lt;li&gt;&lt;code&gt;input_board&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;pack_state&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;unpack_state&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;display_state&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;check_if_final_state&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;enumerate_moves&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;perform_move&lt;/code&gt;&lt;/li&gt;
&lt;li&gt;&lt;code&gt;render_move&lt;/code&gt;&lt;/li&gt;
&lt;/ol&gt;

&lt;p&gt;Here&amp;rsquo;s the beginning of the file where we put the script:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package Jumping::Cards;

use strict;

use Games::LMSolve::Base;

use vars qw(@ISA);

@ISA=qw(Games::LMSolve::Base);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As can be seen, we declared a new package, &lt;code&gt;Jumping::Cards&lt;/code&gt;, imported the &lt;code&gt;Games::LMSolve::Base&lt;/code&gt; namespace, and inherited from it. Now let&amp;rsquo;s start declaring the methods. First, a method to input the board in question.&lt;/p&gt;

&lt;p&gt;Since our board is constant, we just return an array reference that contains the initial sequence.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub input_board
{
    my $self = shift;

    my $filename = shift;

    return [ 1 .. 8 ];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When &lt;code&gt;Games::LMSolve::Base&lt;/code&gt; iterates over the states, it stores data about each state in a hash. This means we&amp;rsquo;re going to have to provide a way to convert each state from its expanded form into a uniquely identifying string. The &lt;code&gt;pack_state&lt;/code&gt; method does this, and in our case, it will look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# A function that accepts the expanded state (as an array ref)
# and returns an atom that represents it.
sub pack_state
{
    my $self = shift;
    my $state_vector = shift;
    return join(&amp;quot;,&amp;quot;, @$state_vector);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It is a good idea to use functions like &lt;code&gt;pack&lt;/code&gt;, &lt;code&gt;join&lt;/code&gt; or any other serialization mechanism here. In our case, we simply used &lt;code&gt;join&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;It is not very convenient to manipulate a packed state, and so we need another function to expand it. &lt;code&gt;unpack_state&lt;/code&gt; does the opposite of &lt;code&gt;pack_state&lt;/code&gt; and expands a packed state.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# A function that accepts an atom that represents a state 
# and returns an array ref that represents it.
sub unpack_state
{
    my $self = shift;
    my $state = shift;
    return [ split(/,/, $state) ];
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;display_state()&lt;/code&gt; converts a packed state to a user-readable string. This is so that it can be displayed to the user. In our case, the comma-delimited notation is already readable, so we leave it as that.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Accept an atom that represents a state and output a 
# user-readable string that describes it.
sub display_state
{
    my $self = shift;
    my $state = shift;
    return $state;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We need to determine when we have reached our goal and can terminate the search with a success. The &lt;code&gt;check_if_final_state&lt;/code&gt; function accepts an expanded state and checks if it qualifies as a final state. In our case, it is final if it&amp;rsquo;s the 8-to-1 sequence.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub check_if_final_state
{
    my $self = shift;

    my $coords = shift;
    return join(&amp;quot;,&amp;quot;, @$coords) eq &amp;quot;8,7,6,5,4,3,2,1&amp;quot;;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now we need a function that will tell the solver what subsequent states are available from each state. This is done by enumerating a set of moves that can be performed on the state. The &lt;code&gt;enumerate_moves&lt;/code&gt; function does exactly that.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This function enumerates the moves accessible to the state.
sub enumerate_moves
{
    my $self = shift;

    my $state = shift;

    my (@moves);
    for my $i (0 .. 6)
    {
        for my $j (($i+1) .. 7)
        {
            my @new = @$state;
            @new[$i,$j]=@new[$j,$i];
            my $is_ok = 1;
            for my $t (0 .. 6)
            {
                if (abs($new[$t]-$new[$t+1]) &amp;gt; 3)
                {
                    $is_ok = 0;
                    last;
                }
            }
            if ($is_ok)
            {
                push @moves, [$i,$j];
            }
        }
    }
    return @moves;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What &lt;code&gt;enumerate_moves&lt;/code&gt; does is iterate over the indices of the locations twice, and checks every move for the validity of the resultant board. If it&amp;rsquo;s OK, it pushes the exchanged indices to the array &lt;code&gt;@moves&lt;/code&gt;, which is returned at the end.&lt;/p&gt;

&lt;p&gt;We also need a function that will translate an origin state and a move to a resultant state. The &lt;code&gt;perform_move&lt;/code&gt; function performs a move on a state and returns the new state. In our case, it simply swaps the cards in the two indices specified by the move.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# This function accepts a state and a move. It tries to perform the
# move on the state. If it is successful, it returns the new state.
sub perform_move
{
    my $self = shift;

    my $state = shift;
    my $m = shift;

    my @new = @$state;

    my ($i,$j) = @$m;
    @new[$i,$j]=@new[$j,$i];
    return \@new;
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Finally, we need a function that will render a move into a user-readable string, so it can be displayed to the user.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub render_move
{
    my $self = shift;

    my $move = shift;

    if (defined($move))
    {
        return join(&amp;quot; &amp;lt;=&amp;gt; &amp;quot;, @$move);
    }
    else
    {
        return &amp;quot;&amp;quot;;
    }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;invoking-the-solver&#34;&gt;Invoking the Solver&lt;/h2&gt;

&lt;p&gt;To make the solver invokable, create an instance of it in the main namespace, and call its &lt;code&gt;main()&lt;/code&gt; function. This will turn it into a script that will solve the board. The code is this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;package main;

my $solver = Jumping::Cards-&amp;gt;new();
$solver-&amp;gt;main();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now save everything to a file, &lt;em&gt;jumping_cards.pl&lt;/em&gt; (or download &lt;a href=&#34;http://t2.technion.ac.il/~shlomif/solving-with-lms/jumping_cards.pl&#34;&gt;the complete one&lt;/a&gt;), and invoke it like this: &lt;code&gt;perl jumping_cards.pl --norle --output-states&lt;/code&gt;. The &lt;code&gt;--norle&lt;/code&gt; option means not to run-length encode the moves. In our case, run-length encoding will do no good, because a move can appear only once (or else its effect will be reversed). &lt;code&gt;--output-states&lt;/code&gt; causes the states to be displayed in the solution.&lt;/p&gt;

&lt;p&gt;The program thinks a little and then outputs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;solved
solved
1,2,3,4,5,6,7,8: Move = 0 &amp;lt;=&amp;gt; 1
2,1,3,4,5,6,7,8: Move = 1 &amp;lt;=&amp;gt; 2
2,3,1,4,5,6,7,8: Move = 1 &amp;lt;=&amp;gt; 3
2,4,1,3,5,6,7,8: Move = 4 &amp;lt;=&amp;gt; 5
2,4,1,3,6,5,7,8: Move = 0 &amp;lt;=&amp;gt; 4
6,4,1,3,2,5,7,8: Move = 2 &amp;lt;=&amp;gt; 3
6,4,3,1,2,5,7,8: Move = 0 &amp;lt;=&amp;gt; 1
4,6,3,1,2,5,7,8: Move = 0 &amp;lt;=&amp;gt; 7
8,6,3,1,2,5,7,4: Move = 6 &amp;lt;=&amp;gt; 7
8,6,3,1,2,5,4,7: Move = 3 &amp;lt;=&amp;gt; 5
8,6,3,5,2,1,4,7: Move = 2 &amp;lt;=&amp;gt; 7
8,6,7,5,2,1,4,3: Move = 1 &amp;lt;=&amp;gt; 2
8,7,6,5,2,1,4,3: Move = 4 &amp;lt;=&amp;gt; 6
8,7,6,5,4,1,2,3: Move = 5 &amp;lt;=&amp;gt; 7
8,7,6,5,4,3,2,1
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which is a correct solution to the problem. If you want to see a run-time display of the solving process, add the &lt;code&gt;--rtd&lt;/code&gt; switch.&lt;/p&gt;

&lt;h2 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h2&gt;

&lt;p&gt;LM-Solve is a usable and flexible framework for writing your own solvers for various kind of puzzles such as the above. Puzzles that are good candidates for implementing solvers have a relatively limited number of states and a small number of states emerging from each origin state.&lt;/p&gt;

&lt;p&gt;I found several solitaire games, such as Freecell, to be solvable by methods similar to the above. On the other hand, Klondike and other games with &lt;code&gt;talon&lt;/code&gt;, are very hard to solve using such methods, because the &lt;code&gt;talon&lt;/code&gt; expands the number of states a great deal.&lt;/p&gt;

&lt;p&gt;Still, for most &amp;ldquo;simple-minded&amp;rdquo; puzzles, LM-Solve is very attractive as a solver framework. Have fun!&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

