<!DOCTYPE html>
<html lang="en-us">
  <head>
  <title> Ilya Regularly Expresses </title>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <meta name="description" content=""/>
  <meta name="robots" content="index, follow">
  <meta name="google-site-verification" content="TZowffo_LX2mmsw2DbeNNbukCMnIOA8T-6CMJPiYllI" />

<meta property="twitter:card" content="summary">
<meta property="twitter:site" content="@PerlFoundation">
<meta property="og:url" content="http://localhost:1313/pub/2000/09/ilya.html/" />
<meta property="og:title" content="Ilya Regularly Expresses" />
<meta property="og:description" content="Since 1997 Perl.com has published articles about the Perl programming language, its culture and community.">
<meta property="og:site_name" content="Perl.com" />

<meta property="og:type" content="article" />
<meta property="og:article:published_time" content="2000-09-09T09:09:09Z" />
<meta property="og:image" content="http://localhost:1313/images/site/avatar.png" />


  <link rel="icon" href="/favicon.ico">
  <link href="/article/index.xml" rel="alternate" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/article/index.xml" rel="feed" type="application/rss+xml" title="Perl.com - programming news, code and culture" />
  <link href="/css/bootstrap.min.css" rel="stylesheet">
  <link rel="stylesheet" type="text/css" href="/css/perldotcom.css"/>


<script>
(function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
(i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
})(window,document,'script','https://www.google-analytics.com/analytics.js','ga');

ga('create', 'UA-50555-22', 'auto');
ga('create', 'UA-85734801-2', 'auto', 'editor');
ga('send', 'pageview');
ga('editor.send', 'pageview');
</script>

</head>
<body>

<div class="container-fluid full-wdith antonio">
 <div class="row">
  <div class="navbar-inverse" style="border-radius:none !important" role="navigation">
    <div class="container-fluid">
      <ul class="nav navbar-nav pull-right follow">
          <li>MORE:</li>
          <li><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a><li>
          <li><a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a><li>
          <li><a href="/article/index.xml" />
              <img src="/images/site/rss_20.png" alt="rss"></a></li>
          <li><a href="https://github.com/tpf/perldotcom" />
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></li>
      </ul>
      <div class="navbar-header">
        <button type="button" class="navbar-toggle" data-toggle="collapse" data-target=".navbar-collapse">
          <span class="sr-only">Toggle navigation</span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
          <span class="icon-bar"></span>
        </button>
          <a class="navbar-nav" href="/">
            <div class="header-logo">Perl.com</div>
          </a>
      </div>
      <div class="navbar-collapse collapse">
        <ul class="nav navbar-nav">
          <li><a href="/about">
              <div class="circle">
                <img src="/images/site/perl-camel.png" alt="" />
              </div>
                  &nbsp;&nbsp;ABOUT</a>
          </li>
          <li><a href="/authors">
              <div class="circle">
                  <span class="glyphicon glyphicon-user txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;AUTHORS</a>
          </li>
          <li><a href="/categories">
              <div class="circle">
                  <span class="glyphicon glyphicon-folder-open txt-blue-major" aria-hidden="true"></span>
              </div>
                  &nbsp;&nbsp;CATEGORIES</a>
          </li>
          <li><a href="/tags">
              <div class="circle">
                <span class="txt-blue-major" aria-hidden="true"><strong>#</strong></span>
              </div>
                  &nbsp;&nbsp;TAGS</a>
          </li>
          <li>
            <form class="search" name="ddg" action="https://duckduckgo.com/" method="get">
              <input type="text" name ="q" placeholder="SEARCH" />
              <input type="hidden" value="perl.com" name="sites" />
            </form>
          </li>
        </ul>
      </div>
    </div>
  </div>
 </div>
</div>


  <section id="content" role="main">
    <section class="entry-content">
      <div class="container">
        <div class="row">
          <div class="col-md-9">
            <div class="row">
              <article class="fulltext">
              <h1 class="blog-post-title">Ilya Regularly Expresses</h1>
              <p class="blog-post-meta">Sep 20, 2000 by
              
              
                
                
                <a href="#author-bio-joe-johnston">Joe Johnston</a>
              
              </p>
              <img alt="" src=""/>
                <p><em>Dr. Ilya Zakharevich is well known to the Perl community as along-time contributor to the Perl5 Porters mailing list and for being a regular expression wizard extraordinaire. Ilya has been a major figure in the Perl world for years, contributing Perl 5&rsquo;s operator overloading feature, much of the current shape of the regex engine, the OS/2 port, and the <code>FreezeThaw</code>, <code>Devel::Peek</code>, <code>Math::Pari</code> and <code>Term::Readline</code> modules. Dr. Zakharevich also teaches mathematics at Ohio State University. Below he shares his thoughts on Perl 6, the U.S. educational system, and Gödel&rsquo;s theorem.</em></p>

<p><strong>Many people know your extensive work with Perl&rsquo;s regular expressions. What is the most common misunderstanding new programmers have about this pattern-matching language?</strong></p>

<p><strong>IZ</strong>: I do not remember. For me, the beginner stage was so long ago, and I try to avoid questions on c.l.p.misc which many posters have enough expertise to answer. Let me guess.</p>

<p>Perl&rsquo;s regular expressions are modeled (eventually) after command-line parameters to grep and other similar utilities. In the command-line world, everything is a string. Bingo: Perl regular expressions look like strings. (Let us forget for a moment that operators <code>qq()</code> etc. were introduced to make strings look like regular expressions &hellip; .)</p>

<p>We have a language with binary operators (for example, `<code>|</code>&rsquo;, `<code>{4}</code>&rsquo;, or `&rsquo; - this was concatenation), unary operators (`<code>[]</code>&rsquo;, `<code>[^]</code>&rsquo;, `<code>(?!)</code>&rsquo;, &lsquo;<code>+</code>&rsquo; - both postfix and aroundfix), grouping (`<code>(?:)</code>&rsquo;), keywords (`<code>\w</code>&rsquo;, `<code>^</code>&rsquo;), ternary (&rsquo;<code>{3,7}</code>&rsquo;), naming (`<code>()</code>&rsquo;) etc. All of this is packed into a string. No wonder that even inherently unreadable languages like Tcl or Lisp start looking like Dr. Seuss compared to regular expressions.</p>

<p>Additionally, newcomers do not understand that one needs to break a regular expression into tokens (not mentioning how to do it!), all these rules about what is special when backslashed, what is special when not backslashed and so on. To add insult to injury, <code>m</code> in <code>m//</code> is optional, but <code>s</code> in <code>s///</code> is not, <code>//x</code> would require you to go into &ldquo;gory details,&rdquo; some switches in <code>//ioxmsg</code> apply to regular expressions, some to the operator in which the regular expression appears, <code>print /foo/, 'bar'</code> is applied to <code>$_</code>, but <code>split /foo/, 'bar'</code> is not etc., etc., etc.</p>

<p><code>//x</code> was introduced as a clever hack around the problem of &ldquo;packing a language into a string,&rdquo; but it went only a small part of the way to make things more maintainable. Languages like SNOBOL introduced COBOL-style patterns, which swing into the opposite end of the scale: things become less readable due to the sheer size of patterns for any nontrivial task.</p>

<p>Regular expressions are extremely powerful tools, they are the functional-programming oasis inside a procedural language, and, when well understood, they map wonderfully into the problem domain they address. Making them into eye candy is not impossible, but requires a lot of work (and probably significant changes in the current mindsets).</p>

<p><strong>For those of us who use the Beast Emacs, you have provided the outstanding cperl-mode syntax highlighter and indenting system. What was so bad about the traditional perl-mode that made you want an alternative?</strong></p>

<p><strong>IZ</strong>: Again, I do not remember the details. But I did not invent the alternative, I just adopted an existing branch. Here&rsquo;s my attempt to reconstruct how it did happen (but it may be a false memory): At the time I grabbed <code>cperl-mode.el</code> v1.3 (by Bob Olson) from gnu.emacs.source, <code>perl-mode.el</code> was handling about 30% of constructs, while <code>cperl-mode.el</code> was handling 60%. Additionally, electric constructs were decreasing the irritation factor a lot. This was what I started with. Bob named and coded <code>cperl-mode.el</code> similarly to the difference between <code>c-mode.el</code> and <code>cc-mode.el</code>.</p>

<p>Being locked into Emacs, being used to (extremely high) standards of good DOS programmers editors, and having a very low irritation threshold for bookkeeping-related repetitive tasks got me some minimal experience with Emacs Lisp (I needed several years to make my Emacs config tolerable). So when facing a problem with the existing cperl-mode.el, I would try to fix it instead of working around it.</p>

<p>While not time-efficient, this was bringing this warm fuzzy feeling of improving the universe instead of just increasing its entropy. So it went and went, with additional fuel supplied by annoyed/pleased/patchy users around the world.</p>

<p><strong>What first attracted you to Perl?</strong></p>

<p><strong>IZ</strong>: Oh, this is easy to answer: <code>command.com</code>. If all you have are scissors, everything starts looking like a nail. So you learn to deal with everything using your scissors. I remember my impression when I printed out the documentation for 4DOS/4OS2: Wow, these guys thought of everything! I may replace half of the tiny utilities I need with this one program!</p>

<p>Then I saw a &ldquo;go&rdquo; script for running LaTeX/BibTeX until successful completion. It required an additional program, perl.exe, which was not exactly tiny (around 200K), but obviously demonstrated quite enough bang for a K. The manpage for this program had a few kilolines, was very well written, so was easy to grasp. Browsing &ldquo;Programming Perl&rdquo; did not hurt, either. (It took a lot of time to understand that the title is a false advertisement). Using this program for intelligent format conversion between bibliographical databases and BibTeX proved to be a success, including a chain of regular expressions like:</p>

<pre><code> elsif (/^\s*No\.\s+([-\d\/]+(\s*\([-\/\d]+\))?)\s+(pp\.\s*)?([-\d]+)(\s*pp\.?)?
       (\s*\((\d{4})\))\s*$/i) {
 elsif (/^\s*(pp\.\s*)?(([ivxlcd]+\+)?([-\d]+)|((\w)\d+-+\6\d+))(\s*pp\.?)?\s*$/) {
</code></pre>

<p>Then there was the year I was trying to make a math-editing widget based on a beefed up TK&rsquo;s text widget. With all the work for &ldquo;typesetting&rdquo; components of formula delegated by the widget to TCL callbacks, TCL turned out to be not an answer.</p>

<p>Then I got an impression that seeing exact numeric answers for the simplest particular cases of a conjecture I was working on would help me treat general cases. A couple of months of programming in a mini-language of the PARI package for math-related calculations (and several weeks of running the code). Custom mini-languages were not the answers. (My conjecture is still there, though the &ldquo;famous&rdquo; conjecture it was a stepping stone to was soon established by my colleagues.)</p>

<p>Stroustroup&rsquo;s &ldquo;Annotated reference&rdquo; showed clearly that C++ is not going to be an answer, either. Aha, Perl is going to be redesigned to allow objects! Given overloading, one could use it for math. But there were no plans to add overloading. &hellip; Well, adding overloading to Perl would clearly improve the universe, and spending some time to improve Perl looked like a just cause &hellip; .</p>

<p><strong>At Perl Conference 4.0, Larry Wall and the Perl 5 Porters announced a complete rewrite of Perl. What are three things that a rewrite of Perl needs to get right?</strong></p>

<p><strong>IZ</strong>: Currently, I have only one sentiment about this effort: It should be terminated ASAP. There are many problems with Perl, but I would consider a ground-up rewrite as the last alternative for fixing these problems.</p>

<p>The only aspect in which a ground-up rewrite would help is PR. While PR is important, I would think that there should be less wasteful ways to improve PR than locking the resources into a possible vaporware for 2 to 3 years.</p>

<p>But let me interpret your question the other way: Which changes to Perl as a language would be beneficial to the users? Well, this is not a question which may be solved in two months. And I did not think about it even for a day. All I can do is to list some ideas I had before. All these ideas are very minor <em>additions</em> to the language. (I do not list badly needed improvements to particular operators, like regular expressions or <code>pack</code>/<code>unpack</code>, or missing operators.) And it is not three most-important things, but just a random pick of ilyaisms:</p>

<ol>
<li><p>Introduce pragmas to tame the bizarreness level. These may go in many different levels, starting, for example, with prohibiting (read warn or die) default arguments, or indirect object (IO) syntax, or <code>?REx?</code>, and possibly going to radical degrees, like</p>

<blockquote>
<p>I will not use the IO syntax (or <code>?REx?</code>), so if a particular construct may be interpreted as IO syntax (or <code>?REx?</code>), do not warn me, but choose the other interpretation.</p>
</blockquote>

<p>or even</p>

<blockquote>
<p>I will not use cryptocontext, so execute everything in the list context, and return the number of elements if the actual context is scalar.</p>
</blockquote>

<p>Another pragmatically controlled thing may be an introduction of a &ldquo;floating precedence&rdquo; of operators. Obviously, one cannot design a precedence table with 20 or so levels of precedence which gives an &ldquo;intuitively obvious&rdquo; or &ldquo;natural&rdquo; parsing of parentheses-less expressions. A solution I can see is to make some operators have a <em>range</em> of precedence, and warn/die on expressions which do not have the same interpretation when the precedences of operators move in these ranges. (Think of A &amp; B || C.) (I confess that I do not know how to do it with yacc, so this may be not so minor.)</p></li>

<li><p>One of the few things (the only one?) where Tcl has a clear advantage over Perl is the I/O control. You can control the I/O buffers with Perl, you can control the blocking state, you can control the autoflush, input granularity, newline translation, etc. However, all these things are done by absolutely different (and quite obscure) means, some of them are done in the core, some by different modules. Having a unified interface, like <code>$fh-&gt;configure(blocking =&gt; 0, text_nl =&gt; 1)</code> would remove a lot of unnecessary complexity.</p></li>

<li><p>Order of destruction. Due to a known bug (or, more precise, a made-in-haste bug fix) the order of destruction of lexicals at the end of scope is reversed (in fact, this is a simplification of what actually happens). Recently I spent several hours tracing a segfault which eventually turned out to be a result of this problem. (In pure-Perl cases this is OK, since if one object needs a longer existence than another, it implies keeping a reference inside the latter object, thus a correct order is guaranteed. However, if objects are just handles into the &ldquo;outside&rdquo; world objects, it may be not possible to reflect their interdependence by the refcount alone.)</p></li>
</ol>

<p><strong>It was widely reported that you left the Perl 5 Porters list earlier is summer. Will you continue to submit patches? Will you continue to use Perl at all? What will you be doing with all your new found spare time?</strong></p>

<p><strong>IZ</strong>: My &ldquo;impedance mismatch&rdquo; with p5p has nothing to do with any unwillingness to improve Perl or my choice of favorite tools to work with. Of course, one should keep in mind that it is not technically simple to continue submitting patches while not on p5p, since a lot of things could have been decided/done which is hard to deduce from &ldquo;Changes&rdquo; files. Additionally, it is not clear now whether Perl v5 development would co-exist with the Perl v6 extravaganza - or it would follow the fate of other promised (but never delivered) maintenance tracks. When was the last release of 5.005_*?</p>

<p>I continue to think that Perl maps better than the alternatives into the mindset of many problems solvers. Given a few of well-focused improvements, Perl might evolve into a Swiss army toolset appropriate for solutions in a very wide problem area. However, at least as far as my experience shows, Perl is as bad as the alternatives for solving those (more complicated?) problems arising in my research-related work. Somehow the advantages above are not fulfilled. Almost all I use Perl for is the system-maintenance-related tasks. Would you maintain a system the principal occupation of which is its own maintenance? I do not think these shortcomings may be resolved by a better support for programming (as opposed to scripting) in Perl which I mention above. Some radical changes, such as better text handling capabilities, a more efficient support for &ldquo;alient objects&rdquo; may help, and these changes are appropriate for Perl 6, but as I see it, Perl 6 advocates have somewhat perpendicular agendas.</p>

<p>As far as my spare time goes, I would not classify my tinkering with Perl into this category. It was more like a necessary distraction: an orthogonal way to keep the mind wheels rolling when it feels like they stuck too deep in the rut. (Of course, one should fight the tendency of the wheels to stuck in that &ldquo;other&rdquo; rut, as well.) And since I did not need such upwheeling yet, I have no idea what kind of occupation will take the place of p5p-ing.</p>

<p><strong><a href="http://www.cs.bell-labs.com/cm/cs/who/rob/utah2000.pdf">Rob Pike was recently lamenting the death of innovative operating-system research</a>. Do you feel the same can be said for programming languages? Will be you learning Microsoft&rsquo;s C# anytime soon?</strong></p>

<p>The first time the Plan 9 people impressed me so much, it was their position on Unicode at time when it was widely considered as a marketing gimmick. Unfortunately, this time their stand has practically no conflict with what I think today, so I could not improve myself by switching to the other side. <code>;-)</code></p>

<p>I suspect that it was my emphasis on the role of delayed gratification which made you remember this paper &hellip; &ldquo;Too much phenomenology: invention has been replaced by observation&rdquo; is also quite Perl-connected. One can find authors of well-written and well-researched Perl books spending an incredible amount of time investigating Perl weaknesses and the ways to work around them. In a lot of cases one could <em>fix</em> these weaknesses in a fraction of time it took to write down these workarounds. And when this becomes published, other people would surely fix these problems, so such a book can become a doorstop soon. Unfortunately, there is cash value in publishing instead of fixing. &hellip;</p>

<p>What I cannot agree with is the nodding down to &ldquo;take an existing thing and tweak it&rdquo; approach. Innovation != redoing everything from scratch. In programming languages, innovation requires</p>

<ul>
<li>categorizing programming subtasks into appropriate groups;</li>
<li>providing uniform efficient ways to solve the problems within one group; and</li>
<li>the tools to collect the subtasks into a solution of the problem.</li>
</ul>

<p><code>sscanf()</code> was such an innovation. Having regular expressions instead of <code>sscanf()</code> was an innovation. Saying goodbye to distributed shell scripting and replacing it by a monstrously monolithic Perl scripting was an innovation.</p>

<p>My feelings are that &ldquo;tweak it&rdquo; is the best approach to be innovative today. There are still many chances to discover a new category of subtasks the programs spend 90% of time doing which, or programmers spend 90% of time coding which. Even if it is 10% (or 2%) of programs/programmers who do this, a canned elegant solution to this category would be a significant innovation. Even if it is provided as a tweak to something else.</p>

<p>About C# - this was the first time I&rsquo;ve heard about it. What I see is that it replaced something else with the lifespan of what, two years? What is the projected half-life of C# then?</p>

<p><strong>You are an Assistant Professor of Mathematics at Ohio State University where your Web page identifies your research area as &ldquo;studying analytic, geometric and algebraic foundations for the phenomenon of integrability of dynamic systems.&rdquo; For those that have been out of school for a while (like myself), what does this mean and how does this study intersect with our everyday world?</strong></p>

<p><strong>IZ</strong>: First of all, this is the departmental page, not mine. I think that in my case FTP speaks louder than HTTP, so do not have any Web presence. But the phrase you quoted is mine (taken from some &ldquo;promotional&rdquo; material), so I cannot avoid your question with this trick.</p>

<p>The short answer first: You do not want to know. This is deep magic, even deeper than the question, &ldquo;What does `deeper magic&rsquo; mean?&rdquo; And it would not bring you any new microchip architecture, won&rsquo;t save any lives, and/or won&rsquo;t lead to new significant fuel economy in your car. At least not in any foreseeable future.</p>

<p>For those nasty persistent minds which are not discouraged by so many negatives, a &ldquo;what Perl does is finishing your assignments on time&rdquo;-style explanation is the best one can hope for. But I need to start it from far away.</p>

<p>There are several dichotomies in modeling a &ldquo;physical&rdquo; system. The first one is of the simple, hairy type: simple systems are &ldquo;linear,&rdquo; so the &ldquo;response&rdquo; of a component is proportional to the &ldquo;stimulus.&rdquo; For a linear system, no matter how many &ldquo;components&rdquo; it has, the behavior is essentially the same: There is a way to break the system into new &ldquo;components&rdquo; without any interaction between these new components. Think of an ideal crystal: There are many interacting atoms, but the oscillation can be also described by phonons (&ldquo;modes&rdquo; of oscillation) which travel without any interaction between them.</p>

<p>This leads to another dichotomy: chaotic versus integrable systems. Oscillations of an ideal crystal are not any more chaotic than a typical random number generator is random. But most &ldquo;hairy&rdquo; systems behave differently: Theoretically, if you know the state of the system at some moment of time, you should be able to predict the future; practically, due to errors in the measurement of the initial state, your predictions about the future behaviour degrade as time goes. For integrable systems, this degradation is linear - you measure things twice as precise, you can predict the future for an interval twice as long. For chaotic systems the degradation is exponential - you collect twice as much meteorological data, you can increase the weather prediction interval by (say) a day; you collect a million times as much data, you get an extra 20 days. In such a situation, do not even think of a two-month prediction; this is the chaos domain.</p>

<p>Nonlinear (read nontrivial) systems are expected to be chaotic. You can get &ldquo;truly random&rdquo; signal from the crystal oscillators in your computer, though the &ldquo;amount of nonlinearity&rdquo; there is minuscule. Here comes &ldquo;integrability.&rdquo; There are exceptions to this law. Say, the two-body gravitational attraction problem is nonlinear, but in Newtonian approximation it is integrable. The &ldquo;standard&rdquo; predator-prey model of the food chain is integrable in many cases. Until 50 years ago such systems were considered to be interesting, but isolated exceptions. The situation changed when one of the first computer simulations modelled a nonlinear interaction of atoms in a crystal. Amazingly, this model did not demonstrate any chaos.</p>

<p>Now we know that a lot of (physically interesting or artificial) examples when hairy systems remain integrable. For example, &ldquo;string theories&rdquo; of elementary particles lead to an enormous amount of different integrable systems. Moreover, there are plenty of known explanations of why a particular system is integrable. Here comes the problem. Typically, all these explanations are applicable <em>simultaneously</em>. Imagine that you cannot start your car because it ran out of gas, the battery is dead, the key broke, the garage door won&rsquo;t open and your driver&rsquo;s license expired. Maybe you should ignore all these explanations, and just go to a shrink.</p>

<p>This is close to outline of what I do: I investigate what could be the reason which connects these fantastically beautiful, but deeply dissimilar explanations of integrability. Going back to the everyday world: Finding such reason(s) would not make any known system &ldquo;more integrable,&rdquo; but I&rsquo;ll be surprised if such new viewpoints would not bring new unknown applications of integrability. But applications to &ldquo;more fundamental&rdquo; physics are more probable, so if you do not interact with strings, you should not worry about this.</p>

<p><strong>Well, I use Perl which has extremely agile text handling facilities, so I&rsquo;m not worried about your bothersome &lsquo;strings.&rsquo; Seriously, that sounds like really engaging, but very elusive research. Do you ever think, &ldquo;This is an intractable problem which the human mind can&rsquo;t solve&rdquo;?</strong></p>

<p><strong>IZ</strong>: Taken theoretically, your question is very dear for a lot of mathematicians (and very demanding of them). It is the fundamental ignoramus-or-ignorabimus dilemma of the life-after-Gödel: Will we ever know? What Gödel says is: If the society of mathematicians may be modeled by a computer, then most of the questions which make sense cannot be resolved, even if we have unlimited resources. However, we know that in practice this is far from happening. Most working mathematicians do not spend their life banging forever against a dead end.</p>

<p>There may be many explanations for this. First of all, bad emotions being bad, we just forget about our failures when we switch to something more rewarding. Second, the most interesting questions are not &ldquo;formalized,&rdquo; they sound more like &ldquo;explain why&rdquo; than &ldquo;calculate this.&rdquo; For example, the problem I mentioned above is about finding an appropriate point of view which would clarify many known coincidences at once. We, mathematicians, as a class, have a very good record in producing new and enlightening points of view. It could take 50 or 100 years, but typically it comes sooner or later. Maybe such questions may not be mapped into the negative spirit of the Gödel program?</p>

<p>Lastly, the questions on whether humans may be modelled by computers is far from having the &ldquo;Of course, yes!&rdquo; answer. Remember that there is a natural ladder of sciences: physics, chemistry, cytology, physiology, ethology, sociology, ecology. We know that the attempts to describe the next step of the ladder basing <em>only</em> on the information obtained on the previous steps would spectacularly fail. And one of the possible explanations of this is quite similar to the chaos semantic of weather forecasts. For example, yes, molecules are built of atoms, which are built of elementary particles. But this does not necessarily mean that we may explain properties of molecules basing of the known properties of elementary particles.</p>

<p>How this can be so? Here is one - imaginary - scenario. Suppose that calculating properties of an n-atom molecule requires the knowledge of the charge of the electron with n decimal places. This would mean a complete separation of physics and organic chemistry into unrelated sciences, since they depend on different decimal places of this number. You may tell me that one can use properties of one n-atom molecule to find the n first digits of the charge of electron, then use this number for other n-atom molecules. Just throw in a cryptographically strong one-way function, and this possibility goes away. And chaotic systems provide spectacularly good one-way functions. There <em>may</em> be obstacles for modeling a human brain (or a human society) by a Turing machine, similar to the obstacles in modeling molecules in terms of the physics of elementary particles.</p>

<p>Now you should not be surprised by me not worrying much about the question you asked. Additionally, what I wrote is just a motto-ized outline of what I&rsquo;m working over. Any particular time I work over something more or less concrete and more or less reachable in a meaningful time frame.</p>

<p>Let me also mention that classifying the text handling facilities of Perl as &ldquo;extremely agile&rdquo; gives me the willies. Perl&rsquo;s regular expressions are indeed more convenient than in other languages. However, the lack of a lot of key text-processing ingredients makes Perl solutions for many averagely complicated tasks either extremely slow, or not easier to maintain than solutions in other languages (and in some cases both).</p>

<p>I wrote a (heuristic-driven) Perlish syntax parser and transformer in Emacs Lisp, and though Perl as a language is incomparably friendlier than Lisps, I would not be even able of thinking about rewriting this tool in Perl: there are just not enough text-handling primitives hardwired into Perl. I will need to code all these primitives first. And having these primitives coded in Perl, the solution would turn out to be (possibly) hundreds times slower than the built-in Emacs operations.</p>

<p>My current conjecture on why people classify Perl as an agile text-handler (in addition to obvious traits of false advertisements) is that most of the problems to handle are more or less trivial (&ldquo;system maintenance&rdquo;-type problems). For such problems Perl indeed shines. But between having simple solutions for simple problems and having it possible to solve complicated problems, there is a principle of having moderately complicated solutions for moderately complicated problems. There is no reason for Perl to be not capable of satisfying this requirement, but currently Perl needs improvement in this regard.</p>

<p><strong>Could you describe in more detail what additional text-handling primitives you would like to see included with Perl? What string munging operations are absent that really ought to be included in Perl&rsquo;s core?</strong></p>

<p>The problem: Perl&rsquo;s text-handling abilities do not scale well. This has two faces, both invisible as far as you confine yourselves to simple tasks only. The first face is not that Perl lacks some &ldquo;operations;&rdquo; it is not that some &ldquo;words&rdquo; are missing, whole &ldquo;word classes&rdquo; are not present. Imagine expressive power of a language without adjectives.</p>

<p>In Perl text-handling equals string-handling. But there is more in a text than the sequence of characters. You see a text of a program - you can see boundaries of blocks, etc.; you see an English text, you can see word boundaries and sentence boundaries, etc. With the exception of the word boundaries, all these &ldquo;distinctive features&rdquo; become very hard to recognize by a &ldquo;local inspection of a sequence of characters near an offset&rdquo; - unless you agree to use a heuristic which works only time to time. But a lot of problems require recognition of the relative position of a substring w.r.t. these &ldquo;distinctive features&rdquo;.</p>

<p>Remember those &ldquo;abstract algorithms&rdquo; books and lessons? You can solve the problems &ldquo;straightforwardly,&rdquo; or you can do it &ldquo;smartly.&rdquo; Typically, &ldquo;straightforward&rdquo; algorithms are easy to code, but they do not scale well. Smart algorithms start by an appropriate preprocessing step. You organize your data first. The particular ways to do this may be quite different: you sort the data, or keep an &ldquo;index&rdquo; of some kind &ldquo;into your data,&rdquo; you hash things appropriately, your balance some trees, and so on. The algorithms use the initial data <em>together</em> with such an &ldquo;index.&rdquo;</p>

<p>Perl provides a few primitives to work with strings, which are quite enough to code any &ldquo;straightforward&rdquo; algorithm. What about &ldquo;smart&rdquo; ones? You need preprocessing. Typically, digging out the info is easy with Perl, but how would you store what you dug? The information should be kept &ldquo;off band,&rdquo; for example, in an array or hash of offsets into the string.</p>

<p>Now modify the string a little bit, say, perform some <code>s()()</code> substitutions, or cut-and-paste with <code>substr()</code>. What happens with your &ldquo;off band&rdquo; information? It went out of sync. You need to update your annotating structures. Do not even think about doing <code>s()()g</code>, since you do not have enough info about the changes after the fact. You need to do your <code>s()()</code> one-by-one - but while <code>s()()g</code> is quite optimized, a series of <code>s()()</code> is not - and you get stuck again into the land of badly scaling algorithms.</p>

<p>(Strictly speaking, for this particular example <code>s()()eg</code> could save you - as well as code-embedded-into-a-regular-expression, but this was only a simple illustration of why off-band data is not appropriate for many algorithms. Please be lenient with this example!)</p>

<p>Even if no modification is done, using off-band data is very awkward: how to check what are the attributes of the character at offset 2001 when there are many different attributes, each marking a large subset of the string?</p>

<p>That was the problem, and the solution supported by many text-processing systems is to have &ldquo;in-band annotations&rdquo;, which is recognized by the editing primitives, and easily queryable. Perl allows exactly one item of in-band data for strings: pos(), which is respected by regular expressions. But it is not preserved by string-editing operations, or even by <code>$s1 = $s2</code>!</p>

<p>&ldquo;In-band&rdquo; data comes in several &ldquo;kinds&rdquo;. A particular &ldquo;kind&rdquo; describes:</p>

<ul>
<li>how it behaves with respect to insertion or deletion of characters nearby;</li>
<li>can the &ldquo;same&rdquo; markup appear &ldquo;several times&rdquo;;</li>
<li>can the markup &ldquo;nest&rdquo; (like nested comments in some languages); and</li>

<li><p>is there an internal structure of the markup (as in a loop, which may be</p>

<pre><code>    [[LABEL DELIM0] KEYWORD [DELIM1 VAR1 SEP VAR2 ... DELIM2] 
     [DELIM4 EXPR DELIM4] [DELIM5 BODY DELIM6]]
</code></pre>

<ul>
<li>with some parts possibly missing, so the internal structure is a tree).</li>
</ul></li>
</ul>

<p>Different answers lead to a zoo of intuitively different kinds of markup, each kind useful for some categories of problems. You can mark &ldquo;gaps between&rdquo; characters, or you can mark characters themselves. The markup may &ldquo;name&rdquo; a position (&ldquo;the first <code>__END__</code> in a Perl program&rdquo;), or cover a subset of the string (&ldquo;show in red&rdquo;, &ldquo;is a link to <em>this</em> URL&rdquo;, or &ldquo;inside comment&rdquo;). Since the kind of the markup defines what happens when the string is modified, the system can support self-consistency of the markup &ldquo;automatically&rdquo; (in exceptionally complicated cases one may need to register a callback or two).</p>

<p>The second face of problem is not with the expressive power of Perl, but with the implementation. Perl has a very rigid rule: a string must be stored in a consecutive sequence of bytes. Remove a character in the middle of the string, and all the chars after it (or before it) should be moved. As I said, <code>s()()g</code> has some optimizations which allow doing such movements &ldquo;in one pass&rdquo;, but what if your problem cannot be reduced to <em>one</em> pass of <code>s()()g</code>? Then each of the tiny modification you do one-at-a-time may require a huge relocation - or maybe even copying of the whole string. This is why a lot of algorithms for text manipulation <em>require</em> a &ldquo;split buffer&rdquo; implementation, when several chunks of the string may be stored (transparently!) at unrelated addresses.</p>

<p>Such &ldquo;split-buffer&rdquo; strings may look incredibly hard to implement, as in &ldquo;all the innards of Perl should be changed&rdquo;, but it is not. Just store &ldquo;split strings&rdquo; similarly to <code>tie()</code>d data. The <code>FETCH</code> (actually, the low-level MAGIC-read method) would &ldquo;glue&rdquo; all the chunks into one - and would remove the MAGIC - before the actual read is performed; and now no part of Perl <em>requires</em> any change. Now four or five primitives for text-handling may be changed to recognize the associated <code>tie()</code>d structures - and act without gluing chunks together. We may even do it in arbitrarily small steps, one opcode at a time.</p>

<p>Another important performance improvement needed for many algorithms would be the copy-on-write, when several variables may refer to the same buffer in memory, or different parts of the same buffer - with suitable semantic what to do when one of these variables is modified. (In fact the core of this is already implemented in one of my patches!) Together with other benefits, this would solve the performance problems of <code>$&amp;</code> and friends, as well as would make <code>m/foo/; $&amp; = 'bar';</code> equivalent to <code>s/foo/bar/</code>. Having copy-on-write *sub*strings may be slightly more patch-intensive than copy-on-write <em>strings</em>, though. The complication: currently the buffers are required to be 0-terminated (so that they may be used with the system APIs). It is hard to make &lsquo;b&rsquo; as in <code>substr('abc',1,1)</code> refer to the same buffer (containing &ldquo;abc\0&rdquo;) as &lsquo;abc&rsquo;. The solution may be to remove this requirement, and have two low-level string access API, SvPV() and SvPVz(), so that SvPVz() may perform the actual copying (as in copy-on-write) and the appending of <code>\0</code> - but only when needed!</p>

<p>Without these - or similar - changes Perl would not scale well as a language for efficient text-processing. What is more, I believe that the changes above can remove most of the significant bottlenecks for the problems we have in text-processing of today. At least I know a lot of problems which would have feasible solutions given these changes.</p>

<p>And I need not repeat that a handful of small extensions to the expressive power of the regular expression engine could radically extend the domain of its applicability. <code>;-)</code></p>

<p><strong>Dr. Nikolai Bezroukov cautions newbies about Perl&rsquo;s Do What I Mean (DWIM) number/string conversions (<a href="http://www.softpanorama.org/Scripting/perl.shtml">http://www.softpanorama.org/Scripting/perl.shtml</a>). He says:</strong></p>

<blockquote>
<p><em>[Perl&rsquo;s automatic conversions] lead to problems that are well known to seasoned PL/1 programmers &ndash; all [is] well until Perl [makes] a wrong decision and you end up searching this error for a week or more.</em></p>
</blockquote>

<p><strong>As a mathematician, do you feel Perl should allow programmers to have better control over these conversions?</strong></p>

<p>A number is a number, whether it is written as &ldquo;3e2&rdquo;, 3e2, &ldquo;300.&rdquo;, 300., &ldquo;300&rdquo; or 300. Of course, if something can/cannot have bugs, it has. Until recently Perl numeric conversions needed a lot of improvement.</p>

<p>Well, actually there <em>is</em> a not-yet-fixed loophole in Perl&rsquo;s conversions. Perl uses the system-supplied float-to-string conversions. They originated in the times of Fortran, when programmers knew what a number is, and knew pitfalls in computer representations of numbers. They could resolve the problems associated with too much precision on output, or could accept tradeoffs of lower precision. (Remember the hardware of 50s which was working in <em>ternary</em>, since it gave better &ldquo;transistor count&rdquo; for memory?) Perl uses these functions for today&rsquo;s programming needs. This results in Perl&rsquo;s conversions which have <em>both</em> a fuzz, <em>and</em> output unneeded digits - depending on what a user of today would think is the phase of the moon.</p>

<p>Now, when we have reproducible (and mostly documented!) numeric conversions, it is very important to use float-to-string conversion which is both lossless (when used with a consequent string-to-float conversion), and uses as few decimal places as possible. Yes, I know that the code to do this was tried with Perl, and this resulted in measurable slowdowns. But first of all, I do not believe that it is hard to modify the current sprintf() code to do &ldquo;the right thing&rdquo; without a lot of slowdown. The tested code being slow does not mean that it <em>should</em> be slow. Second, this testing was done year ago, perl of today is optimized to use conversions much less often.</p>

<p>About control? You got as much as you need with sprintf(). (Overloaded data is an exception, but with more overloaded operations this may be fixed too.) If Nikolai knows some cases where a minimal lossless reproducible conversion leads to problems, and sprintf() is not desired, I would like to hear why not.</p>

<p><strong>I see you received your Ph.D from Moscow State. Political ideology aside, do you think the Russian education system is more effective than that of the US? What element is most lacking in US higher education today?</strong></p>

<p><strong>IZ</strong>: The short answers: you cannot put ideology aside; elementary education.</p>

<p>Now the longer ones. It is extremely difficult to compare the systems. And the results would depend on how deep you are ready to dig. First, consider the purely subjective feelings. (Especially important since &ldquo;objective&rdquo; comparisons produce almost pure garbage.) Yes, it feels like the Russian system gives much better results than the U.S. one. On the other hand, look at top level achievers. Obviously, the &ldquo;stars&rdquo; in the U.S. were not less starry than the &ldquo;stars&rdquo; in the SU.</p>

<p>One of the reasons for a possibly skewed perception is an unbelievable concentration of resources in Russia. Let&rsquo;s look: scratching the surface, SU was significantly larger than US, it is enough to mention 10 (or 11?) time zones. It was a big surprise for me when after several months in US I understood that my <em>feelings</em> about the size were exactly the opposite to the &ldquo;objective&rdquo; sizes. Digging into these feelings brought the following conjecture: subjectively SU was a disk with the radius circa 25 miles.</p>

<p>Why? Imagine that 80% of everything good was in Moscow. Out of the rest, 15% were in Leningrad and Kiev. (I&rsquo;m still subjective!) Well, there is some distance between Moscow and Leningrad, but given sleeper trains, it mostly disappears. This was squeezing resources into a very tight knot. The critical mass requires high mass and high density simultaneously, both were present. The synergetic effects were omnipresent.</p>

<p>Imagine a prevalent migration of talents to metropolises with a negligible back-current. Imagine that top students go not to 25 different universities, but to one, and <em>stay</em> there (the math department in the Moscow University is 5..10 times larger than the largest math departments in the USA). What does this lead to? If you are a good student, then the proportion of good students around you would be much higher.</p>

<p>This skews perceptions, but there is also a giant &ldquo;objective&rdquo; boost due to increased interaction between &ldquo;stars&rdquo; (and &ldquo;starlets&rdquo;). US students in general are much more ready to work hard, but their achievements in the domain of their immediate speciality are only as good as those for Russian students, and not spectacularly better. Typically their knowledge outside this narrow region wishes a lot of improvement.</p>

<p>Additionally, for the most of the beneficial factors, one would not want to copy them. Why &ldquo;stars&rdquo; remain in Moscow? Because there was no way to go abroad. What choices there were for a bright kid? Very few. Learn, learn, and learn. What choices there were for philanthropy? Very few. Teach, teach, and teach. Just consider the payroll differential, which was at most 2x&ndash;4x. So even if elementary education was relatively low-paying, the enthusiasts would not be stopped by this: the difference was not that striking.</p>

<p>Consider also differences in the spending pattern. It was not absolutely ridiculous to spend 10% or 15% of your income on books. Books being cheap, you could allow yourselves to buy <em>all</em> the decent books in your wide speciality, and several related specialities, not even mentioning what is called &ldquo;literature&rdquo; in US. Clearly, there is no way to graft this to the US situation.</p>

<p>Now a theory one of my friends favors, take it at least as a parable: The humanitarian aspect of the elementary education in the U.S. is based on tolerance, basically, all the ideas are considered created equal. Pluralism, respect for opinions of other persons, the ability to look at the problem from different sides and so on. So far so good. Now: math is based on exactly the opposite premise: some arguments are correct, some are wrong. People can tell them apart.</p>

<p>This creates a conflict. Correspondingly, all non-mechanical aspects of math, which is the ultimate device to transfer knowledge in a reproducible way, and to build new knowledge, are censored out (not necessarily consciously). Now kids come to university: &ldquo;Proof? Eh?&rdquo; Bad? Would you like to sacrifice the widespread tolerance to improve math?</p>

<p>So my point is: a lot of ground for success of the Russian education system was hardwired into the ideological situation. However, it might be that the situation already bootstrapped itself into a self-supporting state of a widespread readiness to get fascination from a play of mind, even if this play requires some nontrivial mental tension. Maybe this readiness can survive the &ldquo;return to the normal ideology.&rdquo;</p>

<p>Suppose that all you need is such a readiness in a sufficient number of teachers, and this would create enough interested pupils to form the next generation of such teachers. How to bootstrap such a situation in U.S.? There may be some US-specific answers which I would not be able to even imagine. Something crazy like a philanthropist buying an hour a week on MTV, with MTV specialists who know how to speak to kids-of-today collaborating with science enthusiasts and some cold minds (so that it would not degenerate into another kindergarten like Sesame Street).</p>

<p>Myself, I favor something less focussed on the situation of today. Say, there are teacher&rsquo;s conventions anyway. Why not organize math/physics/chemistry/biology/linguistics problem-solving competition there? It would be quite low-budget. Here I mean &ldquo;cool&rdquo; problems, as on international olympiads (but of course, slightly simpler). It should not be hard to find volunteers to design the problems, the Bay Area already has a Russian-style math olympiad running.</p>

<p><strong>Can the internet be better leveraged as a tool for creating a distributed group of academic specialists? It seems like Perl development models this bringing and binding together of very bright people for a focused task. Can this model work for academia?</strong></p>

<p><strong>IZ</strong>: This would be a wonderful achievement. And I think that in some branches, where many researchers work over many similar problems with the difficulties being more or less technicalities, it is quite close to being possible. But in general, there are many reasons which make this much harder.</p>

<p>One of the reasons I&rsquo;m even ready to spell out. It is the delayed gratification. Math research is very special in the typical delay between the moment you start to work over a particular question, and the moment you can report <em>anything</em>. While the delay of five or 10 years would be rare, for important breakthroughs it may be typical, and the delay of a few years is quite common. In between you accumulate &ldquo;gut feelings,&rdquo; but successful sharing of gut feelings is a special skill which is lacking in most people.</p>

<p>It may be similar to the situation in some experimental sciences, when the results follow from tiny but statistically significant mismatches between vast collections of experimental data. You start to collect the data, but until you are done, you cannot explain <em>why</em> you collect it: you do not even know whether the data is going to self-consistent or not. And if it turns out to be self-consistent, your time is wasted.</p>

<p>There are many timers hardwired into human brains. It is a common delay of 2 months until you are ready to take a newly explained to you point of view (at least in math, where different points of view differ <em>a lot</em>). It is a common delay of three years when a mathematician switches to a completely new to him branch of math. I have not heard it discussed, but there may be a significant reproducible delay when newly invented concepts need to remain in a &ldquo;wordless&rdquo; state. And when you can write them down, usually there is a significant &ldquo;technicalities-only&rdquo; period until these concepts turn out into results.</p>

<p>Given that the gratification is delayed for so long, cooperation between people requires much closer relationships than what the Internet Neighborhood can provide. Who will you trust enough to dedicate several years of your time (even in the time-to-time mode)?</p>

<p>By the way, this may be a major obstacle on the way to Perl 6. People will need to code &ldquo;into their tables:&rdquo; What they produce will not be able to run until all the other required components are finished, too. I would expect that after the initial frenzy there will be a long lull period. Some new ideas will be needed to break the lull.</p>

<p><strong>If you couldn&rsquo;t lecture at a university, how would you spend your days, assuming money wasn&rsquo;t an issue?</strong></p>

<p>It may be I&rsquo;m a very undemanding person, so I&rsquo;m very content with what I already have. Or maybe I&rsquo;m just scared of change &hellip; At least it was always hard to imagine any other way of life than one I had at the moment. (Not that I cannot move my seat if needed - but only if needed indeed!)</p>

              </article>
              <p><strong>Tags</strong></p>
              <div class="tags">
                <div class="category"><a href="/categories/community">community</a></div>
                
              </div>
            </div>
            
              
                
<div class="row" id="author-bio-joe-johnston">
  <div class="col-sm-2">
    
    <a href="/authors/joe-johnston/"><div class="circle-avatar" style="background-image:url(/images/site/avatar.png)"></div></a>
  </div>
  <div class="col-sm-10">
    <a href="/authors/joe-johnston/"><h3>Joe Johnston</h3></a>
    <p></p>
    <h5><a href="/authors/joe-johnston/">Browse their articles</a></h5>
  </div>
</div>

            
            <div class="row">
              <h3>Feedback</h3>
              <p>Something wrong with this article? Help us out by opening an issue or pull request on <a href="https://github.com/tpf/perldotcom/blob/master/content/legacy/_pub_2000_09_ilya.md">GitHub</a></p>
            </div>
          </div>
          <div class="col-md-3">
            <div class="latest-sidebar">

  <div class="row">
    <div class="col-sm-12 centering">
      <span style="font-size:1.8em" class="antonio txt-blue-major">OUR LATEST ARTICLES</span>
    </div>
  </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/the-perl-admbassador-curtis-poe/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/the-perl-ambassador-curtis-poe/curtis-poe.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>The Perl Ambassador: Curtis &#39;Ovid&#39; Poe</h6>
          <p style="line-height:1"><small>The person behind the news of Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/a-tour-with-net-ftp/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/a-tour-with-net-ftp/thumb_kidyes.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>A tour with Net::FTP</h6>
          <p style="line-height:1"><small>How to write an FTP client in Perl</small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/shortcode_test/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/author/brian-d-foy.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>shortcode_test</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/listen-to-larry-wall-s-state-of-the-onion-2000-on-youtube/thumb_larry-wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Listen to Larry Wall&#39;s State of the Onion 2000 on YouTube</h6>
          <p style="line-height:1"><small></small></p>
      </div>
        </a>
    </div>
  
    
    
    <div class="row">
        <a href="http://localhost:1313/article/announcing-perl-7/">
      <div class="col-sm-3">
        <div class="circle-avatar" style="background-image:url(/images/announcing-perl-7/thumb_seven_on_blue_wall.jpg)"></div>
      </div>
      <div class="col-sm-9">
          <h6>Announcing Perl 7</h6>
          <p style="line-height:1"><small>Perl 5 with modern defaults</small></p>
      </div>
        </a>
    </div>
  
</div>
<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
  <script async src="/widget/toplinks/toplinks.js" type="text/javascript"></script>
    <div id="toplinks"></div>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <a class="twitter-timeline" data-height="640" data-dnt="true" data-theme="dark" href="https://twitter.com/perlfoundation?ref_src=twsrc%5Etfw">Tweets by perlfoundation</a> <script async src="//platform.twitter.com/widgets.js" charset="utf-8"></script>
  </div>
</div>

<div class="row" style="margin-top:20px">
  <div class="col-sm-12 centering">
    <script src="https://www.reddit.com/r/perl/hot/.embed?limit=10&t=all" type="text/javascript"></script>
  </div>
</div>



          </div>
        </div>
      </div>
    </section>
  </section>
<script>
 
var tables, i;
tables = document.getElementsByTagName('table');
for (i=0;i<tables.length;i++) {
  tables[i].className = 'table table-striped';
}
</script>
<div class="push"></div>
<div class="footer">
  <div class="container">
    <div class="row">
      <div class="col-md-1">
        <h5>Site Map</h5>
        <ul>
        <li><a href="/">Home</a></li>
        <hr>
        <li><a href="/about">About</a></li>
        <hr>
        <li><a href="/authors">Authors</a></li>
        <hr>
        <li><a href="/categories">Categories</a></li>
        <hr>
        <li><a href="/tags">Tags</a></li>
        <hr>
        </ul>
      </div>
      <div class="col-md-3">
        <h5>Contact Us</h5>
        <p>To get in touch, send an email to: perl.com-editor@perl.org</p>
        <p><a href="https://perl.org">
              <img src="/images/site/perl-onion_20.png" alt="Perl Onion"></a>
          <a href="https://twitter.com/intent/follow?screen_name=perlfoundation">
              <img src="/images/site/twitter_20.png" alt="twitter"></a>
          <a href="/index.xml" /><img src="/images/site/rss_20.png" alt="rss"></a>
          <a href="https://github.com/tpf/perldotcom">
              <img src="/images/site/github_light_20.png" alt="GitHub logo"></a></p>
      </div>
      <div class="col-md-2">
          <h5>License</h5>
          <p>This work is licensed under a <a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/">Creative Commons Attribution-NonCommercial 3.0 Unported License</a>.</p>
          <p><a rel="license" href="https://creativecommons.org/licenses/by-nc/3.0/"><img alt="Creative Commons License" style="border-width:0" src="https://i.creativecommons.org/l/by-nc/3.0/88x31.png" /></a></p>
      </div>
      <div class="col-md-5">
          <h5>Legal</h5>
          <p>Perl.com and the authors make no representations with respect to the accuracy or completeness of the contents of all work on this website and specifically disclaim all warranties, including without limitation warranties of fitness for a particular purpose. The information published on this website may not be suitable for every situation. All work on this website is provided with the understanding that Perl.com and the authors are not engaged in rendering professional services. Neither Perl.com nor the authors shall be liable for damages arising herefrom.</p>
      </div>
    </div>
  </div>
</div>
<script src="/javascript/jquery.min.js"></script>
<script src="/javascript/bootstrap.min.js"></script>
<script data-no-instant>document.write('<script src="/livereload.js?port=1313&mindelay=10"></' + 'script>')</script></body>
</html>

