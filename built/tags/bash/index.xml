<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Bash on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/bash/</link>
    <description>Recent content in Bash on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Tue, 05 Jul 2016 11:18:55 +0000</lastBuildDate>
    <atom:link href="/tags/bash/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Write multiline programs at the terminal</title>
      <link>http://localhost:1313/article/write-multiline-programs-at-the-terminal/</link>
      <pubDate>Tue, 05 Jul 2016 11:18:55 +0000</pubDate>
      
      <guid>http://localhost:1313/article/write-multiline-programs-at-the-terminal/</guid>
      <description>

&lt;p&gt;Perl one liners are incredibly useful, and when I&amp;rsquo;m working I write several a day. Whether it&amp;rsquo;s to test if a new module compiles, check the syntax of a function, or edit a file, one liners do the trick. Sometimes when I need to do something more involved, instead of a one liner I&amp;rsquo;ll write a throwaway script. Of course I usually forget to delete the script and that&amp;rsquo;s why my machine is littered with Perl files like &amp;lsquo;tmp.pl&amp;rsquo;, &amp;lsquo;getname.pl&amp;rsquo; etc. But I&amp;rsquo;ve since found a better way - using a shell here-doc!&lt;/p&gt;

&lt;h3 id=&#34;shell-here-docs&#34;&gt;Shell here-docs&lt;/h3&gt;

&lt;p&gt;In the terminal I can use the here-doc syntax to write an entire Perl script at the command line. Here&amp;rsquo;s an example using &lt;a href=&#34;https://metacpan.org/pod/HTTP::Tiny&#34;&gt;HTTP::Tiny&lt;/a&gt; to print out the HTTP headers returned by this website.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl - &amp;lt;&amp;lt;&#39;EOF&#39;
&amp;gt; use HTTP::Tiny;
&amp;gt; use Data::Dumper;
&amp;gt; my $res = HTTP::Tiny-&amp;gt;new-&amp;gt;get(&#39;http://perltricks.com/&#39;);
&amp;gt; print Dumper($res-&amp;gt;{headers});
&amp;gt; EOF
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;What&amp;rsquo;s happening here? The syntax &lt;code&gt;perl -&lt;/code&gt; primes Perl to execute STDIN. The syntax for a shell here-doc is &lt;code&gt;&amp;lt;&amp;lt;&#39;word&#39;&lt;/code&gt; where &amp;ldquo;word&amp;rdquo; is the value to terminate the here-doc with (I tend to use &lt;code&gt;EOF&lt;/code&gt; or &lt;code&gt;END&lt;/code&gt;). After typing the first line and pressing enter, the shell caret will move to a new line, prefixed with &lt;code&gt;&amp;gt;&lt;/code&gt;. It would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl - &amp;lt;&amp;lt;&#39;EOF&#39;
&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At this point, you can type the lines of the Perl script, pressing enter for a new line. Or you can paste in code from an existing script. Once you type the terminating word on a new line, the terminal sends the script to &lt;code&gt;perl&lt;/code&gt; via STDIN. Unlike with one-liners, you&amp;rsquo;re free to use both single and double quotes in the program text. Yay!&lt;/p&gt;

&lt;p&gt;If I want shell parameter expansion, I leave the terminator unquoted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ perl - &amp;lt;&amp;lt;EOF
&amp;gt; print &amp;quot;$HOME\n&amp;quot;
&amp;gt; EOF
/home/dfarrell
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I can write throwaway scripts in the terminal, and not leave them littered all over my hard drive. Just like other successful commands, Bash will store the script in it&amp;rsquo;s history, so you can search for, edit and re-execute the scripts over and over again.&lt;/p&gt;

&lt;p&gt;This trick isn&amp;rsquo;t specific to Perl. Shell here-docs can be used in the same way to execute code in Perl 6, Python, Ruby &amp;hellip; any binary which can execture code from STDIN.&lt;/p&gt;

&lt;h3 id=&#34;editing-tips&#34;&gt;Editing tips&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s say you just ran a throwaway script using a here-doc, and now you want to edit it and run it again. If you press the up arrow, Bash will display the command, but you can&amp;rsquo;t press up again, else Bash will display the previous command. Instead, use the left and right arrow keys to move to the beginning and end of lines, and the caret will automatically jump to the next line.&lt;/p&gt;

&lt;p&gt;When editing a throwaway script, I start by deleting the terminator word (&amp;ldquo;EOF&amp;rdquo; or whatever). That way when I press enter, I can add more lines to the script. If the command you&amp;rsquo;re looking for is an old one, you can search your terminal history with &lt;code&gt;&amp;lt;Ctrl&amp;gt;&amp;lt;shift&amp;gt;r&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;references&#34;&gt;References&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;The Wikipedia &lt;a href=&#34;https://en.wikipedia.org/wiki/Heredoc#Unix_shells&#34;&gt;here-docs entry&lt;/a&gt; has examples of shell here-doc syntax.&lt;/li&gt;
&lt;li&gt;The bash manpage (&lt;code&gt;man bash&lt;/code&gt;) has a concise but useful entry on shell here-docs and the different types.&lt;/li&gt;
&lt;li&gt;The more common way to use here-docs is inside Perl code. Read about &lt;em&gt;those&lt;/em&gt; in &lt;a href=&#34;https://perldoc.perl.org/perlop.html&#34;&gt;perlop&lt;/a&gt;, the official Perl documentation.Read it in the terminal with &lt;code&gt;perldoc perlop&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/HTTP::Tiny&#34;&gt;HTTP::Tiny&lt;/a&gt; is a lightweight, &lt;em&gt;fast&lt;/em&gt; Perl user agent that comes bundled with Perl (since version 5.14.0). You probably have it installed already, so you can read it&amp;rsquo;s documentation with &lt;code&gt;perldoc HTTP::Tiny&lt;/code&gt;.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;N.B. When reading documentation in the terminal, type &lt;code&gt;/search-term&amp;lt;enter&amp;gt;&lt;/code&gt; to jump to the next search match. Pressing &lt;code&gt;n&lt;/code&gt; will jump to the next match and &lt;code&gt;N&lt;/code&gt; the previous match. Pressing &lt;code&gt;h&lt;/code&gt; will display the help page. (all of this assumes your terminal reader is &lt;code&gt;less&lt;/code&gt;, which is typical).&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Displaying the Git branch in the terminal prompt with and without Perl</title>
      <link>http://localhost:1313/article/displaying-the-git-branch-in-the-terminal-prompt-with-perl/</link>
      <pubDate>Fri, 13 May 2016 07:57:42 +0000</pubDate>
      
      <guid>http://localhost:1313/article/displaying-the-git-branch-in-the-terminal-prompt-with-perl/</guid>
      <description>

&lt;p&gt;One way to evolve as a programmer is to pay attention to things you do repeatedly, and replace that action with an efficient alternative. It took me a shamefully long time to realize I was typing &lt;code&gt;git branch&lt;/code&gt; many times a day to check which branch I was committing code to. A more efficient way is to display the current branch name in the terminal prompt. Ideally I&amp;rsquo;d like to see something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/some/path [master]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;the-branch-command&#34;&gt;The branch command&lt;/h3&gt;

&lt;p&gt;With Git version control, code changes are committed to branches. The active branch is the context for work. For example I might be working on a new feature, so I create a new branch called &amp;ldquo;new-feature-x&amp;rdquo; and start writing code. Any changes I make to the code whilst in this branch, do not affect the master branch of code. This makes knowing the active branch really important - I don&amp;rsquo;t want to commit code to the wrong branch.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;branch&lt;/code&gt; command displays a list of all local branches and places an asterisk next to the active one. So in my fictional example, it might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch
  master
* new-feature-x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Git prepends an asterisk to highlight the active branch name. Sometimes I use this to remind myself which branches are available locally, but most of the time I&amp;rsquo;m checking it to see which branch I&amp;rsquo;m currently working on. The Git &lt;a href=&#34;https://git-scm.com/docs/git-branch&#34;&gt;branch documentation&lt;/a&gt; has more information on the ins and outs of &lt;code&gt;branch&lt;/code&gt;.&lt;/p&gt;

&lt;h3 id=&#34;parsing-git-branch-with-perl&#34;&gt;Parsing git branch with Perl&lt;/h3&gt;

&lt;p&gt;This is the one liner I want to use:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch 2&amp;gt; /dev/null | perl -ne &#39;print &amp;quot; [$_]&amp;quot; if s/^\*\s+// &amp;amp;&amp;amp; chomp&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It runs &lt;code&gt;git branch&lt;/code&gt; redirecting error messages to the netherworld. That means if the current working directory is not a git repository, the ensuing error message will be ignored. We pipe the list of git branches to Perl, which uses the &lt;code&gt;-n&lt;/code&gt; option to loop through each line of input, running the quoted code.&lt;/p&gt;

&lt;p&gt;The code operates on the default variable &lt;code&gt;$_&lt;/code&gt; which is the line of output from &lt;code&gt;git branch&lt;/code&gt; being looped over. The active branch name always begins with an asterisk, So &lt;code&gt;s/^\*\s+//&lt;/code&gt; tries to substitute the leading asterisk and whitespace from the branch name. Substitute returns the number of characters it replaced, so for all lines except the active branch, that will be zero and evaluate to false. If it&amp;rsquo;s true, the code then chomps the trailing newline character from the branch name and prints it.&lt;/p&gt;

&lt;p&gt;I can add this as a function to my &lt;code&gt;.bashrc&lt;/code&gt; file:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;function current_git_branch {
  git branch &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/dev/&lt;/span&gt;null &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;ne&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;print &amp;#34; [$_]&amp;#34; if s/^\*\s+// &amp;amp;&amp;amp; chomp&amp;#39;&lt;/span&gt;
}
PS1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\w\$(current_git_branch) &amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &lt;code&gt;PS1&lt;/code&gt; variable defines the terminal prompt content and style. Here I&amp;rsquo;ve defined it as follows: &lt;code&gt;\w&lt;/code&gt; is the current working directory path, e.g. &lt;code&gt;~/Projects/work/&lt;/code&gt; or whatever. This is followed by the call to &lt;code&gt;current_git_branch&lt;/code&gt;. Once those edits are saved in my &lt;code&gt;.bashrc&lt;/code&gt;, I need to save the file and reload it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ . ~/.bashrc
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now my terminal prompt looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/Projects/work [new-feature-x]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And if I checkout a different branch it will change:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;~/Projects/work [new-feature-x] git checkout master
~/Projects/work [master]
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;some-other-ways&#34;&gt;Some other ways&lt;/h3&gt;

&lt;p&gt;One easy alternative would be to use Perl 6:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch 2&amp;gt; /dev/null | perl6 -ne &#39;print &amp;quot; [$_]&amp;quot; if s/^\*\s+// &amp;amp;&amp;amp; .chomp&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The code is almost the same as before, only &lt;code&gt;chomp&lt;/code&gt; has been changed to a method call. A regex capture could be used instead too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git branch 2&amp;gt; /dev/null | perl -ne &#39;print &amp;quot; [$1]&amp;quot; if /^\*\s+(\S+)/&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;ve also seen &lt;a href=&#34;https://askubuntu.com/questions/730754/how-do-i-show-the-git-branch-with-colours-in-bash-prompt&#34;&gt;examples&lt;/a&gt; using &lt;code&gt;sed&lt;/code&gt; to parse the output instead of Perl.&lt;/p&gt;

&lt;h3 id=&#34;bash-only&#34;&gt;Bash only&lt;/h3&gt;

&lt;p&gt;Perhaps a more efficient approach is to have Git emit only the active branch name, and then we don&amp;rsquo;t need another program to parse the output at all, we can just use bash. Credit goes to &lt;a href=&#34;http://randalschwartz.com&#34;&gt;Randal Schwartz&lt;/a&gt; for showing me this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ git rev-parse --abbrev-ref HEAD
new-feature-x
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This emits the active branch only. So now the code in my &lt;code&gt;.bashrc&lt;/code&gt; becomes:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;function current_git_branch {
  local branch&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;$&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;(&lt;/span&gt;git rev&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;parse &lt;span style=&#34;color:#f92672&#34;&gt;--&lt;/span&gt;abbrev&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;ref HEAD &lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/dev/&lt;/span&gt;null);
  &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; [[ &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;n $branch ]];&lt;span style=&#34;color:#66d9ef&#34;&gt;then&lt;/span&gt;
    echo &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34; [$branch]&amp;#34;&lt;/span&gt;;
  fi
}
PS1&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\w\$(current_git_branch) &amp;#34;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code assigns the output of the git command to the variable &lt;code&gt;branch&lt;/code&gt;. It then echoes the branch name as long as it&amp;rsquo;s not a zero length string (which happens when the current working directory is not a git repository). But wait a second, what happened to that newline at the end of the branch name? Bash has some interesting behavior with nested &lt;code&gt;echo&lt;/code&gt; commands. Check this out:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;$ echo -n $(echo -e &amp;quot;\n\n\n\n&amp;quot;)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you run that command at the terminal you should get no output, even though it includes 4 newline characters, plus another newline appended by the &lt;code&gt;echo&lt;/code&gt; subcommand. The outer &lt;code&gt;echo&lt;/code&gt; ignores all newlines returned by the subcommand, and the &lt;code&gt;-n&lt;/code&gt; option suppresses its own newline append (thanks to Ben Grimm for the explanation).&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m going with the bash variant, but whichever method you use, displaying the branch name in the terminal is a nice time saver.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Neutralize Shellshock by patching Bash with Perl</title>
      <link>http://localhost:1313/article/118/2014/10/5/Neutralize-Shellshock-by-patching-Bash-with-Perl/</link>
      <pubDate>Sun, 05 Oct 2014 18:13:45 +0000</pubDate>
      
      <guid>http://localhost:1313/article/118/2014/10/5/Neutralize-Shellshock-by-patching-Bash-with-Perl/</guid>
      <description>

&lt;p&gt;The safest way to protect a system from Shellshock is to upgrade to a patched version of Bash. However if you&amp;rsquo;re like me, you may find that a hectic Linux distro release &lt;a href=&#34;https://fedoraproject.org/wiki/Fedora_Release_Life_Cycle&#34;&gt;schedule&lt;/a&gt; has left your current distribution unsupported. Rather than run the risk of attack, you can patch Bash yourself. Unfortunately some versions of Bash have as many as 52 different &lt;a href=&#34;http://ftp.gnu.org/gnu/bash/bash-4.2-patches/&#34;&gt;patches&lt;/a&gt; that must be downloaded and applied. So I wrote a Perl called &lt;a href=&#34;https://github.com/sillymoose/bashfix&#34;&gt;bashfix&lt;/a&gt; to automate it.&lt;/p&gt;

&lt;h3 id=&#34;requirements&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;Bashfix has a minimal set of requirements, so you should be able to run it on any Linux platform out of the box:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Perl 5.8 or higher and no extra modules required&lt;/li&gt;
&lt;li&gt;Linux with Bash version 3.* or 4.*&lt;/li&gt;
&lt;li&gt;The following C binaries: wget, curl, bison, byacc, gettext, patch, autoconf&lt;/li&gt;
&lt;li&gt;An internet connection to download Bash and associated patches from GNU&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;synopsis&#34;&gt;Synopsis&lt;/h3&gt;

&lt;p&gt;Using bashfix is fairly straightforward:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ git clone https:&lt;span style=&#34;color:#e6db74&#34;&gt;//gi&lt;/span&gt;thub&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;com&lt;span style=&#34;color:#e6db74&#34;&gt;/sillymoose/&lt;/span&gt;bashfix&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;git
$ cd bashfix
$ chmod &lt;span style=&#34;color:#f92672&#34;&gt;+&lt;/span&gt;x bashfix&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pl
$ &lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;./&lt;/span&gt;bashfix&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pl
Bash version &lt;span style=&#34;color:#ae81ff&#34;&gt;4.2.13&lt;/span&gt; detected
Created working directory &lt;span style=&#34;color:#e6db74&#34;&gt;/tmp/&lt;/span&gt;PIRKRioxmM
Downloading Bash
Downloading Patches
Bash patched to level &lt;span style=&#34;color:#ae81ff&#34;&gt;52&lt;/span&gt;
Bash fully patched&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;
Configuring Bash &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
Building &lt;span style=&#34;color:#f92672&#34;&gt;and&lt;/span&gt; testing Bash &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
Success&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; New Bash binary built&lt;span style=&#34;color:#f92672&#34;&gt;!&lt;/span&gt;
Making backup copy of &lt;span style=&#34;color:#e6db74&#34;&gt;/usr/&lt;/span&gt;bin&lt;span style=&#34;color:#e6db74&#34;&gt;/bash at /&lt;/span&gt;usr&lt;span style=&#34;color:#e6db74&#34;&gt;/bin/&lt;/span&gt;bash&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;bak
Making backup copy of &lt;span style=&#34;color:#e6db74&#34;&gt;/bin/&lt;/span&gt;bash at &lt;span style=&#34;color:#e6db74&#34;&gt;/bin/&lt;/span&gt;bash&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;bak
Bash version &lt;span style=&#34;color:#ae81ff&#34;&gt;4.2.52&lt;/span&gt; is now installed&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Bashfix checks that you have Bash installed, and the necessary prerequisites. It then downloads the Bash source for the same Bash version that is already installed on the system (you can patch an old Bash version to be Shellshock-proof). Note that different versions of Bash have different numbers of patches: 4.2 has 52 patches, whilst 4.1 has only 16. After that, bashfix configures, builds and tests Bash, making a backup of your existing Bash binary, before installing the newly patched version.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;I&amp;rsquo;ve tested &lt;a href=&#34;https://github.com/sillymoose/bashfix&#34;&gt;bashfix&lt;/a&gt; on different versions of Fedora and CentOS, and expect that it works with any RHEL flavoured distro. With other Linux distros or Unix systems, your mileage may vary. If you encounter any issues - get in touch and let me know! Check out our recent &lt;a href=&#34;http://perltricks.com/article/115/2014/9/26/Shellshock-and-Perl&#34;&gt;article&lt;/a&gt; on Shellshock and Perl if you&amp;rsquo;d like to know more about the exploit.&lt;/p&gt;

&lt;p&gt;Thanks to Steve Jenkins whose detailed blog &lt;a href=&#34;http://stevejenkins.com/blog/2014/09/how-to-manually-update-bash-to-patch-shellshock-bug-on-older-fedora-based-systems/&#34;&gt;post&lt;/a&gt; on patching Fedora Bash was the inspiration for this script.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>An interview with Peteris Krumins</title>
      <link>http://localhost:1313/article/54/2013/12/18/An-interview-with-Peteris-Krumins/</link>
      <pubDate>Wed, 18 Dec 2013 03:47:38 +0000</pubDate>
      
      <guid>http://localhost:1313/article/54/2013/12/18/An-interview-with-Peteris-Krumins/</guid>
      <description>&lt;p&gt;&lt;em&gt;Peteris Krumins is a Perl author, start-up founder and all-around hacker. He also runs the popular blog CatOnMat.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You&amp;rsquo;re a really busy guy; running catonmat, Browserling and publishing books. What&amp;rsquo;s your secret?&lt;/strong&gt;
 I just work like crazy. It&amp;rsquo;s pretty much all I do! I&amp;rsquo;m a list person; one of my recent posts on catonmat was about how I work: I use Google Calendar to track the most important tasks; interviews, payments, important events, that kind of thing. Then I also use to-do lists, actually several to-do lists for each one of my projects - &lt;a href=&#34;http://www.browserling.com&#34;&gt;Browserling&lt;/a&gt;, &lt;a href=&#34;%0Ahttp://www.testling.com&#34;&gt;Testling&lt;/a&gt;, books, blog posts, a reading list, stuff like that. &lt;a href=&#34;http://www.catonmat.net/images/codeproject-interview/todo-list.jpg&#34;&gt;Here is an example&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;We&amp;rsquo;re talking because you&amp;rsquo;re famous for writing one liners in Perl. How did you get into that?&lt;/strong&gt;
 So there was this guy, Eric Pement and he collected hundreds of Awk one liners in this file &amp;ldquo;&lt;a href=&#34;http://www.pement.org/awk/awk1line.txt&#34;&gt;awk1line.txt&lt;/a&gt;&amp;rdquo; and he published it on UseNet, like 10 years ago. So I found his file and it was really interesting. I went through all of his one liners and learned Awk. Then I found that he had done the same thing for Sed (&lt;a href=&#34;http://www.pement.org/sed/sed1line.txt&#34;&gt;sed1line.txt&lt;/a&gt;) and I went through that and learned Sed. So that inspired me to create my own file for Perl, &lt;a href=&#34;http://www.catonmat.net/download/perl1line.txt&#34;&gt;perl1line.txt&lt;/a&gt; and it started from there.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I read that that your post &amp;ldquo;Perl One Liners Explained&amp;rdquo; has something like 500,000 hits?&lt;/strong&gt;
 It&amp;rsquo;s an article series made out of eight separate posts. It&amp;rsquo;s actually more like 800,000 now for all posts combined.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Wow! Was that an outlier for you, did it make you think there was a lot of interest in this topic?&lt;/strong&gt;
 Well I had already written perl1line.txt by then. I wrote eight blog posts following the structure used by Eric Pement in his files; for example he had a section called &amp;ldquo;How to do line spacing in Awk&amp;rdquo;, so I wrote one post called &amp;ldquo;How to do line spacing with Perl one liners&amp;rdquo; and so on.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Your Perl One Liners book was originally self-published, then picked up by No Starch Press. How did that happen?&lt;/strong&gt;
 It was amazing. I just got an email from Bill, who runs No Starch Press and he asked me if I wanted to turn my self-published book into a real book. And I said &amp;ldquo;yeah!&amp;rdquo; and we got it published. Here&amp;rsquo;s the result - &lt;a href=&#34;http://nostarch.com/perloneliners&#34;&gt;Perl One Liners book&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;The new No Starch Press version has 30+ more pages of content, did No Starch help you with that?&lt;/strong&gt;
 Yes, we took the original text and improved it mainly by adding more examples. We added examples for most of the one liners. And we also added a section about running Perl on Windows.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;I wanted to ask you about that. That seemed like a topic that hasn&amp;rsquo;t been well-covered elsewhere?&lt;/strong&gt;
 It was really hard to write. I had to test all of the one liners on PowerShell and the command line (cmd.exe) to make sure they worked, find all of the workarounds, handle special symbols, it was very challenging.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Was that a section that No Starch Press encouraged?&lt;/strong&gt;
 Not really. I run Windows as well, it&amp;rsquo;s my primary workstation although I do have a bunch of Linux servers which I ssh into. Sometimes I need to run Perl one liners on Windows, so I thought a lot of my readers would be interested in how to run the one liners on Windows as well. We spent about a month on that section, it delayed the book for about a month and a half, because of it. It was very challenging and hard to write but it should help a lot of Windows users as it&amp;rsquo;s probably the best guide to running Perl from the command line on Windows.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I thought a lot of my readers would be interested in how to run the one liners on Windows&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;Would you still use Unix tools over PowerShell on a Windows?&lt;/strong&gt;
 Well, I run Windows XP and don&amp;rsquo;t have PowerShell. I use Cygwin, but sometimes when I don&amp;rsquo;t want to use that, I just run bash.exe from &lt;a href=&#34;http://win-bash.sourceforge.net/&#34;&gt;win-bash&lt;/a&gt;. My setup is that I have Linux server mounted through Samba as a virtual drive. So if I have to do serious editing, I throw the file onto the shared drive and shh into my Linux server, so I don&amp;rsquo;t need to use the Linux tools on Windows that much.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Your book is full of interesting command line shortcuts and hidden features. Do you have a favourite one liner or code trick in Perl?&lt;/strong&gt;
 I love one liners that are like puzzles - you can&amp;rsquo;t understand them just by looking at them. You have to tinker around and try them out to see what it does. For example a regular expression like: &amp;ldquo;/[ -~]/&amp;rdquo; is fun, which matches every printable ASCII character from space to tilde.&lt;/p&gt;

&lt;p&gt;Another one liner which I like because it has no code in it is: &amp;ldquo;perl -00pe0&amp;rdquo;, for paragraph slurping.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;So how did you find out about that? I don&amp;rsquo;t think it&amp;rsquo;s even documented in perlrun.&lt;/strong&gt;
 I don&amp;rsquo;t know how I came up with this one. I remember something about being on the #perl freenode IRC channel. When I was writing the book I was often on there asking people for advice. Maybe someone told me about it or I found it myself, but it&amp;rsquo;s fun.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You&amp;rsquo;ve also written about Sed and Awk. If you know Perl one liners, do you need to learn Sed or Awk as well?&lt;/strong&gt;
 No, you don&amp;rsquo;t. But sometimes when you write a Perl one liner the equivalent one liner in Awk / Sed would be shorter. For example to reference the fifth word on a line in Awk it&amp;rsquo;s &amp;ldquo;$5&amp;rdquo; but in Perl it&amp;rsquo;s &amp;ldquo;$F[4]&amp;ldquo;, besides you&amp;rsquo;d have to turn on autosplitting and use a bunch of other command line arguments.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What text editor / IDE do you use to code in Perl?&lt;/strong&gt;
 I use Vim. I have a bunch of customizations and shortcuts that I use. I have an article series on my site called &amp;ldquo;&lt;a href=&#34;http://www.catonmat.net/series/vim-plugins-you-should-know-about&#34;&gt;Vim plugins you should know about&lt;/a&gt;&amp;rdquo; that covers this. One of my favourite plugins is &amp;ldquo;&lt;a href=&#34;http://www.catonmat.net/blog/vim-plugins-surround-vim/&#34;&gt;surround.vim&lt;/a&gt;&amp;rdquo; - if you have a single-quoted string and want to change them to double-quotes, you type: cs&amp;rsquo;&amp;rdquo; and it will change them. You can change parentheses and many other things that surround something. Another plugin I like is &amp;ldquo;&lt;a href=&#34;http://www.catonmat.net/blog/vim-plugins-matchit-vim/&#34;&gt;matchit.vim&lt;/a&gt;&amp;rdquo;, which extends the shift + F5 (%) parenthesis matching in Vim to match HTML tags and if/then/else statements and other constructs. Some of my other favorites are &amp;ldquo;&lt;a href=&#34;http://www.catonmat.net/blog/vim-plugins-snipmate-vim/%0A&#34;&gt;snipmate.vim&lt;/a&gt;&amp;rdquo; for code snippets, &amp;ldquo;&lt;a href=&#34;http://www.catonmat.net/blog/vim-plugins-ragtag-allml-vim/&#34;&gt;ragtag.vim&lt;/a&gt;&amp;rdquo; for working with HTML tags and &amp;ldquo;&lt;a href=&#34;http://www.catonmat.net/blog/vim-plugins-nerdtree-vim/&#34;&gt;nerd_tree.vim&lt;/a&gt;&amp;rdquo; for browsing files in vim.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What about color schemes, do you have a favourite?&lt;/strong&gt;
 I don&amp;rsquo;t really care about color schemes - Vim does color the code but I don&amp;rsquo;t change it. I also don&amp;rsquo;t care about programming fonts. The font just have to be constant width and that&amp;rsquo;s it.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;You&amp;rsquo;ve also written about EMACS before. Why do you stick with Vim over other tools?&lt;/strong&gt;
 I was working at this company once and I thought that from day one I would use EMACS (as a way of learning it) and see how it goes. After a few weeks I went back to Vim. I had to learn so many new key combinations it was hurting my productivity.&lt;/p&gt;

&lt;p&gt;When I&amp;rsquo;m programming in C and C++, I use Visual Studio. The best thing about using Visual Studio is if I forget a command or method, I can quickly look it up using IntelliSense.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Apart from one liners, do you develop Perl applications or modules?&lt;/strong&gt;
 Perl is my preferred programming language for writing quick tools, for example: uploading / downloading videos from YouTube, or parsing HTML pages. I&amp;rsquo;m incredibly fast at that and there are so many modules that can help - I wouldn&amp;rsquo;t be able to be that productive in other languages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;Have you used any Perl code analysis tools like Perl::Critic ?&lt;/strong&gt;
 I have used &lt;a href=&#34;https://metacpan.org/pod/Perl::Critic&#34;&gt;Perl::Critic&lt;/a&gt; but I don&amp;rsquo;t like it when someone criticizes my code! (even if it&amp;rsquo;s from Damian Conway&amp;rsquo;s Perl best practices book!) I just write sane code and apply most of the best practices. Other people usually don&amp;rsquo;t have problems with my code.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I have used Perl::Critic but I don&amp;rsquo;t like it when someone criticizes my code&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;You&amp;rsquo;re a real polyglot as apart from Perl, your Github page hosts projects in C++, JavaScript, Python, OCaml, PHP! Are there any features of those languages would you like to see in Perl?&lt;/strong&gt;
 It&amp;rsquo;s hard to take a feature from another language and put it into Perl as it&amp;rsquo;s already very expressive and supports many different programming paradigms. I often get asked this, but I don&amp;rsquo;t have a good answer! I&amp;rsquo;m very productive with Perl as it is, whereas I could definitely name features of Perl that I would like to see in other languages.&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;What about Perl versions, do you keep up to date?&lt;/strong&gt;
 Yeah, right now I&amp;rsquo;m using Perl 5.18 and that&amp;rsquo;s all thanks to &lt;a href=&#34;http://perlbrew.pl/&#34;&gt;Perlbrew&lt;/a&gt;. I remember a few years ago before I knew about Perlbrew it was huge pain to have several different Perl versions and I always had the system Perl and maybe one local version of Perl. Managing packages was a pain, too. Once I found out about Perlbrew, I installed every version of Perl, going back to 5.6. One cool feature is &amp;ldquo;perlbrew exec&amp;rdquo; which I used to test my one liners against every version of Perl to see which ones work and don&amp;rsquo;t.&lt;/p&gt;

&lt;blockquote&gt;
&lt;p&gt;I&amp;rsquo;m using Perl 5.18 and that&amp;rsquo;s all thanks to Perlbrew.&lt;/p&gt;
&lt;/blockquote&gt;

&lt;p&gt;&lt;strong&gt;What are your favourite Perl modules and tools?&lt;/strong&gt;
 I really like &lt;a href=&#34;https://metacpan.org/pod/Try::Tiny&#34;&gt;Try::Tiny&lt;/a&gt; for better exception handling, &lt;a href=&#34;https://metacpan.org/pod/File::Slurp&#34;&gt;File::Slurp&lt;/a&gt; for quickly working with files, &lt;a href=&#34;https://metacpan.org/pod/WWW::Mechanize&#34;&gt;WWW::Mechanize&lt;/a&gt; and [](https://metacpan.org/pod/HTML::TreeBuilder)HTML::TreeBuilder for scraping the web.&lt;/p&gt;

&lt;p&gt;Talking about tools I also like &lt;a href=&#34;https://metacpan.org/pod/Regexp::Debugger&#34;&gt;rxrx&lt;/a&gt; by Damian Conway (&lt;a href=&#34;http://www.youtube.com/watch?v=zcSFIUiMgAs&#34;&gt;here&amp;rsquo;s a demo at YAPC&lt;/a&gt;). It&amp;rsquo;s this interactive regexp debugger. Another tool that I use is &lt;a href=&#34;http://beyondgrep.com/&#34;&gt;ack&lt;/a&gt; that&amp;rsquo;s a better version of grep!&lt;/p&gt;

&lt;p&gt;&lt;strong&gt;And one last final question - what is it that you&amp;rsquo;re doing in your profile picture? Making a cigarette?&lt;/strong&gt;
 Haha, no! I&amp;rsquo;m actually holding a piece of scotch tape. I was making a raft that day from empty bottles so I was taping them together. It turned out to be a really good raft and it worked. &lt;a href=&#34;%0Ahttp://www.flickr.com/photos/pkrumins/11391256906/&#34;&gt;Here&amp;rsquo;s a photo.&lt;/a&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>The ultimate guide to Windows and Unix file line ending conversion in Perl </title>
      <link>http://localhost:1313/article/53/2013/12/14/The-ultimate-guide-to-Windows-and-Unix-file-line-ending-conversion-in-Perl-/</link>
      <pubDate>Sat, 14 Dec 2013 21:13:28 +0000</pubDate>
      
      <guid>http://localhost:1313/article/53/2013/12/14/The-ultimate-guide-to-Windows-and-Unix-file-line-ending-conversion-in-Perl-/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Most programmers know that the file line endings used by Windows and Unix-based systems are different. Windows uses CRLF and the Unix-based systems use LF. So fixing this is in Perl requires a simple substitution regex right? Not so fast &amp;hellip;&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;requirements&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;You must be using Perl version 5.14 or greater.&lt;/p&gt;

&lt;h3 id=&#34;conversion-on-unix-based-systems&#34;&gt;Conversion on Unix-based systems&lt;/h3&gt;

&lt;p&gt;These are easy. To convert a file to Unix-style line endings (as used by Linux, BSD, OSX) just open up the terminal and run:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;pi&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;bak &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;e &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;s/\R/\012/&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;file&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code works by replacing any line break characters (&amp;rdquo;\R&amp;rdquo;) with a single line feed character (&amp;rdquo;\012&amp;rdquo;). The &amp;ldquo;\R&amp;rdquo; meta-character is available in Perl from version 5.10 onwards, it&amp;rsquo;s useful because it will even work for files with mixed line ending styles. The in-place switch (&amp;ldquo;i&amp;rdquo;) creates a backup of the original file with the extension &amp;ldquo;.bak&amp;rdquo;. To convert a file from Unix to Windows-style line endings, use this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;pi&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;bak &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;e &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;s/\R/\015\012/&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;file&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This replaces any vertical character with the CRLF (&amp;rdquo;\015\012&amp;rdquo;) line ending used by Windows. Again, this will also work for files with a mix of Unix and Windows line endings.&lt;/p&gt;

&lt;h3 id=&#34;conversion-on-windows&#34;&gt;Conversion on Windows&lt;/h3&gt;

&lt;p&gt;Things are trickier on Windows; there are a few things to be aware of:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;By default Perl changes the value of &amp;ldquo;\n&amp;rdquo; to CRLF. This means that the regex match: &amp;ldquo;/\015\012/&amp;rdquo; will fail on Windows as Perl is actually running: &amp;ldquo;/\015\015\012/&amp;ldquo;. Regexes using meta-characters and hex codes (&amp;rdquo;/\r\n/&amp;rdquo; and &amp;ldquo;/\x0d\x0a/&amp;ldquo;) fail for the same reason.&lt;/li&gt;
&lt;li&gt;Single-quotes must be replaced with double-quotes to enclose the code in &amp;ldquo;e&amp;rdquo; and quoting operators must be used when single quotes are required within the code (e.g. &amp;ldquo;q||&amp;rdquo;)&lt;/li&gt;
&lt;li&gt;The in-place switch (&amp;ldquo;i&amp;rdquo;) works, but any extension (e.g. &amp;ldquo;.bak&amp;rdquo;) will change the file ending and the default programs associated with it. The examples below use alternative methods.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you&amp;rsquo;re using cmd.exe or PowerShell the following Perl one liner will convert a file to Windows-style line endings:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;pe &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;binmode(STDOUT);s/\R/\015\012/&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#e6db74&#34;&gt;/file &amp;gt; /&lt;/span&gt;path&lt;span style=&#34;color:#e6db74&#34;&gt;/to/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;file&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The main differences here are: replacing single-quotes with double-quotes, &amp;ldquo;binmode(STDOUT)&amp;rdquo; to turn off Perl&amp;rsquo;s CRLF line endings and the use of redirect &amp;ldquo;&amp;gt;&amp;rdquo; to write the contents to a different file, instead of using the in-place switch. To convert a file to Unix-style line endings on cmd.exe this will work:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;pe &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;binmode(STDOUT);s/\R/\012/&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#e6db74&#34;&gt;/file &amp;gt; /&lt;/span&gt;path&lt;span style=&#34;color:#e6db74&#34;&gt;/to/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;file&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On PowerShell a few more changes are required. To convert to Unix-style line endings use:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;ne&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;open(OUT, q(&amp;gt;&amp;gt;), q(/path/to/new/file));binmode(OUT);print OUT s/\R/\012/r&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;file&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;So what just happened there? First of all we changed the command line switch &amp;ldquo;p&amp;rdquo; to &amp;ldquo;n&amp;rdquo;. This stops Perl from printing every line it processes to standard output. Instead we opened an appending filehandle &amp;ldquo;OUT&amp;rdquo; to our output file and printed the result ourselves. The reason we had to do this was that PowerShell automatically interprets standard output as Unicode and replaces Unix-style endings with Windows CRLF endings. Hence using the re-direct method (&amp;rdquo;&amp;gt;&amp;rdquo;) does not work. And before you try, piping the output like this generates an error:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;pe &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;binmode(STDOUT);s/\R/\012/r&amp;#34;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#e6db74&#34;&gt;/file | set-content /&lt;/span&gt;path&lt;span style=&#34;color:#e6db74&#34;&gt;/to/&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;file &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;Encoding Byte&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;We also had to use the quoting operator (&amp;ldquo;q()&amp;rdquo;) to quote our content instead of using single quotes. Finally, the substitution regex (&amp;ldquo;s/\R/\012/&amp;ldquo;) was changed to use the &amp;ldquo;r&amp;rdquo; modifier, which returns the result of the substitution without modifying the original variable. This feature is available from Perl version 5.14 onwards.&lt;/p&gt;

&lt;h3 id=&#34;further-reading&#34;&gt;Further Reading&lt;/h3&gt;

&lt;p&gt;Perl&amp;rsquo;s offical documentation &amp;ldquo;perlrun&amp;rdquo; entry has a lot of detail on Perl&amp;rsquo;s command line switches. Access it &lt;a href=&#34;https://perldoc.perl.org/perlrun.html&#34;&gt;online&lt;/a&gt; or at the command line by typing: &amp;ldquo;perldoc perlrun&amp;rdquo;&lt;/p&gt;

&lt;p&gt;Peteris Krummins&amp;rsquo; &lt;a href=&#34;http://www.catonmat.net/&#34;&gt;website&lt;/a&gt; provides loads of Perl one liners. His new book &lt;a href=&#34;http://www.amazon.com/gp/product/159327520X/ref=as_li_qf_sp_asin_tl?ie=UTF8&amp;amp;camp=1789&amp;amp;creative=9325&amp;amp;creativeASIN=159327520X&amp;amp;linkCode=as2&amp;amp;tag=perltrickscom-20&#34;&gt;Perl One-Liners: 130 Programs That Get Things Done&lt;/a&gt; has just been published (affiliate link). It contains many useful one liners, but also 9 pages of detailed guidance on running one liners on Windows - highly recommended!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>How to redirect and restore STDOUT</title>
      <link>http://localhost:1313/article/45/2013/10/27/How-to-redirect-and-restore-STDOUT/</link>
      <pubDate>Sun, 27 Oct 2013 17:48:34 +0000</pubDate>
      
      <guid>http://localhost:1313/article/45/2013/10/27/How-to-redirect-and-restore-STDOUT/</guid>
      <description>

&lt;p&gt;STDOUT is the Perl filehandle for printing standard output. Unless a filehandle is specified, all standard printed output in Perl will go to the terminal. Because STDOUT is just a global variable, it can be redirected and restored. Want to implement logging on a program without changing every print statement in the source code? Want to capture the standard output of a perl CRON job? Read on.&lt;/p&gt;

&lt;h3 id=&#34;terminal-redirects&#34;&gt;Terminal redirects&lt;/h3&gt;

&lt;p&gt;Before you launch your favourite text editor and start hacking Perl code, you may just need to redirect the program output in the terminal. On UNIX-based systems you can write to a file using &amp;ldquo;&amp;gt;&amp;rdquo; and append to a file using &amp;ldquo;&amp;gt;&amp;gt;&amp;rdquo;. Both write and append will create the file if it doesn&amp;rsquo;t exist.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;perl program&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pl &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;log&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;txt
perl program&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pl &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;log&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;txt&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;On Windows a similar effect can be achieved using PowerShell using a pipe operator (&amp;ldquo;|&amp;rdquo;) and &amp;ldquo;set-content&amp;rdquo; to write, or &amp;ldquo;add-content&amp;rdquo; to append (the pipe will not redirect STDERR).&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;perl program&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pl &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; set&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;content &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;log&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;txt
perl program&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pl &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; add&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;content &lt;span style=&#34;color:#e6db74&#34;&gt;/path/&lt;/span&gt;to&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;log&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;txt&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;perl-solutions&#34;&gt;Perl solutions&lt;/h3&gt;

&lt;p&gt;If a terminal redirect is not specific enough for your needs, you can use one of the following Perl solutions. All of the following solutions use &lt;a href=&#34;https://metacpan.org/pod/autodie&#34;&gt;autodie&lt;/a&gt; which removes the need for the classic &amp;ldquo;|| or die $!&amp;rdquo; syntax to be appended to every open statement in the code.&lt;/p&gt;

&lt;h3 id=&#34;redirect-stdout-using-select&#34;&gt;Redirect STDOUT using select&lt;/h3&gt;

&lt;p&gt;Perl&amp;rsquo;s built-in function &lt;a href=&#34;https://perldoc.perl.org/functions/select.html&#34;&gt;select&lt;/a&gt; changes the standard output filehandle to the filehandle provided as an argument. This makes it easy to globally redirect and restore standard output.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; autodie;

&lt;span style=&#34;color:#75715e&#34;&gt;# open filehandle log.txt&lt;/span&gt;
open (&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $LOG, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;gt;&amp;gt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;log.txt&amp;#39;&lt;/span&gt;);

&lt;span style=&#34;color:#75715e&#34;&gt;# select new filehandle&lt;/span&gt;
select $LOG;

say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;This should be logged.&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;# restore STDOUT&lt;/span&gt;
select STDOUT;

say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;This should show in the terminal&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;redirect-stdout-using-local&#34;&gt;Redirect STDOUT using local&lt;/h3&gt;

&lt;p&gt;Perl&amp;rsquo;s &lt;a href=&#34;https://perldoc.perl.org/functions/local.html&#34;&gt;local&lt;/a&gt; built-in function is another option for redirecting STDOUT. The local function creates a lexically-scoped copy of any variable passed to it. By enclosing local in a do block, the code below limits the STDOUT redirect to the block scope and STDOUT is automatically restored after the closing block brace (&amp;ldquo;}&amp;rdquo;). By definition this is not a global solution for redirecting STDOUT.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; autodie;

&lt;span style=&#34;color:#66d9ef&#34;&gt;do&lt;/span&gt; {
    local &lt;span style=&#34;color:#f92672&#34;&gt;*&lt;/span&gt;STDOUT;

    &lt;span style=&#34;color:#75715e&#34;&gt;# redirect STDOUT to log.txt&lt;/span&gt;
    open (STDOUT, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;gt;&amp;gt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;log.txt&amp;#39;&lt;/span&gt;);

    say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;This should be logged.&amp;#39;&lt;/span&gt;;
};
say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;This should show in the terminal&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;redirect-stdout-using-a-filehandle&#34;&gt;Redirect STDOUT using a filehandle&lt;/h3&gt;

&lt;p&gt;A third way to redirect and restore STDOUT is to copy the STDOUT filehandle before replacing it. This copy can then be restored when required. As with select, this will have a global affect on the Perl program.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; feature &lt;span style=&#34;color:#e6db74&#34;&gt;qw/say/&lt;/span&gt;;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; autodie;

&lt;span style=&#34;color:#75715e&#34;&gt;# copy STDOUT to another filehandle&lt;/span&gt;
open (&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $STDOLD, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;gt;&amp;amp;&amp;#39;&lt;/span&gt;, STDOUT);

&lt;span style=&#34;color:#75715e&#34;&gt;# redirect STDOUT to log.txt&lt;/span&gt;
open (STDOUT, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;gt;&amp;gt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;log.txt&amp;#39;&lt;/span&gt;);

say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;This should be logged.&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#75715e&#34;&gt;# restore STDOUT&lt;/span&gt;
open (STDOUT, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;gt;&amp;amp;&amp;#39;&lt;/span&gt;, $STDOLD);

say &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;This should show in the terminal&amp;#39;&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Run local Perl as root</title>
      <link>http://localhost:1313/article/36/2013/8/10/Run-local-Perl-as-root/</link>
      <pubDate>Sat, 10 Aug 2013 14:33:18 +0000</pubDate>
      
      <guid>http://localhost:1313/article/36/2013/8/10/Run-local-Perl-as-root/</guid>
      <description>&lt;p&gt;This is a simple trick for conveniently running local Perl as a root user on UNIX-based systems.&lt;/p&gt;

&lt;p&gt;Occasionally it&amp;rsquo;s necessary to run locally-installed Perl as root. However at the command line if you type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;sudo perl program&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pl&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By default the Perl that is executed is the system Perl binary. This can be problematic as the System Perl may not have the modules required, or even be the correct version of Perl that you need to run. An easy fix for this is to use the which command:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;sudo $&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;(&lt;/span&gt;which perl) program&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pl&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;By nesting which between a dollar sign parentheses, the terminal will resolve the command first, which returns a string to the local Perl binary. Sudo then operates on this binary instead of the system Perl binary. You can prove this with the following terminal commands:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;which perl
&lt;span style=&#34;color:#e6db74&#34;&gt;/home/si&lt;/span&gt;llymoose&lt;span style=&#34;color:#e6db74&#34;&gt;/perl5/&lt;/span&gt;perlbrew&lt;span style=&#34;color:#e6db74&#34;&gt;/perls/&lt;/span&gt;perl&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5.16.3&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/bin/&lt;/span&gt;perl

sudo which perl
&lt;span style=&#34;color:#e6db74&#34;&gt;/bin/&lt;/span&gt;perl

sudo echo $&lt;span style=&#34;color:#960050;background-color:#1e0010&#34;&gt;(&lt;/span&gt;which perl)
&lt;span style=&#34;color:#e6db74&#34;&gt;/home/si&lt;/span&gt;llymoose&lt;span style=&#34;color:#e6db74&#34;&gt;/perl5/&lt;/span&gt;perlbrew&lt;span style=&#34;color:#e6db74&#34;&gt;/perls/&lt;/span&gt;perl&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5.16.3&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/bin/&lt;/span&gt;perl&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>3 quick ways to find out the version number of an installed Perl module from the terminal</title>
      <link>http://localhost:1313/article/1/2013/3/24/3-quick-ways-to-find-out-the-version-number-of-an-installed-Perl-module-from-the-terminal/</link>
      <pubDate>Sun, 24 Mar 2013 17:30:19 +0000</pubDate>
      
      <guid>http://localhost:1313/article/1/2013/3/24/3-quick-ways-to-find-out-the-version-number-of-an-installed-Perl-module-from-the-terminal/</guid>
      <description>

&lt;p&gt;Perl module features and behaviour can change from version to version and so knowing the version number of an installed Perl module can be useful in several scenarios. Below are three different command line methods for finding out the version number of an installed module that work on Bash and Windows Powershell. So fire up the terminal and get typing!&lt;/p&gt;

&lt;h3 id=&#34;1-use-cpan-with-the-d-flag&#34;&gt;1. Use CPAN with the -D flag&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;cpan &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;D Moose&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Type the code above into the terminal replacing &amp;lsquo;Moose&amp;rsquo; with the Perl module name of your choice (in the typical Perl format of Namespace::ModuleName, e.g. Catalyst::Runtime). CPAN will report the module&amp;rsquo;s version, installed location, the latest version number available on CPAN, and whether the locally installed version of the module is up to date or not. The resulting output looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;D&lt;span style=&#34;color:#e6db74&#34;&gt;/DO/&lt;/span&gt;DOY&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;Moose&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2.0604&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;tar&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;gz
&lt;span style=&#34;color:#e6db74&#34;&gt;/home/si&lt;/span&gt;llymoose&lt;span style=&#34;color:#e6db74&#34;&gt;/perl5/&lt;/span&gt;perlbrew&lt;span style=&#34;color:#e6db74&#34;&gt;/perls/&lt;/span&gt;perl&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;5.14.2&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;/lib/si&lt;/span&gt;te_perl&lt;span style=&#34;color:#e6db74&#34;&gt;/5.14.2/x&lt;/span&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;86_64&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;linux&lt;span style=&#34;color:#f92672&#34;&gt;/&lt;/span&gt;Moose&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;pm
Installed: &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0603&lt;/span&gt;
CPAN:      &lt;span style=&#34;color:#ae81ff&#34;&gt;2.0604&lt;/span&gt;  Not up to date
Jesse Luehrs (DOY)
doy@cpan&lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt;org&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;2-use-a-perl-one-liner-to-load-and-print-the-module-version-number&#34;&gt;2. Use a Perl one-liner to load and print the module version number&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;perl &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;MMoose &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;e &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;print $Moose::VERSION .&amp;#34;\n&amp;#34;;&amp;#39;&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This command loads the module with Perl&amp;rsquo;s -M flag, and then prints the version variable. This should always be available under $MODULENAME::VERSION. Using a one-liner avoids the need to use CPAN, plus it neatly returns only the version number, which can easily be used for further processing:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#ae81ff&#34;&gt;2.0603&lt;/span&gt;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;3-use-perldoc-with-the-m-flag-to-load-the-module-s-source-code-and-extract-the-version-number&#34;&gt;3. Use Perldoc with the -m flag to load the module&amp;rsquo;s source code and extract the version number.&lt;/h3&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;# If you are using Bash:&lt;/span&gt;
perldoc &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;m Moose &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; grep VERSION

&lt;span style=&#34;color:#75715e&#34;&gt;# If you are using Powershell:&lt;/span&gt;
perldoc &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;m Moose &lt;span style=&#34;color:#f92672&#34;&gt;|&lt;/span&gt; select&lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt;string VERSION&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Admittedly somewhat of a hack, but this will usually work. Don&amp;rsquo;t forget to replace Moose with the module name you are searching for.The output can be a messy, but you can usually locate the version number. This is a good option if methods 1 and 2 above do not work.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$Moose::VERSION &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;2.0603&amp;#39;&lt;/span&gt;;
die &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Class::MOP version $Moose::VERSION required--this is version $Class::MOP::VERSION&amp;#34;&lt;/span&gt;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; $Moose::VERSION &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; $Class::MOP::VERSION &lt;span style=&#34;color:#f92672&#34;&gt;ne&lt;/span&gt; $Moose::VERSION;
&lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;head1 VERSION&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

