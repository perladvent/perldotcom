<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Perl 6 Apocalypse Subroutines on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/perl-6-apocalypse-subroutines/</link>
    <description>Recent content in Perl 6 Apocalypse Subroutines on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Fri, 07 Mar 2003 00:00:00 -0800</lastBuildDate>
    <atom:link href="/tags/perl-6-apocalypse-subroutines/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>Apocalypse 6</title>
      <link>http://localhost:1313/pub/2003/03/07/apocalypse6.html/</link>
      <pubDate>Fri, 07 Mar 2003 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2003/03/07/apocalypse6.html/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is the Apocalypse on Subroutines. In Perl culture the term &amp;ldquo;subroutine&amp;rdquo; conveys the general notion of calling something that returns control automatically when it&amp;rsquo;s done. This &amp;ldquo;something&amp;rdquo; that you&amp;rsquo;re calling may go by a more specialized name such as &amp;ldquo;procedure&amp;rdquo;, &amp;ldquo;function&amp;rdquo;, &amp;ldquo;closure&amp;rdquo;, or &amp;ldquo;method&amp;rdquo;. In Perl 5, all such subroutines were declared using the keyword &lt;code&gt;sub&lt;/code&gt; regardless of their specialty. For readability, Perl 6 will use alternate keywords to declare special subroutines, but they&amp;rsquo;re still essentially the same thing underneath. Insofar as they all behave similarly, this Apocalypse will have something to say about them. (And if we also leak a few secrets about how method calls work, that will make Apocalypse 12 all the easier&amp;ndash;presuming we don&amp;rsquo;t have to un-invent anything between now and then&amp;hellip;)&lt;/p&gt;

&lt;p&gt;Here are the RFCs covered in this Apocalypse. PSA stands for &amp;ldquo;problem, solution, acceptance&amp;rdquo;, my private rating of how this RFC will fit into Perl 6. I note that none of the RFCs achieved unreserved acceptance this time around. Maybe I&amp;rsquo;m getting picky in my old age. Or maybe I just can&amp;rsquo;t incorporate anything into Perl without &amp;ldquo;marking&amp;rdquo; it&amp;hellip;&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    RFC   PSA   Title
    ---   ---   -----
     21   abc   Subroutines: Replace C&amp;lt;wantarray&amp;gt; with a generic C&amp;lt;want&amp;gt;
                   function
     23   bcc   Higher order functions
     57   abb   Subroutine prototypes and parameters
     59   bcr   Proposal to utilize C&amp;lt;*&amp;gt; as the prefix to magic subroutines
     75   dcr   structures and interface definitions
    107   adr   lvalue subs should receive the rvalue as an argument
    118   rrr   lvalue subs: parameters, explicit assignment, and wantarray()
                   changes
    128   acc   Subroutines: Extend subroutine contexts to include name
                   parameters and lazy arguments
    132   acr   Subroutines should be able to return an lvalue
    149   adr   Lvalue subroutines: implicit and explicit assignment
    154   bdr   Simple assignment lvalue subs should be on by default
    160   acc   Function-call named parameters (with compiler optimizations)
    168   abb   Built-in functions should be functions
    176   bbb   subroutine / generic entity documentation
    194   acc   Standardise Function Pre- and Post-Handling
    271   abc   Subroutines : Pre- and post- handlers for subroutines
    298   cbc   Make subroutines&#39; prototypes accessible from Perl
    334   abb   Perl should allow specially attributed subs to be called as C
                   functions
    344   acb   Elements of @_ should be read-only by default
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In Apocalypses 1 through 4, I used the RFCs as a springboard for discussion. In Apocalypse 5 I was forced by the complexity of the redesign to switch strategies and present the RFCs after a discussion of all the issues involved. That was so well received that I&amp;rsquo;ll try to follow the same approach with this and subsequent Apocalypses.&lt;/p&gt;

&lt;p&gt;But this Apocalypse is not trying to be as radical as the one on regexes. Well, okay, it is, and it isn&amp;rsquo;t. Alright, it &lt;em&gt;is&lt;/em&gt; radical, but you&amp;rsquo;ll like it anyway (we hope). At least the old way of calling subroutines still works. Unlike regexes, Perl subroutines don&amp;rsquo;t have a lot of historical cruft to get rid of. In fact, the basic problem with Perl 5&amp;rsquo;s subroutines is that they&amp;rsquo;re not crufty enough, so the cruft leaks out into user-defined code instead, by the Conservation of Cruft Principle. Perl 6 will let you migrate the cruft out of the user-defined code and back into the declarations where it belongs. Then you will think it to be very beautiful cruft indeed (we hope).&lt;/p&gt;

&lt;p&gt;Perl 5&amp;rsquo;s subroutines have a number of issues that need to be dealt with. First of all, they&amp;rsquo;re just awfully slow, for various reasons:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Construction of the &lt;code&gt;@_&lt;/code&gt; array&lt;/li&gt;
&lt;li&gt;Needless prepping of potential lvalues&lt;/li&gt;
&lt;li&gt;General model that forces lots of run-time processing&lt;/li&gt;
&lt;li&gt;Difficulty of optimization&lt;/li&gt;
&lt;li&gt;Storage of unneeded context&lt;/li&gt;
&lt;li&gt;Lack of tail recursion optimization&lt;/li&gt;
&lt;li&gt;Named params that aren&amp;rsquo;t really&lt;/li&gt;
&lt;li&gt;Object model that forces double dispatch in some cases&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Quite apart from performance, however, there are a number of problems with usability:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Not easy to detect type errors at compile time&lt;/li&gt;
&lt;li&gt;Not possible to specify the signatures of certain built-in functions&lt;/li&gt;
&lt;li&gt;Not possible to define control structures as subroutines&lt;/li&gt;
&lt;li&gt;Not possible to type-check any variadic args other than as a list&lt;/li&gt;
&lt;li&gt;Not possible to have a variadic list providing scalar context to its elements&lt;/li&gt;
&lt;li&gt;Not possible to have lazy parameters&lt;/li&gt;
&lt;li&gt;Not possible to define immediate subroutines (macros)&lt;/li&gt;
&lt;li&gt;Not possible to define subroutines with special syntax&lt;/li&gt;
&lt;li&gt;Not enough contextual information available at run time.&lt;/li&gt;
&lt;li&gt;Not enough contextual information available at compile time.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;In general, the consensus is that Perl 5&amp;rsquo;s simple subroutine syntax is just a little &lt;em&gt;too&lt;/em&gt; simple. Well, okay, it&amp;rsquo;s a &lt;em&gt;lot&lt;/em&gt; too simple. While it&amp;rsquo;s extremely orthogonal to always pass all arguments as a single variadic array, that mechanism does not always map well onto the problem space. So in Perl 6, subroutine syntax has blossomed in several directions.&lt;/p&gt;

&lt;p&gt;But the most important thing to note is that we haven&amp;rsquo;t actually added a lot of syntax. We&amp;rsquo;ve added some, but most of new capabilities come in through the generalized trait/property system, and the new type system. But in those cases where specialized syntax buys us clarity, we have not hesitated to add it. (Er, actually, we hesitated quite a lot. Months, in fact.)&lt;/p&gt;

&lt;p&gt;One obvious difference is that the &lt;code&gt;sub&lt;/code&gt; on closures is now optional, since every brace-delimited block is now essentially a closure. You can still put the &lt;code&gt;sub&lt;/code&gt; if you like. But it is only required if the block would otherwise be construed as a hash value; that is, if it appears to contain a list of pairs. You can force any block to be considered a subroutine with the &lt;code&gt;sub&lt;/code&gt; keyword; likewise you can force any block to be considered a hash value with the &lt;code&gt;hash&lt;/code&gt; keyword. But in general Perl just dwims based on whether the top-level is a list that happens to have a first argument that is a pair or hash:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Block               Meaning
    -----               -------
    { 1 =&amp;gt; 2 }          hash { 1 =&amp;gt; 2 }
    { 1 =&amp;gt; 2, 3 =&amp;gt; 4 }  hash { 1 =&amp;gt; 2, 3 =&amp;gt; 4 }
    { 1 =&amp;gt; 2, 3, 4 }    hash { 1 =&amp;gt; 2, 3 =&amp;gt; 4 }
    { %foo, 1 =&amp;gt; 2 }    hash { %foo.pairs, 1 =&amp;gt; 2 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Anything else that is not a list, or does not start with a pair or hash, indicates a subroutine:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { 1 }               sub { return 1 }
    { 1, 2 }            sub { return 1, 2 }
    { 1, 2, 3 }         sub { return 1, 2, 3 }
    { 1, 2, 3 =&amp;gt; 4 }    sub { return 1, 2, 3 =&amp;gt; 4 }
    { pair 1,2,3,4 }    sub { return 1 =&amp;gt; 2, 3 =&amp;gt; 4 }
    { gethash() }       sub { return gethash() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is a syntactic distinction, not a semantic one. That last two examples are taken to be subs despite containing functions returning pairs or hashes. Note that it would save no typing to recognize the &lt;code&gt;pair&lt;/code&gt; method specially, since &lt;code&gt;hash&lt;/code&gt; automatically does pairing of non-pairs. So we distinguish these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { pair 1,2,3,4 }    sub { return 1 =&amp;gt; 2, 3 =&amp;gt; 4 }
    hash { 1,2,3,4 }    hash { 1 =&amp;gt; 2, 3 =&amp;gt; 4 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you&amp;rsquo;re worried about the compiler making bad choices before deciding whether it&amp;rsquo;s a subroutine or hash, you shouldn&amp;rsquo;t. The two constructs really aren&amp;rsquo;t all that far apart. The &lt;code&gt;hash&lt;/code&gt; keyword could in fact be considered a function that takes as its first argument a closure returning a hash value list. So the compiler might just compile the block as a closure in either case, then do the obvious optimization.&lt;/p&gt;

&lt;p&gt;Although we say the &lt;code&gt;sub&lt;/code&gt; keyword is now optional on a closure, the &lt;code&gt;return&lt;/code&gt; keyword only works with an explicit &lt;code&gt;sub&lt;/code&gt;. (There are other ways to return values from a block.)&lt;/p&gt;

&lt;h2 id=&#34;span-id-subroutine-declarations-subroutine-declarations-span&#34;&gt;&lt;span id=&#34;subroutine_declarations&#34;&gt;Subroutine Declarations&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;You may still declare a sub just as you did in Perl 5, in which case it behaves much like it did in Perl 5. To wit, the arguments still come in via the &lt;code&gt;@_&lt;/code&gt; array. When you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo { print @_ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;that is just syntactic sugar for this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo (*@_) { print @_ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, Perl 6 will supply a default parameter signature (the precise meaning of which will be explained below) that makes the subroutine behave much as a Perl 5 programmer would expect, with all the arguments in &lt;code&gt;@_&lt;/code&gt;. It is not exactly the same, however. You may not modify the arguments via &lt;code&gt;@_&lt;/code&gt; without declaring explicitly that you want to do so. So in the rare cases that you want to do that, you&amp;rsquo;ll have to supply the &lt;code&gt;rw&lt;/code&gt; trait (meaning the arguments should be considered &amp;ldquo;read-write&amp;rdquo;):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub swap (*@_ is rw) { @_[0,1] = @_[1,0] };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The Perl5-to-Perl6 translator will try to catch those cases and add the parameter signature for you when you want to modify the arguments. (Note: we will try to be consistent about using &amp;ldquo;arguments&amp;rdquo; to mean the actual values you pass to the function when you call it, and &amp;ldquo;parameters&amp;rdquo; to mean the list of lexical variables declared as part of the subroutine signature, through which you access the values that were passed to the subroutine.)&lt;/p&gt;

&lt;p&gt;Perl 5 has rudimentary prototypes, but Perl 6 type signatures can be much more expressive if you want them to be. The entire declaration is much more flexible. Not only can you declare types and names of individual parameters, you can add various traits to the parameters, such as &lt;code&gt;rw&lt;/code&gt; above. You can add traits to the subroutine itself, and declare the return type. In fact, at some level or other, the subroutine&amp;rsquo;s signature and return type are also just traits. You might even consider the body of the subroutine to be a trait.&lt;/p&gt;

&lt;p&gt;For those of you who have been following Perl 6 development, you&amp;rsquo;ll wonder why we&amp;rsquo;re now calling these &amp;ldquo;traits&amp;rdquo; rather than &amp;ldquo;properties&amp;rdquo;. They&amp;rsquo;re all really still properties under the hood, but we&amp;rsquo;re trying to distinguish those properties that are expected to be set on containers at compile time from those that are expected to be set on values at run time. So compile-time properties are now called &amp;ldquo;traits&amp;rdquo;. Basically, if you declare it with &lt;code&gt;is&lt;/code&gt;, it&amp;rsquo;s a trait, and if you add it onto a value with &lt;code&gt;but&lt;/code&gt;, it&amp;rsquo;s a property. The main reason for making the distinction is to keep the concepts straight in people&amp;rsquo;s minds, but it also has the nice benefit of telling the optimizer which properties are subject to change, and which ones aren&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;A given trait may or may not be implemented as a method on the underlying container object. You&amp;rsquo;re not supposed to care.&lt;/p&gt;

&lt;p&gt;There are actually several syntactic forms of trait:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule trait :w {
          is &amp;lt;ident&amp;gt;[\( &amp;lt;traitparam&amp;gt; \)]?
        | will &amp;lt;ident&amp;gt; &amp;lt;closure&amp;gt;
        | of &amp;lt;type&amp;gt;
        | returns &amp;lt;type&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(We&amp;rsquo;re specifying the syntax here using Perl 6 regexes. If you don&amp;rsquo;t know about those, go back and read Apocalypse 5.)&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;&amp;lt;type&amp;gt;&lt;/code&gt; is actually allowed to be a junction of types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo returns Int|Str {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;will&lt;/code&gt; syntax specifically introduces a closure trait without requiring the extra parens that &lt;code&gt;is&lt;/code&gt; would. Saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    will flapdoodle { flap() and doodle() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is exactly equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    is flapdoodle({ flap() and doodle() })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but reads a little better. More typically you&amp;rsquo;ll see traits like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    will first { setup() }
    will last { teardown() }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The final block of a subroutine declaration is the &amp;ldquo;do&amp;rdquo; trait. Saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is like saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo will do { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note however that the closure eventually stored under the &lt;code&gt;do&lt;/code&gt; trait may in fact be modified in various ways to reflect argument processing, exception handling, and such.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll discuss the &lt;code&gt;of&lt;/code&gt; and &lt;code&gt;returns&lt;/code&gt; traits later when we discuss types. Back to syntax.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-the-sub-form-the-sub-form-span&#34;&gt;&lt;span id=&#34;the_sub_form&#34;&gt;The &lt;code&gt;sub&lt;/code&gt; form&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A subroutine can be declared as lexically scoped, package scoped, or unscoped:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule lexicalsub :w {
        &amp;lt;lexscope&amp;gt; &amp;lt;type&amp;gt;?
        &amp;lt;subintro&amp;gt; &amp;lt;subname&amp;gt; &amp;lt;psignature&amp;gt;?
        &amp;lt;trait&amp;gt;*
        &amp;lt;block&amp;gt;
    }

    rule packagesub :w {
        &amp;lt;subintro&amp;gt; &amp;lt;subname&amp;gt; &amp;lt;psignature&amp;gt;?
        &amp;lt;trait&amp;gt;*
        &amp;lt;block&amp;gt;
    }

    rule anonsub :w {
        &amp;lt;subintro&amp;gt; &amp;lt;psignature&amp;gt;?
        &amp;lt;trait&amp;gt;*
        &amp;lt;block&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The non-lexically scoped declaration cannot specify a return type in front. The return type can only be specified as a trait in that case.&lt;/p&gt;

&lt;p&gt;As in Perl 5, the difference between a package sub and an anonymous sub depends on whether you specify the &lt;code&gt;&amp;lt;subname&amp;gt;&lt;/code&gt;. If omitted, the declaration (which is not really a declaration in that case) generates and returns a closure. (Which may not &lt;em&gt;really&lt;/em&gt; be a closure if it doesn&amp;rsquo;t access any external lexicals, but we call them all closures anyway just in case&amp;hellip;)&lt;/p&gt;

&lt;p&gt;A lexical subroutine is declared using either &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;our&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule lexscope { my | our }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This list doesn&amp;rsquo;t include &lt;code&gt;temp&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; because those are not declarators of lexical scope but rather operators that initiate dynamic scoping. See the section below on Lvalue subroutines for more about &lt;code&gt;temp&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;In both lexical and package declarations, the name of the subroutine is introduced by the keyword &lt;code&gt;sub&lt;/code&gt;, or one of its variants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule subintro { sub | method | submethod | multi | rule | macro }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A &lt;code&gt;method&lt;/code&gt; participates in inheritance and always has an invocant (object or class). A &lt;code&gt;submethod&lt;/code&gt; has an invocant but does not participate in inheritance. It&amp;rsquo;s a sub pretending to be a method for the current class only. A &lt;code&gt;multi&lt;/code&gt; is a multimethod, that is, a method that called like a subroutine or operator, but is dispatched based on the types of one or more of its arguments.&lt;/p&gt;

&lt;p&gt;Another variant is the regex &lt;code&gt;rule&lt;/code&gt;, which is really a special kind of method; but in actuality rules probably get their own set of parse rules, since the body of a rule is a regex. I just put &amp;ldquo;rule&amp;rdquo; into &amp;lt;subintro&amp;gt; as a placeholder of sorts, because I&amp;rsquo;m lazy.&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;macro&lt;/code&gt; is a subroutine that is called immediately upon completion of parsing. It has a default means of parsing arguments, or it may be bound to an alternate grammar rule to parse its arguments however you like.&lt;/p&gt;

&lt;p&gt;These syntactic forms correspond the various &lt;code&gt;Routine&lt;/code&gt; types in the &lt;code&gt;Code&lt;/code&gt; type hierarchy:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;                                   Code
                        ____________|________________
                       |                             |
                    Routine                        Block
       ________________|_______________            __|___
      |     |       |       |    |     |          |      |
     Sub Method Submethod Multi Rule Macro      Bare Parametric
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;Routine&lt;/code&gt;/&lt;code&gt;Block&lt;/code&gt; distinction is fairly important, since you always &lt;code&gt;return&lt;/code&gt; out of the current &lt;code&gt;Routine&lt;/code&gt;, that is, the current &lt;code&gt;Sub&lt;/code&gt;, &lt;code&gt;Method&lt;/code&gt;, &lt;code&gt;Submethod&lt;/code&gt;, &lt;code&gt;Multi&lt;/code&gt;, &lt;code&gt;Rule&lt;/code&gt;, or &lt;code&gt;Macro&lt;/code&gt;. Also, the &lt;code&gt;&amp;amp;_&lt;/code&gt; variable refers to your current &lt;code&gt;Routine&lt;/code&gt;. A &lt;code&gt;Block&lt;/code&gt;, whether &lt;code&gt;Bare&lt;/code&gt; or &lt;code&gt;Parametric&lt;/code&gt;, is invisible to both of those notions.&lt;/p&gt;

&lt;p&gt;(It&amp;rsquo;s not yet clear whether the &lt;code&gt;Bare&lt;/code&gt; vs &lt;code&gt;Parametric&lt;/code&gt; distinction is useful. Some apparently &lt;code&gt;Bare&lt;/code&gt; blocks are actually &lt;code&gt;Parametric&lt;/code&gt; if they refer to &lt;code&gt;$_&lt;/code&gt; internally, even implicitly. And a &lt;code&gt;Bare&lt;/code&gt; block is just a &lt;code&gt;Parametric&lt;/code&gt; block with a signature of &lt;code&gt;()&lt;/code&gt;. More later.)&lt;/p&gt;

&lt;p&gt;A &lt;code&gt;&amp;lt;psignature&amp;gt;&lt;/code&gt; is a parenthesized signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule psignature :w { \( &amp;lt;signature&amp;gt; \) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And there is a variant that doesn&amp;rsquo;t declare names:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule psiglet :w { \( &amp;lt;siglet&amp;gt; \) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(We&amp;rsquo;ll discuss &amp;ldquo;siglets&amp;rdquo; later in their own section.)&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s possible to declare a subroutine in an lvalue or a signature as if it were an ordinary variable, in anticipation of binding the symbol to an actual subroutine later. Note this only works with an explicit name, since the whole point of declaring it in the first place is to have a name for it. On the other hand, the formal subroutine&amp;rsquo;s parameters &lt;em&gt;aren&amp;rsquo;t&lt;/em&gt; named, hence they are specified by a &lt;code&gt;&amp;lt;psiglet&amp;gt;&lt;/code&gt; rather than a &lt;code&gt;&amp;lt;psignature&amp;gt;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule scopedsubvar :w {
        &amp;lt;lexscope&amp;gt; &amp;lt;type&amp;gt;? &amp;amp;&amp;lt;subname&amp;gt; &amp;lt;psiglet&amp;gt;? &amp;lt;trait&amp;gt;*
    }

    rule unscopedsubvar :w {
        &amp;amp;&amp;lt;subname&amp;gt; &amp;lt;psiglet&amp;gt;? &amp;lt;trait&amp;gt;*
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If no &lt;code&gt;&amp;lt;psiglet&amp;gt;&lt;/code&gt; is supplied for such a declaration, it just uses whatever the signature of the bound routine is. So instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub foo (*@_) { print @_ }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you could equivalently say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;foo ::= sub (*@_) { print @_ };
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(You may recall that &lt;code&gt;::=&lt;/code&gt; does binding at compile time. Then again, you may not.)&lt;/p&gt;

&lt;p&gt;If there is a &lt;code&gt;&amp;lt;psiglet&amp;gt;&lt;/code&gt;, however, it must be compatible with the signature of the routine that is bound to it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;moo(Cow) ::= sub (Horse $x) { $x.neigh };     # ERROR
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-pointy-subs-pointy-subs-span&#34;&gt;&lt;span id=&#34;pointy_subs&#34;&gt;&amp;ldquo;Pointy subs&amp;rdquo;&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;&amp;ldquo;Pointy subs&amp;rdquo; declare a closure with an unparenthesized signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule pointysub :w {
        -\&amp;gt; &amp;lt;signature&amp;gt; &amp;lt;block&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;They may not take traits.&lt;/p&gt;

&lt;h3 id=&#34;span-id-bare-subs-bare-subs-span&#34;&gt;&lt;span id=&#34;bare_subs&#34;&gt;Bare subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;A bare block generates a closure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule baresub :w {
        &amp;lt;block&amp;gt; { .find_placeholders() }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A bare block declaration does not take traits (externally, anyway), and if there are any parameters, they must be specified with placeholder variables. If no placeholders are used, &lt;code&gt;$_&lt;/code&gt; may be treated as a placeholder variable, provided the surrounding control structure passes an argument to the the closure. Otherwise, &lt;code&gt;$_&lt;/code&gt; is bound as an ordinary lexical variable to the outer &lt;code&gt;$_&lt;/code&gt;. (&lt;code&gt;$_&lt;/code&gt; is also an ordinary lexical variable when explicit placeholders are used.)&lt;/p&gt;

&lt;p&gt;More on parameters below. But before we talk about parameters, we need to talk about types.&lt;/p&gt;

&lt;h2 id=&#34;span-id-digression-on-types-digression-on-types-span&#34;&gt;&lt;span id=&#34;digression_on_types&#34;&gt;Digression on types&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Well, what are types, anyway? Though known as a &amp;ldquo;typeless&amp;rdquo; language, Perl actually supports several built-in container types such as scalar, array, and hash, as well as user-defined, dynamically typed objects via &lt;code&gt;bless&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Perl 6 will certainly support more types. These include some low-level storage types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    bit int str num ref bool
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;as well as some high-level object types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Bit Int Str Num Ref Bool
    Array Hash Code IO
    Routine Sub Method Submethod Macro Rule
    Block Bare Parametric
    Package Module Class Object Grammar
    List Lazy Eager
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(These lists should not be construed as exhaustive.) We&amp;rsquo;ll also need some way of at least hinting at representations to the compiler, so we may also end up with types like these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    int8 int16 int32 int64
    uint8 uint16 uint32 uint64
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or maybe those are just extra &lt;code&gt;size&lt;/code&gt; traits on a declaration somewhere. That&amp;rsquo;s not important at this point.&lt;/p&gt;

&lt;p&gt;The important thing is that we&amp;rsquo;re adding a generalized type system to Perl. Let us begin by admitting that it is the height of madness to add a type system to a language that is well-loved for being typeless.&lt;/p&gt;

&lt;p&gt;But mad or not, there are some good reasons to do just that. First, it makes it possible to write interfaces to other languages in Perl. Second, it gives the optimizer more information to think about. Third, it allows the S&amp;amp;M folks to inflict strongly typed compile-time semantics on each other. (Which is fine, as long as they don&amp;rsquo;t inflict those semantics on the rest of us.) Fourth, a type system can be viewed as a pattern matching system for multi-method dispatch.&lt;/p&gt;

&lt;p&gt;Which basically boils down to the notion that it&amp;rsquo;s fine for Perl to have a type system as long as it&amp;rsquo;s optional. It&amp;rsquo;s just another area where Perl 6 will try to have its cake and eat it too.&lt;/p&gt;

&lt;p&gt;This should not actually come as a surprise to anyone who has been following the development of Perl 5, since the grammatical slot for declaring a variable&amp;rsquo;s effective type has been defined for some time now. In Perl 5 you can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat $felix;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to declare a variable intended to hold a &lt;code&gt;Cat&lt;/code&gt; object. That&amp;rsquo;s nice, as far as it goes. Perl 6 will support the same syntax, but we&amp;rsquo;ll have to push it much further than that if we&amp;rsquo;re to have a type system that is good enough to specify interfaces to languages like C++ or Java. In particular, we have to be able to specify the types of composite objects such as arrays and hashes without resorting to class definitions, which are rather heavyweight&amp;ndash;not to mention opaque. We need to be able to specify the types of individual function and method parameters and return values. Taken collectively, these parameter types can form the signature of a subroutine, which is one of the traits of the subroutine.&lt;/p&gt;

&lt;p&gt;And of course, all this has to be intuitively obvious to the naive user.&lt;/p&gt;

&lt;p&gt;Yeah, sure, you say.&lt;/p&gt;

&lt;p&gt;Well, let&amp;rsquo;s see how far we can get with it. If the type system is too klunky for some particular use, people will simply avoid using it. Which is fine&amp;ndash;that&amp;rsquo;s why it&amp;rsquo;s optional.&lt;/p&gt;

&lt;p&gt;First, let&amp;rsquo;s clarify one thing that seems to confuse people frequently. Unlike some languages, Perl makes a distinction between the type of the variable, and the type of the value. In Perl 5, this shows up as the difference between overloading and tying. You overload the value, but you tie the variable. When you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat $felix;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you are specifying the type of the &lt;em&gt;value&lt;/em&gt; being stored, not the type of the &lt;em&gt;variable&lt;/em&gt; doing the storing. That is, &lt;code&gt;$felix&lt;/code&gt; must contain a reference to a &lt;code&gt;Cat&lt;/code&gt; value, or something that &amp;ldquo;isa&amp;rdquo; &lt;code&gt;Cat&lt;/code&gt;. The variable type in this case is just a simple scalar, though that can be changed by tying the variable to some class implementing the scalar variable operations.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;In Perl 6, the type of the variable is just one of the traits of the variable, so if you want to do the equivalent of a &lt;code&gt;tie&lt;/code&gt; to the &lt;code&gt;Box&lt;/code&gt; class, you say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat $felix is Box;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That declares your intent to store a &lt;code&gt;Cat&lt;/code&gt; value into a &lt;code&gt;Box&lt;/code&gt; variable. (Whether the cat will then dead or alive (or dead|alive) depends on the definition of the &lt;code&gt;Box&lt;/code&gt; class, and whether the &lt;code&gt;Box&lt;/code&gt; object&amp;rsquo;s side effects extend to the &lt;code&gt;Cat&lt;/code&gt; value stored in it.)&lt;/p&gt;

&lt;p&gt;But by default:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat $felix;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;just means something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat $felix is Scalar;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, if you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat @litter;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s like saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat @litter is Array;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, &lt;code&gt;@litter&lt;/code&gt; is an ordinary array of scalar values that happen to be references to &lt;code&gt;Cat&lt;/code&gt;s. In the abstract, &lt;code&gt;@litter&lt;/code&gt; is a function that maps integers to cats.&lt;/p&gt;

&lt;p&gt;Likewise,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat %pet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat %pet is Hash;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can think of the &lt;code&gt;%pet&lt;/code&gt; hash as a function that maps cat names (strings) to cats. Of course, that&amp;rsquo;s an oversimplification&amp;ndash;for both arrays and hashes, subscripting is not the only operation. But it&amp;rsquo;s the fundamental operation, so the declared type of the returned value reflects the return value of such a subscripted call.&lt;/p&gt;

&lt;p&gt;Actually, it&amp;rsquo;s not necessarily the return type. It&amp;rsquo;s merely a type that is &lt;em&gt;consistent&lt;/em&gt; with the returned type. It would be better to declare:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Animal %pet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and then you could return a &lt;code&gt;Cat&lt;/code&gt; or a &lt;code&gt;Dog&lt;/code&gt; or a &lt;code&gt;Sponge&lt;/code&gt;, presuming all those are derived from &lt;code&gt;Animal&lt;/code&gt;. You&amp;rsquo;d have to generalize it a bit further if you want to store your pet &lt;code&gt;Rock&lt;/code&gt;. In the limit, you can just leave the type out. When you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %pet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;re really just saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Object %pet is Hash;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;hellip;except that you&amp;rsquo;re not. We have to push it further than that, because we have to handle more complicated structures as well. When you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat @litter is Array;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s really shorthand for:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @litter is Array of Cat;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, &amp;ldquo;&lt;code&gt;Cat&lt;/code&gt;&amp;rdquo; is really a funny parameter that says what kind of &lt;code&gt;Array&lt;/code&gt; you have. If you like, you could even write it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @litter is Array(returns =&amp;gt; Cat)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise you might write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %pet is Hash(keytype =&amp;gt; Str, returns =&amp;gt; Cat)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and specify the key type of the hash. The &amp;ldquo;&lt;code&gt;of&lt;/code&gt;&amp;rdquo; keyword is just syntactic sugar for specifying the return type of the previous storage class. So we could have&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %pet is Hash of Array of Array of Hash of Array of Cat;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which might really mean:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %pet is Hash(keytype =&amp;gt; Str,
                    returns =&amp;gt; Array(
                        returns =&amp;gt; Array(
                            returns =&amp;gt; Hash(
                                keytype =&amp;gt; Str,
                                returns =&amp;gt; Array(
                                    returns =&amp;gt; Cat)))))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or some such.&lt;/p&gt;

&lt;p&gt;I suppose you could also write that as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Array of Array of Hash of Array of Cat %pet;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but for linguistic reasons it&amp;rsquo;s probably better to keep the variable name near the left and put the long, heavy phrases to the right. (People tend to prefer to say the short parts of their sentences before the long parts&amp;ndash;linguists call this the &amp;ldquo;end-weight&amp;rdquo; problem.) The &lt;code&gt;Hash&lt;/code&gt; is implied by the &lt;code&gt;%pet&lt;/code&gt;, so you could leave out the &amp;ldquo;&lt;code&gt;is&lt;/code&gt;&amp;rdquo; part and just say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my %pet of Array of Array of Hash of Array of Cat;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another possibility is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat %pet is Hash of Array of Array of Hash of Array;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That one reads kinda funny if you leave out the &amp;ldquo;&lt;code&gt;is Hash&lt;/code&gt;&amp;rdquo;, though. Nevertheless, it says that we have this funny data structure that has multiple parameters that you can view as a funny function returning &lt;code&gt;Cat&lt;/code&gt;. In fact, &amp;ldquo;&lt;code&gt;returns&lt;/code&gt;&amp;rdquo; is a synonym for &amp;ldquo;&lt;code&gt;of&lt;/code&gt;&amp;rdquo;. This is also legal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @litter returns Cat;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But the &amp;ldquo;&lt;code&gt;returns&lt;/code&gt;&amp;rdquo; keyword is mostly for use by functions:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my Cat sub find_cat($name) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is the same as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub find_cat($name) returns Cat {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This is more important for things like closures that have no &amp;ldquo;&lt;code&gt;my&lt;/code&gt;&amp;rdquo; on the front:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $closure = sub ($name) returns Cat {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though for the closure case, it&amp;rsquo;s possible we could define some kind of non-&lt;code&gt;my&lt;/code&gt; article to introduce a type unambiguously:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $closure = a Camel sub ($name) {...}
    $closure = an Aardvark sub () {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Presumably &amp;ldquo;&lt;code&gt;a&lt;/code&gt;&amp;rdquo; or &amp;ldquo;&lt;code&gt;an&lt;/code&gt;&amp;rdquo; is short for &amp;ldquo;anonymous&amp;rdquo;. Which is more or less what the indefinite article means in English.&lt;/p&gt;

&lt;p&gt;However, we need &lt;code&gt;returns&lt;/code&gt; anyway in cases where the return value is complicated, so that you&amp;rsquo;d rather list it later (for end-weight reasons):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub next_prisoner() returns (Nationality, Name, Rank, SerialNo) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that the return type is a signature much like the parameter types, though of course there are no formal parameter names on a return value. (Though there could be, I suppose.) We&amp;rsquo;re calling such nameless signatures &amp;ldquo;siglets&amp;rdquo;.&lt;/p&gt;

&lt;h2 id=&#34;span-id-stub-declarations-stub-declarations-span&#34;&gt;&lt;span id=&#34;stub_declarations&#34;&gt;Stub declarations&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;When you declare a subroutine, it can change how the rest of the current file (or string) is compiled. So there is some pressure to put subroutine declarations early. On the other hand, there are good reasons for putting subroutine definitions later in the file too, particularly when you have mutually recursive subroutines. Beyond that, the definition might not even be supplied until run time if you use some kind of autoloading mechanism. (We&amp;rsquo;ll discuss autoloading in Apocalypse 10, Packages.) Perl 5 has long supported the notion of &amp;ldquo;forward&amp;rdquo; declarations or &amp;ldquo;stubs&amp;rdquo; via a syntax that looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub optimal;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl 6 also supports stubbing, but instead you write it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub optimal {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is, the stub is distinguished not by leaving the body of the function out, but by supplying a body that explicitly calls the &amp;ldquo;&lt;code&gt;...&lt;/code&gt;&amp;rdquo; operator (known affectionately as the &amp;ldquo;yada, yada, yada&amp;rdquo; operator). This operator emits a warning if you actually try to execute it. (It can also be made to pitch an exception.) There is no warning for redefining a &lt;code&gt;{...}&lt;/code&gt; body.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;re moving away from the semicolon syntax in order to be consistent with the distinction made by other declarations:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    package Fee;        # scope extends to end of file
    package Fee { ... } # scope extends over block

    module Fie;         # scope extends to end of file
    module Fie { ... }  # scope extends over block

    class Foe;          # scope extends to end of file
    class Foe { ... }   # scope extends over block
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To be consistent, a declaration like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would therefore extend to the end of the file. But that would be confusing for historical reasons, so we disallow it instead, and you have to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h2 id=&#34;span-id-scope-of-subroutine-names-scope-of-subroutine-names-span&#34;&gt;&lt;span id=&#34;scope_of_subroutine_names&#34;&gt;Scope of subroutine names&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Perl 5 gives subroutine names two scopes. Perl 6 gives them four.&lt;/p&gt;

&lt;h3 id=&#34;span-id-package-scoped-subs-package-scoped-subs-span&#34;&gt;&lt;span id=&#34;package_scoped_subs&#34;&gt;Package scoped subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;All named subs in Perl 5 have package scope. (The body provides a lexical scope, but we&amp;rsquo;re not talking about that. We&amp;rsquo;re talking about where the name of the subroutine is visible from.) Perl 6 provides by default a package-scoped name for &amp;ldquo;unscoped&amp;rdquo; declarations such as these:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;          sub fee {...}
       method fie {...}
    submethod foe {...}
        multi foo {...}
        macro sic {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Methods and submethods are ordinarily package scoped, because (just as in Perl 5) a class&amp;rsquo;s namespace is kept in a package.&lt;/p&gt;

&lt;h3 id=&#34;span-id-anonymous-subs-anonymous-subs-span&#34;&gt;&lt;span id=&#34;anonymous_subs&#34;&gt;Anonymous subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s sort of cheating to call this a subroutine scope, because it&amp;rsquo;s really more of a non-scope. Scope is a property of the &lt;em&gt;name&lt;/em&gt; of a subroutine. Since closures and anonymous subs have no name, they naturally have no intrinsic scope of their own. Instead, they rely on the scope of whatever variable contains a reference to them. The only way to get a lexically scoped subroutine name in Perl 5 was by indirection:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $subref = sub { dostuff(@_) }
    &amp;amp;$subref(...)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that doesn&amp;rsquo;t actually give you a lexically scoped name that is equivalent to an ordinary subroutine&amp;rsquo;s name. Hence, Perl 6 also provides&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-lexically-scoped-subs-lexically-scoped-subs-span&#34;&gt;&lt;span id=&#34;lexically_scoped_subs&#34;&gt;Lexically scoped subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;You can declare &amp;ldquo;scoped&amp;rdquo; subroutines by explicitly putting a &lt;code&gt;my&lt;/code&gt; or &lt;code&gt;our&lt;/code&gt; on the front of the declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub privatestuff { ... }
    our sub semiprivatestuff { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Both of these introduce a name into the current lexical scope, though in the case of &lt;code&gt;our&lt;/code&gt; this is just an alias for a package subroutine of the same name. (As with other uses of &lt;code&gt;our&lt;/code&gt;, you might want to introduce a lexical alias if your strictness level prohibits unqualified access to package subroutines.)&lt;/p&gt;

&lt;p&gt;You can also declare lexically scoped macros:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my macro sic { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-global-scoped-subs-global-scoped-subs-span&#34;&gt;&lt;span id=&#34;global_scoped_subs&#34;&gt;Global scoped subs&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Perl 6 also introduces the notion of completely global variables that are visible from everywhere they aren&amp;rsquo;t overridden by the current package or lexical scope. Such variables are named with a leading &lt;code&gt;*&lt;/code&gt; on the identifier, indicating that the package prefix is a wildcard, if you will. Since subroutines are just a funny kind of variable, you can also have global subs:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub *print (*@list) { $*DEFOUT.print(@list) } }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, that&amp;rsquo;s more-or-less how some built-in functions like &lt;code&gt;print&lt;/code&gt; could be implemented in Perl 6. (Methods like &lt;code&gt;$*DEFOUT.print()&lt;/code&gt; are a different story, of course. They&amp;rsquo;re defined off in a class somewhere. (Unless they&amp;rsquo;re multimethods, in which case they could be defined almost anywhere, because multimethods are always globally scoped. (In fact, most built-ins including &lt;code&gt;print&lt;/code&gt; will be multimethods, not subs. (But we&amp;rsquo;re getting ahead of ourselves&amp;hellip;))))&lt;/p&gt;

&lt;h2 id=&#34;span-id-signatures-signatures-span&#34;&gt;&lt;span id=&#34;signatures&#34;&gt;Signatures&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;One of Perl&amp;rsquo;s strong points has always been the blending of positional parameters with variadic parameters.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;Variadic&amp;rdquo; parameters are the ones that &lt;em&gt;vary&lt;/em&gt;. They&amp;rsquo;re the &amp;ldquo;&amp;hellip;And The Rest&amp;rdquo; list of values that many functions&amp;ndash;like &lt;code&gt;print&lt;/code&gt;, &lt;code&gt;map&lt;/code&gt;, and &lt;code&gt;chomp&lt;/code&gt;&amp;ndash;have at the end of their call. Whereas positional parameters generally tell a function &lt;em&gt;how&lt;/em&gt; to do its job, variadic parameters are most often used to pass the arbitrary sequences of data the function is supposed to do its job on/with/to.&lt;/p&gt;

&lt;p&gt;In Perl 5, when you unpack the arguments to a &lt;code&gt;sub&lt;/code&gt; like so:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my ($a, $b, $c, @rest) = @_;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you are defining three positional parameters, followed by a variadic list. And if you give the sub a prototype of &lt;code&gt;($$$@)&lt;/code&gt; it will force the first three parameters to be evaluated in scalar context, while the remaining arguments are evaluated in list context.&lt;/p&gt;

&lt;p&gt;The big problem with the Perl 5 solution is that the parameter binding is done at run time, which has run-time costs. It also means the metadata is not readily available outside the function body. We could just as easily have written it in some other form like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $a = shift;
    my $b = shift;
    my $c = shift;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and left the rest of the arguments in &lt;code&gt;@_&lt;/code&gt;. Not only is this difficult for a compiler to analyze, but it&amp;rsquo;s impossible to get the metadata from a stub declaration; you have to have the body defined already.&lt;/p&gt;

&lt;p&gt;The old approach is very flexible, but the cost to the user is rather high.&lt;/p&gt;

&lt;p&gt;Perl 6 still allows you to access the arguments via &lt;code&gt;@_&lt;/code&gt; if you like, but in general you&amp;rsquo;ll want to hoist the metadata up into the declaration. Perl 6 still fully supports the distinction between positional and variadic data&amp;ndash;you just have to declare them differently. In general, variadic items must follow positional items both in declaration and in invocation.&lt;/p&gt;

&lt;p&gt;In turn, there are at least three kinds of positional parameters, and three kinds of variadic parameters. A declaration for all six kinds of parameter won&amp;rsquo;t win a beauty contest, but might look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method x ($me: $req, ?$opt, +$namedopt, *%named, *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, you&amp;rsquo;d rarely write all of those in one declaration. Most declarations only use one or two of them. Or three or four&amp;hellip; Or five or six&amp;hellip;&lt;/p&gt;

&lt;p&gt;There is some flexibility in how you pass some of these parameters, but the ordering of both formal parameters and actual arguments is constrained in several ways. For instance, positional parameters must precede non-positional, and required parameters must precede optional. Variadic lists must be attached either to the end of the positional list or the end of the named parameter list. These constraints serve a number of purposes:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;They avoid user confusion.&lt;/li&gt;
&lt;li&gt;They enable the system to implement calls efficiently.&lt;/li&gt;
&lt;li&gt;Perhaps most importantly, they allow interfaces to evolve without breaking old code.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;Since there are constraints on the ordering of parameters, similar parameters tend to clump together into &amp;ldquo;zones&amp;rdquo;. So we&amp;rsquo;ll call the &lt;code&gt;?&lt;/code&gt;, &lt;code&gt;+&lt;/code&gt;, and &lt;code&gt;*&lt;/code&gt; symbols you see above &amp;ldquo;zone markers&amp;rdquo;. The underlying metaphor really is very much like zoning regulations&amp;ndash;you know, the ones where your city tells you what you may or may not do on a chunk of land you think you own. Each zone has a set of possible uses, and similar zones often have overlapping uses. But you&amp;rsquo;re still in trouble if you put a factory in the middle of a housing division, just as you&amp;rsquo;re in trouble if you pass a positional argument to a formal parameter that has no position.&lt;/p&gt;

&lt;p&gt;I was originally going to go with a semicolon to separate required from optional parameters (as Perl 5 uses in its prototypes), but I realized that it would get lost in the traffic, visually speaking. It&amp;rsquo;s better to have the zone markers line up, especially if you decide to repeat them in the vertical style:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method action ($self:
                int  $x,
                int ?$y,
                int ?$z,
             Adverb +$how,
        Beneficiary +$for,
           Location +$at is copy,
           Location +$toward is copy,
           Location +$from is copy,
             Reason +$why,
                    *%named,
                    *@list
                ) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So optional parameters are all marked with zone markers.&lt;/p&gt;

&lt;p&gt;In this section we&amp;rsquo;ll be concentrating on the declaration&amp;rsquo;s syntax rather than the call&amp;rsquo;s syntax, though the two cannot be completely disintertwingled. The declaration syntax is actually the more complicated of the two for various good reasons, so don&amp;rsquo;t get too discouraged just yet.&lt;/p&gt;

&lt;h3 id=&#34;span-id-positional-parameters-positional-parameters-span&#34;&gt;&lt;span id=&#34;positional_parameters&#34;&gt;Positional parameters&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The three positional parameter types are the invocant, the required parameters, and the optional positional parameters. (Note that in general, positional parameters may also be called using named parameter notation, but they must be declared as positional parameters if you wish to have the &lt;em&gt;option&lt;/em&gt; of calling them as positional parameters.) All positional parameters regardless of their type are considered scalars, and imply scalar context for the actual arguments. If you pass an array or hash to such a parameter, it will actually pass a reference to the array or hash, just as if you&amp;rsquo;d backslashed the actual argument.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-invocant-the-invocant-span&#34;&gt;&lt;span id=&#34;the_invocant&#34;&gt;The invocant&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The first argument to any method (or submethod) is its invocant, that is, the object or class upon which the method is acting. The invocant parameter, if present, is always declared with a colon following it. The invocant is optional in the sense that, if there&amp;rsquo;s no colon, there&amp;rsquo;s no explicit invocant declared. It&amp;rsquo;s still there, and it must be passed by the caller, but it has no name, and merely sets the outer topic of the method. That is, the invocant&amp;rsquo;s name is &lt;code&gt;$_&lt;/code&gt;, at least until something overrides the current topic. (You can always get at the invocant with the &lt;code&gt;self&lt;/code&gt; built-in, however. If you don&amp;rsquo;t like &amp;ldquo;self&amp;rdquo;, you can change it with a macro. See below.)&lt;/p&gt;

&lt;p&gt;Ordinary subs never have an invocant. If you want to declare a non-method subroutine that behaves as a method, you should declare a submethod instead.&lt;/p&gt;

&lt;p&gt;Multimethods can have multiple invocants. A colon terminates the list of invocants, so if there is no colon, all parameters are considered invocants. Only invocants participate in multimethod dispatch. Only the first invocant is bound to &lt;code&gt;$_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Macros are considered methods on the current parse state object, so they have an invocant.&lt;/p&gt;

&lt;h4 id=&#34;span-id-required-parameters-required-parameters-span&#34;&gt;&lt;span id=&#34;required_parameters&#34;&gt;Required parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Next (or first in the case of subs) come the required positional parameters. If, for instance, the routine declares three of these, you have to pass at least three arguments in the same order. The list of required parameters is terminated at the first optional parameter, that is the first parameter having any kind of zone marker. If none of those are found, all the parameters are required, and if you pass either too many or too few arguments, Perl will throw an exception as soon as it notices. (That might be at either compile time or run time.) If there are optional or variadic parameters, the required list merely serves as the minimum number of arguments you&amp;rsquo;re allowed to pass.&lt;/p&gt;

&lt;h4 id=&#34;span-id-optional-parameters-optional-parameters-span&#34;&gt;&lt;span id=&#34;optional_parameters&#34;&gt;Optional parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Next come the optional positional parameters. (They have to come next because they&amp;rsquo;re positional.) In the declaration, optional positional parameters are distinguished from required parameters by marking the optional parameters with a question mark. (The parameters are not distinguished in the call&amp;ndash;you just use commas. We&amp;rsquo;ll discuss call syntax later.) All optional positional parameters are marked with &lt;code&gt;?&lt;/code&gt;, not just the first one. Once you&amp;rsquo;ve made the transition to the optional parameter zone, all parameters are considered optional from there to the end of the signature, even after you switch zones to &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;. But once you leave the positional zone (at the end of the &lt;code&gt;?&lt;/code&gt; zone), you can&amp;rsquo;t switch back to the positional zone, because positionals may not follow variadics.&lt;/p&gt;

&lt;p&gt;If there are no variadic parameters following the optional parameters, the declaration establishes both a minimum and a maximum number of allowed arguments. And again, Perl will complain when it notices you violating either constraint. So the declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub *substr ($string, ?$offset, ?$length, ?$repl) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;says that &lt;code&gt;substr&lt;/code&gt; can be called with anywhere from 1 to 4 scalar parameters.&lt;/p&gt;

&lt;h3 id=&#34;span-id-variadic-parameters-variadic-parameters-span&#34;&gt;&lt;span id=&#34;variadic_parameters&#34;&gt;Variadic parameters&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Following the positional parameters, three kinds of variadic parameters may be declared. Variadic arguments may be slurped into a hash or an array depending on whether they look like named arguments or not. &amp;ldquo;Slurpy&amp;rdquo; parameters are denoted by a unary &lt;code&gt;*&lt;/code&gt; before the variable name, which indicates that an arbitrary number of values is expected for that variable.&lt;/p&gt;

&lt;p&gt;Additional named parameters may be placed at the end of the declaration, or marked with a unary &lt;code&gt;+&lt;/code&gt; (because they&amp;rsquo;re &amp;ldquo;extra&amp;rdquo; parameters). Since they are&amp;ndash;by definition&amp;ndash;in the variadic region, they may only be passed as named arguments, never positionally. It is illegal to mark a parameter with &lt;code&gt;?&lt;/code&gt; after the first &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;*&lt;/code&gt;, because you can&amp;rsquo;t reenter a positional zone from a variadic zone.&lt;/p&gt;

&lt;p&gt;Unlike the positional parameters, the variadic parameters are not necessarily declared in the same order as they will be passed in the call. They may be declared in any order (though the exact behavior of a slurpy array depends slightly on whether you declare it first or last).&lt;/p&gt;

&lt;h4 id=&#34;span-id-namedonly-parameters-named-only-parameters-span&#34;&gt;&lt;span id=&#34;namedonly_parameters&#34;&gt;Named-only parameters&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Parameters marked with a &lt;code&gt;+&lt;/code&gt; zone marker are named-only parameters. Such a parameter may never be passed positionally, but only by name.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-slurpy-hash-the-slurpy-hash-span&#34;&gt;&lt;span id=&#34;the_slurpy_hash&#34;&gt;The slurpy hash&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A hash declaration like &lt;code&gt;*%named&lt;/code&gt; indicates that the &lt;code&gt;%named&lt;/code&gt; hash should slurp up all the remaining named arguments (that is, those that aren&amp;rsquo;t bound explicitly to a specific formal parameter).&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-slurpy-array-the-slurpy-array-span&#34;&gt;&lt;span id=&#34;the_slurpy_array&#34;&gt;The slurpy array&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;An array declaration like &lt;code&gt;*@rest&lt;/code&gt; indicates that the &lt;code&gt;@rest&lt;/code&gt; array should slurp up all the remaining items after the named parameters. (Later we&amp;rsquo;ll discuss how to disambiguate the situation when the beginning of your list looks like named parameters.) If you &lt;code&gt;shift&lt;/code&gt; or &lt;code&gt;pop&lt;/code&gt; without an argument, it shifts or pops whatever slurpy array is in scope. (So in a sense, your main program has an implicit slurpy array of &lt;code&gt;*@*ARGS&lt;/code&gt; because that&amp;rsquo;s what &lt;code&gt;shift&lt;/code&gt; shifts there.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-formal-parameter-syntax-formal-parameter-syntax-span&#34;&gt;&lt;span id=&#34;formal_parameter_syntax&#34;&gt;Formal parameter syntax&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Formal parameters have lexical scope, as if they were declared with a &lt;code&gt;my&lt;/code&gt;. (That is reflected in the pseudocode in Appendix B.) Their scope extends only to the end of the associated block. Formal parameters are the only lexically scoped variables that are allowed to be declared outside their blocks. (Ordinary &lt;code&gt;my&lt;/code&gt; and &lt;code&gt;our&lt;/code&gt; declarations are always scoped to their surrounding block.)&lt;/p&gt;

&lt;p&gt;Any subroutine can have a method signature syntactically, but subsequent semantic analysis will reject mistakes like invocants on subroutines. This is not just motivated by laziness. I think that &amp;ldquo;&lt;code&gt;You can&#39;t have an invocant on a subroutine&lt;/code&gt;&amp;rdquo; is a better error message than &amp;ldquo;&lt;code&gt;Syntax error&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule signature :w {
        [&amp;lt;parameter&amp;gt; [&amp;lt;[,:]&amp;gt; &amp;lt;parameter&amp;gt; ]* ]?
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, we just treat colon as a funny comma here, so any use of extra colons is detected in semantic analysis. Similarly, zone markers are semantically restricted, not syntactically. Again, &amp;ldquo;&lt;code&gt;Syntax error&lt;/code&gt;&amp;rdquo; doesn&amp;rsquo;t tell you much. It&amp;rsquo;s much more informative to see &amp;ldquo;&lt;code&gt;You can&#39;t declare an optional positional parameter like ?$flag after a slurpy parameter like *@list&lt;/code&gt;&amp;rdquo;, or &amp;ldquo;&lt;code&gt;You can&#39;t use a zone marker on an invocant&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s what an individual parameter looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule parameter :w {
        [ &amp;lt;type&amp;gt;? &amp;lt;zone&amp;gt;? &amp;lt;variable&amp;gt; &amp;lt;trait&amp;gt;* &amp;lt;defval&amp;gt;?
        | \[ &amp;lt;signature&amp;gt; \]     # treat single array ref as an arg list
        ]
    }

    rule zone {
        [ \?            # optional positional
        | \*            # slurpy array or hash
        | \+            # optional named-only
        ]
    }

    rule variable { &amp;lt;sigil&amp;gt; &amp;lt;name&amp;gt; [ \( &amp;lt;siglet&amp;gt; \) ]? }
    rule sigil { &amp;lt;[$@%&amp;amp;]&amp;gt; &amp;lt;[*.?^]&amp;gt;? }   # &amp;quot;What is that, swearing?&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise, we parse any sigil here, but semantically reject things like &lt;code&gt;$*x&lt;/code&gt; or &lt;code&gt;$?x&lt;/code&gt;. We also reject package-qualified names and indirect names. We could have a &lt;code&gt;&amp;lt;simplevar&amp;gt;&lt;/code&gt; rule that only admits &lt;code&gt;&amp;lt;ident&amp;gt;&lt;/code&gt;, but again, &amp;ldquo;&lt;code&gt;Syntax error&lt;/code&gt;&amp;rdquo; is a lot less user-friendly than &amp;ldquo;&lt;code&gt;You can&#39;t use a package variable as a parameter, dimwit!&lt;/code&gt;&amp;ldquo;&lt;/p&gt;

&lt;p&gt;Similarly, the optional &lt;code&gt;&amp;lt;siglet&amp;gt;&lt;/code&gt; in &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; is allowed only on &lt;code&gt;&amp;amp;&lt;/code&gt; parameters, to say what you expect the signature of the referenced subroutine to look like. We should talk about siglets.&lt;/p&gt;

&lt;h4 id=&#34;span-id-siglets-siglets-span&#34;&gt;&lt;span id=&#34;siglets&#34;&gt;Siglets&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;&amp;lt;siglet&amp;gt;&lt;/code&gt; in the &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; rule is an example of a nameless signature, that is, a &amp;ldquo;small signature&amp;rdquo;, or &amp;ldquo;siglet&amp;rdquo;. Signatures without names are also used for return types and context traits (explained later). A siglet is sequential list of paramlets. The paramlets do not refer to actual variable names, nor do they take defaults:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule siglet :w {
        [&amp;lt;paramlet&amp;gt; [&amp;lt;[,:]&amp;gt; &amp;lt;paramlet&amp;gt; ]* ]?
    }

    rule paramlet :w {
        [ &amp;lt;type&amp;gt; &amp;lt;zone&amp;gt;? &amp;lt;varlet&amp;gt;? &amp;lt;trait&amp;gt;*     # require type
        | &amp;lt;zone&amp;gt; &amp;lt;varlet&amp;gt;? &amp;lt;trait&amp;gt;*             # or zone
        | &amp;lt;varlet&amp;gt; &amp;lt;trait&amp;gt;*                     # or varlet
        | \[ &amp;lt;siglet&amp;gt; \]        # treat single array ref as an arg list
        ]
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In place of a &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt;, there&amp;rsquo;s a kind of stub we&amp;rsquo;ll call a &amp;ldquo;varlet&amp;rdquo;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule varlet :w {
        &amp;lt;sigil&amp;gt; [ \( &amp;lt;siglet \) ]?
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with the &lt;code&gt;&amp;lt;variable&amp;gt;&lt;/code&gt; rule, a &lt;code&gt;&amp;lt;varlet&amp;gt;&lt;/code&gt;&amp;rsquo;s optional siglet is allowed only on &lt;code&gt;&amp;amp;&lt;/code&gt; parameters.&lt;/p&gt;

&lt;p&gt;Here&amp;rsquo;s a fancy example with one signature and several siglets.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub (int *@) imap ((int *@) &amp;amp;block(int $),
                        int *@vector is context(int) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You&amp;rsquo;re not expected to understand all of that yet. What you should notice, however, is that a paramlet is allowed to be reduced to a type (such as &lt;code&gt;int&lt;/code&gt;), or a zone (such as &lt;code&gt;?&lt;/code&gt;), or a varlet (such as &lt;code&gt;$&lt;/code&gt;), or some sequence of those (such as &lt;code&gt;int *@&lt;/code&gt;). But it&amp;rsquo;s not allowed to be reduced to a null string. A signature of &lt;code&gt;()&lt;/code&gt; indicates zero arguments, not one argument that could be anything. Use &lt;code&gt;($)&lt;/code&gt; for that. Nor can you specify four arguments by saying &lt;code&gt;(,,,)&lt;/code&gt;. You have to put something there.&lt;/p&gt;

&lt;p&gt;Perl 6 siglets can boil down to something very much like Perl 5&amp;rsquo;s &amp;ldquo;prototype pills&amp;rdquo;. However, you can&amp;rsquo;t leave out the comma between parameters in Perl 6. So you have to say &lt;code&gt;($,$)&lt;/code&gt; rather than &lt;code&gt;($$)&lt;/code&gt;, when you want to indicate a list of two scalars.&lt;/p&gt;

&lt;p&gt;If you use a &lt;code&gt;&amp;lt;siglet&amp;gt;&lt;/code&gt; instead of a &lt;code&gt;&amp;lt;signature&amp;gt;&lt;/code&gt; in declaring a subroutine, it will be taken as a Perl 5 style prototype, and all args still come in via &lt;code&gt;@_&lt;/code&gt;. This is a sop to the Perl5-to-Perl6 translator, which may not be able to figure out how to translate a prototype to a signature if you&amp;rsquo;ve done something strange with &lt;code&gt;@_&lt;/code&gt;. You should not use this feature in new code. If you use a siglet on a stub declaration, you must use the same siglet on the corresponding definition as well, and vice versa. You can&amp;rsquo;t mix siglets and signatures that way. (This is not a special rule, but a natural consequence of the signature matching rules.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-siglets-and-multimethods-siglets-and-multimethods-span&#34;&gt;&lt;span id=&#34;siglets_and_multimethods&#34;&gt;Siglets and multimethods&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;For closure parameters like &lt;code&gt;&amp;amp;block(int $)&lt;/code&gt;, the associated siglet is considered part of its name. This is true not just for parameters, but anywhere you use the &lt;code&gt;&amp;amp;&lt;/code&gt; form in your program, because with multimethods there may be several routines sharing the same identifier, distinguishable only by their type signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi factorial(int $a) { $a&amp;lt;=1 ?? 1 :: $a*factorial($a-1) }
    multi factorial(num $a) { gamma(1+$a) }

    $ref = &amp;amp;factorial;          # illegal--too ambiguous
    $ref = &amp;amp;factorial($);       # illegal--too ambiguous
    $ref = &amp;amp;factorial(int);     # good, means first one.
    $ref = &amp;amp;factorial(num);     # good, means second one.
    $ref = &amp;amp;factorial(complex); # bad, no such multimethod.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that when following a name like &amp;ldquo;&lt;code&gt;&amp;amp;factorial&lt;/code&gt;&amp;rdquo;, parentheses do not automatically mean to make a call to the subroutine. (This Apocalypse contradicts earlier Apocalypses. Guess which one is right&amp;hellip;)&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $val = &amp;amp;factorial($x);      # illegal, must use either
    $val = factorial($x);       #   this or
    $val = &amp;amp;factorial.($x);     #   maybe this.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In general, don&amp;rsquo;t use the &lt;code&gt;&amp;amp;&lt;/code&gt; form when you really want to call something.&lt;/p&gt;

&lt;h3 id=&#34;span-id-formal-parameter-traits-formal-parameter-traits-span&#34;&gt;&lt;span id=&#34;formal_parameter_traits&#34;&gt;Formal parameter traits&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Other than type, zone, and variable name, all other information about parameters is specified by the standard trait syntax, generally introduced by &lt;code&gt;is&lt;/code&gt;. Internally even the type and zone are just traits, but syntactically they&amp;rsquo;re out in front for psychological reasons. &lt;em&gt;Whose&lt;/em&gt; psychological reasons we won&amp;rsquo;t discuss.&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-constant-default-is-constant-default-span&#34;&gt;&lt;span id=&#34;is_constant_(default)&#34;&gt;&lt;code&gt;is constant&lt;/code&gt; (default)&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Every formal parameter is constant by default, meaning primarily that the compiler won&amp;rsquo;t feel obligated to construct an lvalue out the actual argument unless you specifically tell it to. It also means that you may not modify the parameter variable in any way. If the parameter is a reference, you may use it to modify the referenced object (if the object lets you), but you can&amp;rsquo;t assign to it and change the original variable passed to the routine.&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-rw-is-rw-span&#34;&gt;&lt;span id=&#34;is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;rw&lt;/code&gt; trait is how you tell the compiler to ask for an lvalue when evaluating the actual argument for this parameter. Do not confuse this with the &lt;code&gt;rw&lt;/code&gt; trait on the subroutine as a whole, which says that the entire subroutine knows how to function as an lvalue. If you set this trait, then you may modify the variable that was passed as the actual argument. A &lt;code&gt;swap&lt;/code&gt; routine would be:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub swap ($a is rw, $b is rw) { ($a,$b) = ($b,$a) }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If applied to a slurpy parameter, the &lt;code&gt;rw&lt;/code&gt; trait distributes to each element of the list that is bound to the parameter. In the case of a slurpy hash, this implies that the named pairs are in an lvalue context, which actually puts the right side of each named pair into lvalue context.&lt;/p&gt;

&lt;p&gt;Since normal lvalues assume &amp;ldquo;&lt;code&gt;is rw&lt;/code&gt;&amp;rdquo;, I suppose that also implies that you can assign to a pair:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (key =&amp;gt; $var) = &amp;quot;value&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or even do named parameter binding:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (who =&amp;gt; $name, why =&amp;gt; $reason) := (why =&amp;gt; $because, who =&amp;gt; &amp;quot;me&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is the same as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $name   := &amp;quot;me&amp;quot;;
    $reason := $because;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And since a slurpy hash soaks up the rest of the named parameters, this also seems to imply that binding a slurpy &lt;code&gt;rw&lt;/code&gt; hash actually makes the hash values into &lt;code&gt;rw&lt;/code&gt; aliases:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $a = &amp;quot;a&amp;quot;; $b = &amp;quot;b&amp;quot;;
    *%hash := (a =&amp;gt; $a, b =&amp;gt; $b);
    %hash{a} = &#39;x&#39;;
    print $a;   # prints &amp;quot;x&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s kinda scary powerful. I&amp;rsquo;m not sure I want to document that&amp;hellip; [&amp;ldquo;Too late!&amp;rdquo; whispers Evil Damian.]&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-copy-is-copy-span&#34;&gt;&lt;span id=&#34;is_copy&#34;&gt;&lt;code&gt;is copy&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This trait requests copy-in semantics. The variable is modifiable by you, but you&amp;rsquo;re only modifying your own private copy. It has the same effects as assigning the argument to your own &lt;code&gt;my&lt;/code&gt; variable. It does &lt;em&gt;not&lt;/em&gt; do copy-out.&lt;/p&gt;

&lt;p&gt;If you want both copy-in and copy-out semantics, declare it &lt;code&gt;rw&lt;/code&gt; and do your own copying back and forth, preferably with something that works even if you exit by exception (if that&amp;rsquo;s what you want):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub cico ($x is rw) {
        my $copy = $x;
        LAST { $x = $copy }
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Though if you&amp;rsquo;re using a copy you probably only want to copy-out on success, so you&amp;rsquo;d use a &lt;code&gt;KEEP&lt;/code&gt; block instead. Or more succinctly, using the new &lt;code&gt;will&lt;/code&gt; syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub cicomaybe ($x is rw) {
        my $copy will keep { $x = $copy } = $x;
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-is-ref-is-ref-span&#34;&gt;&lt;span id=&#34;is_ref&#34;&gt;&lt;code&gt;is ref&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This trait explicitly requests call-by-reference semantics. It lets you read and write an existing argument but doesn&amp;rsquo;t attempt to coerce that argument to an lvalue (or autovivify it) on the caller end, as &lt;code&gt;rw&lt;/code&gt; would. This trait is distinguished from a parameter of type &lt;code&gt;Ref&lt;/code&gt;, which merely asserts that the return type of the parameter is a reference without necessarily saying anything about calling convention. You can without contradiction say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub copyref (Ref $ref is copy) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;meaning you can modify &lt;code&gt;$ref&lt;/code&gt;, but that doesn&amp;rsquo;t change whatever was passed as the argument for that parameter.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-defaults-defaults-span&#34;&gt;&lt;span id=&#34;defaults&#34;&gt;Defaults&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Default values are also traits, but are written as assignments and must come at the end of the formal parameter for psychological reasons.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule defval :w { \= &amp;lt;item&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That is:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub trim ( Str $_ is rw, Rule ?$remove = /\s+/ ) {
            s:each/^ &amp;lt;$remove&amp;gt; | &amp;lt;$remove&amp;gt; $//;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;lets you call &lt;code&gt;trim&lt;/code&gt; as either:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trim($input);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trim($input, /\n+/);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;s very important to understand that the expression denoted by &lt;code&gt;item&lt;/code&gt; is evaluated in the lexical scope of the subroutine definition, not of the caller. If you want to get at the lexical scope of the caller, you have to do it explicitly (see &lt;code&gt;CALLER::&lt;/code&gt; below). Note also that an &lt;code&gt;item&lt;/code&gt; may not contain unbracketed commas, or the parser wouldn&amp;rsquo;t be able to reliably locate the next parameter declaration.&lt;/p&gt;

&lt;p&gt;Although the default looks like an assignment, it isn&amp;rsquo;t one. Nor is it exactly equivalent to &lt;code&gt;//=&lt;/code&gt;, because the default is set only if the parameter doesn&amp;rsquo;t exist, not if it exists but is undefined. That is, it&amp;rsquo;s used only if no argument is bound to the parameter.&lt;/p&gt;

&lt;p&gt;An &lt;code&gt;rw&lt;/code&gt; parameter may only default to a valid lvalue. If you find yourself wanting it to default to an ordinary value because it&amp;rsquo;s undefined, perhaps you really want &lt;code&gt;//=&lt;/code&gt; instead:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub multprob ($x is rw, $y) {
        $x //= 1.0;     # assume undef means &amp;quot;is certain&amp;quot;
        $x *= $y;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Syntactically, you can put a default on a required parameter, but it would never be used because the argument always exists. So semantic analysis will complain about it. (And I&amp;rsquo;d rather not say that adding a default implies it&amp;rsquo;s optional without the &lt;code&gt;?&lt;/code&gt; zone marker.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-formal-parameter-types-formal-parameter-types-span&#34;&gt;&lt;span id=&#34;formal_parameter_types&#34;&gt;Formal parameter types&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Formal parameters may have any type that any other variable may have, though particular parameters may have particular restrictions. An invocant needs to be an object of an appropriate class or subclass, for instance. As with ordinary variable declarations the type in front is actually the return type, and you can put it afterwards if you like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo (int @array is rw) {...}
    sub foo (@array of int is rw) {...}
    sub foo (@array is Array of int is rw) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The type of the actual argument passed must be compatible with (but not necessarily identical to) the formal type. In particular, for methods the formal type will often indicate a base class of the actual&amp;rsquo;s derived class. People coming from C++ must remember that all methods are &amp;ldquo;virtual&amp;rdquo; in Perl.&lt;/p&gt;

&lt;p&gt;Closure parameters are typically declared with &lt;code&gt;&amp;amp;&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub mygrep (&amp;amp;block, *@list is rw) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Within that subroutine, you can then call &lt;code&gt;block()&lt;/code&gt; as an ordinary subroutine with a lexically scoped name. If such a parameter is declared without its own parameter signature, the code makes no assumptions about the actual signature of the closure supplied as the actual argument. (You can always inspect the actual signature at run time, of course.)&lt;/p&gt;

&lt;p&gt;You may, however, supply a signature if you like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub mygrep (&amp;amp;block($foo), *@list is rw) {
        block(foo =&amp;gt; $bar);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;With an explicit signature, it would be error to bind a block to &lt;code&gt;&amp;amp;block&lt;/code&gt; that is not compatible. We&amp;rsquo;re leaving &amp;ldquo;compatible&amp;rdquo; undefined for the moment, other than to point out that the signature doesn&amp;rsquo;t have to be identical to be compatible. If the actual subroutine accepted one required parameter and one optional, it would work perfectly fine, for instance. The signature in &lt;code&gt;mygrep&lt;/code&gt; is merely specifying what it requires of the subroutine, namely one positional argument named &amp;ldquo;&lt;code&gt;$foo&lt;/code&gt;&amp;rdquo;. (Conceivably it could even be named something different in the actual routine, provided the compiler turns that call into a positional one because it thinks it already knows the signature.)&lt;/p&gt;

&lt;h2 id=&#34;span-id-calling-subroutines-calling-subroutines-span&#34;&gt;&lt;span id=&#34;calling_subroutines&#34;&gt;Calling subroutines&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;The typical subroutine or method is called a lot more often than it is declared. So while the declaration syntax is rather ornate, we strive for a call syntax that is rather simple. Typically it just looks like a comma-separated list. Parentheses are optional on predeclared subroutine calls, but mandatory otherwise. Parentheses are mandatory on method calls with arguments, but may be omitted for argumentless calls to methods such as attribute accessors. Parentheses are optional on multimethod and macro calls because they always parse like list operators. A rule may be called like a method but is normally invoked within a regex via the &lt;code&gt;&amp;lt;rule&amp;gt;&lt;/code&gt; syntax.&lt;/p&gt;

&lt;p&gt;As in Perl 5, within the list there may be an implicit transition from scalar to list context. For example, the declaration of the standard &lt;code&gt;push&lt;/code&gt; built-in in Perl 6 probably looks like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *push (@array, *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but you still generally call it as you would in Perl 5:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push(@foo, 1, 2, 3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This call has two of the three kinds of call arguments. It has one positional argument, followed by a variadic list. We could imagine adding options to &lt;code&gt;push&lt;/code&gt; sometime in the future. We &lt;em&gt;could&lt;/em&gt; define it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *push (@array, ?$how, *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s just an optional positional parameter, so you&amp;rsquo;d call it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push(@foo, &amp;quot;rapidly&amp;quot;, 1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But that won&amp;rsquo;t do, actually, since we used to allow the list to start at the end of the positional parameters, and any pre-existing &lt;code&gt;push(@foo,1,2,3)&lt;/code&gt; call to the new declaration would end up mapping the &amp;ldquo;&lt;code&gt;1&lt;/code&gt;&amp;rdquo; onto the new optional parameter. Oops&amp;hellip;&lt;/p&gt;

&lt;p&gt;If instead we force new parameters to be in named notation, like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *push (@array, *@list, +$how) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;ten we can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push(@foo, how =&amp;gt; &amp;quot;rapidly&amp;quot;, 1,2,3)&amp;lt;/pre~
and it&#39;s no longer ambiguous.  Since dhow is i the named-only zone,
it can never be set positionally, and the old calls to:

    push(@foo, 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;still work fine, because &lt;code&gt;*@list&lt;/code&gt; is still at the end of the positional parameter zone. If we instead declare that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *push (@array, +$how, *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we could still say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push(@foo, how =&amp;gt; &amp;quot;rapidly&amp;quot;, 1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but this becomes illegal:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push(@foo, 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;because the slurpy array is in the named-only zone. We&amp;rsquo;ll need an explicit way to indicate the start of the list in this case. I can think of lots of (mostly bad) ways. You probably can too. We&amp;rsquo;ll come back to this&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-actual-arguments-actual-arguments-span&#34;&gt;&lt;span id=&#34;actual_arguments&#34;&gt;Actual arguments&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;So the actual arguments to a Perl function are of three kinds: positional, named, and list. Any or all of these parts may be omitted, but whenever they are there, they &lt;em&gt;must&lt;/em&gt; occur in that order. It&amp;rsquo;s more efficient for the compiler (and less confusing to the programmer) if all the positional arguments come before all the non-positional arguments in the list. Likewise, the named arguments are constrained to occur before the list arguments for efficiency&amp;ndash;otherwise the implementation would have to scan the entire list for named arguments, and some lists are monstrous huge.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;d call these three parts &amp;ldquo;zones&amp;rdquo; as well, but then people would get them confused with our six declarative zones. In fact, extending the zoning metaphor a bit, our three parts are more like houses, stores, and factories (real ones, not OO ones, sheesh). These are the kinds of things you actually &lt;em&gt;find&lt;/em&gt; in residential, commercial, and industrial zones. Similarly, you can think of the three different kinds of argument as the things you&amp;rsquo;re allowed to &lt;em&gt;bind&lt;/em&gt; in the different parameter zones.&lt;/p&gt;

&lt;p&gt;A house is generally a scalar item that is known for its position; after all, &amp;ldquo;there&amp;rsquo;s no &lt;em&gt;place&lt;/em&gt; like home&amp;rdquo;. Um, yeah. Anyway, we usually number our houses. In the US, we don&amp;rsquo;t usually name our houses, though in the UK they don&amp;rsquo;t seem to mind it.&lt;/p&gt;

&lt;p&gt;A store may have a position (a street number), but usually we refer to stores by name. &amp;ldquo;I&amp;rsquo;m going out to Fry&amp;rsquo;s&amp;rdquo; does not refer to a particular location, at least not here in Silicon Valley. &amp;ldquo;I&amp;rsquo;m going out to McDonald&amp;rsquo;s&amp;rdquo; doesn&amp;rsquo;t mean a particular location anywhere in the world, with the possible exception of &amp;ldquo;not Antarctica&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;You don&amp;rsquo;t really care exactly where a factory is&amp;ndash;as long as it&amp;rsquo;s not in your back yard&amp;ndash;you care what it produces. The typical factory is for mass producing a series of similar things. In programming terms, that&amp;rsquo;s like a generator, or a pipe&amp;hellip;or a list. And you mostly worry about how you get vast quantities of stuff into and out of the factory without keeping the neighbors awake at night.&lt;/p&gt;

&lt;p&gt;So our three kinds of arguments map onto the various parameter zones in a similar fashion.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-positional-arguments-the-positional-arguments-span&#34;&gt;&lt;span id=&#34;the_positional_arguments&#34;&gt;The positional arguments&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Obviously, actual positional arguments are mapped onto the formal parameters in the order in which the formal positional parameters are declared. Invocant parameters (if any) must match invocant arguments, the required parameters match positional arguments, and then any additional non-named arguments are mapped onto the optional positional parameters. However, as soon as the first named argument is seen (that cannot be mapped to an explicitly typed &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Hash&lt;/code&gt; parameter) this mapping stops, and any subsequent positional parameters may only be bound by name.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-named-arguments-the-named-arguments-span&#34;&gt;&lt;span id=&#34;the_named_arguments&#34;&gt;The named arguments&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;After the positional argument part, you may pass as many named pairs as you like. These may bind to any formal parameter named in the declaration, whether declared as positional or named. However, it is erroneous to simultaneously bind a parameter both by position and by name. Perl may (but is not required to) give you a warning or error about this. If the problem is ignored, the positional parameter takes precedence, since the name collision might have come in by accident as a result of passing extra arguments intended for a different routine. Problems like this can arise when passing optional arguments to all the base classes of the current class, for instance. It&amp;rsquo;s not yet clear how fail-soft we should be here.&lt;/p&gt;

&lt;p&gt;Named arguments can come in either as &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Hash&lt;/code&gt; references. When parameter mapper sees an argument that is neither a &lt;code&gt;Pair&lt;/code&gt; nor a &lt;code&gt;Hash&lt;/code&gt;, it assumes it&amp;rsquo;s the end of the named part and the beginning of the list part.&lt;/p&gt;

&lt;p&gt;All unbound named arguments are bound to elements of the slurpy hash, if one was declared. If no slurpy hash is declared, an exception is thrown (although some standard methods, like &lt;code&gt;BUILD&lt;/code&gt;, will provide an implicitly declared slurpy hash&amp;ndash;known as &lt;code&gt;%_&lt;/code&gt; by analogy to &lt;code&gt;@_&lt;/code&gt;&amp;ndash;to handle surplus named arguments).&lt;/p&gt;

&lt;p&gt;At the end of named argument processing, any unmapped optional parameter ends up with the value &lt;code&gt;undef&lt;/code&gt; unless a default value is declared for it. Any unmapped required parameter throws an exception.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-slurpy-array2-the-slurpy-array-span&#34;&gt;&lt;span id=&#34;the_slurpy_array2&#34;&gt;The slurpy array&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;All remaining arguments are bound to the slurpy array, if any. If no slurpy array is specified, any remaining arguments cause an exception to be thrown. (You only get an implicit &lt;code&gt;*@_&lt;/code&gt; slurpy array when the signature is omitted entirely. Otherwise we could never validly give the error &amp;ldquo;Too many arguments&amp;rdquo;.)&lt;/p&gt;

&lt;p&gt;No argument processing is done on this list. If you go back to using named pairs at the end of the list, for instance, you&amp;rsquo;ll have to pop those off yourself. But since the list is potentially very long, Perl isn&amp;rsquo;t going to look for those on your behalf.&lt;/p&gt;

&lt;p&gt;Indeed, the list could be infinitely long, and maybe even a little longer than that. Perl 5 always flattens lists before calling the subroutine. In Perl 6, list flattening is done lazily, so a list could contain several infinite entries:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print(1..Inf, 1..Inf);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That might eventually give the &lt;code&gt;print&lt;/code&gt; function heartburn, of course&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-variadic-transitions-variadic-transitions-span&#34;&gt;&lt;span id=&#34;variadic_transitions&#34;&gt;Variadic transitions&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are, then, two basic transitions in argument processing. First is the transition from positional to named arguments. The second is from named arguments to the variadic list. It&amp;rsquo;s also possible to transition directly from positional arguments to the variadic list if optional positional arguments have been completely specified. That is, the slurp array could just be considered the next optional positional parameter in that case, as it is in &lt;code&gt;push&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But what if you don&amp;rsquo;t want to fill out all the optional parameters, and you aren&amp;rsquo;t planning to use named notation to skip the rest of them? How can you make both transitions simultaneously? There are two workarounds. First, suppose we have a &lt;code&gt;push&lt;/code&gt;-like signature such as this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub stuff (@array, ?$how, *@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The declarative workaround is to move the optional parameters after the slurp array, so that they are required to be specified as named parameters:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub stuff (@array, *@list, +$how) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then you can treat the slurp array as a positional parameter. That&amp;rsquo;s the solution we used to add an extra argument to &lt;code&gt;push&lt;/code&gt; earlier, where the list always starts at the second argument.&lt;/p&gt;

&lt;p&gt;On the calling end, you don&amp;rsquo;t have any control of the declaration, but you can always specify one of the arguments as named, either the final positional one, or the list itself:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff(@foo, how =&amp;gt; undef, 1,2,3)
    stuff(@foo, list =&amp;gt; (1,2,3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The latter is clearer and arguably more correct, but it has a couple of minor problems. For one thing, you have to know what the parameter name is. It&amp;rsquo;s all very well if you have to know the names of optional parameters, but &lt;em&gt;every&lt;/em&gt; list operator has a list that you really ought to be able to feed without knowing its name.&lt;/p&gt;

&lt;p&gt;So we&amp;rsquo;ll just say that the actual name of the slurpy list parameter is &amp;ldquo;&lt;code&gt;*@&lt;/code&gt;&amp;rdquo;. You can always say this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff(@foo, &#39;*@&#39; =&amp;gt; (1,2,3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s still a lot of extra unnecessary cruft&amp;ndash;but we can do better. List operators are like commands in Unix, where there&amp;rsquo;s a command line containing a program name and some options, and streams of data coming in and going out via pipes. The command in this case is &lt;code&gt;stuff&lt;/code&gt;, and the option is &lt;code&gt;@foo&lt;/code&gt;, which says what it is we&amp;rsquo;re stuffing. But what about the streams of stuff going in and out? Perl 6 has lazy lists, so they are in fact more like streams than they used to be.&lt;/p&gt;

&lt;p&gt;There will be two new operators, called pipe operators, that allow us to hook list generators together with list consumers in either order. So either of these works:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff @foo &amp;lt;== 1,2,3
    1,2,3 ==&amp;gt; stuff @foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The (ir)rationale for this is provided in Appendix A.&lt;/p&gt;

&lt;p&gt;To be sure, these newfangled pipe operators do still pass the list as a &amp;ldquo;&lt;code&gt;*@&lt;/code&gt;&amp;rdquo;-named argument, because that allows indirection in the entire argument list. Instead of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt; stuff @foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you can pull everything out in front, including the positional and named parameters, and build a list that gets passed as &amp;ldquo;splat&amp;rdquo; arguments (described in the next section) to &lt;code&gt;stuff&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list(@foo, how =&amp;gt; &#39;scrambled&#39; &amp;lt;== 1,2,3)
        ==&amp;gt; stuff *;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In other words:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list(@foo, how =&amp;gt; &#39;scrambled&#39; &amp;lt;== 1,2,3) ==&amp;gt; stuff *;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list(@foo, how =&amp;gt; &#39;scrambled&#39; &amp;lt;== 1,2,3) ==&amp;gt; stuff *();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff *(list(@foo, how =&amp;gt; &#39;scrambled&#39; &amp;lt;== 1,2,3));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;splat&amp;rdquo; and the &lt;code&gt;list&lt;/code&gt; counteract each other, producing:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff(@foo, how =&amp;gt; &#39;scrambled&#39; &amp;lt;== 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So what &lt;code&gt;stuff&lt;/code&gt; actually sees is exactly as if you called it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff(@foo, how =&amp;gt; &#39;scrambled&#39;, &#39;*@&#39; =&amp;gt; (1,2,3));
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which is equivalent to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff @foo, how =&amp;gt; &#39;scrambled&#39;, 1, 2, 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And yes, the &lt;code&gt;==&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;==&lt;/code&gt; operators are big, fat, and obnoxiously noticeable. I like them that way. I think the pipes are important and &lt;em&gt;should&lt;/em&gt; stand out. In postmodern architecture the ducts are just part of the deconstructed decor. (Just don&amp;rsquo;t anyone suggest a &lt;code&gt;==&amp;gt;=&lt;/code&gt; operator. Just&amp;hellip;don&amp;rsquo;t.)&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;==&amp;gt;&lt;/code&gt; and &lt;code&gt;&amp;lt;==&lt;/code&gt; operators have the additional side effect of forcing their blunt end into list context and their pointy end into scalar context. (More precisely, it&amp;rsquo;s not the expression on the pointy end that is in scalar context, but rather the positional arguments of whatever list function is pointed to by the pointy end.) See Appendix A for details.&lt;/p&gt;

&lt;h3 id=&#34;span-id-context-context-span&#34;&gt;&lt;span id=&#34;context&#34;&gt;Context&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As with Perl 5, the scalar arguments are evaluated in scalar context, while the list arguments are evaluated in list context. However, there are a few wrinkles.&lt;/p&gt;

&lt;h4 id=&#34;span-id-overriding-signature-with-overriding-signature-with-span&#34;&gt;&lt;span id=&#34;overriding_signature_with_*&#34;&gt;Overriding signature with &lt;code&gt;*&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Perl 5 has a syntax for calling a function without paying any attention to its prototype, but in Perl 6 that syntax has been stolen for a higher purpose (referential purity). Also, sometimes you&amp;rsquo;d like to be able to ignore part of a signature rather than the whole signature. So Perl 6 has a different notation, unary &lt;code&gt;*&lt;/code&gt;, for disabling signature checking, which we&amp;rsquo;ve mentioned in earlier Apocalypses, and which you&amp;rsquo;ve already seen in the form of the &lt;code&gt;stuff *&lt;/code&gt; above. (Our splat in the &lt;code&gt;stuff *&lt;/code&gt; above is in fact unary, but the optional argument is missing, because the list is supplied via pipe.)&lt;/p&gt;

&lt;p&gt;The first splatted term in an argument list causes all prior terms to be evaluated in scalar context, and all subsequent terms to be evaluated in list context. (Splat is a no-op in list context, so it doesn&amp;rsquo;t matter if there are more splatted terms.) If the function wants more positional arguments, they are assumed to come from the generated list, as if the list had been specified literally in the program at that point as comma-separated values.&lt;/p&gt;

&lt;p&gt;With splat lists, some of the argument processing may have to be deferred from compile time to runtime, so in general such a call may run slower than the ordinary form.&lt;/p&gt;

&lt;h4 id=&#34;span-id-context-unknown-at-compile-time-context-unknown-at-compile-time-span&#34;&gt;&lt;span id=&#34;context_unknown_at_compile_time&#34;&gt;Context unknown at compile time&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;If Perl can&amp;rsquo;t figure out the signature of a function at compile time (because, for instance, it&amp;rsquo;s a method and not a function), then it may not be known which arguments are in scalar or list context at the time they are evaluated. This doesn&amp;rsquo;t matter for Perl variables, because in Perl 6, they always return a reference in either scalar or list context. But if you call a function in such an indeterminate context, and the function doesn&amp;rsquo;t have a return value declared that clarifies whether the function behaves differently in scalar or list context, then one of two things must happen. The function must either run in an indeterminate context, or the actual call to the function must be delayed until the context is known. It is not yet clear which of these approaches is the lesser evil. It may well depend on whether the function pays more attention to its dynamic context or to global values. A function with no side effects and no global or dynamic dependencies can be called whenever we like, but we&amp;rsquo;re not here to enforce the functional paradigm. Interesting functions may pay attention to their context, and they may have side effects such as reading from an input stream in a particular order.&lt;/p&gt;

&lt;p&gt;A variant of running in indeterminate context is to simply assume the function is running in list context. (That is, after all, what Perl 5 does on methods and on not-yet-declared subroutines.) In Perl 6, we may see most such ambiguities resolved by explicit use of the &lt;code&gt;&amp;lt;==&lt;/code&gt; operator to force preceding args into scalar context, and the following args into list context. Individual arguments may also be forced into scalar or list context, of course.&lt;/p&gt;

&lt;p&gt;By the way, if you mix unary splat with &lt;code&gt;&amp;lt;==&lt;/code&gt;, only the args to the left of the splat are forced into scalar context. (It can do this because &lt;code&gt;&amp;lt;==&lt;/code&gt; governs everything back to the list operator, since it has a precedence slightly looser than comma.) So, given something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @moreargs = (1,2,3);
    mumble $a, @b, c(), *@moreargs &amp;lt;== @list;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we can tell just by looking that &lt;code&gt;$a&lt;/code&gt;, &lt;code&gt;@b&lt;/code&gt;, and &lt;code&gt;c()&lt;/code&gt; are all evaluated in scalar context, while &lt;code&gt;@moreargs&lt;/code&gt; and &lt;code&gt;@list&lt;/code&gt; are both in list context. It is parsed like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mumble( ($a, @b, c(), (*@moreargs)) &amp;lt;== (@list) );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You might also write that like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @moreargs = list(1,2,3 &amp;lt;== @list);
    mumble $a, @b, c(), *@moreargs;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In this case, we can still assume that &lt;code&gt;$a&lt;/code&gt;, &lt;code&gt;@b&lt;/code&gt;, &lt;code&gt;c()&lt;/code&gt; are in scalar context, because as we mentioned in the previous section, the &lt;code&gt;*&lt;/code&gt; forces it. (That&amp;rsquo;s because there&amp;rsquo;s no reason to put the splat if you&amp;rsquo;re already in list context.)&lt;/p&gt;

&lt;p&gt;Before we continue, you probably need a break. Here, have a break:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    *******************************************************
    ******************** Intermission *********************
    *******************************************************
&lt;/code&gt;&lt;/pre&gt;

&lt;h2 id=&#34;span-id-variations-on-a-theme-variations-on-a-theme-span&#34;&gt;&lt;span id=&#34;variations_on_a_theme&#34;&gt;Variations on a theme&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Welcome back.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ve covered the basics up till now, but there are a number of miscellaneous variations we left out in the interests of exposition. We&amp;rsquo;ll now go back to visit some of those issues.&lt;/p&gt;

&lt;h3 id=&#34;span-id-typed-slurps-typed-slurps-span&#34;&gt;&lt;span id=&#34;typed_slurps&#34;&gt;Typed slurps&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Sometimes you want to specify that the variadic list has a particular recurring type, or types. This falls out naturally from the slurp array syntax:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub list_of_ints ($a, $b, Int *@ints) { ... }
    sub list_of_scalars (Scalar *@scalars) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;These still evaluate the list in list context. But if you declare them as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub intlist ($a, $b, Int *@ints is context(Int)) { ... }
    sub scalarlist (Scalar *@scalars is context(Scalar)) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then these provide a list of &lt;code&gt;Int&lt;/code&gt; or &lt;code&gt;Scalar&lt;/code&gt; contexts to the caller. If you call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    scalarlist(@foo, %bar, baz())
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you get two scalar references and the scalar result of &lt;code&gt;baz()&lt;/code&gt;, not a flattened list. You can have lists without list context in Perl 6!&lt;/p&gt;

&lt;p&gt;If you want to have alternating types in your list, you can. Just specify a tuple type on your context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    strintlist( *@strints is context(Str,Int)) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Perl 5&amp;rsquo;s list context did not do lazy evaluation, but always flattened immediately. In Perl 6 the default list context &amp;ldquo;&lt;code&gt;is context(Lazy)&lt;/code&gt;&amp;rdquo;. But you can specify &amp;ldquo;&lt;code&gt;is context(Eager)&lt;/code&gt;&amp;rdquo; to get back to Perl 5 semantics of immediate flattening.&lt;/p&gt;

&lt;p&gt;As a sop to the Perl5-to-Perl6 translator (and to people who have to read translated programs), the &lt;code&gt;Eager&lt;/code&gt; context can also be specified by doubling the slurpy &lt;code&gt;*&lt;/code&gt; on the list to make it look like a pair of rollers that will squish anything flat:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub p5func ($arg, **@list) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &amp;ldquo;eager splat&amp;rdquo; is also available as a unary operator to attempt eager flattening on the rvalue side:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo = **1..Inf;  # Test our &amp;quot;out of memory&amp;quot; handler...
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-sublist-formals-sublist-formals-span&#34;&gt;&lt;span id=&#34;sublist_formals&#34;&gt;Sublist formals&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It&amp;rsquo;s often the case that you&amp;rsquo;d like to treat a single array argument as if it were an argument list of its own. Well, you can. Just put a sublist signature in square brackets. This is particularly good for declaring multimethods in a functional programming mindset:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi apply (&amp;amp;func, []) { }
    multi apply (&amp;amp;func, [$head, *@tail]) {
        return func($head), apply(&amp;amp;func, @tail);
    }

    @squares := apply { $_ * $_ } [1...];
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Of course, in this case, the first multimethod is never called because the infinite list is never null no matter how many elements we pull off the front. But that merely means that &lt;code&gt;@squares&lt;/code&gt; is bound to an infinite list generator. No big deal, as long as you don&amp;rsquo;t try to flatten the list&amp;hellip;&lt;/p&gt;

&lt;p&gt;Note that, unlike the example in the previous section which alternated strings and integers, this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    strintlist( [Str, Int] *@strints ) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;implies single array references coming in, each containing a string and an integer.&lt;/p&gt;

&lt;p&gt;Of course, this may be a bad example insofar as we could just write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi apply (&amp;amp;func) { }
    multi apply (&amp;amp;func, $head, *@tail) {
        return func($head), apply(&amp;amp;func, *@tail);
    }

    @squares := apply { $_ * $_ } *1...;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;It&amp;rsquo;d be nice to lose the &lt;code&gt;*&lt;/code&gt; though on the calls. Maybe what we really want is a slurpy scalar in front of the slurpy array, where presumably the &lt;code&gt;&amp;lt;==&lt;/code&gt; maps to the first slurpy scalar or hash (or it could be passed positionally):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi apply (&amp;amp;func) { }
    multi apply (&amp;amp;func, *$head, *@tail) {
        return func($head), apply(&amp;amp;func &amp;lt;== @tail);
    }

    @squares := apply { $_ * $_ } 1...;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Yow, I think I could like that if I tried.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s say for now that a slurpy scalar parameter just pulls the first (or next) value off of the the slurpy list. The &lt;code&gt;[]&lt;/code&gt; notation is still useful though for when you really do have a single array ref coming in as a parameter.&lt;/p&gt;

&lt;h3 id=&#34;span-id-attributive-parameters-attributive-parameters-span&#34;&gt;&lt;span id=&#34;attributive_parameters&#34;&gt;Attributive parameters&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;It is typical in many languages to see object initializers that look like this (give or take a keyword):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    function init (a_arg, b_arg, c_arg) {
        a = a_arg;
        b = b_arg;
        c = c_arg;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Other languages &lt;em&gt;try&lt;/em&gt; to improve the situation without actually succeeding. In a language resembling C++, it might look more like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method init (int a_arg, int b_arg, int c_arg)
        : a(a_arg), b(b_arg), c(c_arg) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But there&amp;rsquo;s still an awful lot of redundancy there, not to mention inconsistent special syntax.&lt;/p&gt;

&lt;p&gt;Since (as proven by Perl 5) signatures are all about syntactic sugar anyway, and since Perl 6 intentionally makes attribute variables visually distinct from ordinary variables, we can simply write this in Perl 6 as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    submethod BUILD ($.a, $.b, $.c) {}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Any parameter that appears to be an attribute is immediately copied directly into the corresponding object attribute, and no lexical parameter is generated. You can mix these with ordinary parameters&amp;ndash;the general rule of thumb for an initializer is that you should see each dotted attribute at least once:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    submethod BUILD ($.a, $.b, $c) {
        $.c = mung($c);
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This feature is primarily intended for use in constructors and initializers, but Perl does not try to guess which subroutines fall into that category (other than the fact that Perl 6 will implicitly call certain conventional names like CREATE and BUILD.)&lt;/p&gt;

&lt;p&gt;However, submethods such as BUILD are assumed to have an extra &lt;code&gt;*%_&lt;/code&gt; parameter to soak up any extra unrecognized named arguments. Ordinarily you must declare a slurp-hash explicitly to get that behavior. But BUILD submethods are always called with named arguments (except for the invocant), and often have to ignore arguments intended for other classes participating in the current construction. It&amp;rsquo;s likely that this implicit &lt;code&gt;*%_&lt;/code&gt; feature extends to other routines declared in all-caps as well, and perhaps all submethods.&lt;/p&gt;

&lt;p&gt;As in Perl 5, subroutines declared in all-caps are expected to be called automatically most of the time&amp;ndash;but not necessarily all the time. The BUILD routine is a good example, because it&amp;rsquo;s only called automatically when you rely on the default class initialization rules. But you can override those rules, in which case you may have to call BUILD yourself. More on that in Apocalypse 12. Or go to one of Damian&amp;rsquo;s Perl 6 talks&amp;hellip;&lt;/p&gt;

&lt;h3 id=&#34;span-id-other-kinds-of-subroutines-other-kinds-of-subroutines-span&#34;&gt;&lt;span id=&#34;other_kinds_of_subroutines&#34;&gt;Other kinds of subroutines&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-closures-closures-span&#34;&gt;&lt;span id=&#34;closures&#34;&gt;Closures&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;All blocks are considered closures in Perl 6, even the blocks that declare modules or classes (presuming you use the block form). A closure is just an anonymous subroutine that has access its lexical context. The fact that some closures are immediately associated with names or have other kinds of parameter declarations does not change the fact that an anonymous bare block without parameters is also a kind of subroutine. Of course, if the compiler can determine that the block is only executed inline, it&amp;rsquo;s free to optimize away all the subroutine linkage&amp;ndash;but not the lexical linkage. It can only optimize away the lexical linkage if no external lexicals are accessed (or potentially accessed, in the case of &lt;code&gt;eval&lt;/code&gt;).&lt;/p&gt;

&lt;h4 id=&#34;span-id-pointy-subs-pointy-subs-span-1&#34;&gt;&lt;span id=&#34;pointy_subs&#34;&gt;Pointy subs&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As introduced in Apocalypse 4, loops and topicalizers are often written with a special form of closure declaration known these days as &amp;ldquo;pointy subs&amp;rdquo;. A pointy sub is exactly equivalent to a standard anonymous sub declaration having the same parameters. It&amp;rsquo;s almost pure syntactic sugar&amp;ndash;except that we embrace syntactic sugar in Perl when it serves a psychological purpose (not to be confused with a logical psycho purpose, which we also have).&lt;/p&gt;

&lt;p&gt;Anyway, when you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -&amp;gt; $a, $b, $c { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s almost exactly the same as if you&amp;rsquo;d said:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub ($a, $b, $c) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;only without the parentheses, and with the cute arrow that indicates the direction of data flow to that part of your brain that consumes syntactic glucose at a prodigious rate.&lt;/p&gt;

&lt;p&gt;Since the parentheses around the signature are missing, you can&amp;rsquo;t specify anything that would ordinarily go outside the parentheses, such as the return type or other subroutine traits. But you may still put traits or zone markers on each individual formal parameter.&lt;/p&gt;

&lt;p&gt;Also, as a &amp;ldquo;sub-less&amp;rdquo; declaration, you can&amp;rsquo;t return from it using &lt;code&gt;return&lt;/code&gt;, because despite being a closure, it&amp;rsquo;s supposed to &lt;em&gt;look&lt;/em&gt; like a bare &lt;code&gt;Block&lt;/code&gt; embedded in a larger &lt;code&gt;Routine&lt;/code&gt;, and users will expect &lt;code&gt;return&lt;/code&gt; to exit from the &amp;ldquo;real&amp;rdquo; subroutine. All of which just means that, if you need those fancy extras, use a real &lt;code&gt;sub&lt;/code&gt; sub, not a pointy one.&lt;/p&gt;

&lt;h4 id=&#34;span-id-placeholders-placeholders-span&#34;&gt;&lt;span id=&#34;placeholders&#34;&gt;Placeholders&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Also as discussed in Apocalypse 4, a bare block functioning as a closure can have its parameters declared internally. Such parameters are of the form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    rule placeholder { &amp;lt;sigil&amp;gt; \^ &amp;lt;ident&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Placeholder parameters are equivalent to required position parameters declared in alphabetical order. (Er, Unicodical order, really.) For example, the closure:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    { $^fred &amp;lt;=&amp;gt; $^barney }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;has the same signature as the pointy sub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -&amp;gt; $barney, $fred { $fred &amp;lt;=&amp;gt; $barney }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or the standard anonymous sub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub ($barney, $fred) { $fred &amp;lt;=&amp;gt; $barney }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On first hearing about the alphabetical sorting policy, some otherwise level-headed folks immediately panic, imagining all sorts of ways to abuse the mechanism for the purposes of obfuscation. And surely there are many ways to abuse many of the features in Perl, more so in Perl 6. The point of this mechanism, however, is to make it drop-dead easy to write small, self-contained closures with a small number of parameters that you&amp;rsquo;d probably give single-character alphabetical names to in any event. If you want to get fancier than that, you should probably be using a fancier kind of declaration. I define &amp;ldquo;small number&amp;rdquo; as approximately &lt;em&gt;e&lt;/em&gt;  . But as is generally the case in Perl, you get to pick your own definition of &amp;ldquo;small number&amp;rdquo;. (Or at the very least, you get to pick whether to work with a company that has already defined &amp;ldquo;small number&amp;rdquo; for you.)&lt;/p&gt;

&lt;p&gt;As bare rvalue variables embedded in the code, you may not put any traits or zone markers on the placeholders. Again, the desire to do so indicates you should be using a fancier form of declaration.&lt;/p&gt;

&lt;h4 id=&#34;span-id-methods-methods-span&#34;&gt;&lt;span id=&#34;methods&#34;&gt;Methods&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Perl 5 just used subroutines for methods. This is okay as long as you don&amp;rsquo;t want to declare any utility subroutines in your class. But as soon as you do, they&amp;rsquo;re inherited in Perl 5, which is not what you want. In Perl 6, methods and subroutines still share the same namespace, but a method must be declared using the &lt;code&gt;method&lt;/code&gt; keyword. This is good documentation in any event, and further allows us to intuit an invocant where none is declared. (And we know that none is declared if there&amp;rsquo;s no colon after the first argument, at least in the case of an ordinary method.)&lt;/p&gt;

&lt;h4 id=&#34;span-id-submethods-submethods-span&#34;&gt;&lt;span id=&#34;submethods&#34;&gt;Submethods&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;There are certain implementation methods that want to be inherited in general so that you can specify a default implementation, but that you want the class to be able to override without letting derived classes inherit the overridden method from this class. That is, they are scoped like utility subroutines, but can be called as if they are methods, without being visible outside the class. We call these hybrids &amp;ldquo;submethods&amp;rdquo;, and so there&amp;rsquo;s a &lt;code&gt;submethod&lt;/code&gt; keyword to declare them. Submethods are simultaneously subs and methods. You can also think of them as something less than a method, as the &amp;ldquo;sub&amp;rdquo; works in the word &amp;ldquo;subhuman&amp;rdquo;. Or you can think of them as underneath in the infrastructural sense, as in &amp;ldquo;subterranean&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Routines that create, initialize, or destroy the current object tend to fall into this category. Hence, the &lt;code&gt;BUILD&lt;/code&gt; routine we mentioned earlier is ordinarily declared as a submethod, if you don&amp;rsquo;t want to inherit the standard &lt;code&gt;BUILD&lt;/code&gt; method defined in the Object class. But if you override it, your children still inherit &lt;code&gt;BUILD&lt;/code&gt; from Object.&lt;/p&gt;

&lt;p&gt;Contrariwise, if you don&amp;rsquo;t like &lt;code&gt;Object&lt;/code&gt;&amp;rsquo;s default &lt;code&gt;BUILD&lt;/code&gt; method, you can define an entire new class of classes that all default to your own &lt;code&gt;BUILD&lt;/code&gt; method, as long as those classes derive from your new base object with superior characteristics. Each of those derived classes could then define a submethod to override your method only for that class, while classes derived from those classes could still inherit your default.&lt;/p&gt;

&lt;p&gt;And so on, ad OOium.&lt;/p&gt;

&lt;h4 id=&#34;span-id-multimethods-multimethods-span&#34;&gt;&lt;span id=&#34;multimethods&#34;&gt;Multimethods&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Some kinds of programming map easily onto the standard model in which a method has a single invocant. Other kinds of programming don&amp;rsquo;t. Perl 6 supplies support for the latter kind of programming, where the relationships between classes are just as interesting as the classes themselves. In some languages, all methods are multimethods. Perl 6 doesn&amp;rsquo;t go quite that far&amp;ndash;you must declare your multimethods explicitly. To do so, use the &lt;code&gt;multi&lt;/code&gt; keyword in place of &lt;code&gt;method&lt;/code&gt;, and optionally place a colon after the list of invocants in the declaration, unless you want them all to be invocants. Then your multimethod will be registered globally as a being of interest to all the types of its invocants, and will participate in multimethod dispatch.&lt;/p&gt;

&lt;p&gt;It is beyond the scope of this Apocalypse to specify exactly how multimethod dispatch works (see Apocalypse 12, someday), but we can tell you that, in general, you call a multimethod as if it were an ordinary subroutine, and the dispatcher figures out on your behalf how many of the arguments are invocants. This may sound fancy to you, but many of the functions that are built into Perl 5 are &lt;em&gt;not&lt;/em&gt; built into Perl 6, at least, not as keywords. Instead they are either defined as global subroutines or as multimethods, single invocant multimethods in many cases. When you call a function like &lt;code&gt;close($handle)&lt;/code&gt;, it&amp;rsquo;ll first look to see if there&amp;rsquo;s a &lt;code&gt;close&lt;/code&gt; subroutine defined in your scope, and if not, it will dispatch it as a multimethod. Likewise, for something like &lt;code&gt;sysread&lt;/code&gt;, you can call it either as a method:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sysread $handle: $buffer, $length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or as a function:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sysread $handle, $buffer, $length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In the first case, it&amp;rsquo;s explicitly dispatching on the handle, because a colon in place of the first comma indicates an invocant. (That&amp;rsquo;s our new indirect object syntax, in fact. Perl 6 does not support the Perl 5 syntax of just leaving whitespace between the indirect object and the subsequent arguments.)&lt;/p&gt;

&lt;p&gt;In the second case, it looks for a &lt;code&gt;sysread&lt;/code&gt; subroutine, doesn&amp;rsquo;t find it (we hope), and calls multimethod dispatch on it. And it happens that the multimethod dispatch is smart enough to find the ordinary single-invocant &lt;code&gt;sysread&lt;/code&gt; method, even though it may not have been explicitly declared a multimethod. Multimethod dispatch happens to map directly onto ordinary method dispatch when there&amp;rsquo;s only one invocant.&lt;/p&gt;

&lt;p&gt;At least, that&amp;rsquo;s how it works this week&amp;hellip;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-rules-rules-span&#34;&gt;&lt;span id=&#34;rules&#34;&gt;Rules&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Rules were discussed in Apocalypse 5. They are essentially methods with an implicit invocant, consisting of the object containing the current pattern matching context. To match the internals of regex syntax, traits attached to rules are typically written as &amp;ldquo;&lt;code&gt;:w&lt;/code&gt;&amp;rdquo; rather than &amp;ldquo;&lt;code&gt;is w&lt;/code&gt;&amp;rdquo;, but they&amp;rsquo;re essentially the same thing underneath.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s possible to call a rule as if it were a method, as long as you give it the right arguments. And a method defined in a grammar can be called as if it were a rule. They share the same namespace, and a rule really is just a method with a funny syntax.&lt;/p&gt;

&lt;h4 id=&#34;span-id-macros-macros-span&#34;&gt;&lt;span id=&#34;macros&#34;&gt;Macros&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A macro is a function that is called immediately upon completion of the parsing of its arguments. Macros must be defined before they are used&amp;ndash;there are no forward declarations of macros, and while a macro&amp;rsquo;s name may be installed in either a package or a lexical scope, its syntactic effect can only be lexical, from the point of declaration (or importation) to the end of the current lexical scope.&lt;/p&gt;

&lt;p&gt;Every macro is associated (implicitly or explicitly) with a particular grammar rule that parses and reduces the arguments to the macro. The formal parameters of a macro are special in that they must be derived somehow from the results of that associated grammar rule. We treat macros as if they were methods on the parse object returned by the grammar rule, so the first argument is passed as if it were an invocant, and it is always bound to the current parse tree object, known as &lt;code&gt;$0&lt;/code&gt; in Apocalypse 5. (A macro is not a true method of that class, however, because its name is in your scope, not the class&amp;rsquo;s.)&lt;/p&gt;

&lt;p&gt;Since the first parameter is treated as an invocant, you may either declare it or leave it implicit in the actual declaration. In either case, the parse tree becomes the current topic for the macro. Hence you may refer to it as either &lt;code&gt;$_&lt;/code&gt; or &lt;code&gt;$0&lt;/code&gt;, even if you don&amp;rsquo;t give it a name.&lt;/p&gt;

&lt;p&gt;Subsequent parameters may be specified, in which case they bind to internal values of &lt;code&gt;$0&lt;/code&gt; in whatever way makes sense. Positional parameters bind to &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc. Named parameters bind to named elements of &lt;code&gt;$0&lt;/code&gt;. A slurpy hash is really the same as &lt;code&gt;$0&lt;/code&gt;, since &lt;code&gt;$0&lt;/code&gt; already behaves as a hash. A slurpy array gets &lt;code&gt;$1&lt;/code&gt;, &lt;code&gt;$2&lt;/code&gt;, etc., even if already bound to a positional parameter.&lt;/p&gt;

&lt;p&gt;A macro can do anything it likes with the parse tree, but the return value is treated specially by the parser. You can return one of several kinds of values:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;A parse tree (the same one, a modified one, or a synthetic one) to be passed up to the outer grammar rule that was doing pattern matching when we hit the macro.&lt;/li&gt;
&lt;li&gt;A closure functioning as a generic routine that is to be immediately inlined, treating the closure as a template. Within the template, any variable referring back to one of the macro&amp;rsquo;s parse parameters will interpolate that parameter&amp;rsquo;s value at that point in the template. (It will be interpolated as a parse tree, a string, or a number depending on the declaration of the parameter.) Any variable not referring back to a parameter is left alone, so that your template can declare its own lexical variables, or refer to a package variable.&lt;/li&gt;
&lt;li&gt;A string, to be shoved into the input stream and reparsed at the point the macro was found, starting in exactly the same grammar state we were before the macro. This is slightly different from returning the same string parsed into a parse tree, because a parse tree must represent a complete construct at some level, while the string could introduce a construct without terminating it. This is the most dangerous kind of return value, and the least likely to produce coherent error messages with decent line numbers for the end user. But it&amp;rsquo;s also very powerful. Hee, hee.&lt;/li&gt;
&lt;li&gt;An &lt;code&gt;undef&lt;/code&gt;, indicating that the macro is only used for its side effects. Such a macro would be one way of introducing an alternate commenting mechanism, for instance. I suppose returning &amp;ldquo;&amp;rdquo; has the same effect, though.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;A &lt;code&gt;macro&lt;/code&gt; by default parses any subsequent text using whatever &lt;code&gt;macro&lt;/code&gt; rule is currently in effect. Generally this will be the standard &lt;code&gt;Perl::macro&lt;/code&gt; rule, which parses subsequent arguments as a list operator would&amp;ndash;that is, as a comma-separated list with the same policy on using or omitting parentheses as any other list operator. This default may be overridden with the &amp;ldquo;&lt;code&gt;is parsed&lt;/code&gt;&amp;rdquo; trait.&lt;/p&gt;

&lt;p&gt;If there is no signature at all, &lt;code&gt;macro&lt;/code&gt; defaults to using the null rule, meaning it looks for no argument at all. You can use it for simple word substitutions where no argument processing is needed. Instead of the long-winded:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my macro this () is parsed(/&amp;lt;null&amp;gt;/) { &amp;quot;self&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you can just quietly turn your program into C++:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my macro this { &amp;quot;self&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A lot of Perl is fun, and macros are fun, but in general, you should never use a macro just for the fun of it. It&amp;rsquo;s far too easy to poke someone&amp;rsquo;s eye out with a macro.&lt;/p&gt;

&lt;h3 id=&#34;span-id-outofband-parameters-out-of-band-parameters-span&#34;&gt;&lt;span id=&#34;outofband_parameters&#34;&gt;Out-of-band parameters&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Certain kinds of routines want extra parameters in addition to the ordinary parameter list. Autoloading routines for instance would like to know what function the caller was trying to call. Routines sensitive to topicalizers may wish to know what the topic is in their caller&amp;rsquo;s lexical scope.&lt;/p&gt;

&lt;p&gt;There are several possible approaches. The Perl 5 autoloader actually pokes a package variable into the package with the &lt;code&gt;AUTOLOAD&lt;/code&gt; subroutine. It could be argued that something that&amp;rsquo;s in your dynamic scope should be accessed via dynamically scoped variables, and indeed we may end up with a &lt;code&gt;$*AUTOLOAD&lt;/code&gt; variable in Perl 6 that works somewhat like Perl 5&amp;rsquo;s, only better, because &lt;code&gt;AUTOLOAD&lt;/code&gt; kinda sucks. We&amp;rsquo;ll address that in Apocalypse 10, for some definition of &amp;ldquo;we&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;Another approach is to give access to the caller&amp;rsquo;s lexical scope in some fashion. The magical &lt;code&gt;caller()&lt;/code&gt; function could return a handle by which you can access the caller&amp;rsquo;s &lt;code&gt;my&lt;/code&gt; variables. And in general, there will be such a facility under the hood, because we have to be able to construct the caller&amp;rsquo;s lexical scope while it&amp;rsquo;s being compiled.&lt;/p&gt;

&lt;p&gt;In the particular case of grabbing the topic from the caller&amp;rsquo;s lexical scope (and it has to be in the caller&amp;rsquo;s &lt;em&gt;lexical&lt;/em&gt; scope because &lt;code&gt;$_&lt;/code&gt; is now lexically scoped in Perl 6), we think it&amp;rsquo;ll happen often enough that there should be a shorthand for it. Or maybe it&amp;rsquo;s more like a &amp;ldquo;midhand&amp;rdquo;. We don&amp;rsquo;t want it too short, or people will unthinkingly abuse it. Something on the order of a &lt;code&gt;CALLER::&lt;/code&gt; prefix, which we&amp;rsquo;ll discuss below.&lt;/p&gt;

&lt;h3 id=&#34;span-id-lexical-context-lexical-context-span&#34;&gt;&lt;span id=&#34;lexical_context&#34;&gt;Lexical context&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Works just like in Perl 5. Why change something that works?&lt;/p&gt;

&lt;p&gt;Well, okay, we are tweaking a few things related to lexical scopes. &lt;code&gt;$_&lt;/code&gt; (also known as the current topic) is always a lexically scoped variable now. In general, each subroutine will implicitly declare its own &lt;code&gt;$_&lt;/code&gt;. Methods, submethods, macros, rules, and pointy subs all bind their first argument to &lt;code&gt;$_&lt;/code&gt;; ordinary subs declare a lexical &lt;code&gt;$_&lt;/code&gt; but leave it undefined. Every sub definition declares its own &lt;code&gt;$_&lt;/code&gt; and hides any outer &lt;code&gt;$_&lt;/code&gt;. The only exception is bare closures that are pretending to be ordinary blocks and don&amp;rsquo;t commandeer &lt;code&gt;$_&lt;/code&gt; for a placeholder. These continue to see the outer scope&amp;rsquo;s &lt;code&gt;$_&lt;/code&gt;, just as they would any other lexically scoped variable declared in the outer scope.&lt;/p&gt;

&lt;h3 id=&#34;span-id-dynamic-context-dynamic-context-span&#34;&gt;&lt;span id=&#34;dynamic_context&#34;&gt;Dynamic context&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;On the flipside, &lt;code&gt;$_&lt;/code&gt; is no longer visible in the dynamic context. You can still temporize (localize) it, but you&amp;rsquo;ll be temporizing the current subroutine&amp;rsquo;s lexical &lt;code&gt;$_&lt;/code&gt;, not the global &lt;code&gt;$_&lt;/code&gt;. Routines which used to use dynamic scoping to view the &lt;code&gt;$_&lt;/code&gt; of a calling subroutine will need some tweaking. See &lt;code&gt;CALLER::&lt;/code&gt; below.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-caller-function-the-caller-function-span&#34;&gt;&lt;span id=&#34;the_caller_function&#34;&gt;The &lt;code&gt;caller&lt;/code&gt; function&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As in Perl 5, the &lt;code&gt;caller&lt;/code&gt; function will return information about the dynamic context of the current subroutine. Rather than always returning a list, it will return an object that represents the selected caller&amp;rsquo;s context. (In a list context, the object can still return the old list as Perl 5-ers are used to.) Since contexts are polymorphic, different context objects might in fact supply different methods. The &lt;code&gt;caller&lt;/code&gt; function doesn&amp;rsquo;t have to know anything about that, though.&lt;/p&gt;

&lt;p&gt;What &lt;code&gt;caller&lt;/code&gt; does know in Perl 6 is that it takes an optional argument. That argument says where to stop when scanning up the call stack, and so can be used to tell &lt;code&gt;caller&lt;/code&gt; which kinds of context you&amp;rsquo;re interested in. By default, it&amp;rsquo;ll skip any &amp;ldquo;wrapper&amp;rdquo; functions (see &amp;ldquo;The &lt;code&gt;.wrap&lt;/code&gt; method&amp;rdquo; below) and return the outermost context that thought it was calling your routine directly. Here&amp;rsquo;s a possible declaration:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *caller (?$where = &amp;amp;CALLER::_, Int +$skip = 0, Str +$label)
        returns CallerContext {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;$where&lt;/code&gt; argument can be anything that matches a particular context, including a subroutine reference or any of these Code types:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    Code Routine Block Sub Method Submethod Multi Macro Bare Parametric
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;&amp;amp;_&lt;/code&gt; produces a reference to your current &lt;code&gt;Routine&lt;/code&gt;, though in the signature above we have to use &lt;code&gt;&amp;amp;CALLER::_&lt;/code&gt; to get at the caller&amp;rsquo;s &lt;code&gt;&amp;amp;_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note that use of &lt;code&gt;caller&lt;/code&gt; can prevent certain kinds of optimizations, such as tail recursion elimination.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-want-function-the-want-function-span&#34;&gt;&lt;span id=&#34;the_want_function&#34;&gt;The &lt;code&gt;want&lt;/code&gt; function&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;want&lt;/code&gt; function is really just the &lt;code&gt;caller&lt;/code&gt; function in disguise. It also takes an argument telling it which context to pay attention to, which defaults to the one you think it should default to. It&amp;rsquo;s declared like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *want (?$where = &amp;amp;CALLER::_, Int +$skip = 0, Str +$label)
        returns WantContext {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that, as a variant of &lt;code&gt;caller&lt;/code&gt;, use of &lt;code&gt;want&lt;/code&gt; can prevent certain kinds of optimizations.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;want&lt;/code&gt; is called in a scalar context:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        $primary_context = want;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it returns a synthetic object whose type behaves as the junction of all the valid contexts currently in effect, whose numeric overloading returns the count of arguments expected, and whose string overloading produces the primary context as one of &amp;lsquo;Void&amp;rsquo;, &amp;lsquo;Scalar&amp;rsquo;, or &amp;lsquo;List&amp;rsquo;. The boolean overloading produces true unless in a void context.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;want&lt;/code&gt; is called in a list context like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        ($primary, $count, @secondary) = want;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it returns a list of at least two values, indicating the contexts in which the current subroutine was called. The first two values in the list are the primary context (i.e the scalar return value) and the expectation count (see Expectation counts below). Any extra contexts that &lt;code&gt;want&lt;/code&gt; may detect (see Valid contexts below) are appended to these two items.&lt;/p&gt;

&lt;p&gt;When &lt;code&gt;want&lt;/code&gt; is used as an object, it has methods corresponding to its valid contexts:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        if want.rw { ... }
        unless want.count &amp;lt; 2 { ... }
        when want.List { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;want&lt;/code&gt; function can be used with smart matching:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;        if want ~~ List &amp;amp; 2 &amp;amp; Lvalue { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which means it can also be used in a switch:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given want {
        when List &amp;amp; 2 &amp;amp; Lvalue { ... }
        when .count &amp;gt; 2 {...}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The numeric value of the &lt;code&gt;want&lt;/code&gt; object is the &amp;ldquo;expectation count&amp;rdquo;. This is an integer indicating the number of return values expected by the subroutine&amp;rsquo;s caller. For void contexts, the expectation count is always zero; for scalar contexts, it is always zero or one; for list contexts it may be any non-negative number. The &lt;code&gt;want&lt;/code&gt; value can simply be used as a number:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    if want &amp;gt;= 2 { return ($x, $y) }         # context wants &amp;gt;= 2 values
    else         { return ($x); }            # context wants &amp;lt; 2 values
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that &lt;code&gt;Inf &amp;gt;= 2&lt;/code&gt; is true. (&lt;code&gt;Inf&lt;/code&gt; is not the same as &lt;code&gt;undef&lt;/code&gt;.) If the context is expecting an unspecified number of return values (typically because the result is being assigned to an array variable), the expectation count is &lt;code&gt;Inf&lt;/code&gt;. You shouldn&amp;rsquo;t actually return an infinite list, however, unless &lt;code&gt;want ~~ Lazy&lt;/code&gt;. The opposite of &lt;code&gt;Lazy&lt;/code&gt; context is &lt;code&gt;Eager&lt;/code&gt; context (the Perl 5 list context, which always flattened immediately). &lt;code&gt;Eager&lt;/code&gt; and &lt;code&gt;Lazy&lt;/code&gt; are subclasses of &lt;code&gt;List&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The valid contexts are pretty much as listed in RFC 21, though to the extent that the various contexts can be considered types, they can be specified without quotes in smart matches. Also, types are not all-caps any more. We know we have a &lt;code&gt;Scalar&lt;/code&gt; type&amp;ndash;hopefully we also get types or pseudo-types like &lt;code&gt;Void&lt;/code&gt;, &lt;code&gt;List&lt;/code&gt;, etc. The &lt;code&gt;List&lt;/code&gt; type in particular is an internal type for the temporary lists that are passed around in Perl. Preflattened lists are &lt;code&gt;Eager&lt;/code&gt;, while those lists that are not preflattened are &lt;code&gt;Lazy&lt;/code&gt;. When you call &lt;code&gt;@array.specs&lt;/code&gt;, for instance, you actually get back an object of type &lt;code&gt;Lazy&lt;/code&gt;. Lists (&lt;code&gt;Lazy&lt;/code&gt; or otherwise) are internal generator objects, and in general you shouldn&amp;rsquo;t be doing operations on them, but on the arrays to which they are bound. The bound array manages its hidden generators on your behalf to &amp;ldquo;harden&amp;rdquo; the abstract list into concrete array values on demand.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-caller-pseudopackage-the-caller-pseudopackage-span&#34;&gt;&lt;span id=&#34;the_caller::_pseudopackage&#34;&gt;The &lt;code&gt;CALLER::&lt;/code&gt; pseudopackage&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Just as the &lt;code&gt;SUPER::&lt;/code&gt; pseudopackage lets you name a method somewhere in your set of superclasses, the &lt;code&gt;CALLER::&lt;/code&gt; pseudoclass lets you name a variable that is in the lexical scope of your (dynamically scoped) caller. It may not be used to create a variable that does not already exist in that lexical scope. As such, it is is primarily intended for a particular variable that &lt;em&gt;is&lt;/em&gt; known to exist in every caller&amp;rsquo;s lexical scope, namely &lt;code&gt;$_&lt;/code&gt;. Your caller&amp;rsquo;s current topic is named &lt;code&gt;$CALLER::_&lt;/code&gt;. Your caller&amp;rsquo;s current &lt;code&gt;Routine&lt;/code&gt; reference is named &lt;code&gt;&amp;amp;CALLER::_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Note again that, as a form of &lt;code&gt;caller&lt;/code&gt;, use of &lt;code&gt;CALLER::&lt;/code&gt; can prevent certain kinds of optimizations. However, if your signature uses &lt;code&gt;$CALLER::_&lt;/code&gt; as a default value, the optimizer may be able to deal with that as a special case. If you say, for instance:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub myprint (IO $handle, *@list = ($CALLER::_)) {
        print $handle: *@list;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the compiler can just turn the call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    myprint($*OUT);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;into:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    myprint($*OUT, $_);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Our earlier example of &lt;code&gt;trim&lt;/code&gt; might want to default the first argument to the caller&amp;rsquo;s &lt;code&gt;$_&lt;/code&gt;. In which case you can declare it as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub trim ( Str ?$_ is rw = $CALLER::_, Rule ?$remove = /\s+/ ) {
            s:each/^ &amp;lt;$remove&amp;gt; | &amp;lt;$remove&amp;gt; $//;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which lets you call it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trim;   # trims $_
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or even this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    trim remove =&amp;gt; /\n+/;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Do not confuse the caller&amp;rsquo;s lexical scope with the &lt;em&gt;callee&lt;/em&gt;&amp;rsquo;s lexical scope. In particular, when you put a bare block into your program that uses &lt;code&gt;$_&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @array {
        mumble { s/foo/bar/ };
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the compiler may not know whether or not the &lt;code&gt;mumble&lt;/code&gt; routine is intending to pass &lt;code&gt;$_&lt;/code&gt; as the first argument of the closure, which &lt;code&gt;mumble&lt;/code&gt; needs to do if it&amp;rsquo;s some kind of looping construct, and doesn&amp;rsquo;t need to do if it&amp;rsquo;s a one-shot. So such a bare block actually compiles down to something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    for @array {
        mumble(sub ($_ is rw = $OUTER::_) { s/foo/bar/ });
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(If you put &lt;code&gt;$CALLER::_&lt;/code&gt; there instead, it would be wrong, because that would be referring to &lt;code&gt;mumble&lt;/code&gt;&amp;rsquo;s &lt;code&gt;$_&lt;/code&gt;.)&lt;/p&gt;

&lt;p&gt;With &lt;code&gt;$OUTER::_&lt;/code&gt;, if &lt;code&gt;mumble&lt;/code&gt; passes an argument to the block, that argument becomes &lt;code&gt;$_&lt;/code&gt; each time &lt;code&gt;mumble&lt;/code&gt; calls the block. Otherwise, it&amp;rsquo;s just the same outer &lt;code&gt;$_&lt;/code&gt;, as if ordinary lexical scoping were in effect. And, indeed, if the compiler knows that &lt;code&gt;mumble&lt;/code&gt; takes a sub argument with a signature of &lt;code&gt;()&lt;/code&gt;, it may optimize it down to ordinary lexical scoping, and if it has a signature of &lt;code&gt;($)&lt;/code&gt;, it can assume it doesn&amp;rsquo;t need the default. A signature of &lt;code&gt;(?$)&lt;/code&gt; means all bets are off again.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-where-return-leave-returns-to-where-return-leave-returns-to-span&#34;&gt;&lt;span id=&#34;where_return/leave_returns_to&#34;&gt;Where &lt;code&gt;return&lt;/code&gt;/&lt;code&gt;leave&lt;/code&gt; returns to&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;A &lt;code&gt;return&lt;/code&gt; statement needs to return to where the user thinks it ought to return to. Since any block is a closure, any block is really a subroutine in disguise. But the user doesn&amp;rsquo;t generally want &lt;code&gt;return&lt;/code&gt; to return from the innermost block, but from the innermost block that was actually defined using an explicit &lt;code&gt;sub&lt;/code&gt;-ish keyword. So that&amp;rsquo;s what Perl 6 does. If it can, it will implement the &lt;code&gt;return&lt;/code&gt; internally as a simple jump to the end of the subroutine. If it can&amp;rsquo;t, it implements &lt;code&gt;return&lt;/code&gt; by throwing a control exception that is caught by the proper context frame.&lt;/p&gt;

&lt;p&gt;There will be a &lt;code&gt;leave&lt;/code&gt; function that can return from other scopes. By default it exits from the innermost block (anything matching base class &lt;code&gt;Code&lt;/code&gt;), but, as with &lt;code&gt;caller&lt;/code&gt; and &lt;code&gt;want&lt;/code&gt;, you can optionally select the scope you want to return from. It&amp;rsquo;s declared like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi leave (?$where = Code, *@value, Int +$skip, Str +$label) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which lets you say things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    leave;
    leave Block;
    leave &amp;amp;_ &amp;lt;== 1,2,3; # same as &amp;quot;return 1,2,3&amp;quot;
    leave where =&amp;gt; Parametric, value =&amp;gt; (1,2,3);
    leave Loop, label =&amp;gt; &#39;LINE&#39;, $retval
    leave { $_ ~~ Block and $_ !~ Sub } 1,2,3;
    leave () &amp;lt;== 1,2,3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As it currently stands, the parens aren&amp;rsquo;t optional on that last one, because &lt;code&gt;&amp;lt;==&lt;/code&gt; is a binary operator. You could always define yourself a &amp;ldquo;small&amp;rdquo; return, &lt;code&gt;ret&lt;/code&gt;, that leaves the innermost block:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my macro ret { &amp;quot;leave Code &amp;lt;== &amp;quot; }
    # and later...
    { ret 1,2,3 }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that unlike a &lt;code&gt;return&lt;/code&gt;, &lt;code&gt;leave&lt;/code&gt; always evaluates any return value in list context. Another thing to iron out is that the context we choose to leave must have set up an exception handler that can handle the control exception that &lt;code&gt;leave&lt;/code&gt; must in some cases throw. This seems to imply that any context must miminally catch a control exception that is bound to its own identity, since &lt;code&gt;leave&lt;/code&gt; is doing the picking, not the exception handlers.&lt;/p&gt;

&lt;h3 id=&#34;span-id-subroutine-object-methods-subroutine-object-methods-span&#34;&gt;&lt;span id=&#34;subroutine_object_methods&#34;&gt;Subroutine object methods&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;span-id-the-wrap-method-the-wrap-method-span&#34;&gt;&lt;span id=&#34;the_.wrap_method&#34;&gt;The &lt;code&gt;.wrap&lt;/code&gt; method&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;You may ask a subroutine to wrap itself up in another subroutine in place, so that calls to the original are intercepted and interpreted by the wrapper, even if access is only through the reference:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $id = $subref.wrap({
        # preprocessing here
        call;
        # postprocessing here
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;call&lt;/code&gt; built-in knows how to call the inner function that this function is wrapped around. In a void context, &lt;code&gt;call&lt;/code&gt; arranges for the return value of the wrapped routine to be returned implicitly. Alternately, you can fetch the return value yourself from &lt;code&gt;call&lt;/code&gt; and return it explicitly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $id = $subref.wrap({
        my @retval = call;
        push(@retval, &amp;quot;...and your little dog, too!&amp;quot;;
        return @retval;
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The arguments arrive in whatever form you request them, independently of how the parameters look to the wrapped routine. If you wish to modify the parameters, supply a new argument list to &lt;code&gt;call&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $id = $subref.wrap(sub (*@args) {
        call(*@args,1,2,3);
    })
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You need to be careful not to preflatten those generators, though.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;$id&lt;/code&gt; is useful for removing a particular wrapper:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $subref.unwrap($id);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We might also at some point allow a built-in &lt;code&gt;sub&lt;/code&gt;-like keyword &lt;code&gt;wrap&lt;/code&gt;. If we don&amp;rsquo;t, someone will write it anyway.&lt;/p&gt;

&lt;p&gt;There is also likely a &lt;code&gt;.wrappers&lt;/code&gt; method that represents the list of all the current wrappers of the subroutine. The ordering and manipulation of this list is beyond the scope of this document, but such activity will be necessary for anyone implementing Aspect-Oriented Programming in Perl 6.&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-assuming-method-the-assuming-method-span&#34;&gt;&lt;span id=&#34;the_.assuming_method&#34;&gt;The &lt;code&gt;.assuming&lt;/code&gt; method&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Currying is done with the &lt;code&gt;.assuming&lt;/code&gt; method. It works a bit like the &lt;code&gt;.wrap&lt;/code&gt; method, except that instead of wrapping in place, it returns a new function to you with a different signature, one in which some of the parameters are assumed to be certain values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;say ::= &amp;amp;*print.assuming(handle =&amp;gt; $*TERM);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can even curry built-in operators:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;prefix: ::= &amp;amp;infix:/ .assuming(y =&amp;gt; 2);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;(assuming here that built-in infix operators always use &lt;code&gt;$x&lt;/code&gt; and &lt;code&gt;$y&lt;/code&gt;).&lt;/p&gt;

&lt;h4 id=&#34;span-id-the-req-method-the-req-method-span&#34;&gt;&lt;span id=&#34;the_.req_method&#34;&gt;The &lt;code&gt;.req&lt;/code&gt; method&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;.req&lt;/code&gt; method returns the number of required args requested by the sub in question. It&amp;rsquo;s just a shortcut for digging down into the &lt;code&gt;signature&lt;/code&gt; trait and counting up how many required parameters there are. The count includes any invocant (or invocants, for multimethods).&lt;/p&gt;

&lt;p&gt;If you want to know how many optional arguments there are, you can do your own digging. This call is primarily for use by madmen who wish to write variants of &lt;code&gt;map&lt;/code&gt; and &lt;code&gt;reduce&lt;/code&gt; that are sensitive to the number of parameters declared for the supplied block. (Certainly the implementation of &lt;code&gt;for&lt;/code&gt; will make heavy use of this information.)&lt;/p&gt;

&lt;h3 id=&#34;span-id-subroutine-traits-subroutine-traits-span&#34;&gt;&lt;span id=&#34;subroutine_traits&#34;&gt;Subroutine traits&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;These are traits that are declared on the subroutine as a whole, not on any individual parameter.&lt;/p&gt;

&lt;h4 id=&#34;span-id-internal-traits-internal-traits-span&#34;&gt;&lt;span id=&#34;internal_traits&#34;&gt;Internal traits&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;The &lt;code&gt;signature&lt;/code&gt;, &lt;code&gt;returns&lt;/code&gt;, and &lt;code&gt;do&lt;/code&gt; traits are internal traits containing, respectively, the type signature of the parameters, the type signature of the return value, and the body of the function. Saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub Num foo (int $one, Str *@many) { return +@many[$one] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is short for saying something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo is signature( sig(int $one, Str *@many) )
            is returns( sig(Num) )
            will do { return +@many[$one] }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, it&amp;rsquo;s likely that the &amp;ldquo;do&amp;rdquo; trait handler has to set up all the linkage to pass parameters in and to trap &amp;ldquo;return&amp;rdquo; exceptions.&lt;/p&gt;

&lt;p&gt;Many of these pre-defined traits just map straight onto the container object&amp;rsquo;s attribute methods of the same name. Underneath they&amp;rsquo;re just accessors, but we use the trait notation in declarations for several reasons. For one thing, you can string a bunch of them together without repeating the original object, which might be anonymous in any event. It also gives us liberty behind the scenes to promote or demote various traits from mere properties to attributes of every object of a class. It&amp;rsquo;s one of those levels of indirection computer scientists keep talking about&amp;hellip;&lt;/p&gt;

&lt;p&gt;Going the other direction, it allows us to pretend that accessors are just another form of metadata when accessed as a trait. By the same token it allows us to transparently make our metadata active rather than passive, without rewriting our declarations. This seems useful.&lt;/p&gt;

&lt;p&gt;The basic rule of thumb is that you can use any of a container&amp;rsquo;s &lt;code&gt;rw&lt;/code&gt; methods as if it were a trait. For subroutine containers, the example above really turns into something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    BEGIN {
        &amp;amp;foo.signature = sig(int $one, Str *@many);
        &amp;amp;foo.returns = sig(Num);
        &amp;amp;foo.do = { return +@many[$one] }
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-is-rw-is-rw-span-1&#34;&gt;&lt;span id=&#34;is_rw&#34;&gt;&lt;code&gt;is rw&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This trait identifies lvalue subs or methods. See the section on lvalue subs below.&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-parsed-rule-is-parsed-rule-span&#34;&gt;&lt;span id=&#34;is_parsed(&lt;rule&gt;)&amp;ldquo;&amp;gt;&lt;code&gt;is parsed(&amp;lt;rule&amp;gt;)&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This trait binds a macro to a grammar rule for parsing it. The grammar rule is invoked as soon as the initial keyword is seen and before anything else is parsed, so you can completely change the grammar on the fly. For example, the &lt;code&gt;sig()&lt;/code&gt; function above might well invoke special parsing rules on its arguments, since what is inside is not an ordinary expression.&lt;/p&gt;

&lt;p&gt;In the absence of an explicit &amp;lt;is parsed&amp;gt; trait, a macro&amp;rsquo;s arguments are parsed with whatever &lt;code&gt;macro&lt;/code&gt; rule is in effect, by default the standard &lt;code&gt;Perl::macro&lt;/code&gt;.&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-cloned-begin-is-cloned-begin-span&#34;&gt;&lt;span id=&#34;is_cloned(begin)&#34;&gt;&lt;code&gt;is cloned(&amp;quot;BEGIN&amp;quot;)&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;Perhaps this is an alternate way of specifying the parsing and semantics of a macro or function. Or perhaps not. Just an idea for now&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-cached-is-cached-span&#34;&gt;&lt;span id=&#34;is_cached&#34;&gt;&lt;code&gt;is cached&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This is the English translation of what some otherwise sane folks call &amp;ldquo;memoization&amp;rdquo;. This trait asserts that Perl can do automatic caching of return values based on the assumption that, for any particular set of arguments, the return value is always the same. It can dramatically speed up certain kinds of recursive functions that shouldn&amp;rsquo;t have been written recursively in the first place. &lt;code&gt;;-)&lt;/code&gt;&lt;/p&gt;

&lt;h4 id=&#34;span-id-is-inline-is-inline-span&#34;&gt;&lt;span id=&#34;is_inline&#34;&gt;&lt;code&gt;is inline&lt;/code&gt;&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;This says you think performance would be enhanced if the code were inlined into the calling code. Of course, it also constitutes a promise that you&amp;rsquo;re not intending to redefine it or wrap it or do almost anything else fancy with it, such as expecting it to get called by a method dispatcher. In early versions of Perl 6, it&amp;rsquo;s likely to be completely ignored, I suspect. (If not, it&amp;rsquo;s likely to be completely broken&amp;hellip;)&lt;/p&gt;

&lt;h4 id=&#34;span-id-pre-post-first-last-etc-pre-post-first-last-etc-span&#34;&gt;&lt;span id=&#34;pre/post/first/last/etc.&#34;&gt;&lt;code&gt;PRE&lt;/code&gt;/&lt;code&gt;POST&lt;/code&gt;/&lt;code&gt;FIRST&lt;/code&gt;/&lt;code&gt;LAST&lt;/code&gt;/etc.&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;These all-caps traits are generally set from the inside of a subroutine as special blocks. &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;LAST&lt;/code&gt; are expected to have side effects. &lt;code&gt;PRE&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; are expected to not have side effects, but return a boolean value indicating whether pre/post conditions have been met. If you declare any &lt;code&gt;PRE&lt;/code&gt; or &lt;code&gt;POST&lt;/code&gt; conditions, your routine will automatically be wrapped in a wrapper that evaluates them according to Design-by-Contract principles (ORing preconditions, ANDing postconditions).&lt;/p&gt;

&lt;p&gt;Note that the actual &amp;ldquo;first&amp;rdquo; or &amp;ldquo;last&amp;rdquo; property attached to a subroutine may well be a list of &lt;code&gt;FIRST&lt;/code&gt; or &lt;code&gt;LAST&lt;/code&gt; blocks, since there can be more than one of them.&lt;/p&gt;

&lt;h3 id=&#34;span-id-overriding-builtins-overriding-built-ins-span&#34;&gt;&lt;span id=&#34;overriding_builtins&#34;&gt;Overriding built-ins&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;All built-in functions that can be overridden are either multimethods or global subroutines. To override one of these, just declare your own subroutine of that name in your current package or lexical scope. For instance, the standard non-filehandle print function may well be declared as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *print (*@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Just declare your own sub:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub print (*@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to override all &lt;code&gt;print&lt;/code&gt; multimethods in the current package, or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub print (*@list) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to override in the current lexical scope.&lt;/p&gt;

&lt;p&gt;To override or wrap a built-in function for everyone (dangerous), you have to play with the globally named version, but we&amp;rsquo;re not going to tell you how to do that. If you can&amp;rsquo;t figure it out, you shouldn&amp;rsquo;t be doing it.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-subs-with-special-parsing-subs-with-special-parsing-span&#34;&gt;&lt;span id=&#34;subs_with_special_parsing&#34;&gt;Subs with special parsing&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Any macro can have special parsing rules if you use the &lt;code&gt;is parsed&lt;/code&gt; trait. But some subs are automatically treated specially.&lt;/p&gt;

&lt;h4 id=&#34;span-id-operator-subroutines-operator-subroutines-span&#34;&gt;&lt;span id=&#34;operator_subroutines&#34;&gt;Operator subroutines&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;In Perl 6, operators are just subroutines with special names. When you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    -$a + $b
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;re really doing this internally:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    infix:+( prefix:-($a), $b)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Operator names start with one of four names followed by a colon:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    prefix:     a unary prefix operator
    infix:      a binary infix operator
    postfix:    a binary suffix operator
    circumfix:  a bracketing operator
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Everything after the colon and up to the next whitespace or left parenthesis will be taken as the spelling of the actual operator. Unicode is specifically allowed. The null operator is not allowed, so if the first thing after the colon is a left parenthesis, it is part of the operator, and if the first thing is whitespace, it&amp;rsquo;s an illegal name. Boom!&lt;/p&gt;

&lt;p&gt;You can make your own lexically scoped operators like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub postfix:! (Int $x) { return factorial($x) }
    print 5!, &amp;quot;\n&amp;quot;;     # print 120
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can use a newly declared operator recursively as soon as its name is introduced, including in its own definition:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub postfix:! (Int $x) { $x&amp;lt;=1 ?? 1 :: $x*($x-1)! }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;You can declare multimethods that create new syntax like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi postfix:! (Int $x) { $x&amp;lt;=1 ?? 1 :: $x*($x-1)! }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;However, regardless of the scope of the name, the new &lt;em&gt;syntax&lt;/em&gt; is considered to be a lexically scoped declaration, and is only valid after the name is declared (or imported) and after any precedence traits have been parsed.&lt;/p&gt;

&lt;p&gt;If you want to specify a precedence, you always do it relative to some existing operator:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi infix:coddle   (PDL $a, PDL $b) is equiv(&amp;amp;infix:+) { ... }
    multi infix:poach    (PDL $a, PDL $b) is looser(&amp;amp;infix:+) { ... }
    multi infix:scramble (PDL $a, PDL $b) is tighter(&amp;amp;infix:+) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you base a tighter operator on a looser one, or a looser one on a tighter one, you don&amp;rsquo;t get back to where you were. It always goes into the cracks no matter how many times you derive.&lt;/p&gt;

&lt;p&gt;Just a note on implementation: if you&amp;rsquo;ve played with numerically oriented precedence tables in the past, and are thinking, &amp;ldquo;but he&amp;rsquo;ll run out of bits in his number eventually.&amp;rdquo; The answer to that is that we don&amp;rsquo;t use precedence numbers. The actual precedence level can be represented internally by an arbitrarily long string of bytes that are compared byte by byte. When you make a tighter or looser operator, the string just gets one byte longer. A looser looser looser looser &lt;code&gt;infix:*&lt;/code&gt; is still tighter than a tighter tighter tighter tighter &lt;code&gt;infix:+&lt;/code&gt;, because the string comparison bails out on the first byte. The first byte compares the built-in multiplication operator against the built-in addition operator, and those are already different, so we don&amp;rsquo;t have to compare any more.&lt;/p&gt;

&lt;p&gt;However, two operators derived by the same path have the same precedence. All binary operators of a given precedence level are assumed to be left associative unless declared otherwise with an &lt;code&gt;assoc(&#39;right&#39;)&lt;/code&gt; or &lt;code&gt;assoc(&#39;non&#39;)&lt;/code&gt; trait. (Unaries pay no attention to associativity&amp;ndash;they always go from the outside in.)&lt;/p&gt;

&lt;p&gt;This may sound complicated, and it is, if you&amp;rsquo;re implementing it internally. But from the user&amp;rsquo;s point of view, it&amp;rsquo;s much less complicated than trying to keep track of numeric precedence levels yourself. By making the precedence levels relative to existing operators, we keep the user from having to think about how to keep those cracks open. And most user-defined operators will have exactly the same precedence as something built-in anyway. Not to mention the fact that it&amp;rsquo;s just plain better documentation to say that an operator works like a familiar operator such as &amp;ldquo;&lt;code&gt;+&lt;/code&gt;&amp;rdquo;. Who the heck can remember what precedence level 17 is, anyway?&lt;/p&gt;

&lt;p&gt;If you don&amp;rsquo;t specify a precedence on an operator, it will default to something reasonable. A named unary operator, whether prefix or postfix, will default to the same precedence as other named unary operators like &lt;code&gt;abs()&lt;/code&gt;. Symbolic unaries default to the same precedence as unary &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt; (hence the &lt;code&gt;!&lt;/code&gt; in our factorial example is tighter than the &lt;code&gt;*&lt;/code&gt; of multiplication.) Binaries default to the same precedence as binary &lt;code&gt;+&lt;/code&gt; or &lt;code&gt;-&lt;/code&gt;. So in our &lt;code&gt;coddle&lt;/code&gt; example above, the &lt;code&gt;is equiv(&amp;amp;infix::+)&lt;/code&gt; is completely redundant.&lt;/p&gt;

&lt;p&gt;Unless it&amp;rsquo;s completely wrong. For multimethods, it&amp;rsquo;s an error to specify two different precedences for the same name. Multimethods that overload an existing name will be assumed to have the same precedence as the existing name.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll note that the rules for the scope of syntax warping are similar to those for macros. In essence, these definitions are macros, but specialized ones. If you declare one as a macro, the body is executed at compile time, and returns a string, a parse tree, or a closure just as a macro would:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    # define Pascal comments:
    macro circumfix:(**) () is parsed(/.*?/ { &amp;quot;&amp;quot; }
                                # &amp;quot;Comment? What comment?&amp;quot;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A circumfix operator is assumed to be split symmetrically between prefix and postfix. In this case the circumfix of four characters is split exactly in two, but if you don&amp;rsquo;t want it split in the middle (which is particularly gruesome when there&amp;rsquo;s an odd number of characters) you may specify exactly where the parse rule is interpolated with a special &lt;code&gt;...&lt;/code&gt; marker, which is considered part of the name:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    macro circumfix:(*...*) () is parsed(/.*?/ { &amp;quot;&amp;quot; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The default parse rule for a circumfix is an ordinary Perl expression of lowest precedence, the same one Perl uses inside ordinary parentheses. The defaults for other kinds of operators depend on the precedence of the operator, which may or may not be reflected in the actual name of the grammatical rule.&lt;/p&gt;

&lt;p&gt;Note that the ternary operator &lt;code&gt;??::&lt;/code&gt; has to be parsed as an infix &lt;code&gt;??&lt;/code&gt; operator with a special parsing rule to find the associated &lt;code&gt;::&lt;/code&gt; part. I&amp;rsquo;m not gonna explain that here, partly because user-defined ternary operators are discouraged, and partly because I haven&amp;rsquo;t actually bothered to figure out the details yet. This Apocalypse is already late enough.&lt;/p&gt;

&lt;p&gt;Also please note that it&amp;rsquo;s perfectly permissible (but not extremely expeditious) to rapidly reduce the Perl grammar to a steaming pile of gopher guts by redefining built-in operators such as commas or parentheses.&lt;/p&gt;

&lt;h4 id=&#34;span-id-named-unaries-named-unaries-span&#34;&gt;&lt;span id=&#34;named_unaries&#34;&gt;Named unaries&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As in Perl 5, a named unary operator by default parses with the same precedence as all other named unary operators like &lt;code&gt;sleep&lt;/code&gt; and &lt;code&gt;rand&lt;/code&gt;. Any sub declared with a single scalar argument counts as a named unary, not just explicit operator definitions. So it doesn&amp;rsquo;t really matter whether you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub plaster ($x) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub prefix:plaster ($x) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;h4 id=&#34;span-id-argumentless-subs-argumentless-subs-span&#34;&gt;&lt;span id=&#34;argumentless_subs&#34;&gt;Argumentless subs&lt;/span&gt;&lt;/h4&gt;

&lt;p&gt;As in Perl 5, a 0-ary subroutine (one with a &lt;code&gt;()&lt;/code&gt; signature) parses without looking for any argument at all, much like the &lt;code&gt;time&lt;/code&gt; built-in. (An optional pair of empty parens are allowed on the call, as in &lt;code&gt;time()&lt;/code&gt;.) Constant subs with a null signature will likely be inlined as they are in Perl 5, though the preferred way to declare constants will be as standard variables with the &lt;code&gt;is constant&lt;/code&gt; trait.&lt;/p&gt;

&lt;h3 id=&#34;span-id-matching-of-forward-declarations-matching-of-forward-declarations-span&#34;&gt;&lt;span id=&#34;matching_of_forward_declarations&#34;&gt;Matching of forward declarations&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;If you define a subroutine for which you earlier had a stub declaration, its signature and traits must match the stub&amp;rsquo;s subroutine signature and traits, or it will be considered to be declaring a different subroutine of the same name, which may be any of illegal, immoral, or fattening. In the case of standard subs, it would be illegal, but in the case of multimethods, it would merely be fattening. (Well, you&amp;rsquo;d also get a warning if you called the stub instead of the &amp;ldquo;real&amp;rdquo; definition.)&lt;/p&gt;

&lt;p&gt;The declaration and the definition should have the same defaults. That does not just mean that they should merely &lt;em&gt;look&lt;/em&gt; the same. If you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    our $x = 1;
    sub foo ($y = $x) {...}             # default to package var

    {
        my $x = 2;
        sub foo ($y = $x) { print $y }  # default to lexical var
        foo();
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then what you&amp;rsquo;ve said is an error if the compiler can catch it, and is erroneous if it can&amp;rsquo;t. In any event, the program may correctly print any of these values:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1
    2
    1.5
    12
    1|2
    (1,2)
    Thbthbthbthth...
    1|2|1.5|12|(1|2)|(1,2)|Thbthbthbthth...
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-lvalue-subroutines-lvalue-subroutines-span&#34;&gt;&lt;span id=&#34;lvalue_subroutines&#34;&gt;Lvalue subroutines&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;The purpose of an lvalue subroutine is to return a &amp;ldquo;proxy&amp;rdquo;&amp;ndash;that is, to return an object that represents a &amp;ldquo;single evaluation&amp;rdquo; of the subroutine while actually allowing multiple accesses within a single transaction. An lvalue subroutine has to pretend to be a storage location, with all the rights, privileges, and responsibilities pertaining thereto. But it has to do this without repeatedly calculating the &lt;em&gt;identity&lt;/em&gt; of whatever it is you&amp;rsquo;re actually modifying underneath&amp;ndash;especially if that calculation entails side effects. (Or is expensive&amp;ndash;meaning that it has the side-effect of chewing up computer resources&amp;hellip;)&lt;/p&gt;

&lt;p&gt;An lvalue subroutine is declared with the &lt;code&gt;is rw&lt;/code&gt; trait. The compiler will take whatever steps necessary to ensure that the returned value references a storage location that can be treated as an lvalue. If you merely return a variable (such as an object attribute), that variable can act as its own proxy. You can also return the result of a call to another lvalue subroutine or method. If you need to do pre- or post-processing on the &amp;ldquo;public&amp;rdquo; value, however, you&amp;rsquo;ll need to return a tied proxy variable.&lt;/p&gt;

&lt;p&gt;But if you know how hard it is to tie variables in Perl 5, you&amp;rsquo;ll be pleasantly surprised that we&amp;rsquo;re providing some syntactic relief for the common cases. In particular, you can say something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my sub thingie is rw {
        return my $var
            is Proxy( for =&amp;gt; $hidden_var,
                      FETCH =&amp;gt; { ... },
                      STORE =&amp;gt; { ... },
                      TEMP  =&amp;gt; { ... },
                      ...
            );
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in order to generate a tie class on the fly, and only override the standard proxy methods you need to, while letting others default to doing the standard behavior. This is particularly important when proxying things like arrays and hashes that have oodles of potential service routines.&lt;/p&gt;

&lt;p&gt;But in particular, note that we want to be able to temporize object attributes, which is why there&amp;rsquo;s a &lt;code&gt;TEMP&lt;/code&gt; method in our proxy. In Perl 5 you could only temporize (localize) variables. But we want accessors to be usable exactly as if they were variables, which implies that temporization is part of the interface. When you use a &lt;code&gt;temp&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; context specifier:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    temp $obj.foo = 42;
    let $obj.bar = 43;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the proxy attribute returned by the lvalue method needs to know how to temporize the value. More precisely, it needs to know how to restore the old value at the end of the dynamic scope. So what the &lt;code&gt;.TEMP&lt;/code&gt; method returns is a closure that knows how to restore the old value. As a closure, it can simply keep the old value in a lexical created by &lt;code&gt;.TEMP&lt;/code&gt;. The same method is called for both &lt;code&gt;temp&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;. The only difference is that &lt;code&gt;temp&lt;/code&gt; executes the returned closure unconditionally at end of scope, while &lt;code&gt;let&lt;/code&gt; executes the closure conditionally only upon failure (where failure is defined as throwing a non-control exception or returning undef in scalar context or &lt;code&gt;()&lt;/code&gt; in list context).&lt;/p&gt;

&lt;p&gt;After the &lt;code&gt;.TEMP&lt;/code&gt; method returns the closure, you never have to worry about it again. The &lt;code&gt;temp&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt; will squirrel away the closure and execute it later when appropriate. That&amp;rsquo;s where the real power of &lt;code&gt;temp&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; comes from&amp;ndash;they&amp;rsquo;re fire-and-forget operators.&lt;/p&gt;

&lt;p&gt;The standard &lt;code&gt;Scalar&lt;/code&gt;, &lt;code&gt;Array&lt;/code&gt;, and &lt;code&gt;Hash&lt;/code&gt; classes also have a &lt;code&gt;.TEMP&lt;/code&gt; method (or equivalent). So &lt;em&gt;any&lt;/em&gt; such variable can be temporized, even lexicals:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my $identity = &#39;Clark Kent&#39;;

    for @emergencies {
         temp $identity = &#39;SUPERMAN&#39;;   # still the lexical $identity
         ...
    }

    print $identity;    # prints &#39;Clark Kent&#39;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We&amp;rsquo;ll talk more about lvalues below in reference to various RFCs that espouse lvalue subs&amp;ndash;all of which were rejected. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;span-id-temporizing-any-subroutine-call-temporizing-any-subroutine-call-span&#34;&gt;&lt;span id=&#34;temporizing_any_subroutine_call&#34;&gt;Temporizing any subroutine call&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Lvalue subroutines have a special way to return a proxy that can be temporized, but sometimes that&amp;rsquo;s overkill. Maybe you don&amp;rsquo;t want an lvalue; you just want a subroutine that can do something temporarily in an rvalue context. To do that, you can declare a subroutine with a &lt;code&gt;TEMP&lt;/code&gt; block that works just like the &lt;code&gt;.TEMP&lt;/code&gt; method described earlier. The &lt;code&gt;TEMP&lt;/code&gt; block returns a closure that will be called when the &lt;em&gt;call&lt;/em&gt; to this function goes out of scope.&lt;/p&gt;

&lt;p&gt;So if you declare a function with a &lt;code&gt;TEMP&lt;/code&gt; property:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub setdefout ($x) {
        my $oldout = $*OUT;
        $*DEFOUT = $x;
        TEMP {{ $*DEFOUT = $oldout }}
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then you can call it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    temp setdefout($MYFILE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and it will automatically undo itself on scope exit. One place where this might be useful is for wrappers:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    temp &amp;amp;foo.wrap({...})
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The routine will automatically unwrap itself at the end of the current dynamic scope. A &lt;code&gt;let&lt;/code&gt; would similarly put a hypothetical wrapper in place, but keep it wrapped on success.&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;TEMP&lt;/code&gt; block is called only if you invoke the subroutine or method with &lt;code&gt;temp&lt;/code&gt; or &lt;code&gt;let&lt;/code&gt;. Otherwise the &lt;code&gt;TEMP&lt;/code&gt; block is ignored. So if you just call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    setdefout($MYFILE);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then the side-effects are permanent.&lt;/p&gt;

&lt;p&gt;That being said&amp;hellip;&lt;/p&gt;

&lt;p&gt;I don&amp;rsquo;t think we&amp;rsquo;ll actually be using explicit &lt;code&gt;TEMP&lt;/code&gt; closures all over the place, because I&amp;rsquo;d like to extend the semantics of &lt;code&gt;temp&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; such that they automatically save state of anything within their dynamic scopes. In essence, Perl writes most of the &lt;code&gt;TEMP&lt;/code&gt; methods for you, and you don&amp;rsquo;t have to worry about them unless you&amp;rsquo;re interfacing to external code or data that doesn&amp;rsquo;t know how to save its own state. (Though there&amp;rsquo;s certainly plenty of all that out in the wide world.)&lt;/p&gt;

&lt;p&gt;See appendix C for more about this line of thought.&lt;/p&gt;

&lt;h2 id=&#34;span-id-the-rfcs-the-rfcs-span&#34;&gt;&lt;span id=&#34;the_rfcs&#34;&gt;The RFCs&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;Let me reiterate that there&amp;rsquo;s little difference between an RFC accepted with major caveats and a rejected RFC from which some ideas may have been stolen. Please don&amp;rsquo;t take any of this personally&amp;ndash;I ignore author names when evaluating RFCs.&lt;/p&gt;

&lt;h3 id=&#34;span-id-rejected-rfcs-rejected-rfcs-span&#34;&gt;&lt;span id=&#34;rejected_rfcs&#34;&gt;Rejected RFCs&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-59-html-id-rfc-59-proposal-to-utilize-as-the-prefix-to-magic-subroutines-rfc-59-proposal-to-utilize-code-code-as-the-prefix-to-magic-subroutines-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/59.html&#34; id=&#34;rfc_59:_proposal_to_utilize_*_as_the_prefix_to_magic_subroutines&#34;&gt;RFC 59: Proposal to utilize &lt;code&gt;*&lt;/code&gt; as the prefix to magic subroutines&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;There are several problems with doing this.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;The &lt;code&gt;*&lt;/code&gt; prefix is already taken for two other meanings. (It indicates a completely global symbol or a splatlist.) We could come up with something else, but we&amp;rsquo;re running out of keyboard. And I don&amp;rsquo;t think it&amp;rsquo;s important enough to inflict a Unicode character on people.&lt;/li&gt;
&lt;li&gt;It would be extra clutter that conveys little extra information over what is already conveyed by all-caps.&lt;/li&gt;
&lt;li&gt;All-caps routines are a fuzzy set. Some of these routines are always called implicitly, while others are only &lt;em&gt;usually&lt;/em&gt; called implicitly. We&amp;rsquo;d have to be continually making arbitrary decisions on where to cut it off.&lt;/li&gt;
&lt;li&gt;Some routines are in the process of migrating into (or out of) the core. We don&amp;rsquo;t want to force people to rewrite their programs when that happens.&lt;/li&gt;
&lt;li&gt;People are already used to the all-caps convention.&lt;/li&gt;
&lt;li&gt;Most importantly, I have an irrational dislike for anything that resembles Python&amp;rsquo;s &lt;code&gt;__foo__&lt;/code&gt; convention. &lt;code&gt;:-)&lt;/code&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;So we&amp;rsquo;ll continue to half-heartedly reserve the all-caps space for Perl magic.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-75-html-id-rfc-75-structures-and-interface-definitions-rfc-75-structures-and-interface-definitions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/75.html&#34; id=&#34;rfc_75:_structures_and_interface_definitions&#34;&gt;RFC 75: structures and interface definitions&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;In essence, this proposal turns every subroutine call into a constructor of a parameter list object. That&amp;rsquo;s an interesting way to look at it, but the proposed notation for class declaration suffers from some problems. It&amp;rsquo;s run-time rather than compile-time, and it&amp;rsquo;s based on a value list rather than a statement list. In other words, it&amp;rsquo;s not what we&amp;rsquo;re gonna do, because we&amp;rsquo;ll have a more standard-looking way of declaring classes. (On the other hand, I think the proposed functionality can probably be modeled by suitable use of constructors.)&lt;/p&gt;

&lt;p&gt;The proposal also runs afoul of the rule that a lexically scoped variable ought generally to be declared explicitly at the beginning of its lexical scope. The parameters to subroutines will be lexically scoped in Perl 6, so there needs to be something equivalent to a &lt;code&gt;my&lt;/code&gt; declaration at the beginning.&lt;/p&gt;

&lt;p&gt;Unifying parameter passing with &lt;code&gt;pack&lt;/code&gt;/&lt;code&gt;unpack&lt;/code&gt; syntax is, I think, a false economy. &lt;code&gt;pack&lt;/code&gt; and &lt;code&gt;unpack&lt;/code&gt; are serialization operators, while parameter lists are about providing useful aliases to caller-provided data without any implied operation. The fact that both deal with lists of values on some level doesn&amp;rsquo;t mean we should strain to make them the same on every level. That will merely make it impossible to implement subroutine calls efficiently, particularly since the Parrot engine is register-based, not stack-based as this RFC assumes. Register-based machines don&amp;rsquo;t access parameters by offsets from the stack pointer.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-107-html-id-rfc-107-lvalue-subs-should-receive-the-rvalue-as-an-argument-rfc-107-lvalue-subs-should-receive-the-rvalue-as-an-argument-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/107.html&#34; id=&#34;rfc_107:_lvalue_subs_should_receive_the_rvalue_as_an_argument&#34;&gt;RFC 107: lvalue subs should receive the rvalue as an argument&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This would make it hard to dynamically scope an attribute. You&amp;rsquo;d have to call the method twice&amp;ndash;once to get the old value, and once to set the new value.&lt;/p&gt;

&lt;p&gt;The essence of the lvalue problem is that you&amp;rsquo;d like to separate the identification of the object from its manipulation. Forcing the new value into the same argument list as arguments meant to identify the object is going to mess up all sorts of things like assignment operators and temporization.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-118-html-id-rfc-118-lvalue-subs-parameters-explicit-assignment-and-wantarray-changes-rfc-118-lvalue-subs-parameters-explicit-assignment-and-code-wantarray-code-changes-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/118.html&#34; id=&#34;rfc_118:_lvalue_subs:_parameters,_explicit_assignment,_and_wantarray()_changes&#34;&gt;RFC 118: lvalue subs: parameters, explicit assignment, and &lt;code&gt;wantarray()&lt;/code&gt; changes&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This proposal has a similar problem in that it doesn&amp;rsquo;t separate the identity from the operation.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-132-html-id-rfc-132-subroutines-should-be-able-to-return-an-lvalue-rfc-132-subroutines-should-be-able-to-return-an-lvalue-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/132.html&#34; id=&#34;rfc_132:_subroutines_should_be_able_to_return_an_lvalue&#34;&gt;RFC 132: Subroutines should be able to return an lvalue&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This RFC proposes a keyword &lt;code&gt;lreturn&lt;/code&gt; to return an lvalue.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d rather the lvalue hint be available to the compiler, I think, even if the body has not been compiled yet. So it needs to be declared in the signature somehow. The compiler would like to know whether it&amp;rsquo;s even legal to assign to the subroutine. Plus it might have to deal with the returned value as a different sort of object.&lt;/p&gt;

&lt;p&gt;At least this proposal doesn&amp;rsquo;t confuse identification with modification. The lvalue is presumably an object with a &lt;code&gt;STORE&lt;/code&gt; method that works independently of the original arguments. But this proposal also doesn&amp;rsquo;t provide any mechanism to do postprocessing on the stored value.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-149-html-id-rfc-149-lvalue-subroutines-implicit-and-explicit-assignment-rfc-149-lvalue-subroutines-implicit-and-explicit-assignment-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/149.html&#34; id=&#34;rfc_149:_lvalue_subroutines:_implicit_and_explicit_assignment&#34;&gt;RFC 149: Lvalue subroutines: implicit and explicit assignment&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This is sort of the don&amp;rsquo;t-have-your-cake-and-don&amp;rsquo;t-eat-it-too approach. The implicit assignment doesn&amp;rsquo;t allow for virtual attributes. The explicit assignment doesn&amp;rsquo;t allow for delayed modification.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-154-html-id-rfc-154-simple-assignment-lvalue-subs-should-be-on-by-default-rfc-154-simple-assignment-lvalue-subs-should-be-on-by-default-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/154.html&#34; id=&#34;rfc_154:_simple_assignment_lvalue_subs_should_be_on_by_default&#34;&gt;RFC 154: Simple assignment lvalue subs should be on by default&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Differentiating &amp;ldquo;simple&amp;rdquo; lvalue subs is a problem. A user ought to just be able to say something fancy like&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    temp $obj.attr += 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and have it behave right, provided &lt;code&gt;.attr&lt;/code&gt; allows that.&lt;/p&gt;

&lt;p&gt;Even with:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $obj.attr = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;we have a real problem with knowing what can be done at compile time, since we might not know the exact type of &lt;code&gt;$obj&lt;/code&gt;. Even if &lt;code&gt;$obj&lt;/code&gt; is declared with a type, it&amp;rsquo;s only an &amp;ldquo;isa&amp;rdquo; assertion. We could enforce things based on the declared type with the assumption that a derived type won&amp;rsquo;t violate the contract, but I&amp;rsquo;m a little worried about large semantic changes happening just because one adds an optional type declaration. It seems safer that the untyped method behave just like the typed method, only with run-time resolution rather than compile-time resolution. Anything else would violate the principle of least surprise. So if it is not known whether &lt;code&gt;$obj.attr&lt;/code&gt; can be an lvalue, it must be assumed that it can, and compiled with a mechanism that will work consistently, or throw a run-time exception if it can&amp;rsquo;t.&lt;/p&gt;

&lt;p&gt;The same goes for argument lists, actually. &lt;code&gt;$obj.meth(@foo)&lt;/code&gt; can&amp;rsquo;t assume that &lt;code&gt;@foo&lt;/code&gt; is either scalar or list until it knows the signature of the &lt;code&gt;.meth&lt;/code&gt; method. And it probably doesn&amp;rsquo;t know that until dispatch time, unless it can analyze the entire set of available methods in advance. In general, modification of an invalid lvalue (an object without a write method, essentially) has to be handled by throwing an exception. This may well mean that it is illegal for a method to have an &lt;code&gt;rw&lt;/code&gt; parameter!&lt;/p&gt;

&lt;p&gt;Despite the fact that there are similar constraints on the arguments and on the lvalue, we cannot combine them, because the values are needed at different times. The arguments are needed when identifying the object to modify, since lvalue objects often act as proxies for other objects elsewhere.` Think of subscripting an array, for instance, where the subscripts function as arguments, so you can say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $elem := @a[0][1][2];
    $elem = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Likewise we should be able to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $ref := a(0,1,2);
    $ref = 3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and have &lt;code&gt;$ref&lt;/code&gt; be the lvalue returned by &lt;code&gt;a()&lt;/code&gt;. It&amp;rsquo;s the implied &amp;ldquo;&lt;code&gt;is rw&lt;/code&gt;&amp;rdquo; on the left that causes &lt;code&gt;a()&lt;/code&gt; to return an lvalue, just as a subroutine parameter that is &amp;ldquo;&lt;code&gt;rw&lt;/code&gt;&amp;rdquo; causes lvaluehood to be passed to its actual argument.&lt;/p&gt;

&lt;p&gt;Since we can&amp;rsquo;t in general know at compile time whether a method is &amp;ldquo;simple&amp;rdquo; or not, we don&amp;rsquo;t know whether it&amp;rsquo;s appropriate to treat an assignment as an extra argument or as a parameter to an internal &lt;code&gt;STORE&lt;/code&gt; method. We have to compile the call assuming there&amp;rsquo;s a separate &lt;code&gt;STORE&lt;/code&gt; method on the lvalue object. Which means there&amp;rsquo;s no such thing as a &amp;ldquo;simple&amp;rdquo; lvalue from the viewpoint of the caller.&lt;/p&gt;

&lt;h3 id=&#34;span-id-accepted-rfcs-accepted-rfcs-span&#34;&gt;&lt;span id=&#34;accepted_rfcs&#34;&gt;Accepted RFCs&lt;/span&gt;&lt;/h3&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-168-html-id-rfc-168-builtin-functions-should-be-functions-rfc-168-built-in-functions-should-be-functions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/168.html&#34; id=&#34;rfc_168:_builtin_functions_should_be_functions&#34;&gt;RFC 168: Built-in functions should be functions&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This all seems fine to me in principle. All built-in functions and multimethods exist in the &amp;ldquo;&lt;code&gt;*&lt;/code&gt;&amp;rdquo; space, so &lt;code&gt;system()&lt;/code&gt; is really &lt;code&gt;&amp;amp;*system();&lt;/code&gt; in Perl 6 .&lt;/p&gt;

&lt;p&gt;We do need to consider whether &amp;ldquo;&lt;code&gt;sub system&lt;/code&gt;&amp;rdquo; changes the meaning of calls to &lt;code&gt;system()&lt;/code&gt; earlier in the lexical scope. Or are built-ins imported as third-class keywords like &lt;code&gt;lock()&lt;/code&gt; is in Perl 5? It&amp;rsquo;s probably best if we detect the ambiguous situation and complain. A &amp;ldquo;late&amp;rdquo; definition of &lt;code&gt;system()&lt;/code&gt; could be considered a redefinition, in fact, any definition of &lt;code&gt;system()&lt;/code&gt; could be considered a redefinition. We could require &amp;ldquo;&lt;code&gt;is redefined&lt;/code&gt;&amp;rdquo; or some such on all such redefinitions.&lt;/p&gt;

&lt;p&gt;The &amp;ldquo;&lt;code&gt;lock&lt;/code&gt;&amp;rdquo; situation arises when we add a new built-in, however. Do we want to force people to add in an &amp;ldquo;&lt;code&gt;is redefined&lt;/code&gt;&amp;rdquo; where they didn&amp;rsquo;t have to before? Worse, if their definition of &amp;ldquo;&lt;code&gt;lock&lt;/code&gt;&amp;rdquo; is retroactive to the front of the file, merely adding &amp;ldquo;&lt;code&gt;sub lock is redefined&lt;/code&gt;&amp;rdquo; is not necessarily good enough to become retroactive.&lt;/p&gt;

&lt;p&gt;This is not a problem with &lt;code&gt;my&lt;/code&gt; subs, since they have to be declared in advance. If we defer committing compilation of package-named subs to the end of the compilation unit, then we can just say that the current package overrides the &amp;ldquo;&lt;code&gt;*&lt;/code&gt;&amp;rdquo; package. All built-ins become &amp;ldquo;third class&amp;rdquo; keywords in that case. But does that mean that a built-in can&amp;rsquo;t override ordinary function-call syntax? Built-ins should at least be able to be used as list operators, but in Perl 5 you couldn&amp;rsquo;t use your own sub as a list operator unless it was predeclared. Maybe we could relax that.&lt;/p&gt;

&lt;p&gt;Since there are no longer any barewords, we can assume that any unrecognized word is a subroutine or method call of some sort even in the absence of parens. We could assume all such words are list operators. That works okay for overriding built-ins that actually *are* list operators&amp;ndash;but not all of them are. If you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print rand 1, 2;
    sub rand (*@x) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then it cannot be determined whether &lt;code&gt;rand&lt;/code&gt; should be parsed as a unary operator &lt;code&gt;($)&lt;/code&gt; or as a list operator &lt;code&gt;(*@)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;Perl has to be able to parse its unary operators. So that code must be interpreted as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print rand(1), 2;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At that point in the parse, we&amp;rsquo;ve essentially committed to a signature of &lt;code&gt;($)&lt;/code&gt;, which makes the subsequent sub declaration a redefinition with a different signature, which is illegal. But when someone says:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print foo 1, 2;
    sub foo (*@x) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s legal until someone defines &lt;code&gt;&amp;amp;*foo($)&lt;/code&gt;. We can protect ourselves from the backward compatibility problem by use of parens. When there are parens, we can probably defer the decision about the binding of its arguments to the end of the compilation. So either of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print foo(1), 2;
    sub foo (*@x) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print foo(1, 2);
    sub foo (*@x) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;remain legal even if we later add a unary &lt;code&gt;&amp;amp;*foo&lt;/code&gt; operator, as long as no other syntactic monkey business is going on with the functions args. So I think we keep the rule that says post-declared subs have to be called using parens, even though we could theoretically relax it.&lt;/p&gt;

&lt;p&gt;On the other hand, this means that any unrecognized word followed by a list may unambiguously be taken to be a multimethod being called as a list operaotr. After all, we don&amp;rsquo;t know when someone will be adding more multimethods. I currently think this is a feature, but I could be sadly mistaken. It has happened once or twice in the past.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-57-html-id-rfc-57-subroutine-prototypes-and-parameters-rfc-57-subroutine-prototypes-and-parameters-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/57.html&#34; id=&#34;rfc_57:_subroutine_prototypes_and_parameters&#34;&gt;RFC 57: Subroutine prototypes and parameters&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;We ended up with something like this proposal, though with some differences. Instead of &lt;code&gt;=&lt;/code&gt;, we&amp;rsquo;re using &lt;code&gt;=&amp;gt;&lt;/code&gt; to specify names because it&amp;rsquo;s a pair constructor in Perl 6, so there&amp;rsquo;s little ambiguity with positional parameters. Unless a positional parameter is explicitly declared with a &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Hash&lt;/code&gt; type, it&amp;rsquo;s assumed not to be interested in named arguments.&lt;/p&gt;

&lt;p&gt;Also, as the RFC points out, use of &lt;code&gt;=&lt;/code&gt; would be incompatible with lvalue subs, which we&amp;rsquo;re supporting.&lt;/p&gt;

&lt;p&gt;The RFC allows for mixing of positional and named parameters, both in declaration and in invocation. I think such a feature would provide far more confusion than functionality, so we won&amp;rsquo;t allow it. You can always process your own argument list if you want to. You could even install your own signature handler in place of Perl&amp;rsquo;s.&lt;/p&gt;

&lt;p&gt;The RFC suggests treating the first parameter with a default as the first optional parameter. I think I&amp;rsquo;d rather mark optional parameters explicitly, and then disallow defaults on required parameters as a semantic constraint.&lt;/p&gt;

&lt;p&gt;It&amp;rsquo;s also suggested that something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub waz ($one, $two, 
             $three = add($one, $two), 
             $four  = add($three, 1)) {
        ...
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;be allowed, where defaults can refer back to previous parameters. It seems as though we could allow that, if we assume that symbols are introduced in signatures as soon as they are seen. That would be consistent with how we&amp;rsquo;ve said &lt;code&gt;my&lt;/code&gt; variables are introduced. It does mean that a prototype that defaults to the prior &lt;code&gt;$_&lt;/code&gt; would have to be written like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $myclosure = sub ($_ = $OUTER::_) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, that&amp;rsquo;s exactly what:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $myclosure = { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;means in the absence of placeholder variables, so the situation will likely not arise all that often. So I&amp;rsquo;d say yes, defaults should be able to refer back to previous parameters in the same signature, unless someone thinks of a good reason not to.&lt;/p&gt;

&lt;p&gt;As explained in Apocalypse 4, &lt;code&gt;$OUTER::&lt;/code&gt; is for getting at an outer lexical scope. This ruling about formal parameters means that, effectively, the lexical scope of a subroutine &amp;ldquo;starts to begin&amp;rdquo; where the formal parameters are declared, and &amp;ldquo;finishes beginning&amp;rdquo; at the opening brace. Whether a given symbol in the signature actually belongs to the inner scope or the outer scope depends on whether it&amp;rsquo;s already been introduced by the inner scope. Our sub above needed &lt;code&gt;$OUTER::_&lt;/code&gt; because &lt;code&gt;$_&lt;/code&gt; had already been introduced as the name of the first argument. Had some other name been introduced, &lt;code&gt;$_&lt;/code&gt; might still be taken to refer to the outer &lt;code&gt;$_&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $myclosure = sub ($arg = $_) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If so, use of &lt;code&gt;$OUTER::_&lt;/code&gt; would be erroneous in that case, because the subroutine&amp;rsquo;s implicit &lt;code&gt;$_&lt;/code&gt; declaration wouldn&amp;rsquo;t happen till the opening curly, and instead of getting &lt;code&gt;$OUTER::_&lt;/code&gt;, the user would unexpectedly be getting &lt;code&gt;$OUTER::OUTER::_&lt;/code&gt;, as it were. So instead, we&amp;rsquo;ll say that the implicit introduction of the new sub&amp;rsquo;s &lt;code&gt;$_&lt;/code&gt; variable &lt;em&gt;always&lt;/em&gt; happens after the &lt;code&gt;&amp;lt;subintro&amp;gt;&lt;/code&gt; and before the &lt;code&gt;&amp;lt;signature&amp;gt;&lt;/code&gt;, so any use of &lt;code&gt;$_&lt;/code&gt; as a default in a signature or as an argument to a property can only refer to the subroutine&amp;rsquo;s own topic, if any. To refer to any external &lt;code&gt;$_&lt;/code&gt; you must say either &lt;code&gt;$CALLER::_&lt;/code&gt; or &lt;code&gt;$OUTER::_&lt;/code&gt;. This approach seems much cleaner.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-160-html-id-rfc-160-functioncall-named-parameters-with-compiler-optimizations-rfc-160-function-call-named-parameters-with-compiler-optimizations-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/160.html&#34; id=&#34;rfc_160:_functioncall_named_parameters_(with_compiler_optimizations)&#34;&gt;RFC 160: Function-call named parameters (with compiler optimizations)&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;For efficiency, we have to be able to hoist the semantics from the signature into the calling module when that&amp;rsquo;s practical, and that has to happen at compile time. That means the information has to be in the signature, not embedded in a &lt;code&gt;fields()&lt;/code&gt; function within the body of the subroutine. In fact, my biggest complaint about this RFC is that it arbitrarily separates the prototype characters, the parameter names, and the variable names. That&amp;rsquo;s a recipe for things getting out of sync.&lt;/p&gt;

&lt;p&gt;Basically, this RFC has a lot of the right ideas, but just doesn&amp;rsquo;t go far enough in the signature direction, based on the (at the time) laudable notion that we were interested in keeping Perl 6 as close to Perl 5 as possible. Which turned out not to be &lt;em&gt;quite&lt;/em&gt; the case. &lt;code&gt;:-)&lt;/code&gt; Our new signatures look more hardwired than the attribute syntax proposed here, but it&amp;rsquo;s all still very hookable underneath via the sub and parameter traits. And everything is together that should be together.&lt;/p&gt;

&lt;p&gt;Although the signature is really just a trait underneath, I thought it important to have special syntax for it, just as there&amp;rsquo;s special syntax for the body of the function. Signatures are very special traits, and people like special things to look special. It&amp;rsquo;s just more of those darn psychological reasons that keep popping up in the design of Perl.&lt;/p&gt;

&lt;p&gt;Still and all, the current design is optimized for many of the same sensitivities described in this RFC.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-128-html-id-rfc-128-subroutines-extend-subroutine-contexts-to-include-name-parameters-and-lazy-arguments-rfc-128-subroutines-extend-subroutine-contexts-to-include-name-parameters-and-lazy-arguments-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/128.html&#34; id=&#34;rfc_128:_subroutines:_extend_subroutine_contexts_to_include_name_parameters_and_lazy_arguments&#34;&gt;RFC 128: Subroutines: Extend subroutine contexts to include name parameters and lazy arguments&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This RFC also has lots of good ideas, but tends to stay a little too close to Perl 5 in various areas where I&amp;rsquo;ve decided to swap the defaults around. For instance, marking reference parameters in prototypes rather than slurpy parameters in signatures, identifying lazy parameters rather than flattening, and defaulting to &lt;code&gt;rw&lt;/code&gt; (autovivifying lvalue args) rather than &lt;code&gt;constant&lt;/code&gt; (rvalue args).&lt;/p&gt;

&lt;p&gt;Context classes are handled by the automatic coercion to references within scalar context, and by type junctions.&lt;/p&gt;

&lt;p&gt;Again, I don&amp;rsquo;t buy into two-pass, fill-in-the-blanks argument processing.&lt;/p&gt;

&lt;p&gt;Placeholders are now just for argument declaration, and imply no currying. Currying on the other hand is done with an explicit &lt;code&gt;.assuming&lt;/code&gt; method, which requires named args that will be bound to the corresponding named parameters in the function being curried.&lt;/p&gt;

&lt;p&gt;Or should I say functions? When module and class writers write systems of subroutines or methods, they usually go to great pains to make sure all the parameter names are consistent. Why not take advantage of that?&lt;/p&gt;

&lt;p&gt;So currying might even be extended to classes or modules, where all methods or subs with a given argument name are curried simultaneously:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my module MyIO ::= (use IO::Module).assuming(ioflags =&amp;gt; &amp;quot;:crlf&amp;quot;);
    my class UltAnswer ::= (use Answer a,b,c).assuming(answer =&amp;gt; 42);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you curry a class&amp;rsquo;s invocant, it would turn the class into a module instead of another class, since there are no longer any methods if there are no invocants:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my module UltAnswer ::=
        (use Answer a,b,c).assuming(self =&amp;gt; new Answer: 42);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or something like that. If you think this implies that there are class and module objects that can be sufficiently introspected to do this sort of chicanery, you&amp;rsquo;d be right. On the other hand, given that we&amp;rsquo;ll have module name aliasing anyway to support running multiple versions of the same module, why not support multiple curried versions without explicit renaming of the module:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (use IO::Module).assuming(ioflags =&amp;gt; &amp;quot;:crlf&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Then for the rest of this scope, IO::Module really points to your aliased idea of IO::Module, without explicitly binding it to a different name. Well, that&amp;rsquo;s for Apocalypse 11, really&amp;hellip;&lt;/p&gt;

&lt;p&gt;One suggestion from this RFC I&amp;rsquo;ve taken to heart, which is to banish the term &amp;ldquo;prototype&amp;rdquo;. You&amp;rsquo;ll note we call them signatures now. (You may still call Perl 5&amp;rsquo;s prototypes &amp;ldquo;prototypes&amp;rdquo;, of course, because Perl 5&amp;rsquo;s prototypes really &lt;em&gt;were&lt;/em&gt; a prototype of signatures.)&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-344-html-id-rfc-344-elements-of-should-be-readonly-by-default-rfc-344-elements-of-code-code-should-be-read-only-by-default-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/344.html&#34; id=&#34;rfc_344:_elements_of_@__should_be_readonly_by_default&#34;&gt;RFC 344: Elements of &lt;code&gt;@_&lt;/code&gt; should be read-only by default&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;I admit it, I waffled on this one. Up until the last moment, I was going to reject it, because I wanted &lt;code&gt;@_&lt;/code&gt; to work exactly like it does in Perl 5 in subs without a signature. It seemed like a nice sop towards backward compatibility.&lt;/p&gt;

&lt;p&gt;But when I started writing about why I was rejecting it, I started thinking about whether a sig-less sub is merely a throwback to Perl 5, or whether we&amp;rsquo;ll see it continue as a viable Perl 6 syntax. And if the latter, perhaps it should be designed to work right rather than merely to work the same. The vast majority of subroutines in Perl 5 refrain from modifying their arguments via &lt;code&gt;@_&lt;/code&gt;, and it somehow seems wrong to punish such good deeds.&lt;/p&gt;

&lt;p&gt;So I changed my mind, and the default signature on a sub without a signature is simply &lt;code&gt;(*@_)&lt;/code&gt;, meaning that &lt;code&gt;@_&lt;/code&gt; is considered an array of constants by default. This will probably have good effects on performance, in general. If you really want to write through the &lt;code&gt;@_&lt;/code&gt; parameter back into the actual arguments, you&amp;rsquo;ll have to declare an explicit signature of &lt;code&gt;(*@_ is rw)&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;The Perl5-to-Perl6 translator will therefore need to translate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub (*@_ is rw) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;unless it can be determined that elements of &lt;code&gt;@_&lt;/code&gt; are not modified within the sub. (It&amp;rsquo;s okay to shift a constant &lt;code&gt;@_&lt;/code&gt; though, since that doesn&amp;rsquo;t change the elements passed to the call; remember that for slurpy arrays the implied &amp;ldquo;&lt;code&gt;is constant&lt;/code&gt;&amp;rdquo; or explicit &amp;ldquo;&lt;code&gt;is rw&lt;/code&gt;&amp;rdquo; distributes to the individual elements.)&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-194-html-id-rfc-194-standardise-function-pre-and-posthandling-rfc-194-standardise-function-pre-and-post-handling-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/194.html&#34; id=&#34;rfc_194:_standardise_function_pre_and_posthandling&#34;&gt;RFC 194: Standardise Function Pre- and Post-Handling&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Yes, this needs to be standardized, but we&amp;rsquo;ll be generalizing to the notion of wrappers, which can automatically keep their pre and post routines in sync, and, more importantly, keep a single lexical scope across the related pre and post processing. A wrapper is installed with the &lt;code&gt;.wrap&lt;/code&gt; method, which can have optional parameters to tell it how to wrap, and which can return an identifier by which the particular wrapper can be named when unwrapping or otherwise rearranging the wrappings. A wrapper automatically knows what function it&amp;rsquo;s wrapped around, and invoking the &lt;code&gt;call&lt;/code&gt; builtin automatically invokes the next level routine, whether that&amp;rsquo;s the actual routine or another layer of wrapper. That does matter, because with that implicit knowledge &lt;code&gt;call&lt;/code&gt; doesn&amp;rsquo;t need to be given the name of the routine to invoke.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;The implementation is dependent on what happens to typeglobs in Perl 6, how does one inspect and modify the moral equivalent of the symbol table?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;This is not really a problem, since we&amp;rsquo;ve merely split the typeglob up into separate entries.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Also: what will become of prototypes? Will it become possible to declare return types of functions?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;Yes. Note that if you do introspection on a sub ref, by default you&amp;rsquo;re going to get the signature and return type of the actual routine, not of any wrappers. There needs to be some method for introspecting the wrappers as well, but it&amp;rsquo;s not the default.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;As pointed out in [JP:HWS] certain intricacies are involved: what are the semantic of caller()? Should it see the prehooks? If yes, how?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;It seems to me that sometimes you want to see the wrappers, and sometimes you don&amp;rsquo;t. I think &lt;code&gt;caller&lt;/code&gt; needs some kind of argument that says which levels to recognize and which levels to ignore. It&amp;rsquo;s not necessarily a simple priority either. One invocation may want to find the innermost enclosing loop, while another might want the innermost enclosing &lt;code&gt;try&lt;/code&gt; block. A general matching term will be supplied on such calls, defaulting to ignore the wrappers.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;How does this relate to the proposed generalized want() [DC:RFC21]?&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;The &lt;code&gt;want()&lt;/code&gt; function can be viewed as based on &lt;code&gt;caller()&lt;/code&gt;, but with a different interface to the information available at the the particular call level.&lt;/p&gt;

&lt;p&gt;I worry that generalized wrappers will make it impossible to compile fast subroutine calls, if we always have to allow for run-time insertion of handlers. Of course, that&amp;rsquo;s no slower than Perl 5, but we&amp;rsquo;d like to do better than Perl 5. Perhaps we can have the default be to have wrappable subs, and then turn that off with specific declarations for speed, such as &amp;ldquo;&lt;code&gt;is inline&lt;/code&gt;&amp;rdquo;.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-271-html-id-rfc-271-subroutines-pre-and-post-handlers-for-subroutines-rfc-271-subroutines-pre-and-post-handlers-for-subroutines-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/271.html&#34; id=&#34;rfc_271:_subroutines_:_pre_and_post_handlers_for_subroutines&#34;&gt;RFC 271: Subroutines : Pre- and post- handlers for subroutines&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;I find it odd to propose using &lt;code&gt;PRE&lt;/code&gt; for something with side effects like flock. Of course, this RFC was written before &lt;code&gt;FIRST&lt;/code&gt; blocks existed&amp;hellip;&lt;/p&gt;

&lt;p&gt;On the other hand, it&amp;rsquo;s possible that a system of &lt;code&gt;PRE&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; blocks would need to keep &amp;ldquo;dossiers&amp;rdquo; of its own internal state independent of the &amp;ldquo;real&amp;rdquo; data. So I&amp;rsquo;m not exactly sure what the effective difference is between &lt;code&gt;PRE&lt;/code&gt; and &lt;code&gt;FIRST&lt;/code&gt;. But we can always put a &lt;code&gt;PRE&lt;/code&gt; into a lexical wrapper if we need to keep info around till the &lt;code&gt;POST&lt;/code&gt;. So we can keep &lt;code&gt;PRE&lt;/code&gt; and &lt;code&gt;POST&lt;/code&gt; with the semantics of simply returning boolean expressions, while &lt;code&gt;FIRST&lt;/code&gt; and &lt;code&gt;LAST&lt;/code&gt; are evaluated primarily for side effects.&lt;/p&gt;

&lt;p&gt;You might think that you wouldn&amp;rsquo;t need a signature on any pre or post handler, since it&amp;rsquo;s gonna be the same as the primary. However, we have to worry about multimethods of the same name, if the handlers are defined outside of the subroutine. Again, embedding PRE and POST blocks either in the routine itself or inside a wrapper around the routine should handle that. (And turning the problem into one of being able to generate a reference to a multimethod with a particular signature, in essence, doing method dispatch without actually dispatching at the end.)&lt;/p&gt;

&lt;p&gt;My gut feeling is that &lt;code&gt;$_[-1]&lt;/code&gt; is a bad place to keep the return value. With the &lt;code&gt;call&lt;/code&gt; interface we&amp;rsquo;re proposing, you just harvest the return value of &lt;code&gt;call&lt;/code&gt; if you&amp;rsquo;re interested in the return value. Or perhaps this is a good place for a return signature to actually have formal variables bound to the return values.&lt;/p&gt;

&lt;p&gt;Also, defining pre and post conditions in terms of exceptions is probably a mistake. If they&amp;rsquo;re just boolean expressions, they can be ANDed and ORed together more easily in the approved DBC fashion.&lt;/p&gt;

&lt;p&gt;We haven&amp;rsquo;t specified a declarative form of wrapper, merely a &lt;code&gt;.wrap&lt;/code&gt; method that you can call at run time. However, as with most of Perl, anything you can do at run time, you can also do at compile time, so it&amp;rsquo;d be fairly trivial to come up with a syntax that used a &lt;code&gt;wrap&lt;/code&gt; keyword in place of a &lt;code&gt;sub&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    wrap split(Regex ?$re, ?$src = $CALLER::_, ?$limit = Inf) {
        print &amp;quot;Entering split\n&amp;quot;;
        call;
        print &amp;quot;Leaving split\n&amp;quot;;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I keep mistyping &amp;ldquo;wrap&amp;rdquo; as &amp;ldquo;warp&amp;rdquo;. I suppose that&amp;rsquo;s not so far off, actually&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-21-html-id-rfc-21-subroutines-replace-wantarray-with-a-generic-c-lt-want-gt-function-rfc-21-subroutines-replace-code-wantarray-code-with-a-generic-code-want-code-function-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/21.html&#34; id=&#34;rfc_21:_subroutines:_replace_wantarray_with_a_generic_c&amp;lt;want&amp;gt;_function&#34;&gt;RFC 21: Subroutines: Replace &lt;code&gt;wantarray&lt;/code&gt; with a generic &lt;code&gt;want&lt;/code&gt; function&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Overall, I like it, except that it&amp;rsquo;s reinventing several wheels. It seems that this has evolved into a powerful method for each sub to do its own overloading based on return type. How does this play with a more declarative approach to return types? I dunno. For now we&amp;rsquo;re assuming multmethod dispatch only pays attention to argument types. We might get rid of a lot of calls to &lt;code&gt;want&lt;/code&gt; if we could dispatch on return type as well. Perhaps we could do primary dispatch on the arguments and then do tie-breaking on return type when more then one multimethod has the same parameter profile.&lt;/p&gt;

&lt;p&gt;I also worry a bit that we&amp;rsquo;re assuming an interpreter here that &lt;em&gt;can&lt;/em&gt; keep track of all the context information in a way suitable for searching by the called subroutine. When running on top of a JVM or CLR, this info might not be convenient to provide, and I&amp;rsquo;d hate to have to keep a descriptor of every call, or do some kind of double dispatch, just because the called routine &lt;em&gt;might&lt;/em&gt; want to use &lt;code&gt;want()&lt;/code&gt;, or might want to call another routine that might want to use &lt;code&gt;want&lt;/code&gt;, or so on. Maybe the situation is not that bad.&lt;/p&gt;

&lt;p&gt;I sometimes wonder if &lt;code&gt;want&lt;/code&gt; should be a method on the context object:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given caller.want {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or perhaps the two could be coalesced into a single call:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    given context { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But for the moment let&amp;rsquo;s assume for readability that there&amp;rsquo;s a &lt;code&gt;want&lt;/code&gt; function distinct from &lt;code&gt;caller&lt;/code&gt;, though with a similar signature:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi *want (?$where = &amp;amp;CALLER::_, Int +$skip = 0, Str +$label)
        returns WantContext {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;As with &lt;code&gt;caller&lt;/code&gt;, calling &lt;code&gt;want&lt;/code&gt; with no arguments looks for the context of the currently executing subroutine or method. Like &lt;code&gt;return&lt;/code&gt;, it specifically ignores bare blocks and routines interpreting bare blocks, and finds the context for the lexically enclosing explicit sub or method declaration, named by &lt;code&gt;&amp;amp;_&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;You&amp;rsquo;ll note that unlike in the proposal, we don&amp;rsquo;t pass a list to &lt;code&gt;want&lt;/code&gt;, so we don&amp;rsquo;t support the implicit &lt;code&gt;&amp;amp;&amp;amp;&lt;/code&gt; that is proposed for the arguments to &lt;code&gt;want&lt;/code&gt;. But that&amp;rsquo;s one of the re-invented wheels, anyway, so I&amp;rsquo;m not too concerned about that. What we really want is a &lt;code&gt;want&lt;/code&gt; that works well with smart matching and switch statements.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-23-html-id-rfc-23-higher-order-functions-rfc-23-higher-order-functions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/23.html&#34; id=&#34;rfc_23:_higher_order_functions&#34;&gt;RFC 23: Higher order functions&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;In general, this RFC proposes some interesting semantic sugar, but the rules are too complicated. There&amp;rsquo;s really no need for special numbered placeholders. And the special &lt;code&gt;^_&lt;/code&gt; placeholder is too confusing. Plus we really need regular sigils on our placeholder variables so we can distinguish &lt;code&gt;$^x&lt;/code&gt; from &lt;code&gt;@^x&lt;/code&gt; from &lt;code&gt;%^x&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;But the main issue is that the RFC is confusing two separate concepts (though that can be blamed on the languages this idea was borrowed from). Anyway, it turns out we&amp;rsquo;ll have an explicit pre-binding method called &lt;code&gt;.assuming&lt;/code&gt; for actual currying.&lt;/p&gt;

&lt;p&gt;We&amp;rsquo;ll make the self-declaring parameters a separate concept, called placeholder variables. They don&amp;rsquo;t curry. Some of the examples of placeholders in the RFC are actually replaced by topics and junctions in our smart matching mode, but there are still lots of great uses for placeholder variables.&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-176-html-id-rfc-176-subroutine-generic-entity-documentation-rfc-176-subroutine-generic-entity-documentation-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/176.html&#34; id=&#34;rfc_176:_subroutine_/_generic_entity_documentation&#34;&gt;RFC 176: subroutine / generic entity documentation&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;This would be trivial to do with declared traits and here docs. But it might be better to use a POD directive that is accessible to the program. An entity might even have implicit traits that bind to nearby chunks of the right sort. Maybe we could get Don Knuth to come up with something literate&amp;hellip;&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-298-html-id-rfc-298-make-subroutines-39-prototypes-accessible-from-perl-rfc-298-make-subroutines-prototypes-accessible-from-perl-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/298.html&#34; id=&#34;rfc_298:_make_subroutines&amp;#39;_prototypes_accessible_from_perl&#34;&gt;RFC 298: Make subroutines&amp;rsquo; prototypes accessible from Perl&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;While I&amp;rsquo;m all in favor of a sub&amp;rsquo;s signature being available for inspection, this RFC goes beyond that to make indirection in the signature the norm. This seems to be a solution in search of a problem. I&amp;rsquo;m not sure the confusion of the indirection is worth the ability to factor out common parameter lists. Certainly parameter lists must have introspection, but using it to &lt;em&gt;set&lt;/em&gt; the prototype seems potentially confusing. That being said, the signatures are just traits, so this may be one of those things that is permitted, but not advised, like shooting your horse in the middle of the desert, or chewing out your SO for burning dinner. Implicit declaration of lexically scoped variables will undoubtedly be considered harmful by somebody someday. [Damian says, &amp;ldquo;Me. Today.&amp;rdquo;]&lt;/p&gt;

&lt;h4 id=&#34;a-href-http-dev-perl-org-rfc-334-html-id-rfc-334-perl-should-allow-specially-attributed-subs-to-be-called-as-c-functions-rfc-334-perl-should-allow-specially-attributed-subs-to-be-called-as-c-functions-a&#34;&gt;&lt;a href=&#34;http://dev.perl.org/rfc/334.html&#34; id=&#34;rfc_334:_perl_should_allow_specially_attributed_subs_to_be_called_as_c_functions&#34;&gt;RFC 334: Perl should allow specially attributed subs to be called as C functions&lt;/a&gt;&lt;/h4&gt;

&lt;p&gt;Fine, Dan, you implement it. ;-)&lt;/p&gt;

&lt;p&gt;Did I claim I ignore the names of RFC authors? Hmm.&lt;/p&gt;

&lt;p&gt;The syntax for the suggested:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo : C_visible(&amp;quot;i&amp;quot;, &amp;quot;iii&amp;quot;) {#sub body}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;is probably a bit more verbose in real life:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my int sub foo (int $a, int $b, int $c)
         is callable(&amp;quot;C&amp;quot;,&amp;quot;Python&amp;quot;,&amp;quot;COBOL&amp;quot;) { ... }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we can&amp;rsquo;t figure out the &amp;ldquo;i&amp;rdquo; and &amp;ldquo;iii&amp;rdquo; bits from introspection of the &lt;code&gt;signature&lt;/code&gt; and &lt;code&gt;returns&lt;/code&gt; traits, we haven&amp;rsquo;t done introspection right. And if we&amp;rsquo;re gonna have an optional type system, I can&amp;rsquo;t think of a better place to use it than for interfaces to optional languages.&lt;/p&gt;

&lt;h2 id=&#34;span-id-acknowledgements-acknowledgements-span&#34;&gt;&lt;span id=&#34;acknowledgements&#34;&gt;Acknowledgements&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;This work was made possible by a grant from the Perl Foundation. I would like to thank everyone who made this dissertation possible by their generous support. So, I will&amp;hellip;&lt;/p&gt;

&lt;p&gt;Thank you all very, very, very, very much!!!&lt;/p&gt;

&lt;p&gt;I should also point out that I would have been stuck forever on some of these design issues without the repeated prodding (as in cattle) of the Perl 6 design team. So I would also like to publicly thank Allison, chromatic, Damian, Dan, Hugo, Jarkko, Gnat, and Steve. Thanks, you guys! Many of the places we said &amp;ldquo;I&amp;rdquo; above, I should have said &amp;ldquo;we&amp;rdquo;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;d like to publicly thank O&amp;rsquo;Reilly &amp;amp; Associates for facilitating the design process in many ways.&lt;/p&gt;

&lt;p&gt;I would also like to thank my wife Gloria, but not publicly.&lt;/p&gt;

&lt;h2 id=&#34;span-id-future-plans-future-plans-span&#34;&gt;&lt;span id=&#34;future_plans&#34;&gt;Future Plans&lt;/span&gt;&lt;/h2&gt;

&lt;p&gt;From here on out, the Apocalypses are probably going to be coming out in priority order rather than sequential order. The next major one will probably be Apocalypse 12, Objects, though it may take a while since (like a lot of people in Silicon Valley) I&amp;rsquo;m in negative cash flow at the moment, and need to figure out how to feed my family. But we&amp;rsquo;ll get it done eventually. Some Apocalypses might be written by other people, and some of them hardly need to be written at all. In fact, let&amp;rsquo;s write Apocalypse 7 right now&amp;hellip;&lt;/p&gt;

&lt;h1 id=&#34;span-id-apocalypse-7-formats-apocalypse-7-formats-span&#34;&gt;&lt;span id=&#34;apocalypse_7:_formats&#34;&gt;Apocalypse 7: Formats&lt;/span&gt;&lt;/h1&gt;

&lt;p&gt;Gone from the core. See Damian.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;span-id-appendix-a-rationale-for-pipe-operators-appendix-a-rationale-for-pipe-operators-span&#34;&gt;&lt;span id=&#34;appendix_a:_rationale_for_pipe_operators&#34;&gt;Appendix A: Rationale for pipe operators&lt;/span&gt;&lt;/h1&gt;

&lt;p&gt;As we pointed out in the text, the named form of passing a list has the disadvantage that you have to know what the formal parameter&amp;rsquo;s name is. We could get around that by saying that a null name maps to the slurp array. In other words, we could define a &lt;code&gt;=&amp;gt;&lt;/code&gt; unary operator that creates a null key:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff(@foo, =&amp;gt;(1,2,3))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can at least lose the outer parens in this case:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff @foo, =&amp;gt;(1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But darn it, we can&amp;rsquo;t get rid of those pesky inner parens because of the precedence of &lt;code&gt;=&amp;gt;&lt;/code&gt; with respect to comma. So perhaps it&amp;rsquo;s time for a new operator with looser precedence than comma:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stuff @foo *: 1,2,3         # * to match * zone marker
    stuff @foo +* 1,2,3         # put the * on the list side
    stuff @foo *=&amp;gt; 1,2,3        # or combine with =&amp;gt; above
    stuff @foo ==&amp;gt; 1,2,3        # maybe just lengthen =&amp;gt;
    stuff @foo &amp;lt;== 1,2,3        # except the dataflow is to the left
    stuff @foo with 1,2,3       # could use a word
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Whichever one we pick, it&amp;rsquo;d still probably want to construct a special pair internally, because we have to be able to use it indirectly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = (\@foo, &#39;*@&#39; =&amp;gt; (1,2,3));
    stuff *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But if we&amp;rsquo;re going to have a special operator to switch explicitly to the list part, it really needs to earn its keep, and do more work. A special operator could also force scalar context on the left and list context on the right. So with implied scalar context we could omit the backslash above:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = (@foo with 1,2,3);
    stuff *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That&amp;rsquo;s all well and good, and some language designers would stop right there, if not sooner. But if we think about this in relation to cascaded list operators, we&amp;rsquo;ll see a different pattern emerging. Here&amp;rsquo;s a left-to-right variant on the Schwartzian Transform:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @x := map {...} @input;
    my @y := sort {...} with @x;
    my @z := map {...} with @y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;When we think of data flowing left-to-right, it&amp;rsquo;s more like a pipe operator from a shell, except that we&amp;rsquo;re naming our pipes &lt;code&gt;@x&lt;/code&gt; and &lt;code&gt;@y&lt;/code&gt;. But it&amp;rsquo;d be nice not to have to name the temporary array values. If we do have a pipe operator in Perl, it&amp;rsquo;s not going to be &lt;code&gt;|&lt;/code&gt;, for two reasons. First, &lt;code&gt;|&lt;/code&gt; is taken for junctions. Second, piping is a big, low-precedence operation, and I want a big fat operator that will show up to the eye. Of our candidate list above, I think the big, fat arrows really stand out, and look like directed pipes. So assuming we have the &lt;code&gt;==&amp;gt;&lt;/code&gt; operator to go with the &lt;code&gt;&amp;lt;==&lt;/code&gt;, we could write our ST like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @input     ==&amp;gt;
    map {...}  ==&amp;gt;
    sort {...} ==&amp;gt;
    map {...}  ==&amp;gt;
    push my @z;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;That argues that the scalar-to-list transition operator should be &lt;code&gt;&amp;lt;==&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @x := map {...} @input;
    my @y := sort {...} &amp;lt;== @x;
    my @z := map {...} &amp;lt;== @y;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And that means this should maybe dwim:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = (@foo &amp;lt;== 1,2,3);
    stuff *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hmm.&lt;/p&gt;

&lt;p&gt;That does imply that &lt;code&gt;&amp;lt;==&lt;/code&gt; is (at least in this case) a data composition operator, unlike the &lt;code&gt;==&amp;gt;&lt;/code&gt; operator which merely sends the output of one function to the next. Maybe that&amp;rsquo;s not a problem. But people might see:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @x &amp;lt;== 1,2,3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;and expect it does assignment when it in fact doesn&amp;rsquo;t. Internally it would really do something more like appending a named argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @x, &#39;*@&#39; =&amp;gt; (1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or however we decide to mark the beginning of the &amp;ldquo;real&amp;rdquo; list within a larger list.&lt;/p&gt;

&lt;p&gt;But I do rather like the looks of:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push @foo &amp;lt;== 1,2,3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;not to mention the symmetrical:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt;
    push @foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note however that the pointy end of &lt;code&gt;==&amp;gt;&lt;/code&gt; &lt;em&gt;must&lt;/em&gt; be bound to a function that takes a list. You can&amp;rsquo;t say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt;
    my @foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;because you can&amp;rsquo;t say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @foo &amp;lt;== 1,2,3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Or rather, you can, if we allow:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (@foo &amp;lt;== 1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;but it would mean the Wrong Thing. Ouch. So maybe that should not be legal. The asymmetry was bugging me anyway.&lt;/p&gt;

&lt;p&gt;So let&amp;rsquo;s say that &lt;code&gt;&amp;lt;==&lt;/code&gt; and &lt;code&gt;==&amp;gt;&lt;/code&gt; must always be bound on their pointy end to a slurpy function, and if you want to build an indirect argument list, you have to use some kind of explicit list function such as &lt;code&gt;args&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = args @foo &amp;lt;== 1,2,3;
    stuff *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;args&lt;/code&gt; function would really be a no-op, much like other context enforcers such as &lt;code&gt;scalar&lt;/code&gt; and &lt;code&gt;list&lt;/code&gt;. In fact, I&amp;rsquo;d be tempted to just use &lt;code&gt;list&lt;/code&gt; like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list @foo &amp;lt;== 1,2,3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But unless we can get people to see &lt;code&gt;&amp;lt;==&lt;/code&gt; as a strange kind of comma, that will likely be misread as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list(@foo) &amp;lt;== 1,2,3;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;when it&amp;rsquo;s really this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list(@foo &amp;lt;== 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;On the other hand, using &lt;code&gt;list&lt;/code&gt; would cut out the need for yet another built-in, for which there is much to be said&amp;hellip; I&amp;rsquo;d say, let&amp;rsquo;s go with &lt;code&gt;list&lt;/code&gt; on the assumption that people &lt;em&gt;will&lt;/em&gt; learn to read &lt;code&gt;&amp;lt;==&lt;/code&gt; as a pipe comma. If someone wants to use &lt;code&gt;args&lt;/code&gt; for clarity, they can always just alias &lt;code&gt;list&lt;/code&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my &amp;amp;args ::= &amp;amp;*list;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;More likely, they&amp;rsquo;ll just use the parenthesized form:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list(@foo &amp;lt;== 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I suppose there could also be a prefix unary form, in case they want to use it without scalar arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list(&amp;lt;== 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or in case they want to put a comma after the scalar arguments:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list(@foo, &amp;lt;== 1,2,3);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;In fact, it could be argued that we should &lt;em&gt;only&lt;/em&gt; have the unary form, since in this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stan @array, ollie &amp;lt;== 1,2,3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;it&amp;rsquo;s visually ambiguous whether the pointy pipe belongs to &lt;code&gt;stan&lt;/code&gt; or &lt;code&gt;ollie&lt;/code&gt;. It could be ambiguous to the compiler as well. With a unary operator, it unambiguously belongs to &lt;code&gt;ollie&lt;/code&gt;. You&amp;rsquo;d have to say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    stan @array, ollie, &amp;lt;== 1,2,3
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to make it belong to &lt;code&gt;stan&lt;/code&gt;. And yet, it&amp;rsquo;d be really strange for a unary &lt;code&gt;&amp;lt;==&lt;/code&gt; to force the arguments to its left into scalar context if the operator doesn&amp;rsquo;t govern those arguments syntactically. And I still think I want &lt;code&gt;&amp;lt;==&lt;/code&gt; to do that. And it&amp;rsquo;s probably better to disambiguate with parentheses anyway. So we keep it a binary operator. There&amp;rsquo;s no unary variant, either prefix or postfix. You can always say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list( () &amp;lt;== 1,2,3 )
    list( @foo &amp;lt;== () )
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Similarly, &lt;code&gt;==&amp;gt;&lt;/code&gt; is also always a binary operator. As the reverse of &lt;code&gt;&amp;lt;==&lt;/code&gt;, it forces its left side into list context, and it also forces all the arguments of the list operator on the right into scalar context. Just as:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    mumble @foo &amp;lt;== @bar
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tells you that &lt;code&gt;@foo&lt;/code&gt; is in scalar context and &lt;code&gt;@bar&lt;/code&gt; is in list context regardless of the signature of mumble, so too:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @bar ==&amp;gt;
    mumble @foo
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;tells you exactly the same thing. This is particularly useful when you have a method with an unknown signature that you have to dispatch on:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @bar ==&amp;gt;
    $objects[$x].mumble(@foo)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;==&amp;gt;&lt;/code&gt; unambiguously indicates that all the other arguments to &lt;code&gt;mumble&lt;/code&gt; are in scalar context. It also allows &lt;code&gt;mumble&lt;/code&gt;&amp;rsquo;s signature to check to see if the number of scalar arguments is within the correct range, counting only required and optional parameters, since we don&amp;rsquo;t have to allow for extra arguments to slop into the slurp array.&lt;/p&gt;

&lt;p&gt;If we do want extra list arguments, we could conceivably allow both kinds of pipe at once:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @bar ==&amp;gt;
    $objects[$x].mumble(@foo &amp;lt;== 1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If we did that, it could be equivalent to either:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $objects[$x].mumble(@foo &amp;lt;== 1,2,3,@bar)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $objects[$x].mumble(@foo &amp;lt;== @bar,1,2,3)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Since I can argue it both ways, we&amp;rsquo;ll have to disallow it entirely. &lt;code&gt;:-)&lt;/code&gt;&lt;/p&gt;

&lt;p&gt;Seriously, the conservative thing to do is to disallow it until we know what we want it to mean, if anything.&lt;/p&gt;

&lt;p&gt;On the perl6-language list, an operator was discussed that would do argument rearrangement, but this is a little different in that it is constrained (by default) to operate only with the slurpy list part of the input to a function. This is as it should be, if you think about it. When you pipe things around in Unix, you don&amp;rsquo;t expect the command line switches to come in via the pipe, but from the command line. The scalar arguments of a list operator function as the command line, and the list argument functions as the pipe.&lt;/p&gt;

&lt;p&gt;That being said, if you want to pull the scalar arguments from the front of the pipe, we already have a mechanism for that:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @args = list(@foo &amp;lt;== 1,2,3);
    stuff *@args;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By extension, we also have this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list(@foo &amp;lt;== 1,2,3) ==&amp;gt;
      stuff *();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So there&amp;rsquo;s no need for a special syntax to put the invocant after all the arguments. It&amp;rsquo;s just this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list(@foo &amp;lt;== 1,2,3) ==&amp;gt;
     $object.stuff *();
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Possibly the &lt;code&gt;*()&lt;/code&gt; could be inferred in some cases, but it may be better not to if we can&amp;rsquo;t do it consistently. If &lt;code&gt;stuff&lt;/code&gt;&amp;rsquo;s signature started with optional positional parameters, we wouldn&amp;rsquo;t know whether the pipe starts with positional arguments or list elements. I think that passing positionals at the front of the pipe is rare enough that it ought to be specially marked with &lt;code&gt;*()&lt;/code&gt;. Maybe we can reduce it to a &lt;code&gt;*&lt;/code&gt;, like a unary that has an optional argument:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    list(@foo &amp;lt;== 1,2,3) ==&amp;gt;
     $object.stuff *;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;By the way, you may think that we&amp;rsquo;re being silly calling these pipes, since we&amp;rsquo;re just passing lists around. But remember that these can potentially be lazy lists produced by a generator. Indeed, a common idiom might be something like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    &amp;lt;$*IN&amp;gt; ==&amp;gt; process() ==&amp;gt; print;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which arguably reads better than:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    print process &amp;lt;$*IN&amp;gt;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Another possibility is that we extend the argumentless &lt;code&gt;*&lt;/code&gt; to mark where the list goes in constructs that take lists but aren&amp;rsquo;t officially list operators:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt;
    my @foo = (*)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But maybe we should just make:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt; my @foo;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;do what people will expect it to. Since we require the &lt;code&gt;list&lt;/code&gt; operator for the other usage, it&amp;rsquo;s easy enough to recognize that this is not a list operator, and that we should therefore assign it. It seems to have a kind of inevitability about it.&lt;/p&gt;

&lt;p&gt;Damian: &amp;ldquo;Certainly, if we don&amp;rsquo;t support it, someone (*ahem*) will immediately write:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    multi infix:==&amp;gt; (Lazy $list, @array is rw) { @array = $list }
    multi infix:&amp;lt;== (@array is rw, Lazy $list) { @array = $list }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&amp;ldquo;So we might as well make it standard.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;On the other hand&amp;hellip;&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;m suddenly wondering if assignment and binding can change precedence on the right like list operators do if it&amp;rsquo;s known we&amp;rsquo;re assigning to a list. I, despite my credentials as TheLarry, keep finding myself writing list assignments like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @foo := 0..9,&#39;a&#39;..&#39;z&#39;;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Oops. But what if it wasn&amp;rsquo;t an oops. What if that parsed like a list operator, and slurped up all the commas to the right? Parens would still be required around a list on the left though. And it might break weird things like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    (@a = (1,2), @b = (3,4))
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;But how often do you do a list assignment inside a list? On the other hand, making list assignment a different precedence than scalar is weird. But it&amp;rsquo;d have to be that way if we still wanted:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    ($a = 1, $b = 2)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to work as a C programmer expects. Still, I think I like it. In particular, it&amp;rsquo;d let us write what we mean explicitly:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt;
    my @foo = *;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;So let&amp;rsquo;s go ahead and do that, and then maybe someone (*ahem*) might just forget to overload the pipe operators on arrays.*&lt;/p&gt;

&lt;p&gt;* The words &amp;ldquo;fat&amp;rdquo;, &amp;ldquo;slim&amp;rdquo;, and &amp;ldquo;none&amp;rdquo; come to mind.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;span-id-appendix-b-how-to-bind-strange-arguments-to-weird-parameters-appendix-b-how-to-bind-strange-arguments-to-weird-parameters-span&#34;&gt;&lt;span id=&#34;appendix_b:_how_to_bind_strange_arguments_to_weird_parameters&#34;&gt;Appendix B: How to bind strange arguments to weird parameters&lt;/span&gt;&lt;/h1&gt;

&lt;p&gt;It may seem like the declaration syntax has too many options (and it does), but it&amp;rsquo;s actually saving you a good deal of complexity. When you say something excruciatingly fancy like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method x ($me: $req, ?$opt, *%named, *@list, +$namedopt) {...}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;you&amp;rsquo;re actually getting a whole pile of semantics resembling this pseudocode:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    method x (*@list) {
        my %named;
        my $argnum = 0;

        # find beginning of named arguments
        while exists @list[$argnum] and @list[$argnum] !~ Pair|Hash {
            $argnum++;
            last if $argnum == 3;               # force transition to named or list
        }
        my $posmax = $argnum;

        # pull out named actuals (pairs or hashes)
        while exists @list[$argnum] and @list[$argnum] ~~ Pair|Hash {
            %named.add(@list[$argnum++].pairs);
        }

        # the invocant comes in like this
        my $_   := $posmax &amp;gt; 0 ?? @list[0] :: delete %named{me}  // die &amp;quot;Not enough args&amp;quot;;
        my $me  := $_;                          # only if invocant declared

        # required parameters are bound like this
        my $req := $posmax &amp;gt; 1 ?? @list[1] :: delete %named{req} // die &amp;quot;Not enough args&amp;quot;;

        # optional positional parameters are bound like this
        my $opt := $posmax &amp;gt; 2 ?? @list[2] :: delete %named{opt};

        # optional named parameters are bound like this
        my $namedopt := delete %named{namedopt};

        # trim @list down to just the remaining list
        splice(@list, 0, $argnum, ());

        if defined @list {
            die &amp;quot;Can&#39;t have two lists&amp;quot; if exists %named{&#39;*@&#39;};
        }
        else {
            @list := delete %named{&#39;*@&#39;} // [];
        }

        ...     # Your ad here.
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Only hopefully it runs a lot faster. Regardless, I know which version I&amp;rsquo;d rather write&amp;hellip;&lt;/p&gt;

&lt;p&gt;Or maintain&amp;hellip;&lt;/p&gt;

&lt;p&gt;You can get even more semantics than that if we need to process default values or do run-time type checking. It also gets hairier if you have any positional parameters declared as &lt;code&gt;Pair&lt;/code&gt; or &lt;code&gt;Hash&lt;/code&gt;. On the other hand, the compiler can probably optimize away lots of the linkage code in general, particularly when it can compare the actual arguments against the signature at compile time and, for instance, turn named arguments into positional arguments internally. Or prebuild a hash of the named args. Even if it can&amp;rsquo;t do that, it could generate specially marked lists that already know where the named arguments start and stop so we don&amp;rsquo;t have to scan for those boundaries. This gets easier if the caller marks the list part with &lt;code&gt;&amp;lt;==&lt;/code&gt; or &lt;code&gt;==&amp;gt;&lt;/code&gt;. Though it gets harder again if they use splat to pass indirect positional arguments.&lt;/p&gt;

&lt;p&gt;Note also that we don&amp;rsquo;t necessarily have to build a real &lt;code&gt;%named&lt;/code&gt; slurphash. The &lt;code&gt;%named&lt;/code&gt; hash can just be a proxy for a function that scans those args known to contain named arguments, whether pairs or hashes. In general, although there may be quite a few optional parameters, most of them aren&amp;rsquo;t set in the average call, so the brute-force approach of scanning the call list linearly for each possible parameter may well be faster than trying to build a real hash (particularly if any or all of named parameters already come in as a hash).&lt;/p&gt;

&lt;p&gt;It might be tricky to make bound named arguments disappear from the proxy hash, however. In the code above, you&amp;rsquo;ll note that we actually delete named arguments from &lt;code&gt;%named&lt;/code&gt; as we bind them to positional parameters. A proxy hash might have to figure out how to hide &amp;ldquo;used&amp;rdquo; values somehow. Or maybe we just leave them visible as aliases to bound parameters. I don&amp;rsquo;t profess to know which is better. Could be a pragma for it&amp;hellip;seems the usual cure for festering bogons these days&amp;hellip;&lt;/p&gt;

&lt;p&gt;In our pseudocode above, we don&amp;rsquo;t ever actually evaluate the arguments of the entire list, because it could be a generated list like &lt;code&gt;1..Inf&lt;/code&gt;, and flattening that kind of list would chew up just a &lt;em&gt;wee&lt;/em&gt; bit too much memory. If &lt;code&gt;@list&lt;/code&gt; were an ordinary array, its boolean value would tell us if it will produce any values, but that&amp;rsquo;s not really what we want. What we really want to know is whether the caller specified anything, not whether what they specified is going to produce any values. If you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push @foo, 1..0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;the range doesn&amp;rsquo;t generate any values, but you shouldn&amp;rsquo;t look anywhere else for the list either. That is,&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    1,2,3 ==&amp;gt;
    push @foo, 1..0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;should probably be an error. It&amp;rsquo;s equivalent to saying:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    push @foo, &#39;*@&#39;=&amp;gt;(1,2,3), 1..0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;or some such. We try to catch that in our pseudocode above.&lt;/p&gt;

&lt;p&gt;When you bind a lazy list to an array name such as &lt;code&gt;@_&lt;/code&gt; or &lt;code&gt;@list&lt;/code&gt;, by default it&amp;rsquo;s going to try to give the appearance that the array is all there, even if behind the scenes it is having to generate values for you. In this case, we don&amp;rsquo;t want to flatten the list, so instead of trying to access any of the values of the variadic list, we just ask if it is defined. In Perl 6, an ordinary array is considered defined if it either has some flattened arguments in it already, or it has an associated list generator definition of how to produce more elements. We can figure this out without changing the state of the array.&lt;/p&gt;

&lt;p&gt;Contrast this with the array&amp;rsquo;s boolean value, which is true only if it is &lt;em&gt;known&lt;/em&gt; that there are actual elements in the array. If an array has no remaining flattened elements but has a definition for how to produce more, the boolean evaluation must evaluate the definition sufficiently to determine whether there will be at least one more value. In the case of a range object, it can ask the range object without actually flattening another element, but in the limiting case of a random generator subroutine, it would have to go ahead and call the wretched generator to get the next flattened element, so that it can know to return false if there were no next element.&lt;/p&gt;

&lt;p&gt;Note that even the flat view of the array doesn&amp;rsquo;t necessarily flatten until you actually access the array, in which case it flattens as much as it needs to in order to produce the value you requested, and no more.&lt;/p&gt;

&lt;p&gt;We need a name for the list of internal generators bound to the array. Since they&amp;rsquo;re behaving as specifications for the array, we&amp;rsquo;ll get at them using the predefined &lt;code&gt;.specs&lt;/code&gt; method that arrays support.&lt;/p&gt;

&lt;p&gt;So, for instance, if you say:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @foo := (0..9,&#39;a&#39;..&#39;z&#39;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo.length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would return &lt;code&gt;36&lt;/code&gt;, but:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    @foo.specs.length
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;would return 2, one for each range object. (That&amp;rsquo;s presuming you didn&amp;rsquo;t already ask for the length of the array, since in general asking for the length of an array flattens it completely and blows away the specs&amp;ndash;though perhaps in this case the range specs can calculate their lengths non-destructively.)&lt;/p&gt;

&lt;p&gt;Anyway, in the absence of such a flattening event, both &lt;code&gt;@foo&lt;/code&gt; and &lt;code&gt;@foo.specs&lt;/code&gt; are true. However, if instead you&amp;rsquo;d given it a null range:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @foo := 1..0;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;then &lt;code&gt;@foo.specs&lt;/code&gt; would be true at least temporarily, but &lt;code&gt;@foo&lt;/code&gt; would be false, because the flattened list contains no values.&lt;/p&gt;

&lt;p&gt;Now here&amp;rsquo;s where it gets interesting. As you process a flat array view, the corresponding specs mutate:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @flat = 1..10;
    shift @flat;
    print @flat.specs;   # prints 2..10
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The specs aren&amp;rsquo;t just a queue, but also a stack:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @flat = 1..10;
    pop @flat;
    print @flat.specs;   # prints 1..9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Note that you can &lt;code&gt;pop&lt;/code&gt; an array without committing to flattening the entire list:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @flat = (1..Inf, 1..10);
    pop @flat;
    print @flat.specs;   # prints 1..Inf, 1..9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;If you pop the array 9 more times, the resulting null spec pops itself from the specs list, and you get a single spec of &lt;code&gt;1..Inf&lt;/code&gt; out of &lt;code&gt;@flat.specs&lt;/code&gt;. (Continuing to pop &lt;code&gt;@flat&lt;/code&gt; returns &lt;code&gt;Inf&lt;/code&gt; forever, of course, with no change to the spec.)&lt;/p&gt;

&lt;p&gt;However, if you access the last element using the &lt;em&gt;length&lt;/em&gt; of the array, it may try to flatten, and fail:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @flat = (1..Inf, 1..10);
    $last = @flat[@flat - 1];   # Kaboom!
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Still, we should be able to detect the attempt to flatten an infinite list and give a better diagnostic than Perl 5&amp;rsquo;s &amp;ldquo;Out of memory&amp;rdquo;. Either that, or someone should just up and figure out how to subscript arrays using transfinite numbers.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Editor&amp;rsquo;s Note: this Apocalypse is out of date and remains here for historic reasons. See &lt;a href=&#34;http://dev.perl.org/perl6/doc/design/syn/S06.html&#34;&gt;Synopsis 06&lt;/a&gt; for the latest information.&lt;/em&gt;&lt;/p&gt;

&lt;h1 id=&#34;span-id-appendix-c-hypotheticality-and-flight-recorders-appendix-c-hypotheticality-and-flight-recorders-span&#34;&gt;&lt;span id=&#34;appendix_c:_hypotheticality_and_flight_recorders&#34;&gt;Appendix C: Hypotheticality and Flight Recorders&lt;/span&gt;&lt;/h1&gt;

&lt;p&gt;[This is a portion of a letter I sent to the design team. This stuff is still in discussion with the internals folks, so please take this as informative rather than definitive. But I just thought you might like to see how sausage is made. &lt;code&gt;:-)&lt;/code&gt; &amp;ndash;Larry]&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    : Seems like you&#39;re going to have to explain the C&amp;lt;TEMP&amp;gt;/C&amp;lt;RESTORE&amp;gt; 
    : relationship in A6, Larry, since C&amp;lt;RESTORE&amp;gt; isn&#39;t even mentioned
    : there at present.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;I&amp;rsquo;d like to explain it primarily by making both of them unnecessary most of the time.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    : But maybe after a good nights sleep, eh? ;-)
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Okay, I&amp;rsquo;ve had a night&amp;rsquo;s sleep. Whether it was a good one remains to be seen. But here&amp;rsquo;s what I&amp;rsquo;m after. Forget implementation for a moment. What&amp;rsquo;s the interface that people want, in the abstract? You were starting to think this way yourself with &amp;ldquo;&lt;code&gt;suppose {...}&lt;/code&gt;&amp;rdquo;. So let&amp;rsquo;s do some supposin&amp;rsquo;.&lt;/p&gt;

&lt;p&gt;I&amp;rsquo;ll talk about caller and callee here, but I&amp;rsquo;m really talking about the user&amp;rsquo;s abstract view vs. the user&amp;rsquo;s implementation view, so it applies to variables, lvalue routines, and rvalue routines alike.&lt;/p&gt;

&lt;p&gt;On the caller side, people want to be able to make a temporary assumption or a hypothesis. There is some scope over which the hypothesis is stated, and then some scope over which the hypothesis is assumed. At the end of that scope, the hypothesis may or may not be retracted. (I&amp;rsquo;m trying not to state this in terms of &lt;code&gt;temp&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt;, just to keep our current ideas out of it.)&lt;/p&gt;

&lt;p&gt;Historically, the scope of the hypothesis &lt;em&gt;statement&lt;/em&gt; is a single variable/value, because &lt;code&gt;local&lt;/code&gt; only knew how to temporize that kind of thing. The scope of the hypothesis assumption has always extended to the end of the current dynamic scope.&lt;/p&gt;

&lt;p&gt;In the very abstract view, supposing is a transactional function with two arguments, the first one of which establishes a scope in which any state change is labelled as provisional. The second argument establishes a scope in which we work out the ramifications of that supposing, which may include other supposings. In classical terms, they&amp;rsquo;re the &lt;em&gt;protasis&lt;/em&gt; and &lt;em&gt;apodosis&lt;/em&gt;:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    suppose { &amp;lt;pro&amp;gt; } { &amp;lt;apo&amp;gt; }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;At the end of the second scope we decide whether to succeed or fail. On failure, we unsuppose everything that was supposed from the beginning, and upon success, we allow certain new &amp;ldquo;facts&amp;rdquo; to leak out into a larger reality (which may itself be a hypothesis, but leave that aside for the moment). It&amp;rsquo;s basically commit/rollback.&lt;/p&gt;

&lt;p&gt;It could also be written:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    suppose &amp;lt;pro&amp;gt; {
        &amp;lt;apo&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;to make it look more like an &lt;code&gt;if&lt;/code&gt;. But up till now we&amp;rsquo;ve written it:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    {
        temp &amp;lt;pro&amp;gt;;
        &amp;lt;apo&amp;gt;
    }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;which actually works out fine as a syntax, since every statement is in a sense conditional on preceding statements. If we want to allow a hypothetical result to leak out, we use &amp;ldquo;let&amp;rdquo; instead of &amp;ldquo;temp&amp;rdquo;. Whatever. I&amp;rsquo;m not caring about the syntax yet, just the abstract interface.&lt;/p&gt;

&lt;p&gt;And the abstract interface wants both &amp;lt;pro&amp;gt; and &amp;lt;apo&amp;gt; to be as general as possible. We already have a completely general &amp;lt;apo&amp;gt;, but we&amp;rsquo;ve severely restricted the &amp;lt;pro&amp;gt; so far to be (in Perl 5) a storage location, or in Perl 6 (Seb), anything with a &lt;code&gt;.TEMP&lt;/code&gt; method. You&amp;rsquo;d like to be able to turn anything involving state changes into an &amp;lt;pro&amp;gt;, but we can&amp;rsquo;t. We can only do it to values that cooperate.&lt;/p&gt;

&lt;p&gt;So the real question is what does cooperation look like from the &amp;ldquo;callee&amp;rdquo; end of things? What&amp;rsquo;s the best interface for cooperating? I submit that the best interface for that does not look like &lt;code&gt;TEMP =&amp;gt; {}&lt;/code&gt;, or &lt;code&gt;RESTORE {}&lt;/code&gt;. It looks like nothing at all!&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    sub foo { $x = 1234; }
    $x = 0;
    {
        temp foo();
        print $x;       # prints 1234
    }
    print $x;           # prints 0
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;How might this work in practice? If Perl (as a language) is aware of when it is making a state change, and if it also aware of when it is doing so in a hypothetical context (*any* hypothetical context in the dynamic scope), then Perl (as a language) can save its own record of that state change, filing it with the proper hypothetical context management authorities, to be undone (or committed) at the appropriate moment.&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s fine as long as we&amp;rsquo;re running in Perl. Where an explicit &lt;code&gt;TEMP&lt;/code&gt; method is useful is in the interface to foreign code or data that doesn&amp;rsquo;t support dynamically scoped hypotheticality. If a Proxy is proxying for a Perl variable or attribute, however, then the &lt;code&gt;STORE&lt;/code&gt; already knows its dynamic context, and handles &lt;code&gt;temp&lt;/code&gt; and &lt;code&gt;let&lt;/code&gt; implicitly just as any other Perl code running in hypothetical context would.&lt;/p&gt;

&lt;p&gt;As for a hypothesis within a hypothesis, I think it just means that when you refrain from &lt;code&gt;UNDO&lt;/code&gt;ing the &lt;code&gt;let&lt;/code&gt; state changes, you actually &lt;code&gt;KEEP&lt;/code&gt; them into a higher undo list, if there is one. (In practice, this may mean there aren&amp;rsquo;t separate &lt;code&gt;LAST&lt;/code&gt; and &lt;code&gt;UNDO&lt;/code&gt; lists. Just a &lt;code&gt;LAST&lt;/code&gt; list, in which some entries do a &lt;code&gt;KEEP&lt;/code&gt; or &lt;code&gt;UNDO&lt;/code&gt; at the last moment. Otherwise a &lt;code&gt;let&lt;/code&gt; within a &lt;code&gt;let&lt;/code&gt; has to poke something onto both a keep list and an undo list. But maybe it comes out to the same thing.)&lt;/p&gt;

&lt;p&gt;(In any event, we do probably need a name for the current innermost supposition we&amp;rsquo;re in the dynamic scope of. I have my doubts that &lt;code&gt;$?_&lt;/code&gt; is that name, however. &lt;code&gt;$0&lt;/code&gt; is closer to it. Can thrash that out later.)&lt;/p&gt;

&lt;p&gt;That&amp;rsquo;s all very powerful. But here&amp;rsquo;s where it borders on disruptive technology. I mentioned a while back the talk by Todd A. Proebsting on Disruptive Language Technologies. In it he projects which new disruptive language technologies will take over the world someday. The one that stuck in my head was the flight data recorder, where every state change for the last N instructions was recorded for analysis in case of failure. Sound familiar?&lt;/p&gt;

&lt;p&gt;Taken together with my hypotheticality hypothesis, I think this likely indicates a two-birds-with-one-stone situation that we must design for. If state changes are automatically stored in a type-appropriate manner, we don&amp;rsquo;t necessarily have to generate tons of artificial closures merely to create artificial lexical variables just so we have them around later at the right moment. I don&amp;rsquo;t mind writing double closures for things like macros, where they&amp;rsquo;re not in hot code. But &lt;code&gt;let&lt;/code&gt; and friends need to be blazing fast if we&amp;rsquo;re ever going to use Perl for logic programming, or even recursive descent parsing. And if we want a flight data recorder, it had better not hang on the outside of the airplane where it&amp;rsquo;ll induce drag.&lt;/p&gt;

&lt;p&gt;And that&amp;rsquo;s what I think is wrong with our Sebastopolian formulation of &lt;code&gt;.TEMP&lt;/code&gt;. Am I making any sense?&lt;/p&gt;

&lt;p&gt;Larry&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

