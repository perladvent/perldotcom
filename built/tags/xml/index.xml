<?xml version="1.0" encoding="utf-8" standalone="yes" ?>
<?xml version="1.0" encoding="UTF-8"?>
<rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom">
  <channel>
    <title>Xml on Perl.com - programming news, code and culture</title>
    <link>http://localhost:1313/tags/xml/</link>
    <description>Recent content in Xml on Perl.com - programming news, code and culture</description>
    <generator>Hugo -- gohugo.io</generator>
    <language>en-us</language>
    <lastBuildDate>Wed, 29 Apr 2020 01:05:57 +0000</lastBuildDate>
    <atom:link href="/tags/xml/" rel="self" type="application/rss+xml" />
    
    <item>
      <title>What&#39;s new on CPAN - March 2020</title>
      <link>http://localhost:1313/article/what-s-new-on-cpan---march-2020/</link>
      <pubDate>Wed, 29 Apr 2020 01:05:57 +0000</pubDate>
      
      <guid>http://localhost:1313/article/what-s-new-on-cpan---march-2020/</guid>
      <description>

&lt;p&gt;Welcome to &amp;ldquo;What&amp;rsquo;s new on CPAN&amp;rdquo;, a curated look at last month&amp;rsquo;s new CPAN uploads for your reading and programming pleasure. Enjoy!&lt;/p&gt;

&lt;h2 id=&#34;apis-apps&#34;&gt;APIs &amp;amp; Apps&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Get a colorful calendar in the terminal with &lt;a href=&#34;https://metacpan.org/pod/week&#34;&gt;App::week&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Google::reCAPTCHA::v3&#34;&gt;Google::reCAPTCHA::v3&lt;/a&gt; is another Google captcha module&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/GraphQL::Client&#34;&gt;GraphQL::Client&lt;/a&gt; … is a GraphQL client&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Masscan::Scanner&#34;&gt;Masscan::Scanner&lt;/a&gt; makes it easy to use the masscan port scanner.&lt;/li&gt;
&lt;li&gt;Make non-blocking requests to LastFM with &lt;a href=&#34;https://metacpan.org/pod/Mojo::WebService::LastFM&#34;&gt;Mojo::WebService::LastFM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Use Telegram&amp;rsquo;s Bot API with &lt;a href=&#34;https://metacpan.org/pod/Net::API::Telegram&#34;&gt;Net::API::Telegram&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Net::OpenVAS&#34;&gt;Net::OpenVAS&lt;/a&gt; let&amp;rsquo;s you program Greenbone&amp;rsquo;s OpenVAS platform with Perl&lt;/li&gt;
&lt;li&gt;Use Elasticsearch 6.x APIs with &lt;a href=&#34;https://metacpan.org/pod/Search::Elasticsearch::Client::6_0&#34;&gt;Search::Elasticsearch::Client::6_0&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;config-devops&#34;&gt;Config &amp;amp; Devops&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Block::NJH&#34;&gt;Block::NJH&lt;/a&gt; is interesting; add it to your CPAN distribution to &amp;ldquo;prevent your tests from running on NJH&amp;rsquo;s broken smokers&amp;rdquo;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Config::Structured&#34;&gt;Config::Structured&lt;/a&gt; provides &amp;ldquo;generalized and structured configuration value access&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Ping a database handle to check its health using &lt;a href=&#34;https://metacpan.org/pod/HealthCheck::Diagnostic::DBHPing&#34;&gt;HealthCheck::Diagnostic::DBHPing&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/HealthCheck::Diagnostic::FilePermissions&#34;&gt;HealthCheck::Diagnostic::FilePermissions&lt;/a&gt; checks filepaths for expected permissions&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;data&#34;&gt;Data&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/DB::Object&#34;&gt;DB::Object&lt;/a&gt; is a database abstraction built on top of DBI&lt;/li&gt;
&lt;li&gt;Inspect DBIC objects in a compact format using &lt;a href=&#34;https://metacpan.org/pod/Data::Tersify::Plugin::DBIx::Class&#34;&gt;Data::Tersify::Plugin::DBIx::Class&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/MIME::Base32::XS&#34;&gt;MIME::Base32::XS&lt;/a&gt; is a faster Base32 encoder/decoder&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Statistics::Covid&#34;&gt;Statistics::Covid&lt;/a&gt; fetches and manages Covid-19 statistics&lt;/li&gt;
&lt;li&gt;Get a Postgresql mock server for testing via &lt;a href=&#34;https://metacpan.org/pod/Test::PostgreSQL::Docker&#34;&gt;Test::PostgreSQL::Docker&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Bind Perl data structures into XML with &lt;a href=&#34;https://metacpan.org/pod/XML::BindData&#34;&gt;XML::BindData&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/XML::Minifier&#34;&gt;XML::Minifier&lt;/a&gt; is a configurable XML minifier&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;development-version-control&#34;&gt;Development &amp;amp; Version Control&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Devel::Wherefore&#34;&gt;Devel::Wherefore&lt;/a&gt; helps debug Perl: &amp;ldquo;Where the heck did these subroutines come from?&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Create relative symbolic links &lt;a href=&#34;https://metacpan.org/pod/File::Symlink::Relative&#34;&gt;File::Symlink::Relative&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Module::Generic&#34;&gt;Module::Generic&lt;/a&gt; is another class library, it uses AUTOLOAD for getter/setter methods&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/new&#34;&gt;new&lt;/a&gt; saves you from typing module names twice in one liners&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;science-mathematics&#34;&gt;Science &amp;amp; Mathematics&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Bio::DB::Taxonomy::sqlite&#34;&gt;Bio::DB::Taxonomy::sqlite&lt;/a&gt; stores and manages NCBI data using sqlite&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Math::Polynomial::Chebyshev&#34;&gt;Math::Polynomial::Chebyshev&lt;/a&gt; creates Chebyshev polynomials&lt;/li&gt;
&lt;/ul&gt;

&lt;h2 id=&#34;web&#34;&gt;Web&lt;/h2&gt;

&lt;ul&gt;
&lt;li&gt;Store Catalyst sessions in Redis with &lt;a href=&#34;https://metacpan.org/pod/Catalyst::Plugin::Session::Store::RedisFast&#34;&gt;Catalyst::Plugin::Session::Store::RedisFast&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Not a traditional distribution, but &lt;a href=&#34;https://metacpan.org/pod/Mojo::Server::AWSLambda&#34;&gt;Mojo::Server::AWSLambda&lt;/a&gt; contains a simple example of how to define an AWS Lambda function which uses Mojo&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Mojolicious::Plugin::Sticker&#34;&gt;Mojolicious::Plugin::Sticker&lt;/a&gt; combines Mojo apps into a single app&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>What&#39;s new on CPAN - June 2016</title>
      <link>http://localhost:1313/article/what-s-new-on-cpan---june-2016/</link>
      <pubDate>Wed, 13 Jul 2016 09:34:38 +0000</pubDate>
      
      <guid>http://localhost:1313/article/what-s-new-on-cpan---june-2016/</guid>
      <description>

&lt;p&gt;Welcome to &amp;ldquo;What&amp;rsquo;s new on CPAN&amp;rdquo;, a curated look at last month&amp;rsquo;s new CPAN uploads for your reading and programming pleasure. June saw YAPC::NA (among other conferences) which meant CPAN activity was lower than normal. I&amp;rsquo;m expecting a bumper July though; for now enjoy!&lt;/p&gt;

&lt;h3 id=&#34;apis-apps&#34;&gt;APIs &amp;amp; Apps&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/App::Licensecheck&#34;&gt;App::Licensecheck&lt;/a&gt; inspects source files for licenses&lt;/li&gt;
&lt;li&gt;Use the Runkeeper (Health Graph) API with &lt;a href=&#34;https://metacpan.org/pod/WebService::HealthGraph&#34;&gt;WebService::HealthGraph&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/WebService::SQLFormat&#34;&gt;WebService::SQLFormat&lt;/a&gt; formats SQL via the sqlformat.org API&lt;/li&gt;
&lt;li&gt;Monitor the status of other plack applications using &lt;a href=&#34;https://metacpan.org/pod/Plack::App::ServiceStatus&#34;&gt;Plack::App::ServiceStatus&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;config-devops&#34;&gt;Config &amp;amp; Devops&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;In the docs for &lt;a href=&#34;https://metacpan.org/pod/Acme::Devel::Hide::Tiny&#34;&gt;Acme::Devel::Hide::Tiny&lt;/a&gt; author David Golden shows how to force the unavailability of a module for testing without adding a test dependency&lt;/li&gt;
&lt;li&gt;Get a single list of all dependencies (including indirect ones) for a distribution with &lt;a href=&#34;https://metacpan.org/pod/CPAN::Flatten&#34;&gt;CPAN::Flatten&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;data&#34;&gt;Data&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/DBIx::EAV&#34;&gt;DBIx::EAV&lt;/a&gt; enables Entity-Attribute-Value data modeling (aka &amp;lsquo;open schema&amp;rsquo;) via DBI&lt;/li&gt;
&lt;li&gt;Useful testing tool: generate random IPs with &lt;a href=&#34;https://metacpan.org/pod/IP::Random&#34;&gt;IP::Random&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Estimates the length of all the vectors in an SVG file using &lt;a href=&#34;https://metacpan.org/pod/SVG::Estimate&#34;&gt;SVG::Estimate&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/String::Normal&#34;&gt;String::Normal&lt;/a&gt; is another text normalization module&lt;/li&gt;
&lt;li&gt;Extract strings from markup with &lt;a href=&#34;https://metacpan.org/pod/XML::Lenient&#34;&gt;XML::Lenient&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Get convenient, fast and jQuery-like DOM manipulation with &lt;a href=&#34;https://metacpan.org/pod/XML::LibXML::jQuery&#34;&gt;XML::LibXML::jQuery&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;development-version-control&#34;&gt;Development &amp;amp; Version Control&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Use U2F authentication with your app using with &lt;a href=&#34;https://metacpan.org/pod/Authen::U2F&#34;&gt;Authen::U2F&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/PDF::PDFUnit&#34;&gt;PDF::PDFUnit&lt;/a&gt; Perl interface to the Java PDFUnit testing framework&lt;/li&gt;
&lt;li&gt;The &lt;a href=&#34;https://metacpan.org/pod/Parallel::Dragons&#34;&gt;Parallel::Dragons&lt;/a&gt; abstract says &amp;ldquo;Daemon are forever&amp;hellip; Dragons lay eggs, grow fast and die in flames!&amp;rdquo;&lt;/li&gt;
&lt;li&gt;Useful Perl::Critic policies:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Perl::Critic::Policy::Moo::ProhibitMakeImmutable&#34;&gt;Perl::Critic::Policy::Moo::ProhibitMakeImmutable&lt;/a&gt; checks that Moo classes do not contain calls to make_immutable á la Moose&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Perl::Critic::Policy::TryTiny::RequireBlockTermination&#34;&gt;Perl::Critic::Policy::TryTiny::RequireBlockTermination&lt;/a&gt; checks that try/catch/finally blocks are properly terminated - this is so easy to get wrong and the error message is often cryptic.&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Perl::Critic::Policy::TryTiny::RequireUse&#34;&gt;Perl::Critic::Policy::TryTiny::RequireUse&lt;/a&gt; checks that code which uses Try::Tiny actually imports it&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;li&gt;Do meta programming with &lt;a href=&#34;https://metacpan.org/pod/Sub::Attributes&#34;&gt;Sub::Attributes&lt;/a&gt; (disclosure - I am the module author)&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;hardware&#34;&gt;Hardware&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Medical: a SLURM-specific driver for HPCI using &lt;a href=&#34;https://metacpan.org/pod/HPCD::SLURM&#34;&gt;HPCD::SLURM&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;New chip drivers:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Device::Chip::PCF8574&#34;&gt;Device::Chip::PCF8574&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Device::Chip::SSD1306&#34;&gt;Device::Chip::SSD1306&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;other&#34;&gt;Other&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Solve for the WordBrain mobile Game with &lt;a href=&#34;https://metacpan.org/pod/Game::WordBrain&#34;&gt;Game::WordBrain&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;Ham radio enthusiasts:

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Ham::WSJTX::Logparse&#34;&gt;Ham::WSJTX::Logparse&lt;/a&gt; parses ALL.TXT log files from Joe Taylor K1JT&amp;rsquo;s WSJT-X, to extract CQ and calling station information for all entries in a given amateur band&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Ham::WorldMap&#34;&gt;Ham::WorldMap&lt;/a&gt; creates an Imager image containing an equirectangular projection of the world map, with optional Maidenhead locator grid and day/night illumination and additional utility methods&lt;/li&gt;
&lt;/ul&gt;&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;science-mathematics&#34;&gt;Science &amp;amp; Mathematics&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Math::BivariateCDF&#34;&gt;Math::BivariateCDF&lt;/a&gt; provides Bivariate CDF functions&lt;/li&gt;
&lt;/ul&gt;

&lt;h3 id=&#34;web&#34;&gt;Web&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;Interesting: &lt;a href=&#34;https://metacpan.org/pod/Mojo::UserAgent::CookieJar::ChromeMacOS&#34;&gt;Mojo::UserAgent::CookieJar::ChromeMacOS&lt;/a&gt; can read OSX Chrome Chrome cookies for Mojo::UserAgent&lt;/li&gt;
&lt;li&gt;Scrape the FindaGrave site using &lt;a href=&#34;https://metacpan.org/pod/WWW::Scrape::FindaGrave&#34;&gt;WWW::Scrape::FindaGrave&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;https://metacpan.org/pod/Weasel&#34;&gt;Weasel&lt;/a&gt; let&amp;rsquo;s you use a single module for different web drivers like Selenium. Inspired by PHP&amp;rsquo;s Mink&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Build a Reddit bot with Perl</title>
      <link>http://localhost:1313/article/151/2015/2/9/Build-a-Reddit-bot-with-Perl/</link>
      <pubDate>Mon, 09 Feb 2015 13:41:04 +0000</pubDate>
      
      <guid>http://localhost:1313/article/151/2015/2/9/Build-a-Reddit-bot-with-Perl/</guid>
      <description>

&lt;p&gt;One of my goals for this year was to post more links to the Perl &lt;a href=&#34;http://www.reddit.com/r/perl&#34;&gt;subreddit&lt;/a&gt;. I&amp;rsquo;m usually good at linking to PerlTricks articles, but not so good at linking to other content. And that&amp;rsquo;s a shame because there are a lot of active Perl blogs out there (I know of at least 25-30).&lt;/p&gt;

&lt;p&gt;A busier Perl subreddit is good for the community; more links on /r/perl should lead to more visitors, and more activity on the subreddit and so on - a virtuous circle. So I built a bot to automate the posting of links. In this article I&amp;rsquo;m going to show you how I did it.&lt;/p&gt;

&lt;h3 id=&#34;reddit-api&#34;&gt;Reddit API&lt;/h3&gt;

&lt;p&gt;You&amp;rsquo;ll need a Reddit account to use the API. I like to use &lt;a href=&#34;https://metacpan.org/pod/Reddit::Client&#34;&gt;Reddit::Client&lt;/a&gt; as it works well, has good documentation and maintains a session cache. This is a subroutine for posting links to Reddit:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; warnings;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; strict;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Reddit::Client;

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_reddit_link&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($title, $url, $subreddit) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @_; 

    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $reddit       &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Reddit::Client&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;(
        session_file &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;logs/session_data.json&amp;#39;&lt;/span&gt;,
        user_agent   &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;perly_bot/v0.01&amp;#39;&lt;/span&gt;,
    );  

    &lt;span style=&#34;color:#66d9ef&#34;&gt;unless&lt;/span&gt; ( $reddit&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;is_logged_in ) { 
        $reddit&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;login( $ENV{REDDIT_USERNAME}, 
                        $ENV{REDDIT_PASSWORD} );
        $reddit&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;save_session();
    }   
    
    $reddit&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;submit_link(
            subreddit &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; $subreddit,
            title     &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; $title,
            url       &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; $url
    );
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The code should be fairly self-explanatory. The &lt;code&gt;post_reddit_link&lt;/code&gt; subroutine accepts three parameters: the subreddit to post to, the title of the post, and the URL of the link. It initializes a new Reddit::Client object, passing the path of the session file and the user agent string to use when calling the Reddit API. The session file is just a cache for storing a session cookie.&lt;/p&gt;

&lt;p&gt;Next, the subroutine checks if the &lt;code&gt;$reddit&lt;/code&gt; object has an active session or not, triggering a login request if necessary. I like to store credentials in environment variables: that way the code and any config files can still be hosted on a public repository, without risk of sharing your login details with anyone. The last bit of code calls &lt;code&gt;submit_link&lt;/code&gt; method to post the link to the Reddit API.&lt;/p&gt;

&lt;p&gt;This code will work in ideal scenarios, but what if something goes wrong? For example, Reddit imposes restrictions on the posting of links: the same link cannot be posted twice to the same subreddit, proxy domains are banned and links cannot be posted too frequently. In order to capture the error messages, I&amp;rsquo;m going to wrap the &lt;code&gt;submit_link&lt;/code&gt; method in a try/catch block.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; warnings;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; strict;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Reddit::Client;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Try::Tiny;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Time::Piece;

open &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $ERROR_LOG, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;gt;&amp;gt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;logs/error.log&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; die $!;

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_reddit_link&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($title, $url, $subreddit) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @_; 

    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $reddit       &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Reddit::Client&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;(
        session_file &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;logs/session_data.json&amp;#39;&lt;/span&gt;,
        user_agent   &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;perly_bot/v0.01&amp;#39;&lt;/span&gt;,
    );  

    &lt;span style=&#34;color:#66d9ef&#34;&gt;unless&lt;/span&gt; ( $reddit&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;is_logged_in ) { 
        $reddit&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;login( $ENV{REDDIT_USERNAME}, 
                        $ENV{REDDIT_PASSWORD} );
        $reddit&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;save_session();
    }   
    
    try {
        $reddit&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;submit_link(
            subreddit &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; $subreddit,
            title     &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; $title,
            url       &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; $url
        );
    } catch {
        log_error(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Error posting $title $url $_&amp;#34;&lt;/span&gt;);
    };
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;log_error&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $datetime &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; localtime;
    say $ERROR_LOG $datetime_now&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;datetime &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\t$_[0]&amp;#34;&lt;/span&gt;;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;In addition to the try/catch, I&amp;rsquo;ve added a &lt;code&gt;log_error&lt;/code&gt; subroutine which will write error messages to the error log.&lt;/p&gt;

&lt;h3 id=&#34;reading-blog-feeds&#34;&gt;Reading blog feeds&lt;/h3&gt;

&lt;p&gt;Now I have a subroutine for posting links to Reddit, I need a way to monitor blog feeds and post links to new articles. Most blogs provide feed data via RSS or atom data, for example &lt;a href=&#34;http://blogs.perl.org&#34;&gt;blogs.perl.org&lt;/a&gt; uses atom. I can monitor this feed using &lt;a href=&#34;https://metacpan.org/pod/HTTP::Tiny&#34;&gt;HTTP::Tiny&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/XML::Atom::Client&#34;&gt;XML::Atom::Client&lt;/a&gt;.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; XML::Atom::Client;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; HTTP::Tiny;

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;check_feed&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($url) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @_;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $ua &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HTTP::Tiny&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $ua&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;get($url);
    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ( $response&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{success} )
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $posts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 
          XML::Atom::Feed&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;( Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt;$response&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{content} );

        &lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $post ( $posts&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;entries )
        {
            post_reddit_link(
                $post&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;title,
                $post&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;link&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;href,
                &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;perl&amp;#39;&lt;/span&gt;
            );
        }
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
    {
        log_error(
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Error requesting $url. $response-&amp;gt;{status} $response-&amp;gt;{reason}&amp;#34;&lt;/span&gt;
        );
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code declares a subroutine called &lt;code&gt;check_feed&lt;/code&gt; which accepts a URL as parameter. It fetches the URL content using HTTP::Tiny, and if successful, loops through every blog post in an atom feed, calling &lt;code&gt;post_reddit_link&lt;/code&gt; on each post. As it stands, this code is going to cause problems. We only want to post relevant and new content to the Perl subreddit, but this code will post a link for every blog post returned by the feed URL.&lt;/p&gt;

&lt;p&gt;To check for relevant content, I can use a regex to match against keywords. If the text contains words like &amp;ldquo;Perl&amp;rdquo; or &amp;ldquo;CPAN&amp;rdquo;, I assume it&amp;rsquo;s Perl related. This is the regex:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#75715e&#34;&gt;#  must contain a Perl keyword to be considered relevant&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $looks_perly &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;qr/\b(?:perl|cpan|cpanminus|moose|metacpan|modules?)\b/&lt;/span&gt;i;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;To filter out stale content, I need to set a threshold for how long posts should be considered fresh. I can then subtract the publication date of the blog post from the current datetime to see if the publication date exceeds my threshold or not. I&amp;rsquo;m going to use 24 hours as my threshold:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Time::Piece;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Time::Seconds;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $datetime_post &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; 
  Time::Piece&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;strptime($post&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;published, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%Y-%m-%dT%H:%M:%SZ&amp;#39;&lt;/span&gt;);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $datetime_now &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; localtime;

&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ( $datetime_post &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; $datetime_now &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; ONE_DAY )
{
   &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;This code uses the &lt;code&gt;strptime&lt;/code&gt; function in Time::Piece to extract the publication datetime of the post. It then compares the datetime of the post with the current datetime minus 24 hours (&amp;ldquo;ONE_DAY&amp;rdquo; is a constant for 24 hours that is exported by Time::Seconds).&lt;/p&gt;

&lt;h3 id=&#34;wrap-up&#34;&gt;Wrap up&lt;/h3&gt;

&lt;p&gt;Putting it all together, the code looks like this:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; warnings;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; strict;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Reddit::Client;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Try::Tiny;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Time::Piece;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Time::Seconds;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; XML::Atom::Client;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; HTTP::Tiny;

open &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $ERROR_LOG, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;&amp;gt;&amp;gt;&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;logs/error.log&amp;#39;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;or&lt;/span&gt; die $!;

&lt;span style=&#34;color:#75715e&#34;&gt;#  must contain a Perl keyword to be considered relevant&lt;/span&gt;
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $looks_perly &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;qr/\b(?:perl|cpan|cpanminus|moose|metacpan|modules?)\b/&lt;/span&gt;i;

&lt;span style=&#34;color:#75715e&#34;&gt;# post links for new posts on blogs.perl.org&lt;/span&gt;
check_feed(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://blogs.perl.org/atom.xml&amp;#39;&lt;/span&gt;);

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;post_reddit_link&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($title, $url, $subreddit) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @_;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $reddit       &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; Reddit::Client&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;(
        session_file &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;logs/session_data.json&amp;#39;&lt;/span&gt;,
        user_agent   &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;perly_bot/v0.01&amp;#39;&lt;/span&gt;,
    );

    &lt;span style=&#34;color:#66d9ef&#34;&gt;unless&lt;/span&gt; ( $reddit&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;is_logged_in ) {
        $reddit&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;login( $ENV{REDDIT_USERNAME},
                        $ENV{REDDIT_PASSWORD} );
        $reddit&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;save_session();
    }

    try {
        $reddit&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;submit_link(
            subreddit &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; $subreddit,
            title     &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; $title,
            url       &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; $url
        );
    } catch {
        log_error(&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Error posting $title $url $_&amp;#34;&lt;/span&gt;);
    };
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;log_error&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $datetime &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; localtime;
    say $ERROR_LOG $datetime&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;datetime &lt;span style=&#34;color:#f92672&#34;&gt;.&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;\t$_[0]&amp;#34;&lt;/span&gt;;
}

&lt;span style=&#34;color:#66d9ef&#34;&gt;sub&lt;/span&gt; &lt;span style=&#34;color:#a6e22e&#34;&gt;check_feed&lt;/span&gt;
{
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; ($url) &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; @_;

    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $ua &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HTTP::Tiny&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;;
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $response &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $ua&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;get($url);

    &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ( $response&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{success} )
    {
        &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $posts &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
          XML::Atom::Feed&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;( Stream &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt;$response&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{content} );

        &lt;span style=&#34;color:#66d9ef&#34;&gt;foreach&lt;/span&gt; &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $post ( $posts&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;entries )
        {
            &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $datetime_post &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt;
              Time::Piece&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;strptime($post&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;published, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;%Y-%m-%dT%H:%M:%SZ&amp;#39;&lt;/span&gt;);
            &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $datetime_now &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; localtime;

            &lt;span style=&#34;color:#75715e&#34;&gt;# if fresh post and contains Perl keyword&lt;/span&gt;
            &lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; (   $datetime_post &lt;span style=&#34;color:#f92672&#34;&gt;&amp;gt;&lt;/span&gt; $datetime_now &lt;span style=&#34;color:#f92672&#34;&gt;-&lt;/span&gt; ONE_DAY
                &lt;span style=&#34;color:#f92672&#34;&gt;&amp;amp;&amp;amp;&lt;/span&gt; $post&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;summary &lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt; $looks_perly)
            {
                post_reddit_link(
                    $post&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;title,
                    $post&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;link&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;href,
                    &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;perl&amp;#39;&lt;/span&gt;
                );
            }
        }
    }
    &lt;span style=&#34;color:#66d9ef&#34;&gt;else&lt;/span&gt;
    {
        log_error(
&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Error requesting $url. $response-&amp;gt;{status} $response-&amp;gt;{reason}&amp;#34;&lt;/span&gt;
        );
    }
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;When run, this script will check blogs.perl.org for new posts, and submit them to /r/perl.&lt;/p&gt;

&lt;p&gt;There&amp;rsquo;s a lot more that could be done with this script: for instance it only supports atom feeds, but many blog feeds use RSS. The URLs to check must be hard coded into the script - it would be better to take them from a configurable list. Finally, there is no URL caching, so running this script twice in 24 hours will lead to it attempting to post the same links to Reddit twice. For an extended example that addresses these issues and more, check out my Perly-Bot GitHub &lt;a href=&#34;https://github.com/dnmfarrell/Perly-Bot&#34;&gt;repo&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>HTML pro-parsing tips</title>
      <link>http://localhost:1313/article/101/2014/7/10/HTML-pro-parsing-tips/</link>
      <pubDate>Thu, 10 Jul 2014 12:33:45 +0000</pubDate>
      
      <guid>http://localhost:1313/article/101/2014/7/10/HTML-pro-parsing-tips/</guid>
      <description>

&lt;p&gt;&lt;em&gt;Perl has some fantastic modules for parsing HTML and one of the best is XML::LibXML. It&amp;rsquo;s an interface to the libxml2 C library; super fast but also super-picky. I&amp;rsquo;ve often found XML::LibXML croaking on relatively simple - but incorrectly formed HTML. If you find this, do not give up! This article shares 3 simple techniques for overcoming malformed HTML when parsing with XML::LibXML.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;tip-1-turn-on-recovery-mode&#34;&gt;Tip 1: turn on recovery mode&lt;/h3&gt;

&lt;p&gt;If XML::LibXML is croaking on a later part of the HTML, try turning on recovery mode, which will return all of the correctly parsed HTML up until XML::LibXML encountered the error.&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; XML::LibXML;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $xml &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; XML::LibXML&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;( recover &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt; );
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $dom &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $xml&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;load_html( string &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; $html );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;With recovery mode set to 1, the parser will still warn about parsing errors. To suppress the warnings, set recover to 2.&lt;/p&gt;

&lt;h3 id=&#34;tip-2-sanitize-the-input-first-with-html-scrubber&#34;&gt;Tip 2: sanitize the input first with HTML::Scrubber&lt;/h3&gt;

&lt;p&gt;Sometimes recovery mode alone is not enough - XML::LibXML will croak at the first whiff of HTML if there are two doctype declarations for example. In these situations, consider sanitizing the HTML with &lt;a href=&#34;https://metacpan.org/pod/HTML::Scrubber&#34;&gt;HTML::Scrubber&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;HTML::Scrubber provides both whitelist and blacklist functions to include or exclude HTML tags and attributes. It&amp;rsquo;s a powerful combination which allows you to create a custom filter to scrub the HTML that you want to parse.&lt;/p&gt;

&lt;p&gt;By default HTML::Scrubber removes all tags, but in the case of a duplicate doctype declaration, you just need that one tag removed. Let&amp;rsquo;s remove all div tags too for good measure:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; HTML::Scrubber;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $scrubber &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HTML::Scrubber&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;( deny &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; [ &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;doctype&amp;#39;&lt;/span&gt;, &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;div&amp;#39;&lt;/span&gt; ],
                                    allow&lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;*&amp;#39;&lt;/span&gt; );
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $scrubbed_html &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; $scrubber&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;scrub($html);
&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $dom &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; XML::LibXML&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;load_html( string &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; $scrubbed_html );&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The &amp;ldquo;deny&amp;rdquo; rule sets the scrubber blacklist (what to exclude) and the &amp;ldquo;allow&amp;rdquo; rule specifies the whitelist (what to include). Here we passed an asterisk (&amp;rdquo;*&amp;rdquo;) to allow, which means allow everything, but because we&amp;rsquo;re denying div and doctype tags, they&amp;rsquo;ll be removed.&lt;/p&gt;

&lt;h3 id=&#34;tip-3-extract-a-subset-of-data-with-a-regex-capture&#34;&gt;Tip 3: extract a subset of data with a regex capture&lt;/h3&gt;

&lt;p&gt;If the subset HTML you want to parse has a unique identifier (such as an id attribute), consider using a regex capture to extract it from the HTML document. You can then scrub or immediately parse this subset with XML::LibXML.&lt;/p&gt;

&lt;p&gt;For example recently I had to extract an HTML table from a badly-formed web page. Fortunately the table had an id attribute, which made extracting it with a regex a piece-of-cake:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;if&lt;/span&gt; ( $html &lt;span style=&#34;color:#f92672&#34;&gt;=~&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;/(&amp;lt;table id=&amp;#34;t2&amp;#34;&amp;gt;.*?&amp;lt;\/table&amp;gt;)/s&lt;/span&gt; ) {
    &lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $dom &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; XML::LibXML&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;load_html( string &lt;span style=&#34;color:#f92672&#34;&gt;=&amp;gt;&lt;/span&gt; $1 );
    &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note the use of the &amp;ldquo;s&amp;rdquo; modifier in the regex to match multiline. Many HTML pages contain newlines and you don&amp;rsquo;t want your match fail because of that.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;Hopefully these tips will make parsing HTML with XML::LibXML easier. My GitHub account has a web scraper &lt;a href=&#34;https://gist.github.com/sillymoose/998b9199007589199dce#file-get_swift_code-pl-L42&#34;&gt;script&lt;/a&gt; that uses some of these tips. If you&amp;rsquo;re looking for an entirely different approach to parsing HTML, check out &lt;a href=&#34;https://metacpan.org/pod/XML::Rabbit&#34;&gt;XML::Rabbit&lt;/a&gt; and &lt;a href=&#34;https://metacpan.org/pod/HTML::TreeBuilder&#34;&gt;HTML::TreeBuilder&lt;/a&gt;.&lt;/p&gt;

&lt;p&gt;Enjoyed this article? Help us out and &lt;a href=&#34;https://twitter.com/intent/tweet?original_referer=http%3A%2F%2Fperltricks.com%2Farticle%2F101%2F2014%2F7%2F10%2FHTML-pro-parsing-tips&amp;amp;text=HTML+pro-parsing+tips&amp;amp;tw_p=tweetbutton&amp;amp;url=http%3A%2F%2Fperltricks.com%2Farticle%2F101%2F2014%2F7%2F10%2FHTML-pro-parsing-tips&amp;amp;via=perltricks&#34;&gt;tweet&lt;/a&gt; about it!&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Parsing data couldn&#39;t be easier with XML::Dataset</title>
      <link>http://localhost:1313/article/87/2014/5/9/Parsing-data-couldn-t-be-easier-with-XML--Dataset/</link>
      <pubDate>Fri, 09 May 2014 03:14:01 +0000</pubDate>
      
      <guid>http://localhost:1313/article/87/2014/5/9/Parsing-data-couldn-t-be-easier-with-XML--Dataset/</guid>
      <description>

&lt;p&gt;&lt;em&gt;It&amp;rsquo;s hard to believe that when it comes to XML parsing CPAN hasn&amp;rsquo;t already got you covered, but &lt;a href=&#34;https://metacpan.org/pod/XML::Dataset&#34;&gt;XML::Dataset&lt;/a&gt; is a new module that fills a useful void. XML::Dataset let&amp;rsquo;s you declare a plaintext data collection schema, and then goes and extracts the data for you, super fast. Read on to see how it works.&lt;/em&gt;&lt;/p&gt;

&lt;h3 id=&#34;requirements&#34;&gt;Requirements&lt;/h3&gt;

&lt;p&gt;The CPAN Testers results &lt;a href=&#34;http://matrix.cpantesters.org/?dist=XML-Dataset+0.006&#34;&gt;show&lt;/a&gt; that XML::Dataset v0.06 will run on any platform with Perl (down to 5.8.9). To install the module with CPAN, open up the terminal and type:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;$ cpan XML::Dataset&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;your-data-extracted&#34;&gt;Your data, extracted&lt;/h3&gt;

&lt;p&gt;To use XML::Dataset you&amp;rsquo;ll need some stringified XML source data and a data profile. A profile is just a plaintext schema which specifies the data you&amp;rsquo;d like to extract. Let&amp;rsquo;s look at an example:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; strict;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; warnings;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; XML::Dataset;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Printer;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $sample_data &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;q(&amp;lt;?xml version=&amp;#34;1.0&amp;#34;?&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;colleagues&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;lt;colleague&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;lt;title&amp;gt;The Boss&amp;lt;/title&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;lt;phone&amp;gt;+1 202-663-9108&amp;lt;/phone&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;lt;/colleague&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;lt;colleague&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;lt;title&amp;gt;Admin Assistant&amp;lt;/title&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;lt;phone&amp;gt;+1 347-999-5454&amp;lt;/phone&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;lt;email&amp;gt;inbox@the_company.com&amp;lt;/email&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;lt;/colleague&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;lt;colleague&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;lt;title&amp;gt;Minion&amp;lt;/title&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;        &amp;lt;phone&amp;gt;+1 792-123-4109&amp;lt;/phone&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;    &amp;lt;/colleague&amp;gt;
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;&amp;lt;/colleagues&amp;gt;)&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $sample_data_profile
    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;q(colleagues
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            colleague
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                title   = dataset:colleagues
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                email   = dataset:colleagues
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                phone   = dataset:colleagues)&lt;/span&gt;;

p parse_using_profile($sample_data, $sample_data_profile);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The code above declares a simple XML dataset ($sample_data) and a data profile to extract the required data ($sample_data_profile). XML::Dataset requires every indented newline in the data profile to map to another nested level of the data set. Once we reach the data attributes we want to extract, we simply assign a dataset to them (dataset:colleagues).&lt;/p&gt;

&lt;p&gt;XML::Dataset exports the &amp;ldquo;parse_using_profile&amp;rdquo; function which extracts the data using our data profile and returns a Perl data structure. We use &lt;a href=&#34;https://metacpan.org/pod/Data::Printer&#34;&gt;Data::Printer&lt;/a&gt; to print out the results. Running this code we get this output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt; {
    colleagues   [
        [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] {
            phone   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;+1 202-663-9108&amp;#34;&lt;/span&gt;,
            title   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;The Boss&amp;#34;&lt;/span&gt;
        },
        [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] {
            email   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;inbox@the_company.com&amp;#34;&lt;/span&gt;,
            phone   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;+1 347-999-5454&amp;#34;&lt;/span&gt;,
            title   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Admin Assistant&amp;#34;&lt;/span&gt;
        },
        [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] {
            phone   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;+1 792-123-4109&amp;#34;&lt;/span&gt;,
            title   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Minion&amp;#34;&lt;/span&gt;
        },
    ]
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Note that XML::Dataset had no problem extracting the one email address that was present in the data, even though the other colleagues did not have that attribute. What if we wanted to collect emails and phone numbers, but in separate datasets? All we need to do is update $sample_data_profile with two datasets:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $sample_data_profile
    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;q(colleagues
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            colleague
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                title   = dataset:emails dataset:phones
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                email   = dataset:emails
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                phone   = dataset:phones)&lt;/span&gt;;&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;Re-running the code, XML::Dataset now produces two datasets for us:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt; {
    emails   [
        [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] {
            title   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;The Boss&amp;#34;&lt;/span&gt;
        },
        [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] {
            email   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;inbox@the_company.com&amp;#34;&lt;/span&gt;,
            title   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Admin Assistant&amp;#34;&lt;/span&gt;
        },
        [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] {
            title   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Minion&amp;#34;&lt;/span&gt;
        }
    ],
    phones   [
        [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;] {
            phone   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;+1 202-663-9108&amp;#34;&lt;/span&gt;,
            title   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;The Boss&amp;#34;&lt;/span&gt;
        },
        [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;] {
            phone   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;+1 347-999-5454&amp;#34;&lt;/span&gt;,
            title   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Admin Assistant&amp;#34;&lt;/span&gt;
        },
        [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;] {
            phone   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;+1 792-123-4109&amp;#34;&lt;/span&gt;,
            title   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;Minion&amp;#34;&lt;/span&gt;
        }
    ]
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;h3 id=&#34;a-real-example&#34;&gt;A real example&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s write a program to parse a a more realistic data set. Many websites provide a sitemap that lists all of the content on the website, and when it was last updated. This information is used by search engines to optimize their crawling routines. The sitemap has a defined xml format, so it&amp;rsquo;s a cinch to parse it with XML::Dataset:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; strict;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; warnings;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; XML::Dataset;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; Data::Printer;
&lt;span style=&#34;color:#66d9ef&#34;&gt;use&lt;/span&gt; HTTP::Tiny;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $url &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#39;http://perltricks.com/sitemap.xml&amp;#39;&lt;/span&gt;;

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $sitemap_data 
    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; HTTP::Tiny&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;&lt;span style=&#34;color:#66d9ef&#34;&gt;new&lt;/span&gt;&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;get($url)&lt;span style=&#34;color:#f92672&#34;&gt;-&amp;gt;&lt;/span&gt;{content};

&lt;span style=&#34;color:#66d9ef&#34;&gt;my&lt;/span&gt; $sitemap_data_profile
    &lt;span style=&#34;color:#f92672&#34;&gt;=&lt;/span&gt; &lt;span style=&#34;color:#e6db74&#34;&gt;q(urlset
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;            url
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                loc     = dataset:sitemap_locations_modified
&lt;/span&gt;&lt;span style=&#34;color:#e6db74&#34;&gt;                lastmod = dataset:sitemap_locations_modified)&lt;/span&gt;;

p parse_using_profile($sitemap_data, $sitemap_data_profile);&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;The code above downloads the PerlTricks.com sitemap using &lt;a href=&#34;https://metacpan.org/pod/HTTP::Tiny&#34;&gt;HTTP::Tiny&lt;/a&gt; and extracts every URL and last modified timestamp from the sitemap. Running the code, we get this output:&lt;/p&gt;
&lt;div class=&#34;highlight&#34;&gt;&lt;pre style=&#34;color:#f8f8f2;background-color:#272822;-moz-tab-size:4;-o-tab-size:4;tab-size:4&#34;&gt;&lt;code class=&#34;language-perl&#34; data-lang=&#34;perl&#34;&gt;&lt;span style=&#34;color:#f92672&#34;&gt;\&lt;/span&gt; {
    sitemap_locations_modified   [
        [&lt;span style=&#34;color:#ae81ff&#34;&gt;0&lt;/span&gt;]  {
            lastmod   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2014-05-09&amp;#34;&lt;/span&gt;,
            loc       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://perltricks.com/&amp;#34;&lt;/span&gt;
        },
        [&lt;span style=&#34;color:#ae81ff&#34;&gt;1&lt;/span&gt;]  {
            lastmod   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2013-03-24&amp;#34;&lt;/span&gt;,
            loc       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://perltricks.com/article/1/2013/3/24/3-quick-ways-to-find-out-the-version-number-of-an-installed-Perl-module-from-the-terminal&amp;#34;&lt;/span&gt;
        },
        [&lt;span style=&#34;color:#ae81ff&#34;&gt;2&lt;/span&gt;]  {
            lastmod   &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;2013-03-27&amp;#34;&lt;/span&gt;,
            loc       &lt;span style=&#34;color:#e6db74&#34;&gt;&amp;#34;http://perltricks.com/article/3/2013/3/27/How-to-cleanly-uninstall-a-Perl-module&amp;#34;&lt;/span&gt;
        },
        &lt;span style=&#34;color:#f92672&#34;&gt;...&lt;/span&gt;
    ]
}&lt;/code&gt;&lt;/pre&gt;&lt;/div&gt;
&lt;p&gt;No problem! We could re-use that same program to download and parse any sitemap on the Internet.&lt;/p&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;XML::Dataset is fantastic for extracting fixed data schemas from XML. The plaintext data profiles are so easy to use, a non-programmer could write them. XML::Dataset is also fast: under the hood it uses XML::LibXML (and a few optimizations) and could be adapted for well-formatted HTML. It has great &lt;a href=&#34;https://metacpan.org/pod/XML::Dataset&#34;&gt;documentation&lt;/a&gt; and offers some advanced features like partial dataset parse dispatching. Module author James Spurin deserves credit for producing a quality module and a welcome addition to CPAN&amp;rsquo;s XML namespace.&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Do you have a much-loved CPAN module that you&amp;rsquo;d like us to cover? Drop us an &lt;a href=&#34;mailto:perltricks.com@gmail.com&#34;&gt;email&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;em&gt;Cover image &lt;a href=&#34;https://creativecommons.org/licenses/by/2.0/&#34;&gt;©&lt;/a&gt; &lt;a href=&#34;https://www.flickr.com/photos/dullhunk/3948166814/in/photolist-71TorC-5RcLVC-5RcLk1-5R8vpe-5RcMC9-5R8w7D-5R8v7e-5RcM9Q-5RcLeL-5R8upk-5RcMso-5RcL7J-72QCEU-7KoKym-72QCsE-6FtTJ-6m6pyB-5AJCpY-6FvjN-6FuLy-6FtQL-6Fv4J-5BHeXd-6FuUe-6FtXH-6Fu9t-6FuAs-5AJCs3-5AJCsd-5AJCro-tS2dS-6kzkkD-6kDvjQ-6kDAtY-6kDvzS-6kD45L-6kzqYM-6kDvsE-6kDuys-6kDvcE-6m6prT-6kDupU-6kDuWw-6kDv6j-6kzkd2-6kDALo-5AJCsA-CJhVy-5AJCrN-5MzAkw&#34;&gt;Duncun Hull&lt;/a&gt;&lt;/em&gt;&lt;/p&gt;

&lt;p&gt;&lt;br /&gt;
&lt;em&gt;This article was originally posted on &lt;a href=&#34;http://perltricks.com&#34;&gt;PerlTricks.com&lt;/a&gt;.&lt;/em&gt;&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>MSXML, It&#39;s Not Just for VB Programmers Anymore</title>
      <link>http://localhost:1313/pub/2001/04/17/msxml.html/</link>
      <pubDate>Tue, 17 Apr 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/04/17/msxml.html/</guid>
      <description>

&lt;p&gt;My co-workers cringe when I tell them the truth. &lt;em&gt;What XML parser are you using? MSXML? With Perl?&lt;/em&gt; You&amp;rsquo;ve gotta be crazy.&lt;/p&gt;

&lt;p&gt;Yes, it&amp;rsquo;s true, but I couldn&amp;rsquo;t help myself. After test driving MSXML in a Visual Basic application, it begged the question: &amp;ldquo;I wonder if Perl can use MSXML?&amp;rdquo;&lt;/p&gt;

&lt;p&gt;I have been using MSXML to do my XML parsing in Perl and the truth is that Perl is excellent for working with the Microsoft&amp;rsquo;s MSXML Parser on the Win32 platform. If you use Perl on Win32, give MSXML a try from the comfort of your favorite text editor.&lt;/p&gt;

&lt;h3 id=&#34;grab-the-msxml-parser&#34;&gt;Grab the MSXML Parser&lt;/h3&gt;

&lt;h4 id=&#34;you-grab-it&#34;&gt;You Grab It&lt;/h4&gt;

&lt;p&gt;Go to Microsoft&amp;rsquo;s &lt;a href=&#34;http://www.msdn.microsoft.com/xml/default.asp&#34;&gt;MSDN site&lt;/a&gt; to download the latest version of MSXML, which is the 3.0 Release. Run the installation program and restart your machine. You have installed the latest version in side-by-side mode. None of your other Microsoft applications that use previous versions of MSXML will be affected.&lt;/p&gt;

&lt;h4 id=&#34;now-let-perl-at-it&#34;&gt;Now Let Perl at It&lt;/h4&gt;

&lt;p&gt;Perl can control the MSXML parser using OLE. As with almost everything Perl, the difficult part has been done for us. The &amp;ldquo;kind people at Hip and ActiveWare(ActiveState)&amp;rdquo; have already provided us with the &lt;code&gt;Win32::OLE&lt;/code&gt; module. The only thing that we need to know is the progID for the MSXML parser. A progID is a string used to uniquely identify an OLE automation class in the Windows registry. MSXML offers version dependent and version independent progIDs depending on the method of the installation. Since we have installed MSXML in side-by-side mode, we will need to use the version dependent progID.&lt;/p&gt;

&lt;h3 id=&#34;creating-an-ole-instance-of-msxml-domdocument&#34;&gt;Creating an OLE Instance of MSXML.DOMDocument&lt;/h3&gt;

&lt;p&gt;I begin by using the &lt;code&gt;Win32::OLE&lt;/code&gt; module.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;use Win32::OLE qw(in with);  # make sure you include(in &amp;amp; with)!!
                             # we will need them later.
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Now I am ready to use OLE to create an instance of the MSXML parser or, more correctly, an OLE instance of &lt;code&gt;MSXML2.DOMDocument.3.0&lt;/code&gt;, which I will simply call a DOMDocument.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;# Version dependent method - this is what we want -
  my $DOM_document = Win32::OLE-&amp;gt;new(&#39;MSXML2.DOMDocument.3.0&#39;) 
    or die &amp;quot;couldn&#39;t create&amp;quot;;

# Version independent method - Assumes MSXML was installed in Replace Mode
# if you get errors with the above example - try using this example.
  my $DOM_document = Win32::OLE-&amp;gt;new(&#39;MSXML2.DOMDocument&#39;) 
    or die &amp;quot;couldn&#39;t create&amp;quot;;
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;parsing-the-xml&#34;&gt;Parsing the XML&lt;/h3&gt;

&lt;p&gt;Since I am a swim coach, I keep all kind of records, times and scores on hand. One of my favorite things to track is records, so I maintain an XML document that contains the school&amp;rsquo;s top 10 times for each event. Below is what &lt;strong&gt;toptimes.xml&lt;/strong&gt; looks like:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;TOP_TEN_TIMES&amp;gt;
   &amp;lt;EVENT NAME=&amp;quot;200 Freestyle&amp;quot;&amp;gt;
      &amp;lt;SWIMMER NUMBER=&amp;quot;1&amp;quot; TIME=&amp;quot;1:51.49&amp;quot; DATE=&amp;quot;2/21/98&amp;quot; NAME=&amp;quot;Chris Miller&amp;quot;/&amp;gt;
      &amp;lt;SWIMMER NUMBER=&amp;quot;2&amp;quot; TIME=&amp;quot;1:54.19&amp;quot; DATE=&amp;quot;2/17/01&amp;quot; NAME=&amp;quot;Peter Myers&amp;quot;/&amp;gt;
 ...
      &amp;lt;SWIMMER NUMBER=&amp;quot;10&amp;quot; TIME=&amp;quot;2:19.31&amp;quot; DATE=&amp;quot;12/8/00&amp;quot; NAME=&amp;quot;Andrew Johnson&amp;quot;/&amp;gt;
   &amp;lt;/EVENT&amp;gt;
   &amp;lt;EVENT NAME=&amp;quot;200 IM&amp;quot;&amp;gt;
 ... 
   &amp;lt;/EVENT&amp;gt;
   ...
&amp;lt;/TOP_TEN_TIMES&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;My backstrokers and butterfliers don&amp;rsquo;t like XML very much, so I want to parse the XML document and print out the top 10 times for the 100 backstroke and 100 butterfly. I begin by loading &lt;strong&gt;toptimes.xml&lt;/strong&gt; using the DOMDocument object that I have already created. The load method is where the XML document is actually parsed into its respective pieces such as Nodes and NodeLists. Validation also occurs at this point. The Load method returns a boolean that I can use to test whether my document loaded properly. I am going to validate my document, so I will set the &lt;code&gt;validateOnParse&lt;/code&gt; property to &amp;lsquo;True&amp;rsquo;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt; $DOM_document-&amp;gt;{async} = &amp;quot;False&amp;quot;;           # disable asynchrous
 $DOM_document-&amp;gt;{validateOnParse} = &amp;quot;True&amp;quot;;  # validate
 my $boolean_Load = $DOM_document-&amp;gt;Load(&amp;quot;topten.xml&amp;quot;);
 if (!$boolean_Load) 
 {
   die &amp;quot;topten.xml did not load&amp;quot;;
 }
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;iterating-through-the-xml-document&#34;&gt;Iterating Through the XML Document&lt;/h3&gt;

&lt;p&gt;Now that I have successfully loaded the document, I need a method of iterating through all of the document Nodes. In order to iterate through the document, I first need to find the root Node. In this example, the root Node is &lt;code&gt;&amp;lt;TOP_TEN_TIMES&amp;gt;&lt;/code&gt;, so I will define &lt;code&gt;$Top_Ten_Times&lt;/code&gt; to be the root Node of the xml document as such:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $Top_Ten_Times = $DOM_document-&amp;gt;DocumentElement();  # assign the root node
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Next, I want to find all of the child Nodes of &lt;code&gt;&amp;lt;TOP_TEN_TIMES&amp;gt;&lt;/code&gt;. &lt;code&gt;$Events&lt;/code&gt; will be all of the root&amp;rsquo;s child Nodes. In this example, &lt;code&gt;$Events&lt;/code&gt; refers to every &lt;code&gt;&amp;lt;EVENT&amp;gt;&lt;/code&gt; Node.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $Events = $Top_Ten_Times-&amp;gt;childNodes();      # all of the root&#39;s child nodes
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;&lt;code&gt;$Events&lt;/code&gt; is now an NodeList (which is an OLE collection object) that I can use to iterate through each &lt;code&gt;&amp;lt;EVENT&amp;gt;&lt;/code&gt; node in the XML document. Veteran Perl programmers will recognize the iteration code as being very similar to iterating through the elements of an array. The only difference is the little keyword &lt;code&gt;&#39;in&#39;&lt;/code&gt; that I mentioned earlier when we used &lt;code&gt;Win32::OLE&lt;/code&gt;. The keyword &lt;code&gt;&#39;in&#39;&lt;/code&gt; is used to distinguish an OLE collection object from a standard Perl array.&lt;/p&gt;

&lt;p&gt;I now iterate over each &lt;code&gt;&amp;lt;EVENT&amp;gt;&lt;/code&gt; Node in the document checking each time to see whether I have one of the events that I need. When I arrive at one of the desired events, I will print the &lt;code&gt;NAME&lt;/code&gt; Attribute of the current &lt;code&gt;&amp;lt;EVENT&amp;gt;&lt;/code&gt; Node and create a new NodeList called &lt;code&gt;$Swimmers&lt;/code&gt;. I will then iterate over each &lt;code&gt;&amp;lt;SWIMMER&amp;gt;&lt;/code&gt; Node and print the &lt;code&gt;TIME&lt;/code&gt; Attribute.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;foreach my $Event (in $Events) # make sure you include the &#39;in&#39;
{
   if ( ($Event-&amp;gt;Attributes-&amp;gt;getNamedItem(&amp;quot;NAME&amp;quot;)-&amp;gt;{Text} eq &amp;quot;100 Backstroke&amp;quot;) ||
        ($Event-&amp;gt;Attributes-&amp;gt;getNamedItem(&amp;quot;NAME&amp;quot;)-&amp;gt;{Text} eq &amp;quot;100 Butterfly&amp;quot;) )
   {
       # print the event name stored in the NAME attribute
        print $Event-&amp;gt;Attributes-&amp;gt;getNamedItem(&amp;quot;NAME&amp;quot;)-&amp;gt;{Text}, &amp;quot;\n&amp;quot;; 
        my $Swimmers = $Event-&amp;gt;childNodes();       # $Swimmers is now a NodeList collection
        foreach my $Swimmer (in $Swimmers )        # iterate through all swimmers
        {
           print $Swimmer-&amp;gt;Attributes-&amp;gt;getNamedItem(&amp;quot;TIME&amp;quot;)-&amp;gt;{Text}, &amp;quot;\n&amp;quot;;  # print the time
        }
   }
}
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;transforming-the-xml&#34;&gt;Transforming the XML&lt;/h3&gt;

&lt;p&gt;Now that I have satisfied the butterfliers and backstrokers on my team, I am beginning to realize that the design of my XML syntax is less than desirable. Most of my actual data is stored as attribute data, and I would really like it to be element data. I am going to perform a transformation that will place all of my actual data into element data. My goal is to make the XML document look like the following.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;TOP_TEN_TIMES&amp;gt;
   &amp;lt;EVENT&amp;gt;
      &amp;lt;EVENT_NAME&amp;gt;200 Freestyle&amp;lt;/EVENT_NAME&amp;gt;
      &amp;lt;SWIM&amp;gt;
         &amp;lt;SWIMMER&amp;gt;Chris Miller&amp;lt;/SWIMMER&amp;gt;
         &amp;lt;TIME&amp;gt;1:51.49&amp;lt;/TIME&amp;gt;
         &amp;lt;DATE&amp;gt;2/21/98&amp;lt;/DATE&amp;gt;
      &amp;lt;/SWIM&amp;gt;
      &amp;lt;SWIM&amp;gt;
         &amp;lt;SWIMMER&amp;gt;Peter Myers&amp;lt;/SWIMMER&amp;gt;
         &amp;lt;TIME&amp;gt;1:54.19&amp;lt;/TIME&amp;gt;
         &amp;lt;DATE&amp;gt;2/17/01&amp;lt;/DATE&amp;gt;
      &amp;lt;/SWIM&amp;gt;
      ...
   &amp;lt;/EVENT&amp;gt; 
   &amp;lt;EVENT&amp;gt;
      ...
   &amp;lt;/EVENT&amp;gt;
   ...
&amp;lt;/TOP_TEN_TIMES&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After a little work, I come up with the following stylesheet to do the transformation.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;&amp;lt;?xml version=&amp;quot;1.0&amp;quot; encoding=&amp;quot;ISO-8859-1&amp;quot;?&amp;gt; 
&amp;lt;xsl:stylesheet xmlns:xsl=&amp;quot;http://www.w3.org/1999/XSL/Transform&amp;quot; version=&amp;quot;1.0&amp;quot;&amp;gt;
&amp;lt;xsl:output method=&amp;quot;xml&amp;quot; indent=&amp;quot;yes&amp;quot; encoding=&amp;quot;ISO-8859-1&amp;quot;/&amp;gt;
&amp;lt;xsl:template match=&amp;quot;/&amp;quot;&amp;gt;
&amp;lt;TOP_TEN_TIMES&amp;gt;
&amp;lt;xsl:for-each select=&amp;quot;TOP_TEN_TIMES&amp;quot;&amp;gt;
  &amp;lt;xsl:for-each select=&amp;quot;EVENT&amp;quot;&amp;gt;
  &amp;lt;EVENT&amp;gt;
     &amp;lt;EVENT_NAME&amp;gt;&amp;lt;xsl:value-of select=&amp;quot;@NAME&amp;quot;/&amp;gt;&amp;lt;/EVENT_NAME&amp;gt;
     &amp;lt;xsl:for-each select=&amp;quot;SWIMMER&amp;quot;&amp;gt;
     &amp;lt;SWIM&amp;gt;
        &amp;lt;SWIMMER&amp;gt;&amp;lt;xsl:value-of select=&amp;quot;@NAME&amp;quot;/&amp;gt;&amp;lt;/SWIMMER&amp;gt;
        &amp;lt;TIME&amp;gt;&amp;lt;xsl:value-of select=&amp;quot;@TIME&amp;quot;/&amp;gt;&amp;lt;/TIME&amp;gt;
        &amp;lt;DATE&amp;gt;&amp;lt;xsl:value-of select=&amp;quot;@DATE&amp;quot;/&amp;gt;&amp;lt;/DATE&amp;gt;
     &amp;lt;/SWIM&amp;gt;
     &amp;lt;/xsl:for-each&amp;gt;
  &amp;lt;/EVENT&amp;gt;
  &amp;lt;/xsl:for-each&amp;gt;
&amp;lt;/xsl:for-each&amp;gt;
&amp;lt;/TOP_TEN_TIMES&amp;gt;
&amp;lt;/xsl:template&amp;gt;
&amp;lt;/xsl:stylesheet&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;To perform the transformation, I will need to create three OLE instances of DOMDocument. The first instance loads the top-times document and the second instance loads the stylesheet from above. The third instance will be used as the result of the transformation. I have created a subroutine that uses what we have already covered to create the three DOMDocument instances, and to load the top-times and stylesheet documents.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;sub Transform {
 # Assign the File Names
  my $xml_doc_file     = shift;
  my $stylesheet_file  = shift;
  my $new_xml_doc_file = shift;
  my $boolean_Load;

 # Create the three OLE DOM instances
  my $doc_to_transform = Win32::OLE-&amp;gt;new(&#39;MSXML2.DOMDocument.3.0&#39;);  
  my $style_sheet_doc  = Win32::OLE-&amp;gt;new(&#39;MSXML2.DOMDocument.3.0&#39;);
  my $transformed_doc  = Win32::OLE-&amp;gt;new(&#39;MSXML2.DOMDocument.3.0&#39;);

 # Load the Top Times document - just like above
  $doc_to_transform-&amp;gt;{async} = &amp;quot;False&amp;quot;;
  $doc_to_transform-&amp;gt;{validateOnParse} = &amp;quot;True&amp;quot;;
  $boolean_Load = $doc_to_transform-&amp;gt;Load(&amp;quot;$xml_doc_file&amp;quot;);
  if(!$boolean_Load)
  {
      die &amp;quot;The Top Times did not load\n&amp;quot;;
  }

 # Load the Stylesheet - just like above
  $style_sheet_doc-&amp;gt;{async} = &amp;quot;False&amp;quot;;
  $style_sheet_doc-&amp;gt;{validateOnParse} = &amp;quot;True&amp;quot;;
  $boolean_Load = $style_sheet_doc-&amp;gt;Load($stylesheet_file);
  if(!$boolean_Load)
  {
      die &amp;quot;The Stylesheet did not load\n&amp;quot;;
  }

 #Perform the transformation and save the resulting DOM object
  $doc_to_transform-&amp;gt;transformNodeToObject($style_sheet_doc, $transformed_doc);
  $transformed_doc-&amp;gt;save(&amp;quot;$new_xml_doc_file&amp;quot;);
}
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;The &lt;code&gt;transformNodeToObject&lt;/code&gt; method is where the magic happens. I use the top-times DOMDocument instance to invoke the &lt;code&gt;transformNodeToObject&lt;/code&gt; method and I pass the stylesheet and transformation-result instances as arguments. After the method returns, the result of the transformation is stored in &lt;code&gt;$transformed_doc&lt;/code&gt;, which is strictly in memory. We simply call the save method and write the XML document to disk.&lt;/p&gt;

&lt;p&gt;Now we can perform transformations using any stylesheet or XML document that we want (as long as the stylesheet relates to the XML document). We just need to pass the subroutine three file names: the name of the document to transform, the name of the stylesheet and the name of the new document. For our example, I will call the subroutine like the following.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;Transform(&amp;quot;toptimes.xml&amp;quot;, &amp;quot;toptimes.xsl&amp;quot;, &amp;quot;newtoptimes.xml&amp;quot;);
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;After this code has executed, I have a brand new XML document &lt;strong&gt;newtoptimes.xml&lt;/strong&gt; that conforms to my new XML syntax.&lt;/p&gt;

&lt;h3 id=&#34;updating-the-xml-document&#34;&gt;Updating the XML Document&lt;/h3&gt;

&lt;p&gt;After all this great work, one of my butterfliers informs me that I have been spelling his name wrong all season. I guess that there is two &amp;lsquo;e&amp;rsquo;s in Myers, not one. No problem. I can do this easily enough.&lt;/p&gt;

&lt;p&gt;I can&amp;rsquo;t use the exact code from above because the document structure has changed. Since the swimmers&amp;rsquo; names are pretty deep in the new structure, it will be too painful to find the root node and create a slew of nested loops (not to mention expensive to the processor). This is exactly what XPath is for. I will create a query to find all occurrences of &amp;ldquo;Peter Myers&amp;rdquo; and change them to &amp;ldquo;Peter Meyers&amp;rdquo;. Once again, I create an instance of DOMDocument and load the XML document. However, this time I will call a new method, the &lt;code&gt;selectNodes&lt;/code&gt; method, directly against the DOMDocument. As an argument, I supply an XPath query. The method returns a NodeList of all the Nodes that matched the XPath query. I can then iterate through the NodeList just like above and update the element data as I go.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;my $Peter_Nodes = 
     $new_DOM_document-&amp;gt;selectNodes(&amp;quot;TOP_TEN_TIMES/EVENT/SWIM/SWIMMER[. = \&amp;quot;Peter Myers\&amp;quot;]&amp;quot;);
foreach my $Peter (in $Peter_Nodes)
{
   $Peter-&amp;gt;{nodeTypedValue} = &amp;quot;Peter Meyers&amp;quot;  # update the Value
}
$new_DOM_document-&amp;gt;save(&amp;quot;newertoptimes.xml&amp;quot;); # save the changes
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;conclusion&#34;&gt;Conclusion&lt;/h3&gt;

&lt;p&gt;MSXML isn&amp;rsquo;t just for Visual Basic and Visual C++ programmers. The &lt;code&gt;Win32::OLE&lt;/code&gt; module allows Perl programmers to take advantage of Microsoft&amp;rsquo;s XML parser from the comfort of their favorite text editor, and now that everyone on the team is happy with the top ten times, I can put away my XML Parser until next season &amp;hellip; .&lt;/p&gt;

&lt;h3 id=&#34;resources&#34;&gt;Resources&lt;/h3&gt;

&lt;ul&gt;
&lt;li&gt;&lt;a href=&#34;http://localhost:1313/media/_pub_2001_04_17_msxml/msxml_sample_code.zip&#34;&gt;Download Sample Code&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.msdn.microsoft.com/xml/default.asp&#34;&gt;Microsoft MSDN XML Developer Center&lt;/a&gt;&lt;/li&gt;
&lt;li&gt;&lt;a href=&#34;http://www.activestate.com/ASPN/Mail/browse/perl-win32-users&#34;&gt;ActiveState&amp;rsquo;s Win32 Users Mailing List&lt;/a&gt;&lt;/li&gt;
&lt;/ul&gt;
</description>
    </item>
    
    <item>
      <title>Creating Data Output Files Using the Template Toolkit</title>
      <link>http://localhost:1313/pub/2001/01/tt2.html/</link>
      <pubDate>Tue, 23 Jan 2001 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/2001/01/tt2.html/</guid>
      <description>

&lt;table&gt;
&lt;colgroup&gt;
&lt;col width=&#34;100%&#34; /&gt;
&lt;/colgroup&gt;
&lt;tbody&gt;
&lt;tr class=&#34;odd&#34;&gt;
&lt;td&gt;Table of Contents&lt;/td&gt;
&lt;/tr&gt;
&lt;tr class=&#34;even&#34;&gt;
&lt;td&gt;&lt;p&gt;•&lt;a href=&#34;#a%20more%20complex%20example&#34;&gt;A more complex example&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#producing%20xml&#34;&gt;Producing XML&lt;/a&gt;&lt;br /&gt;
&lt;br /&gt;
•&lt;a href=&#34;#multiple%20formats&#34;&gt;Multiple Formats&lt;/a&gt;&lt;br /&gt;
&lt;/p&gt;&lt;/td&gt;
&lt;/tr&gt;
&lt;/tbody&gt;
&lt;/table&gt;

&lt;h3 id=&#34;span-id-introducing-the-template-toolkit-introducing-the-template-toolkit-span&#34;&gt;&lt;span id=&#34;introducing the template toolkit&#34;&gt;Introducing the Template Toolkit&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;There are a number of Perl modules that are universally recognised as The Right Thing To Use for certain tasks. If you accessed a database without using DBI, pulled data from the WWW without using on of the LWP modules or parsed XML without using XML::Parser or one of its subclasses then you&amp;rsquo;d run the risk of being shunned by polite Perl society.&lt;/p&gt;

&lt;p&gt;I believe that the year 2000 saw the emergence of another &amp;lsquo;must have&amp;rsquo; Perl module - the Template Toolkit. I don&amp;rsquo;t think I&amp;rsquo;m alone in this belief as the Template Toolkit won the &amp;lsquo;Best New Module&amp;rsquo; award at the Perl Conference last summer. Version 2.0 of the Template Toolkit (known as TT2 to its friends) was recently released to the CPAN.&lt;/p&gt;

&lt;p&gt;TT2 was designed and written by Andy Wardley &amp;lt;&lt;a href=&#34;mailto:abw@cre.canon.co.uk&#34;&gt;abw@cre.canon.co.uk&lt;/a&gt;&amp;gt;. It was born out of Andy&amp;rsquo;s previous templating module, Text::Metatext, in best Fred Brooks &amp;lsquo;plan to throw one away&amp;rsquo; manner; and aims to be the most useful (or, at least, the most &lt;em&gt;used&lt;/em&gt;) Perl templating system.&lt;/p&gt;

&lt;p&gt;TT2 provides a way to take a file of fixed boilerplate text (the template) and embed variable data within it. One obvious use of this is in the creation of dynamic web pages and this is where a lot of the attention that TT2 has received has been focussed. In this article, I hope to demonstrate that TT2 is just as useful in non-web applications.&lt;/p&gt;

&lt;h3 id=&#34;span-id-using-the-template-toolkit-using-the-template-toolkit-span&#34;&gt;&lt;span id=&#34;using the template toolkit&#34;&gt;Using the Template Toolkit&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Let&amp;rsquo;s look at how we&amp;rsquo;d use TT2 to process a simple data file. TT2 is an object oriented Perl module. Having downloaded it from CPAN and installed it in the usual manner, using it in your program is as easy as putting the lines&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    use Template;

    my $tt = Template-&amp;gt;new;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;in your code. The constructor function, &lt;code&gt;new&lt;/code&gt;, takes a number of optional parameters which are documented in the copious manual pages that come with the module, but for the purposes of this article we&amp;rsquo;ll keep things as simple as possible.&lt;/p&gt;

&lt;p&gt;To process the template, you would call the &lt;code&gt;process&lt;/code&gt; method like this&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    $tt-&amp;gt;process(&#39;my_template&#39;, \%data)
      || die $tt-&amp;gt;error;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We pass two parameters to &lt;code&gt;process&lt;/code&gt;, the first is the name of the file containing the template to process (in this case, my_template) and the second is a reference to a hash which contains the data items that you want to use in the template. If processing the template gives any kind of error, the program will die with a (hopefully) useful error message.&lt;/p&gt;

&lt;p&gt;So what kinds of things can go in &lt;code&gt;%data&lt;/code&gt;? The answer is just about anything. Here&amp;rsquo;s an example showing data about English Premier League football teams.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    my @teams = ({ name =&amp;gt; &#39;Man Utd&#39;,
                   played =&amp;gt; 16,
                   won =&amp;gt; 12,
                   drawn =&amp;gt; 3,
                   lost =&amp;gt; 1 },
                 { name =&amp;gt; &#39;Bradford&#39;,
                   played =&amp;gt; 16,
                   won =&amp;gt; 2,
                   drawn =&amp;gt; 5,
                   lost =&amp;gt; 9 });

    my %data = ( name =&amp;gt; &#39;English Premier League&#39;,
                 season =&amp;gt; &#39;2000/01&#39;,
                 teams =&amp;gt; \@teams );
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This creates three data items which can be accessed within the template, called &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;season&lt;/code&gt; and &lt;code&gt;teams&lt;/code&gt;. Notice that &lt;code&gt;teams&lt;/code&gt; is a complex data structure.&lt;/p&gt;

&lt;p&gt;Here is a template that we might use to process this data.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    League Standings

    League Name: [% name %]
    Season     : [% season %]

    Teams:
    [% FOREACH team = teams -%]
    [% team.name %] [% team.played -%] 
     [% team.won %] [% team.drawn %] [% team.lost %]
    [% END %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Running this template with this data gives us the following output&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;    League Standings

    League Name: English Premier League
    Season     : 2000/01

    Teams:
    Man Utd 16 12 3 1
    Bradford 16 2 5 9
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Hopefully the syntax of the template is simple enough to follow. There are a few points to note.&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Template processing directives are written using a simple language which is not Perl.&lt;/li&gt;
&lt;li&gt;The keys of the &lt;code&gt;%data&lt;/code&gt; have become the names of the data variables within the template.&lt;/li&gt;
&lt;li&gt;Template processing directives are surrounded by &lt;code&gt;[%&lt;/code&gt; and &lt;code&gt;%]&lt;/code&gt; sequences.&lt;/li&gt;
&lt;li&gt;If these tags are replaced with &lt;code&gt;[%-&lt;/code&gt; &lt;code&gt;-%]&lt;/code&gt; then the preceding or following linefeed is suppressed.&lt;/li&gt;
&lt;li&gt;In the &lt;code&gt;FOREACH&lt;/code&gt; loop, each element of the &lt;code&gt;teams&lt;/code&gt; list was assigned, in turn, to the temporary variable &lt;code&gt;team&lt;/code&gt;.&lt;/li&gt;
&lt;li&gt;Each item assigned to the &lt;code&gt;team&lt;/code&gt; variable is a Perl hash. Individual values within the hash are accessed using a dot notation.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;It&amp;rsquo;s probably the first and last of these points which are the most important. The first point emphasises the separation of the data acquisition logic from the presentation logic. The person creating the presentation template doesn&amp;rsquo;t need to know Perl, they only need to know the data items which will be passed into the template.&lt;/p&gt;

&lt;p&gt;The last point demonstrates the way that TT2 protects the template designer from the implementation of the data structures. The data objects passed to the template processor can be scalars, arrays, hashes, objects or even subroutines. The template processor will just interpret your data correctly and Do The Right Thing to return the correct value to you. In this example each team was a hash, but in a larger system each team might be an object, in which case &lt;code&gt;name&lt;/code&gt;, &lt;code&gt;played&lt;/code&gt;, etc. would be accessor methods to the underlying object attributes. No changes would be required to the template as the template processor would realise that it needed to call methods rather than access hash values.&lt;/p&gt;

&lt;h3 id=&#34;span-id-a-more-complex-example-a-more-complex-example-span&#34;&gt;&lt;span id=&#34;a more complex example&#34;&gt;A more complex example&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;Stats about the English Football League are usually presented in a slightly more complex format that the one we used above. A full set of stats will show the number of games that a team has won, lost or drawn, the number of goals scored for and against the team and the number of points that the team therefore has. Teams gain three points for a win and one point for a draw. When teams have the same number of points they are separated by the goal difference, that is the number of goals the team has scored minus the number of team scored against them. To complicate things even further, the games won, drawn and lost and the goals for and against are often split between home and away games.&lt;/p&gt;

&lt;p&gt;Therefore if you have a data source which lists the team name togther with the games won, drawn and lost and the goals for and against split into home and away (a total of eleven data items) you can calculate all of the other items (goal difference, points awarded and even position in the league). Let&amp;rsquo;s take such a file, but we&amp;rsquo;ll only look at the top three teams. It will look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  Man Utd,7,1,0,26,4,5,2,1,15,6
  Arsenal,7,1,0,17,4,2,3,3,7,9
  Leicester,4,3,1,10,8,4,2,2,7,4
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;A simple script to read this data into an array of hashes will look something like this (I&amp;rsquo;ve simplified the names of the data columns - w, d, and l are games won, drawn and lost and f and a are goals scored for and against; h and a at the front of a data item name indicates whether it&amp;rsquo;s a home or away statistic):&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  my @cols = qw(name hw hd hl hf ha aw ad al af aa);

  my @teams;
  while (&amp;lt;&amp;gt;) {
    chomp;

    my %team;

    @team{@cols} = split /,/;

    push @teams, \%team;
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;We can then go thru the teams again and calculate all of the derived data items:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  foreach (@teams) {
    $_-&amp;gt;{w} = $_-&amp;gt;{hw} + $_-&amp;gt;{aw};
    $_-&amp;gt;{d} = $_-&amp;gt;{hd} + $_-&amp;gt;{ad};
    $_-&amp;gt;{l} = $_-&amp;gt;{hl} + $_-&amp;gt;{al};

    $_-&amp;gt;{pl} = $_-&amp;gt;{w} + $_-&amp;gt;{d} + $_-&amp;gt;{l};


    $_-&amp;gt;{f} = $_-&amp;gt;{hf} + $_-&amp;gt;{af};
    $_-&amp;gt;{a} = $_-&amp;gt;{ha} + $_-&amp;gt;{aa};

    $_-&amp;gt;{gd} = $_-&amp;gt;{f} - $_-&amp;gt;{a};

    $_-&amp;gt;{pt} = (3 * $_-&amp;gt;{w}) + $_-&amp;gt;{d};
  }
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And then produce a list sorted in descending order:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  @teams 
    = sort { $b-&amp;gt;{pt} &amp;lt;=&amp;gt; $b-&amp;gt;{pt}
             || $b-&amp;gt;{gd} &amp;lt;=&amp;gt; $a-&amp;gt;{gd} } @teams;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And finally add the league position data item:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $teams[$_]-&amp;gt;{pos} = $_ + 1 
    foreach 0 .. $#teams;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Having pulled all of our data into an internal data structure we can start to produce output using out templates. A template to create a CSV file containing the data split between home and away stats would look like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% FOREACH team = teams -%]
  [% team.pos %],[% team.name %],[% team.pl %],[% team.hw %],
  [%- team.hd %],[% team.hl %],[% team.hf %],[% team.ha %],
  [%- team.aw %],[% team.ad %],[% team.al %],[% team.af %],
  [%- team.aa %],[% team.gd %],[% team.pt %]
  [%- END %]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And processing it like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  $tt-&amp;gt;process(&#39;split.tt&#39;, { teams =&amp;gt; \@teams }, &#39;split.csv&#39;)
    || die $tt-&amp;gt;error;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;produces the following output:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1,Man Utd,16,7,1,0,26,4,5,2,1,15,6,31,39
  2,Arsenal,16,7,1,0,17,4,2,3,3,7,9,11,31
  3,Leicester,16,4,3,1,10,8,4,2,2,7,4,5,29
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that we&amp;rsquo;ve introduced the third parameter to &lt;code&gt;process&lt;/code&gt;. If this parameter is missing then the TT2 sends its output to &lt;code&gt;STDOUT&lt;/code&gt;. If this parameter is a scalar then it is taken as the name of a file to write the output to. This parameter can also be (amongst other things) a filehandle or a reference to an object which is assumed to implement a &lt;code&gt;print&lt;/code&gt; method.&lt;/p&gt;

&lt;p&gt;If we weren&amp;rsquo;t interested in the split between home and away games, then we could use a simpler template like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  [% FOREACH team = teams -%]
  [% team.pos %],[% team.name %],[% team.pl %],[% team.w %],
  [%- team.d %],[% team.l %],[% team.f %],[% team.a %],
  [%- team.aa %],[% team.gd %],[% team.pt %]
  [% END -%]
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Which would produce output like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  1,Man Utd,16,12,3,1,41,10,6,31,39
  2,Arsenal,16,9,4,3,24,13,9,11,31
  3,Leicester,16,8,5,3,17,12,4,5,29
&lt;/code&gt;&lt;/pre&gt;

&lt;h3 id=&#34;span-id-producing-xml-producing-xml-span&#34;&gt;&lt;span id=&#34;producing xml&#34;&gt;Producing XML&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;This is starting to show some of the power and flexibility of TT2, but you may be thinking that you could just as easily produce this output with a &lt;code&gt;foreach&lt;/code&gt; loop and a couple of &lt;code&gt;print&lt;/code&gt; statements in your code. This is, of course, true; but that&amp;rsquo;s because I&amp;rsquo;ve chosen a deliberately simple example to explain the concepts. What if we wanted to produce an XML file containing the data? And what if (as I mentioned earlier) the league data was held in an object? The code would then look even easier as most of the code we&amp;rsquo;ve written earlier would be hidden away in &lt;code&gt;FootballLeague.pm&lt;/code&gt;.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use FootballLeague;
  use Template;

  my $league = FootballLeague-&amp;gt;new(name =&amp;gt; &#39;English Premier&#39;);

  my $tt = Template-&amp;gt;new;

  $tt-&amp;gt;process(&#39;league_xml.tt&#39;, { league =&amp;gt; $league })
    || die $tt-&amp;gt;error;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;And the template in &lt;code&gt;league_xml.tt&lt;/code&gt; would look something like this:&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  &amp;lt;?xml version=&amp;quot;1.0&amp;quot;?&amp;gt;
  &amp;lt;!DOCTYPE LEAGUE SYSTEM &amp;quot;league.dtd&amp;quot;&amp;gt;

  &amp;lt;league name=&amp;quot;[% league.name %]&amp;quot; season=&amp;quot;[% league.season %]&amp;quot;&amp;gt;
  [% FOREACH team = league.teams -%]
    &amp;lt;team name=&amp;quot;[% team.name %]&amp;quot;
          pos=&amp;quot;[% team.pos %]&amp;quot;
          played=&amp;quot;[% team.pl %]&amp;quot;
          goal_diff=&amp;quot;[% team.gd %]&amp;quot;
          points=&amp;quot;[% team.pt %]&amp;quot;&amp;gt;
       &amp;lt;stats type=&amp;quot;home&amp;quot;&amp;gt;
              win=&amp;quot;[% team.hw %]&amp;quot;
              draw=&amp;quot;[%- team.hd %]&amp;quot;
              lose=&amp;quot;[% team.hl %]&amp;quot;
              for=&amp;quot;[% team.hf %]&amp;quot;
              against=&amp;quot;[% team.ha %]&amp;quot; /&amp;gt;
       &amp;lt;stats type=&amp;quot;away&amp;quot;&amp;gt;
              win=&amp;quot;[% team.aw %]&amp;quot;
              draw=&amp;quot;[%- team.ad %]&amp;quot;
              lose=&amp;quot;[% team.al %]&amp;quot;
              for=&amp;quot;[% team.af %]&amp;quot;
              against=&amp;quot;[% team.aa %]&amp;quot; /&amp;gt;
    &amp;lt;/team&amp;gt;
  [% END -%]
  &amp;lt;/league&amp;gt;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;Notice that as we&amp;rsquo;ve passed the whole object into &lt;code&gt;process&lt;/code&gt; then we need to put an extra level of indirection on our template variables - everything is now a component of the &lt;code&gt;league&lt;/code&gt; variable. Other than that, everything in the template is very similar to what we&amp;rsquo;ve used before. Presumably now &lt;code&gt;team.name&lt;/code&gt; calls an accessor function rather than carrying out a hash lookup, but all of this is transparent to our template designer.&lt;/p&gt;

&lt;h3 id=&#34;span-id-multiple-formats-multiple-formats-span&#34;&gt;&lt;span id=&#34;multiple formats&#34;&gt;Multiple Formats&lt;/span&gt;&lt;/h3&gt;

&lt;p&gt;As a final example, let&amp;rsquo;s suppose that we need to create out football league tables in a number of formats. Perhaps we are passing this data on to other people and they can&amp;rsquo;t all use the same format. Some of our users need CSV files and others need XML. Some require data split between home and away matches and other just want the totals. In total, then, we&amp;rsquo;ll need four different templates, but the good news is that they can use the same data object. All the script needs to do is to establish which template is required and process it.&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  use FootballLeague;
  use Template;

  my ($name, $type, $stats) = @_;

  my $league = FootballLeague-&amp;gt;new(name =&amp;gt; $name);

  my $tt = Template-&amp;gt;new;

  $tt-&amp;gt;process(&amp;quot;league_${type}_$stats.tt&amp;quot;, 
               { league =&amp;gt; $league }
               &amp;quot;league_$stats.$type&amp;quot;)
    || die $tt-&amp;gt;error;
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;For example, calling this script as&lt;/p&gt;

&lt;pre&gt;&lt;code&gt;  league.pl &#39;English Premier&#39; xml split
&lt;/code&gt;&lt;/pre&gt;

&lt;p&gt;This will process a template called &lt;code&gt;league_xml_split.tt&lt;/code&gt; and put the results in a file called &lt;code&gt;league_split.xml&lt;/code&gt;.&lt;/p&gt;

&lt;p&gt;This starts to show the true strength of the Template Toolkit. If we later wanted to add another file format - perhaps we wanted to create a league table HTML page or even a LaTeX document - then we would just need to create the appropriate template and name it according to our existing naming convention. We would need to make no changes to the code.&lt;/p&gt;

&lt;p&gt;I hope you can now see why the Template Toolkit is fast becoming an essential part of many people&amp;rsquo;s Perl installation.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl Support for XML Developing</title>
      <link>http://localhost:1313/pub/1998/06/perl-xml.html/</link>
      <pubDate>Tue, 10 Mar 1998 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/1998/06/perl-xml.html/</guid>
      <description>

&lt;h3 id=&#34;how-to-make-perl-the-language-of-choice-for-xml&#34;&gt;How to Make Perl The Language of Choice for XML&lt;/h3&gt;

&lt;p&gt;Perl has been the language of choice for anyone doing serious text processing. Now efforts are underway to make Perl the language of choice for those doing &amp;ldquo;structured&amp;rdquo; text processing using the Extensible Markup Language (XML).&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://www.w3.org/tr/1998/rec-xml-19980210&#34;&gt;XML 1.0 specification&lt;/a&gt; was recently (Feb. 10, 1998) released as a recommendation by the &lt;a href=&#34;http://www.w3.org/&#34;&gt;World Wide Web Consortium&lt;/a&gt;. XML is a subset of SGML (Standard Generalized Markup Language) and it seems to be emerging as a universal syntax for defining non-proprietary document markup and data formats. XML made significant changes to SGML to reflect the nature of the Web and to make it easier to build tools that process XML.&lt;/p&gt;

&lt;p&gt;Tim Bray, co-editor of the XML 1.0 specification, has used Perl extensively for huge text processing applications. He had a special interest in seeing a bridge built from Perl to XML &amp;ndash; one that would make it simple for programmers to process XML data. So, out of this interest, a small group of developers met at O&amp;rsquo;Reilly &amp;amp; Associates in Sebastopol, California for a one-day Perl/XML summit. In addition to Tim, those attending the summit were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Larry Wall, creator of Perl, and senior developer, O&amp;rsquo;Reilly &amp;amp; Associates&lt;/li&gt;
&lt;li&gt;Dick Hardt, developer of Perl for Win 32, and Chief Technology Officer, ActiveState Tool Corp.&lt;/li&gt;
&lt;li&gt;Tim O&amp;rsquo;Reilly, President and CEO, O&amp;rsquo;Reilly &amp;amp; Associates&lt;/li&gt;
&lt;li&gt;Dale Dougherty, CEO, Songline Studios&lt;/li&gt;
&lt;li&gt;Gina Blaber, Director, Software Products Group, O&amp;rsquo;Reilly &amp;amp; Associates.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;ldquo;In the design of XML, we were continuously mindful of the need to enable the fast, efficient creation of scripts and programs for processing XML,&amp;rdquo; says Tim Bray.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;For many of us in the XML effort, the most important goal is to increase the proportion of the world&amp;rsquo;s documents stored in open, non-proprietary formats,&amp;rdquo; Bray continues. &amp;ldquo;Building slick XML processing into Perl makes the use of such formats more rewarding and helps frustrate the efforts of those who would imprison human knowledge behind the barbed-wire of proprietary file formats.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;XML is currently perceived as powerful and important, but not particularly easy,&amp;rdquo; explains Larry Wall. &amp;ldquo;This makes XML and Perl naturally complementary, since Perl is a language that makes easy things easy to do, and hard things possible.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;One of the first steps that the summit group identified was to get Perl working with Unicode (ISO 10646). Unicode enables code to be easily translated into other languages; XML requires Unicode. Larry Wall will lead the team working on this task.&lt;/p&gt;

&lt;p&gt;The next step is figuring out at what level Perl actually provides support for XML: whether it&amp;rsquo;s built into the language, implemented as a module or a combination of both.&lt;/p&gt;

&lt;p&gt;Among the goals set at the meeting were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Release a Perl/XML spec in Q3, 1998.&lt;/li&gt;
&lt;li&gt;Establish a mailing list for discussion of Perl and XML developer issues.&lt;/li&gt;
&lt;li&gt;Develop an XML white paper, co-authored by Larry Wall and Tim Bray, to be released this spring.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you are interested in these efforts, you might want to attend the Perl and XML session at the XML Developer&amp;rsquo;s Day in Seattle at the &lt;a href=&#34;http://www.gca.org/&#34;&gt;The XML Conference&lt;/a&gt; on March 27, 1998. Larry Wall and Dick Hardt will be speaking. The Perl Developer Update will also keep track of new announcements.&lt;/p&gt;
</description>
    </item>
    
    <item>
      <title>Perl Support for XML Developing</title>
      <link>http://localhost:1313/pub/1998/06/perl-xml.html/</link>
      <pubDate>Tue, 10 Mar 1998 00:00:00 -0800</pubDate>
      
      <guid>http://localhost:1313/pub/1998/06/perl-xml.html/</guid>
      <description>

&lt;h3 id=&#34;how-to-make-perl-the-language-of-choice-for-xml&#34;&gt;How to Make Perl The Language of Choice for XML&lt;/h3&gt;

&lt;p&gt;Perl has been the language of choice for anyone doing serious text processing. Now efforts are underway to make Perl the language of choice for those doing &amp;ldquo;structured&amp;rdquo; text processing using the Extensible Markup Language (XML).&lt;/p&gt;

&lt;p&gt;The &lt;a href=&#34;http://www.w3.org/tr/1998/rec-xml-19980210&#34;&gt;XML 1.0 specification&lt;/a&gt; was recently (Feb. 10, 1998) released as a recommendation by the &lt;a href=&#34;http://www.w3.org/&#34;&gt;World Wide Web Consortium&lt;/a&gt;. XML is a subset of SGML (Standard Generalized Markup Language) and it seems to be emerging as a universal syntax for defining non-proprietary document markup and data formats. XML made significant changes to SGML to reflect the nature of the Web and to make it easier to build tools that process XML.&lt;/p&gt;

&lt;p&gt;Tim Bray, co-editor of the XML 1.0 specification, has used Perl extensively for huge text processing applications. He had a special interest in seeing a bridge built from Perl to XML &amp;ndash; one that would make it simple for programmers to process XML data. So, out of this interest, a small group of developers met at O&amp;rsquo;Reilly &amp;amp; Associates in Sebastopol, California for a one-day Perl/XML summit. In addition to Tim, those attending the summit were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Larry Wall, creator of Perl, and senior developer, O&amp;rsquo;Reilly &amp;amp; Associates&lt;/li&gt;
&lt;li&gt;Dick Hardt, developer of Perl for Win 32, and Chief Technology Officer, ActiveState Tool Corp.&lt;/li&gt;
&lt;li&gt;Tim O&amp;rsquo;Reilly, President and CEO, O&amp;rsquo;Reilly &amp;amp; Associates&lt;/li&gt;
&lt;li&gt;Dale Dougherty, CEO, Songline Studios&lt;/li&gt;
&lt;li&gt;Gina Blaber, Director, Software Products Group, O&amp;rsquo;Reilly &amp;amp; Associates.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;&amp;ldquo;In the design of XML, we were continuously mindful of the need to enable the fast, efficient creation of scripts and programs for processing XML,&amp;rdquo; says Tim Bray.&lt;/p&gt;

&lt;p&gt;&amp;ldquo;For many of us in the XML effort, the most important goal is to increase the proportion of the world&amp;rsquo;s documents stored in open, non-proprietary formats,&amp;rdquo; Bray continues. &amp;ldquo;Building slick XML processing into Perl makes the use of such formats more rewarding and helps frustrate the efforts of those who would imprison human knowledge behind the barbed-wire of proprietary file formats.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;&amp;ldquo;XML is currently perceived as powerful and important, but not particularly easy,&amp;rdquo; explains Larry Wall. &amp;ldquo;This makes XML and Perl naturally complementary, since Perl is a language that makes easy things easy to do, and hard things possible.&amp;rdquo;&lt;/p&gt;

&lt;p&gt;One of the first steps that the summit group identified was to get Perl working with Unicode (ISO 10646). Unicode enables code to be easily translated into other languages; XML requires Unicode. Larry Wall will lead the team working on this task.&lt;/p&gt;

&lt;p&gt;The next step is figuring out at what level Perl actually provides support for XML: whether it&amp;rsquo;s built into the language, implemented as a module or a combination of both.&lt;/p&gt;

&lt;p&gt;Among the goals set at the meeting were:&lt;/p&gt;

&lt;ul&gt;
&lt;li&gt;Release a Perl/XML spec in Q3, 1998.&lt;/li&gt;
&lt;li&gt;Establish a mailing list for discussion of Perl and XML developer issues.&lt;/li&gt;
&lt;li&gt;Develop an XML white paper, co-authored by Larry Wall and Tim Bray, to be released this spring.&lt;/li&gt;
&lt;/ul&gt;

&lt;p&gt;If you are interested in these efforts, you might want to attend the Perl and XML session at the XML Developer&amp;rsquo;s Day in Seattle at the &lt;a href=&#34;http://www.gca.org/&#34;&gt;The XML Conference&lt;/a&gt; on March 27, 1998. Larry Wall and Dick Hardt will be speaking. The Perl Developer Update will also keep track of new announcements.&lt;/p&gt;
</description>
    </item>
    
  </channel>
</rss>

