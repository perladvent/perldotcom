<!-- $Id: pod2html,v 1.6.1.1 1995/11/10 03:56:07 bmiddlet Exp $ -->
<HTML><HEAD>
<CENTER><TITLE>perlfunc</TITLE>
</HEAD>
<BODY></CENTER><p><hr>

<H1> 
<A NAME="perlfunc_name_0">
NAME</A>
</H1>

perlfunc - Perl builtin functions
<p><p><hr>

<H1> 
<A NAME="perlfunc_description_0">
DESCRIPTION</A>
</H1>

The functions in this section can serve as terms in an expression.
They fall into two major categories: list operators and named unary
operators.  These differ in their precedence relationship with a
following comma.  (See the precedence table in 
<A HREF="perlop.html">
the <EM>perlop</EM> manpage</A>
.)  List
operators take more than one argument, while unary operators can never
take more than one argument.  Thus, a comma terminates the argument of
a unary operator, but merely separates the arguments of a list
operator.  A unary operator generally provides a scalar context to its
argument, while a list operator may provide either scalar and list
contexts for its arguments.  If it does both, the scalar arguments will
be first, and the list argument will follow.  (Note that there can only
ever be one list argument.)  For instance, 
<A HREF="perlfunc.html#perlfunc_splice_2">splice()</A>
 has three scalar
arguments followed by a list.
<p>In the syntax descriptions that follow, list operators that expect a
list (and provide list context for the elements of the list) are shown
with LIST as an argument.  Such a list may consist of any combination
of scalar arguments or list values; the list values will be included
in the list as if each individual element were interpolated at that
point in the list, forming a longer single-dimensional list value.
Elements of the LIST should be separated by commas.
<p>Any function in the list below may be used either with or without
parentheses around its arguments.  (The syntax descriptions omit the
parens.)  If you use the parens, the simple (but occasionally
surprising) rule is this: It <EM>LOOKS</EM> like a function, therefore it <EM>IS</EM> a
function, and precedence doesn't matter.  Otherwise it's a list
operator or unary operator, and precedence does matter.  And whitespace
between the function and left parenthesis doesn't count--so you need to
be careful sometimes:
<p>
<XMP>
    print 1+2+3;        # Prints 6.
    print(1+2) + 3;     # Prints 3.
    print (1+2)+3;      # Also prints 3!
    print +(1+2)+3;     # Prints 6.
    print ((1+2)+3);    # Prints 6.

</XMP>
<p>If you run Perl with the 
<A HREF="perlrun.html#perlrun_w_0">-w</A>
 switch it can warn you about this.  For
example, the third line above produces:
<p>
<XMP>
    print (...) interpreted as function at - line 1.
    Useless use of integer addition in void context at - line 1.

</XMP>
<p>For functions that can be used in either a scalar or list context,
non-abortive failure is generally indicated in a scalar context by
returning the undefined value, and in a list context by returning the
null list.
<p>Remember the following rule:
<p>
<UL>
<LI>
<EM>THERE IS NO GENERAL RULE FOR CONVERTING A LIST INTO A SCALAR!</EM>
<p>
</UL>
Each operator and function decides which sort of value it would be most.appropriate to return in a scalar context.  Some operators return the
length of the list that would have been returned in a list context.  Some
operators return the first value in the list.  Some operators return the
last value in the list.  Some operators return a count of successful
operations.  In general, they do what you want, unless you want
consistency.
<p>
<DL COMPACT>
<DT><STRONG>
<EM>-X FILEHANDLE</EM>
</STRONG>
<DD>
<p>
<DT><STRONG>
<EM>-X EXPR</EM>
</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_x_0">
-X</A>

</STRONG>
<DD>

A file test, where X is one of the letters listed below.  This unary
operator takes one argument, either a filename or a filehandle, and
tests the associated file to see if something is true about it.  If the
argument is omitted, tests 
<A HREF="perlvar.html#perlvar__0">$_</A>
, except for <CODE>-t</CODE>, which tests STDIN.
Unless otherwise documented, it returns <CODE>1</CODE> for TRUE and <CODE>''</CODE> for FALSE, or
the undefined value if the file doesn't exist.  Despite the funny
names, precedence is the same as any other named unary operator, and
the argument may be parenthesized like any other unary operator.  The
operator may be any of:
<p>
<XMP>
    -r  File is readable by effective uid/gid.
    -w  File is writable by effective uid/gid.
    -x  File is executable by effective uid/gid.
    -o  File is owned by effective uid.
    -R  File is readable by real uid/gid.
    -W  File is writable by real uid/gid.
    -X  File is executable by real uid/gid.
    -O  File is owned by real uid.
    -e  File exists.
    -z  File has zero size.
    -s  File has non-zero size (returns size).
    -f  File is a plain file.
    -d  File is a directory.
    -l  File is a symbolic link.
    -p  File is a named pipe (FIFO).
    -S  File is a socket.
    -b  File is a block special file.
    -c  File is a character special file.
    -t  Filehandle is opened to a tty.
    -u  File has setuid bit set.
    -g  File has setgid bit set.
    -k  File has sticky bit set.
    -T  File is a text file.
    -B  File is a binary file (opposite of -T).
    -M  Age of file in days when script started.
    -A  Same for access time.
    -C  Same for inode change time.

</XMP>
<p>The interpretation of the file permission operators <CODE>-r</CODE>, <CODE>-R</CODE>, 
<A HREF="perlrun.html#perlrun_w_0">-w</A>
,
<CODE>-W</CODE>, 
<A HREF="perlrun.html#perlrun_x_0">-x</A>
 and 
<A HREF="perlfunc.html#perlfunc_x_0">-X</A>
 is based solely on the mode of the file and the
uids and gids of the user.  There may be other reasons you can't actually
read, write or execute the file.  Also note that, for the superuser,
<CODE>-r</CODE>, <CODE>-R</CODE>, 
<A HREF="perlrun.html#perlrun_w_0">-w</A>
 and <CODE>-W</CODE> always return 1, and 
<A HREF="perlrun.html#perlrun_x_0">-x</A>
 and 
<A HREF="perlfunc.html#perlfunc_x_0">-X</A>
 return
1 if any execute bit is set in the mode.  Scripts run by the superuser may
thus need to do a 
<A HREF="perlfunc.html#perlfunc_stat_1">stat()</A>
 in order to determine the actual mode of the
file, or temporarily set the uid to something else.
<p>Example:
<p>
<XMP>
    while (<>) {
        chop;
        next unless -f $_;      # ignore specials
        ...
    }

</XMP>
<p>Note that 
<A HREF="perlrun.html#perlrun_s_0">-s/a/b/</A>
 does not do a negated substitution.  Saying
<CODE>-exp(<STRONG>$foo</STRONG>)</CODE> still works as expected, however--only single letters
following a minus are interpreted as file tests.
<p>The 
<A HREF="perlrun.html#perlrun_t_0">-T</A>
 and <CODE>-B</CODE> switches work as follows.  The first block or so of the
file is examined for odd characters such as strange control codes or
characters with the high bit set.  If too many odd characters (&gt;30%)
are found, it's a <CODE>-B</CODE> file, otherwise it's a 
<A HREF="perlrun.html#perlrun_t_0">-T</A>
 file.  Also, any file
containing null in the first block is considered a binary file.  If 
<A HREF="perlrun.html#perlrun_t_0">-T</A>

or <CODE>-B</CODE> is used on a filehandle, the current stdio buffer is examined
rather than the first block.  Both 
<A HREF="perlrun.html#perlrun_t_0">-T</A>
 and <CODE>-B</CODE> return TRUE on a null
file, or a file at EOF when testing a filehandle.
<p>If any of the file tests (or either the 
<A HREF="perlfunc.html#perlfunc_stat_1">stat()</A>
 or 
<A HREF="perlfunc.html#perlfunc_lstat_1">lstat()</A>
 operators) are given the
special filehandle consisting of a solitary underline, then the stat
structure of the previous file test (or stat operator) is used, saving
a system call.  (This doesn't work with <CODE>-t</CODE>, and you need to remember
that 
<A HREF="perlfunc.html#perlfunc_lstat_1">lstat()</A>
 and 
<A HREF="perlrun.html#perlrun_l_0">-l</A>
 will leave values in the stat structure for the
symbolic link, not the real file.)  Example:
<p>
<XMP>
    print "Can do.\n" if -r $a || -w _ || -x _;
    stat($filename);
    print "Readable\n" if -r _;
    print "Writable\n" if -w _;
    print "Executable\n" if -x _;
    print "Setuid\n" if -u _;
    print "Setgid\n" if -g _;
    print "Sticky\n" if -k _;
    print "Text\n" if -T _;
    print "Binary\n" if -B _;

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_abs_0">
abs VALUE</A>

</STRONG>
<DD>

Returns the absolute value of its argument.
<p>
<DT><STRONG>

<A NAME="perlfunc_accept_0">
accept NEWSOCKET,GENERICSOCKET</A>

</STRONG>
<DD>

Accepts an incoming socket connect, just as the accept(2) system call
does.  Returns the packed address if it succeeded, FALSE otherwise.
See example in 
<A HREF="perlipc.html">
the <EM>perlipc</EM> manpage</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_alarm_0">
alarm SECONDS</A>

</STRONG>
<DD>

Arranges to have a SIGALRM delivered to this process after the
specified number of seconds have elapsed.  (On some machines,
unfortunately, the elapsed time may be up to one second less than you
specified because of how seconds are counted.)  Only one timer may be
counting at once.  Each call disables the previous timer, and an
argument of 0 may be supplied to cancel the previous timer without
starting a new one.  The returned value is the amount of time remaining
on the previous timer.
<p>For sleeps of finer granularity than one second, you may use Perl's

<A HREF="perlfunc.html#perlfunc_syscall_0">syscall()</A>
 interface to access setitimer(2) if your system supports it, 
or else see 
<A HREF="perlfunc.html#perlfunc_select_1"><EM>select</EM></A>
 below.
<p>
<DT><STRONG>

<A NAME="perlfunc_atan_0">
atan2 Y,X</A>

</STRONG>
<DD>

Returns the arctangent of Y/X in the range -PI to PI.
<p>
<DT><STRONG>

<A NAME="perlfunc_bind_0">
bind SOCKET,NAME</A>

</STRONG>
<DD>

Binds a network address to a socket, just as the bind system call
does.  Returns TRUE if it succeeded, FALSE otherwise.  NAME should be a
packed address of the appropriate type for the socket.  See example in

<A HREF="perlipc.html">
the <EM>perlipc</EM> manpage</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_binmode_0">
binmode FILEHANDLE</A>

</STRONG>
<DD>

Arranges for the file to be read or written in ``binary'' mode in
operating systems that distinguish between binary and text files.
Files that are not in binary mode have CR LF sequences translated to LF
on input and LF translated to CR LF on output.  Binmode has no effect
under Unix; in DOS, it may be imperative.  If FILEHANDLE is an expression,
the value is taken as the name of the filehandle.
<p>
<DT><STRONG>

<A NAME="perlfunc_bless_0">
bless REF,PACKAGE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_bless_1">
bless REF</A>

</STRONG>
<DD>

This function tells the referenced object (passed as REF) that it is now
an object in PACKAGE--or the current package if no PACKAGE is specified,
which is the usual case.  It returns the reference for convenience, since
a 
<A HREF="perlfunc.html#perlfunc_bless_1">bless()</A>
 is often the last thing in a constructor.  See the <EM>perlobj</EM>  manpage
 for
more about the blessing (and blessings) of objects.
<p>
<DT><STRONG>

<A NAME="perlfunc_caller_0">
caller EXPR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_caller_0">
caller</A>

</STRONG>
<DD>

Returns the context of the current subroutine call.  In a scalar context,
returns TRUE if there is a caller, that is, if we're in a subroutine or

<A HREF="perlfunc.html#perlfunc_eval_1">eval()</A>
 or 
<A HREF="perlfunc.html#perlfunc_require_0">require()</A>
, and FALSE otherwise.  In a list context, returns
<p>
<XMP>
    ($package, $filename, $line) = caller;

</XMP>
<p>With EXPR, it returns some extra information that the debugger uses to
print a stack trace.  The value of EXPR indicates how many call frames
to go back before the current one.
<p>
<XMP>
    ($package, $filename, $line,
     $subroutine, $hasargs, $wantargs) = caller($i);

</XMP>
<p>Furthermore, when called from within the DB package, caller returns more
detailed information: it sets sets the list variable <STRONG>@DB:args</STRONG> to be the
arguments with which that subroutine was invoked.
<p>
<DT><STRONG>

<A NAME="perlfunc_chdir_0">
chdir EXPR</A>

</STRONG>
<DD>

Changes the working directory to EXPR, if possible.  If EXPR is
omitted, changes to home directory.  Returns TRUE upon success, FALSE
otherwise.  See example under 
<A HREF="perlfunc.html#perlfunc_die_0">die()</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_chmod_0">
chmod LIST</A>

</STRONG>
<DD>

Changes the permissions of a list of files.  The first element of the
list must be the numerical mode.  Returns the number of files
successfully changed.
<p>
<XMP>
    $cnt = chmod 0755, 'foo', 'bar';
    chmod 0755, @executables;

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_chomp_0">
chomp VARIABLE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_chomp_1">
chomp LIST</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_chomp_1">
chomp</A>

</STRONG>
<DD>

This is a slightly safer version of chop (see below).  It removes any
line ending that corresponds to the current value of 
<A HREF="perlvar.html#perlvar__7">$/</A>
 (also known as

<A HREF="perlvar.html#perlvar_input_record_separator_1">$INPUT_RECORD_SEPARATOR</A>
 in the <CODE>English</CODE> module).  It returns the number
of characters removed.  It's often used to remove the newline from the
end of an input record when you're worried that the final record may be
missing its newline.  When in paragraph mode (<CODE>$/ = ``''</CODE>), it removes all
trailing newlines from the string.  If VARIABLE is omitted, it chomps

<A HREF="perlvar.html#perlvar__0">$_</A>
.  Example:
<p>
<XMP>
    while (<>) {
        chomp;  # avoid \n on last field
        @array = split(/:/);
        ...
    }

</XMP>
<p>You can actually chomp anything that's an lvalue, including an assignment:
<p>
<XMP>
    chomp($cwd = `pwd`);
    chomp($answer = <STDIN>);

</XMP>
<p>If you chomp a list, each element is chomped, and the total number of
characters removed is returned.
<p>
<DT><STRONG>

<A NAME="perlfunc_chop_0">
chop VARIABLE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_chop_1">
chop LIST</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_chop_1">
chop</A>

</STRONG>
<DD>

Chops off the last character of a string and returns the character
chopped.  It's used primarily to remove the newline from the end of an
input record, but is much more efficient than <CODE>s/\n//</CODE> because it neither
scans nor copies the string.  If VARIABLE is omitted, chops 
<A HREF="perlvar.html#perlvar__0">$_</A>
.
Example:
<p>
<XMP>
    while (<>) {
        chop;   # avoid \n on last field
        @array = split(/:/);
        ...
    }

</XMP>
<p>You can actually chop anything that's an lvalue, including an assignment:
<p>
<XMP>
    chop($cwd = `pwd`);
    chop($answer = <STDIN>);

</XMP>
<p>If you chop a list, each element is chopped.  Only the value of the
last chop is returned.
<p>Note that chop returns the last character.  To return all but the last
character, use 
<A HREF="perlfunc.html#perlfunc_substr_1">substr(<STRONG>$string</STRONG>, 0, -1)</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_chown_0">
chown LIST</A>

</STRONG>
<DD>

Changes the owner (and group) of a list of files.  The first two
elements of the list must be the <EM>NUMERICAL</EM> uid and gid, in that order.
Returns the number of files successfully changed.
<p>
<XMP>
    $cnt = chown $uid, $gid, 'foo', 'bar';
    chown $uid, $gid, @filenames;

</XMP>
<p>Here's an example that looks up non-numeric uids in the passwd file:
<p>
<XMP>
    print "User: ";
    chop($user = <STDIN>);
    print "Files: "
    chop($pattern = <STDIN>);
    ($login,$pass,$uid,$gid) = getpwnam($user)
        or die "$user not in passwd file";
    @ary = <${pattern}>;        # expand filenames
    chown $uid, $gid, @ary;

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_chr_0">
chr NUMBER</A>

</STRONG>
<DD>

Returns the character represented by that NUMBER in the character set.
For example, 
<A HREF="perlfunc.html#perlfunc_chr_0">chr(65)</A>
 is ``A'' in ASCII.
<p>
<DT><STRONG>

<A NAME="perlfunc_chroot_0">
chroot FILENAME</A>

</STRONG>
<DD>

Does the same as the system call of that name.  If you don't know what
it does, don't worry about it.  If FILENAME is omitted, does chroot to

<A HREF="perlvar.html#perlvar__0">$_</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_close_0">
close FILEHANDLE</A>

</STRONG>
<DD>

Closes the file or pipe associated with the file handle, returning TRUE
only if stdio successfully flushes buffers and closes the system file
descriptor.  You don't have to close FILEHANDLE if you are immediately
going to do another open on it, since open will close it for you.  (See

<A HREF="perlfunc.html#perlfunc_open_1">open()</A>
.)  However, an explicit close on an input file resets the line
counter ($.), while the implicit close done by 
<A HREF="perlfunc.html#perlfunc_open_1">open()</A>
 does not.  Also,
closing a pipe will wait for the process executing on the pipe to
complete, in case you want to look at the output of the pipe
afterwards.  Closing a pipe explicitly also puts the status value of
the command into 
<A HREF="perlvar.html#perlvar__20">$?</A>
.  Example:
<p>
<XMP>
    open(OUTPUT, '|sort >foo'); # pipe to sort
    ...                         # print stuff to output
    close OUTPUT;               # wait for sort to finish
    open(INPUT, 'foo');         # get sort's results

</XMP>
<p>FILEHANDLE may be an expression whose value gives the real filehandle name.
<p>
<DT><STRONG>

<A NAME="perlfunc_closedir_0">
closedir DIRHANDLE</A>

</STRONG>
<DD>

Closes a directory opened by 
<A HREF="perlfunc.html#perlfunc_opendir_0">opendir()</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_connect_0">
connect SOCKET,NAME</A>

</STRONG>
<DD>

Attempts to connect to a remote socket, just as the connect system call
does.  Returns TRUE if it succeeded, FALSE otherwise.  NAME should be a
packed address of the appropriate type for the socket.  See example in

<A HREF="perlipc.html">
the <EM>perlipc</EM> manpage</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_cos_0">
cos EXPR</A>

</STRONG>
<DD>

Returns the cosine of EXPR (expressed in radians).  If EXPR is omitted
takes cosine of 
<A HREF="perlvar.html#perlvar__0">$_</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_crypt_0">
crypt PLAINTEXT,SALT</A>

</STRONG>
<DD>

Encrypts a string exactly like the crypt(3) function in the C library.
Useful for checking the password file for lousy passwords, amongst
other things.  Only the guys wearing white hats should do this.  
<p>Here's an example that makes sure that whoever runs this program knows
their own password:
<p>
<XMP>
    $pwd = (getpwuid($<))[1];
    $salt = substr($pwd, 0, 2);
    system "stty -echo";
    print "Password: ";
    chop($word = <STDIN>);
    print "\n";
    system "stty echo";
    if (crypt($word, $salt) ne $pwd) {
        die "Sorry...\n";
    } else {
        print "ok\n";
    } 

</XMP>
<p>Of course, typing in your own password to whoever asks you 
for it is unwise.
<p>
<DT><STRONG>

<A NAME="perlfunc_dbmclose_0">
dbmclose ASSOC_ARRAY</A>

</STRONG>
<DD>

[This function has been superseded by the 
<A HREF="perlfunc.html#perlfunc_untie_0">untie()</A>
 function.]
<p>Breaks the binding between a DBM file and an associative array.
<p>
<DT><STRONG>

<A NAME="perlfunc_dbmopen_0">
dbmopen ASSOC,DBNAME,MODE</A>

</STRONG>
<DD>

[This function has been superseded by the 
<A HREF="perlfunc.html#perlfunc_tie_0">tie()</A>
 function.]
<p>This binds a dbm(3) or ndbm(3) file to an associative array.  ASSOC is the
name of the associative array.  (Unlike normal open, the first argument
is <EM>NOT</EM> a filehandle, even though it looks like one).  DBNAME is the
name of the database (without the <EM>.dir</EM> or <EM>.pag</EM> extension).  If the
database does not exist, it is created with protection specified by
MODE (as modified by the 
<A HREF="perlfunc.html#perlfunc_umask_0">umask()</A>
).  If your system only supports the
older DBM functions, you may perform only one 
<A HREF="perlfunc.html#perlfunc_dbmopen_0">dbmopen()</A>
 in your program.
If your system has neither DBM nor ndbm, calling 
<A HREF="perlfunc.html#perlfunc_dbmopen_0">dbmopen()</A>
 produces a
fatal error.
<p>If you don't have write access to the DBM file, you can only read
associative array variables, not set them.  If you want to test whether
you can write, either use file tests or try setting a dummy array entry
inside an 
<A HREF="perlfunc.html#perlfunc_eval_1">eval()</A>
, which will trap the error.
<p>Note that functions such as 
<A HREF="perlfunc.html#perlfunc_keys_0">keys()</A>
 and 
<A HREF="perlfunc.html#perlfunc_values_0">values()</A>
 may return huge array
values when used on large DBM files.  You may prefer to use the 
<A HREF="perlfunc.html#perlfunc_each_0">each()</A>

function to iterate over large DBM files.  Example:
<p>
<XMP>
    # print out history file offsets
    dbmopen(%HIST,'/usr/lib/news/history',0666);
    while (($key,$val) = each %HIST) {
        print $key, ' = ', unpack('L',$val), "\n";
    }
    dbmclose(%HIST);

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_defined_0">
defined EXPR</A>

</STRONG>
<DD>

Returns a boolean value saying whether the lvalue EXPR has a real value
or not.  Many operations return the undefined value under exceptional
conditions, such as end of file, uninitialized variable, system error
and such.  This function allows you to distinguish between an undefined
null scalar and a defined null scalar with operations that might return
a real null string, such as referencing elements of an array.  You may
also check to see if arrays or subroutines exist.  Use of defined on
predefined variables is not guaranteed to produce intuitive results.
<p>When used on a hash array element, it tells you whether the value
is defined, not whether the key exists in the hash.  Use 
<A HREF="perlfunc.html#perlfunc_exists_0">exists()</A>
 for that.
<p>Examples:
<p>
<XMP>
    print if defined $switch{'D'};
    print "$val\n" while defined($val = pop(@ary));
    die "Can't readlink $sym: $!"
        unless defined($value = readlink $sym);
    eval '@foo = ()' if defined(@foo);
    die "No XYZ package defined" unless defined %_XYZ;
    sub foo { defined &$bar ? &$bar(@_) : die "No bar"; }

</XMP>
<p>See also 
<A HREF="perlfunc.html#perlfunc_undef_0">undef()</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_delete_0">
delete EXPR</A>

</STRONG>
<DD>

Deletes the specified value from its hash array.  Returns the deleted
value, or the undefined value if nothing was deleted.  Deleting from
<CODE><STRONG>$ENV</STRONG>{}</CODE> modifies the environment.  Deleting from an array tied to a DBM
file deletes the entry from the DBM file.  (But deleting from a 
<A HREF="perlfunc.html#perlfunc_tie_0">tie()</A>
d
hash doesn't necessarily return anything.)
<p>The following deletes all the values of an associative array:
<p>
<XMP>
    foreach $key (keys %ARRAY) {
        delete $ARRAY{$key};
    }

</XMP>
<p>(But it would be faster to use the 
<A HREF="perlfunc.html#perlfunc_undef_0">undef()</A>
 command.)  Note that the
EXPR can be arbitrarily complicated as long as the final operation is
a hash key lookup:
<p>
<XMP>
    delete $ref->[$x][$y]{$key};

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_die_0">
die LIST</A>

</STRONG>
<DD>

Outside of an 
<A HREF="perlfunc.html#perlfunc_eval_1">eval()</A>
, prints the value of LIST to <CODE>STDERR</CODE> and exits with
the current value of $!  (errno).  If $! is 0, exits with the value of
<CODE>($? &gt;&gt; 8)</CODE> (backtick `command` status).  If <CODE>($? &gt;&gt; 8)</CODE> is 0,
exits with 255.  Inside an 
<A HREF="perlfunc.html#perlfunc_eval_1">eval()</A>
, the error message is stuffed into 
<A HREF="perlvar.html#perlvar__22">$@</A>
,
and the 
<A HREF="perlfunc.html#perlfunc_eval_1">eval()</A>
 is terminated with the undefined value.
<p>Equivalent examples:
<p>
<XMP>
    die "Can't cd to spool: $!\n" unless chdir '/usr/spool/news';
    chdir '/usr/spool/news' or die "Can't cd to spool: $!\n" 

</XMP>
<p>If the value of EXPR does not end in a newline, the current script line
number and input line number (if any) are also printed, and a newline
is supplied.  Hint: sometimes appending ``, stopped'' to your message
will cause it to make better sense when the string ``at foo line 123'' is
appended.  Suppose you are running script ``canasta''.
<p>
<XMP>
    die "/etc/games is no good";
    die "/etc/games is no good, stopped";

</XMP>
<p>produce, respectively
<p>
<XMP>
    /etc/games is no good at canasta line 123.
    /etc/games is no good, stopped at canasta line 123.

</XMP>
<p>See also 
<A HREF="perlfunc.html#perlfunc_exit_0">exit()</A>
 and 
<A HREF="perlfunc.html#perlfunc_warn_0">warn()</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_do_0">
do BLOCK</A>

</STRONG>
<DD>

Not really a function.  Returns the value of the last command in the
sequence of commands indicated by BLOCK.  When modified by a loop
modifier, executes the BLOCK once before testing the loop condition.
(On other statements the loop modifiers test the conditional first.)
<p>
<DT><STRONG>

<A NAME="perlfunc_do_1">
do SUBROUTINE(LIST)</A>

</STRONG>
<DD>

A deprecated form of subroutine call.  See the <EM>perlsub</EM>  manpage
.
<p>
<DT><STRONG>

<A NAME="perlfunc_do_2">
do EXPR</A>

</STRONG>
<DD>

Uses the value of EXPR as a filename and executes the contents of the
file as a Perl script.  Its primary use is to include subroutines
from a Perl subroutine library.
<p>
<XMP>
    do 'stat.pl';

</XMP>
<p>is just like
<p>
<XMP>
    eval `cat stat.pl`;

</XMP>
<p>except that it's more efficient, more concise, keeps track of the
current filename for error messages, and searches all the 
<A HREF="perlrun.html#perlrun_i_1">-I</A>

libraries if the file isn't in the current directory (see also the 
<A HREF="perlvar.html#perlvar_inc_0">@INC</A>

array in 
<A HREF="perlvar.html#perlvar_predefined_0"><EM>Predefined Names</EM></A>
).  It's the same, however, in that it does
reparse the file every time you call it, so you probably don't want to
do this inside a loop.
<p>Note that inclusion of library modules is better done with the

<A HREF="perlfunc.html#perlfunc_use_1">use()</A>
 and 
<A HREF="perlfunc.html#perlfunc_require_0">require()</A>
 operators.
<p>
<DT><STRONG>

<A NAME="perlfunc_dump_0">
dump LABEL</A>

</STRONG>
<DD>

This causes an immediate core dump.  Primarily this is so that you can
use the <STRONG>undump</STRONG> program to turn your core dump into an executable binary
after having initialized all your variables at the beginning of the
program.  When the new binary is executed it will begin by executing a

<A HREF="perlfunc.html#perlfunc_goto_0">goto LABEL</A>
 (with all the restrictions that 
<A HREF="perlfunc.html#perlfunc_goto_2">goto</A>
 suffers).  Think of
it as a goto with an intervening core dump and reincarnation.  If LABEL
is omitted, restarts the program from the top.  WARNING: any files
opened at the time of the dump will NOT be open any more when the
program is reincarnated, with possible resulting confusion on the part
of Perl.  See also 
<A HREF="perlrun.html#perlrun_u_0">-u</A>
 option in 
<A HREF="perlrun.html">
the <EM>perlrun</EM> manpage</A>
.
<p>Example:
<p>
<XMP>
    #!/usr/bin/perl
    require 'getopt.pl';
    require 'stat.pl';
    %days = (
        'Sun' => 1,
        'Mon' => 2,
        'Tue' => 3,
        'Wed' => 4,
        'Thu' => 5,
        'Fri' => 6,
        'Sat' => 7,
    );
    dump QUICKSTART if $ARGV[0] eq '-d';
    QUICKSTART:
    Getopt('f');

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_each_0">
each ASSOC_ARRAY</A>

</STRONG>
<DD>

Returns a 2 element array consisting of the key and value for the next
value of an associative array, so that you can iterate over it.
Entries are returned in an apparently random order.  When the array is
entirely read, a null array is returned (which when assigned produces a
FALSE (0) value).  The next call to 
<A HREF="perlfunc.html#perlfunc_each_0">each()</A>
 after that will start
iterating again.  The iterator can be reset only by reading all the
elements from the array.  You should not add elements to an array while
you're iterating over it.  There is a single iterator for each
associative array, shared by all 
<A HREF="perlfunc.html#perlfunc_each_0">each()</A>
, 
<A HREF="perlfunc.html#perlfunc_keys_0">keys()</A>
 and 
<A HREF="perlfunc.html#perlfunc_values_0">values()</A>
 function
calls in the program.  The following prints out your environment like
the printenv(1) program, only in a different order:
<p>
<XMP>
    while (($key,$value) = each %ENV) {
        print "$key=$value\n";
    }

</XMP>
<p>See also 
<A HREF="perlfunc.html#perlfunc_keys_0">keys()</A>
 and 
<A HREF="perlfunc.html#perlfunc_values_0">values()</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_eof_0">
eof FILEHANDLE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_eof_0">
eof</A>

</STRONG>
<DD>

Returns 1 if the next read on FILEHANDLE will return end of file, or if
FILEHANDLE is not open.  FILEHANDLE may be an expression whose value
gives the real filehandle name.  (Note that this function actually
reads a character and then <EM>ungetc()</EM>s it, so it is not very useful in an
interactive context.)  Do not read from a terminal file (or call

<A HREF="perlfunc.html#perlfunc_eof_0">eof(FILEHANDLE)</A>
 on it) after end-of-file is reached.  Filetypes such
as terminals may lose the end-of-file condition if you do.
<p>An 
<A HREF="perlfunc.html#perlfunc_eof_0">eof</A>
 without an argument uses the last file read as argument.
Empty parentheses () may be used to indicate
the pseudo file formed of the files listed on the command line, i.e.

<A HREF="perlfunc.html#perlfunc_eof_0">
<A HREF="perlfunc.html#perlfunc_eof_0">eof()</A>
</A>
 is reasonable to use inside a while (&lt;&gt;) loop to detect the end
of only the last file.  Use 
<A HREF="perlfunc.html#perlfunc_eof_0">eof(ARGV)</A>
 or eof without the parentheses to
test <EM>EACH</EM> file in a while (&lt;&gt;) loop.  Examples:
<p>
<XMP>
    # reset line numbering on each input file
    while (<>) {
        print "$.\t$_";
        close(ARGV) if (eof);   # Not eof().
    }
    # insert dashes just before last line of last file
    while (<>) {
        if (eof()) {
            print "--------------\n";
            close(ARGV);        # close or break; is needed if we
                                # are reading from the terminal
        }
        print;
    }

</XMP>
<p>Practical hint: you almost never need to use 
<A HREF="perlfunc.html#perlfunc_eof_0">eof</A>
 in Perl, because the
input operators return undef when they run out of data.
<p>
<DT><STRONG>

<A NAME="perlfunc_eval_0">
eval EXPR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_eval_1">
eval BLOCK</A>

</STRONG>
<DD>

EXPR is parsed and executed as if it were a little Perl program.  It
is executed in the context of the current Perl program, so that any
variable settings, subroutine or format definitions remain afterwards.
The value returned is the value of the last expression evaluated, or a
return statement may be used, just as with subroutines.
<p>If there is a syntax error or runtime error, or a 
<A HREF="perlfunc.html#perlfunc_die_0">die()</A>
 statement is
executed, an undefined value is returned by 
<A HREF="perlfunc.html#perlfunc_eval_1">eval()</A>
, and 
<A HREF="perlvar.html#perlvar__22">$@</A>
 is set to the
error message.  If there was no error, 
<A HREF="perlvar.html#perlvar__22">$@</A>
 is guaranteed to be a null
string.  If EXPR is omitted, evaluates 
<A HREF="perlvar.html#perlvar__0">$_</A>
.  The final semicolon, if
any, may be omitted from the expression.
<p>Note that, since 
<A HREF="perlfunc.html#perlfunc_eval_1">eval()</A>
 traps otherwise-fatal errors, it is useful for
determining whether a particular feature (such as 
<A HREF="perlfunc.html#perlfunc_dbmopen_0">dbmopen()</A>
 or 
<A HREF="perlfunc.html#perlfunc_symlink_0">symlink()</A>
)
is implemented.  It is also Perl's exception trapping mechanism, where
the die operator is used to raise exceptions.
<p>If the code to be executed doesn't vary, you may use the eval-BLOCK
form to trap run-time errors without incurring the penalty of
recompiling each time.  The error, if any, is still returned in 
<A HREF="perlvar.html#perlvar__22">$@</A>
.
Examples:
<p>
<XMP>
    # make divide-by-zero non-fatal
    eval { $answer = $a / $b; }; warn $@ if $@;
    # same thing, but less efficient
    eval '$answer = $a / $b'; warn $@ if $@;
    # a compile-time error
    eval { $answer = };
    # a run-time error
    eval '$answer =';   # sets $@

</XMP>
<p>With an 
<A HREF="perlfunc.html#perlfunc_eval_1">eval()</A>
, you should be especially careful to remember what's 
being looked at when:
<p>
<XMP>
    eval $x;            # CASE 1
    eval "$x";          # CASE 2
    eval '$x';          # CASE 3
    eval { $x };        # CASE 4
    eval "\$$x++"       # CASE 5
    $$x++;              # CASE 6

</XMP>
<p>Cases 1 and 2 above behave identically: they run the code contained in the
variable <STRONG>$x</STRONG>.  (Although case 2 has misleading double quotes making the
reader wonder what else might be happening (nothing is).) Cases 3 and 4
likewise behave in the same way: they run the code &lt;<STRONG>$x</STRONG>&gt;, which does
nothing at all.  (Case 4 is preferred for purely visual reasons.) Case 5
is a place where normally you <EM>WOULD</EM> like to use double quotes, except
in that particular situation, you can just use symbolic references
instead, as in case 6.
<p>
<DT><STRONG>

<A NAME="perlfunc_exec_0">
exec LIST</A>

</STRONG>
<DD>

The 
<A HREF="perlfunc.html#perlfunc_exec_0">exec()</A>
 function executes a system command <EM>AND NEVER RETURNS</EM>.  Use
the 
<A HREF="perlfunc.html#perlfunc_system_0">system()</A>
 function if you want it to return.
<p>If there is more than one argument in LIST, or if LIST is an array with
more than one value, calls execvp(3) with the arguments in LIST.  If
there is only one scalar argument, the argument is checked for shell
metacharacters.  If there are any, the entire argument is passed to
<CODE>/bin/sh -c</CODE> for parsing.  If there are none, the argument is split
into words and passed directly to <EM>execvp()</EM>, which is more efficient.
Note: 
<A HREF="perlfunc.html#perlfunc_exec_0">exec()</A>
 (and system(0) do not flush your output buffer, so you may
need to set 
<A HREF="perlvar.html#perlvar__8">$|</A>
 to avoid lost output.  Examples:
<p>
<XMP>
    exec '/bin/echo', 'Your arguments are: ', @ARGV;
    exec "sort $outfile | uniq";

</XMP>
<p>If you don't really want to execute the first argument, but want to lie
to the program you are executing about its own name, you can specify
the program you actually want to run as an ``indirect object'' (without a
comma) in front of the LIST.  (This always forces interpretation of the
LIST as a multi-valued list, even if there is only a single scalar in
the list.)  Example:
<p>
<XMP>
    $shell = '/bin/csh';
    exec $shell '-sh';          # pretend it's a login shell

</XMP>
<p>or, more directly,
<p>
<XMP>
    exec {'/bin/csh'} '-sh';    # pretend it's a login shell

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_exists_0">
exists EXPR</A>

</STRONG>
<DD>

Returns TRUE if the specified hash key exists in its hash array, even
if the corresponding value is undefined.
<p>
<XMP>
    print "Exists\n" if exists $array{$key};
    print "Defined\n" if defined $array{$key};
    print "True\n" if $array{$key};

</XMP>
<p>A hash element can only be TRUE if it's defined, and defined if
it exists, but the reverse doesn't necessarily hold true.
<p>Note that the EXPR can be arbitrarily complicated as long as the final
operation is a hash key lookup:
<p>
<XMP>
    if (exists $ref->[$x][$y]{$key}) { ... }

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_exit_0">
exit EXPR</A>

</STRONG>
<DD>

Evaluates EXPR and exits immediately with that value.  (Actually, it
calls any defined <CODE>END</CODE> routines first, but the <CODE>END</CODE> routines may not
abort the exit.  Likewise any object destructors that need to be called
are called before exit.)  Example:
<p>
<XMP>
    $ans = <STDIN>;
    exit 0 if $ans =~ /^[Xx]/;

</XMP>
<p>See also 
<A HREF="perlfunc.html#perlfunc_die_0">die()</A>
.  If EXPR is omitted, exits with 0 status.
<p>
<DT><STRONG>

<A NAME="perlfunc_exp_0">
exp EXPR</A>

</STRONG>
<DD>

Returns <EM>e</EM> (the natural logarithm base) to the power of EXPR.  
If EXPR is omitted, gives 
<A HREF="perlfunc.html#perlfunc_exp_0">exp(
<A HREF="perlvar.html#perlvar__0">$_</A>
)</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_fcntl_0">
fcntl FILEHANDLE,FUNCTION,SCALAR</A>

</STRONG>
<DD>

Implements the fcntl(2) function.  You'll probably have to say
<p>
<XMP>
    use Fcntl;

</XMP>
<p>first to get the correct function definitions.  Argument processing and
value return works just like 
<A HREF="perlfunc.html#perlfunc_ioctl_0">ioctl()</A>
 below.  Note that 
<A HREF="perlfunc.html#perlfunc_fcntl_0">fcntl()</A>
 will produce
a fatal error if used on a machine that doesn't implement fcntl(2).
For example:
<p>
<XMP>
    use Fcntl;
    fcntl($filehandle, F_GETLK, $packed_return_buffer);

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_fileno_0">
fileno FILEHANDLE</A>

</STRONG>
<DD>

Returns the file descriptor for a filehandle.  This is useful for
constructing bitmaps for 
<A HREF="perlfunc.html#perlfunc_select_1">select()</A>
.  If FILEHANDLE is an expression, the
value is taken as the name of the filehandle.
<p>
<DT><STRONG>

<A NAME="perlfunc_flock_0">
flock FILEHANDLE,OPERATION</A>

</STRONG>
<DD>

Calls flock(2) on FILEHANDLE.  See the 
<A HREF="perlfunc.html#perlfunc_flock_0">flock</A>
(2) manpage for
definition of OPERATION.  Returns TRUE for success, FALSE on failure.
Will produce a fatal error if used on a machine that doesn't implement
flock(2).  Here's a mailbox appender for BSD systems.
<p>
<XMP>
    $LOCK_SH = 1;
    $LOCK_EX = 2;
    $LOCK_NB = 4;
    $LOCK_UN = 8;
    sub lock {
        flock(MBOX,$LOCK_EX);
        # and, in case someone appended
        # while we were waiting...
        seek(MBOX, 0, 2);
    }
    sub unlock {
        flock(MBOX,$LOCK_UN);
    }

</XMP>
<PRE>
    open(MBOX, ``&gt;&gt;/usr/spool/mail/<STRONG>$ENV</STRONG>{'USER'}'')
            or die ``Can't open mailbox: $!'';
    lock();
    print MBOX $msg,"\n\n";
    unlock();

</PRE>
<p>Note that 
<A HREF="perlfunc.html#perlfunc_flock_0">flock()</A>
 can't lock things over the network.  You need to do
locking with 
<A HREF="perlfunc.html#perlfunc_fcntl_0">fcntl()</A>
 for that.
<p>
<DT><STRONG>

<A NAME="perlfunc_fork_0">
fork</A>

</STRONG>
<DD>

Does a fork(2) system call.  Returns the child pid to the parent process
and 0 to the child process, or undef if the fork is unsuccessful.
Note: unflushed buffers remain unflushed in both processes, which means
you may need to set 
<A HREF="perlvar.html#perlvar__8">$|</A>
 (<STRONG>$AUTOFLUSH</STRONG> in English) or call the 

<A HREF="perlvar.html#perlvar_autoflush_0">autoflush()</A>
 FileHandle method to avoid duplicate output.
<p>If you 
<A HREF="perlfunc.html#perlfunc_fork_0">fork()</A>
 without ever waiting on your children, you will accumulate
zombies:
<p>
<XMP>
    $SIG{'CHLD'} = sub { wait };

</XMP>
<p>There's also the double-fork trick (error checking on 

<A HREF="perlfunc.html#perlfunc_fork_0">fork()</A>
 returns omitted);
<p>
<XMP>
    unless ($pid = fork) {
        unless (fork) {
            exec "what you really wanna do";
            die "no exec";
            # ... or ...
            some_perl_code_here;
            exit 0;
        }
        exit 0;
    }
    waitpid($pid,0);

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_formline_0">
formline PICTURE, LIST</A>

</STRONG>
<DD>

This is an internal function used by formats, though you may call it
too.  It formats (see the <EM>perlform</EM>  manpage
) a list of values according to the
contents of PICTURE, placing the output into the format output
accumulator, 
<A HREF="perlvar.html#perlvar_a_0">
<A HREF="perlvar.html#perlvar__18">$^</A>
A</A>
.  Eventually, when a 
<A HREF="perlfunc.html#perlfunc_write_1">write()</A>
 is done, the contents of

<A HREF="perlvar.html#perlvar_a_0">
<A HREF="perlvar.html#perlvar__18">$^</A>
A</A>
 are written to some filehandle, but you could also read 
<A HREF="perlvar.html#perlvar_a_0">
<A HREF="perlvar.html#perlvar__18">$^</A>
A</A>

yourself and then set 
<A HREF="perlvar.html#perlvar_a_0">
<A HREF="perlvar.html#perlvar__18">$^</A>
A</A>
 back to ``''.  Note that a format typically
does one 
<A HREF="perlfunc.html#perlfunc_formline_0">formline()</A>
 per line of form, but the 
<A HREF="perlfunc.html#perlfunc_formline_0">formline()</A>
 function itself
doesn't care how many newlines are embedded in the PICTURE.  This means
that the ~ and ~~ tokens will treat the entire PICTURE as a single line.
You may therefore need to use multiple formlines to implement a single
record format, just like the format compiler.
<p>Be careful if you put double quotes around the picture, since an ``<CODE>@</CODE>''
character may be taken to mean the beginning of an array name.

<A HREF="perlfunc.html#perlfunc_formline_0">formline()</A>
 always returns TRUE.
<p>
<DT><STRONG>

<A NAME="perlfunc_getc_0">
getc FILEHANDLE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getc_0">
getc</A>

</STRONG>
<DD>

Returns the next character from the input file attached to FILEHANDLE,
or a null string at end of file.  If FILEHANDLE is omitted, reads from STDIN.
<p>
<DT><STRONG>

<A NAME="perlfunc_getlogin_0">
getlogin</A>

</STRONG>
<DD>

Returns the current login from <EM>/etc/utmp</EM>, if any.  If null, use

<A HREF="perlfunc.html#perlfunc_getpwuid_0">getpwuid()</A>
.
<p>
<XMP>
    $login = getlogin || (getpwuid($<))[0] || "Kilroy";

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_getpeername_0">
getpeername SOCKET</A>

</STRONG>
<DD>

Returns the packed sockaddr address of other end of the SOCKET connection.
<p>
<XMP>
    # An internet sockaddr
    $sockaddr = 'S n a4 x8';
    $hersockaddr = getpeername(S);
    ($family, $port, $heraddr) = unpack($sockaddr,$hersockaddr);

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_getpgrp_0">
getpgrp PID</A>

</STRONG>
<DD>

Returns the current process group for the specified PID, 0 for the
current process.  Will produce a fatal error if used on a machine that
doesn't implement getpgrp(2).  If PID is omitted, returns process
group of current process.
<p>
<DT><STRONG>

<A NAME="perlfunc_getppid_0">
getppid</A>

</STRONG>
<DD>

Returns the process id of the parent process.
<p>
<DT><STRONG>

<A NAME="perlfunc_getpriority_0">
getpriority WHICH,WHO</A>

</STRONG>
<DD>

Returns the current priority for a process, a process group, or a
user.  (See the 
<A HREF="perlfunc.html#perlfunc_getpriority_0">getpriority</A>
(2) manpage.)  Will produce a fatal error if used on a
machine that doesn't implement getpriority(2).
<p>
<DT><STRONG>

<A NAME="perlfunc_getpwnam_0">
getpwnam NAME</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getgrnam_0">
getgrnam NAME</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_gethostbyname_0">
gethostbyname NAME</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getnetbyname_0">
getnetbyname NAME</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getprotobyname_0">
getprotobyname NAME</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getpwuid_0">
getpwuid UID</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getgrgid_0">
getgrgid GID</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getservbyname_0">
getservbyname NAME,PROTO</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_gethostbyaddr_0">
gethostbyaddr ADDR,ADDRTYPE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getnetbyaddr_0">
getnetbyaddr ADDR,ADDRTYPE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getprotobynumber_0">
getprotobynumber NUMBER</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getservbyport_0">
getservbyport PORT,PROTO</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getpwent_0">
getpwent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getgrent_0">
getgrent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_gethostent_0">
gethostent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getnetent_0">
getnetent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getprotoent_0">
getprotoent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_getservent_0">
getservent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_setpwent_0">
setpwent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_setgrent_0">
setgrent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_sethostent_0">
sethostent STAYOPEN</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_setnetent_0">
setnetent STAYOPEN</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_setprotoent_0">
setprotoent STAYOPEN</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_setservent_0">
setservent STAYOPEN</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_endpwent_0">
endpwent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_endgrent_0">
endgrent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_endhostent_0">
endhostent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_endnetent_0">
endnetent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_endprotoent_0">
endprotoent</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_endservent_0">
endservent</A>

</STRONG>
<DD>

These routines perform the same functions as their counterparts in the
system library.  Within a list context, the return values from the
various get routines are as follows:
<p>
<XMP>
    ($name,$passwd,$uid,$gid,
       $quota,$comment,$gcos,$dir,$shell) = getpw*
    ($name,$passwd,$gid,$members) = getgr*
    ($name,$aliases,$addrtype,$length,@addrs) = gethost*
    ($name,$aliases,$addrtype,$net) = getnet*
    ($name,$aliases,$proto) = getproto*
    ($name,$aliases,$port,$proto) = getserv*

</XMP>
<p>(If the entry doesn't exist you get a null list.)
<p>Within a scalar context, you get the name, unless the function was a
lookup by name, in which case you get the other thing, whatever it is.
(If the entry doesn't exist you get the undefined value.)  For example:
<p>
<XMP>
    $uid = getpwnam
    $name = getpwuid
    $name = getpwent
    $gid = getgrnam
    $name = getgrgid
    $name = getgrent
    etc.

</XMP>
<p>The <STRONG>$members</STRONG> value returned by <EM>getgr*()</EM> is a space separated list of
the login names of the members of the group.
<p>For the <EM>gethost*()</EM> functions, if the <CODE>h_errno</CODE> variable is supported in
C, it will be returned to you via 
<A HREF="perlvar.html#perlvar__20">$?</A>
 if the function call fails.  The
<STRONG>@addrs</STRONG> value returned by a successful call is a list of the raw
addresses returned by the corresponding system library call.  In the
Internet domain, each address is four bytes long and you can unpack it
by saying something like:
<p>
<XMP>
    ($a,$b,$c,$d) = unpack('C4',$addr[0]);

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_getsockname_0">
getsockname SOCKET</A>

</STRONG>
<DD>

Returns the packed sockaddr address of this end of the SOCKET connection.
<p>
<XMP>
    # An internet sockaddr
    $sockaddr = 'S n a4 x8';
    $mysockaddr = getsockname(S);
    ($family, $port, $myaddr) =
                    unpack($sockaddr,$mysockaddr);

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_getsockopt_0">
getsockopt SOCKET,LEVEL,OPTNAME</A>

</STRONG>
<DD>

Returns the socket option requested, or undefined if there is an error.
<p>
<DT><STRONG>

<A NAME="perlfunc_glob_0">
glob EXPR</A>

</STRONG>
<DD>

Returns the value of EXPR with filename expansions such as a shell
would do.  This is the internal function implementing the &lt;*.*&gt;
operator.
<p>
<DT><STRONG>

<A NAME="perlfunc_gmtime_0">
gmtime EXPR</A>

</STRONG>
<DD>

Converts a time as returned by the time function to a 9-element array
with the time localized for the Greenwich timezone.  Typically used as
follows:
<p>
<XMP>
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                            gmtime(time);

</XMP>
<p>All array elements are numeric, and come straight out of a struct tm.
In particular this means that <STRONG>$mon</STRONG> has the range 0..11 and <STRONG>$wday</STRONG> has
the range 0..6.  If EXPR is omitted, does 
<A HREF="perlfunc.html#perlfunc_gmtime_0">gmtime(
<A HREF="perlfunc.html#perlfunc_time_0">time()</A>
)</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_goto_0">
goto LABEL</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_goto_1">
goto EXPR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>
<EM>goto &amp;NAME</EM>
</STRONG>
<DD>

The goto-LABEL form finds the statement labeled with LABEL and resumes
execution there.  It may not be used to go into any construct that
requires initialization, such as a subroutine or a foreach loop.  It
also can't be used to go into a construct that is optimized away.  It
can be used to go almost anywhere else within the dynamic scope,
including out of subroutines, but it's usually better to use some other
construct such as last or die.  The author of Perl has never felt the
need to use this form of goto (in Perl, that is--C is another matter).
<p>The goto-EXPR form expects a label name, whose scope will be resolved
dynamically.  This allows for computed gotos per FORTRAN, but isn't
necessarily recommended if you're optimizing for maintainability:
<p>
<XMP>
    goto ("FOO", "BAR", "GLARCH")[$i];

</XMP>
<p>The goto-&amp;NAME form is highly magical, and substitutes a call to the
named subroutine for the currently running subroutine.  This is used by
AUTOLOAD subroutines that wish to load another subroutine and then
pretend that the other subroutine had been called in the first place
(except that any modifications to <STRONG>@_</STRONG> in the current subroutine are
propagated to the other subroutine.)  After the goto, not even 
<A HREF="perlfunc.html#perlfunc_caller_0">caller()</A>

will be able to tell that this routine was called first.
<p>
<DT><STRONG>

<A NAME="perlfunc_grep_0">
grep BLOCK LIST</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_grep_1">
grep EXPR,LIST</A>

</STRONG>
<DD>

Evaluates the BLOCK or EXPR for each element of LIST (locally setting

<A HREF="perlvar.html#perlvar__0">$_</A>
 to each element) and returns the list value consisting of those
elements for which the expression evaluated to TRUE.  In a scalar
context, returns the number of times the expression was TRUE.
<p>
<XMP>
    @foo = grep(!/^#/, @bar);    # weed out comments

</XMP>
<p>or equivalently,
<p>
<XMP>
    @foo = grep {!/^#/} @bar;    # weed out comments

</XMP>
<p>Note that, since 
<A HREF="perlvar.html#perlvar__0">$_</A>
 is a reference into the list value, it can be used
to modify the elements of the array.  While this is useful and
supported, it can cause bizarre results if the LIST is not a named
array.
<p>
<DT><STRONG>

<A NAME="perlfunc_hex_0">
hex EXPR</A>

</STRONG>
<DD>

Returns the decimal value of EXPR interpreted as an hex string.  (To
interpret strings that might start with 0 or 0x see 
<A HREF="perlfunc.html#perlfunc_oct_0">oct()</A>
.)  If EXPR is
omitted, uses 
<A HREF="perlvar.html#perlvar__0">$_</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_import_0">
import</A>

</STRONG>
<DD>

There is no built-in 
<A HREF="perlfunc.html#perlfunc_import_0">import()</A>
 function.  It is merely an ordinary
method subroutine defined (or inherited) by modules that wish to export
names to another module.  The 
<A HREF="perlfunc.html#perlfunc_use_1">use()</A>
 function calls the 
<A HREF="perlfunc.html#perlfunc_import_0">import()</A>
 method
for the package used.  See also 
<A HREF="perlfunc.html#perlfunc_use_1"><EM>use</EM></A>
 and the <EM>perlmod</EM>  manpage
.
<p>
<DT><STRONG>

<A NAME="perlfunc_index_0">
index STR,SUBSTR,POSITION</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_index_1">
index STR,SUBSTR</A>

</STRONG>
<DD>

Returns the position of the first occurrence of SUBSTR in STR at or
after POSITION.  If POSITION is omitted, starts searching from the
beginning of the string.  The return value is based at 0, or whatever
you've set the $[ variable to.  If the substring is not found, returns
one less than the base, ordinarily -1.
<p>
<DT><STRONG>

<A NAME="perlfunc_int_0">
int EXPR</A>

</STRONG>
<DD>

Returns the integer portion of EXPR.  If EXPR is omitted, uses 
<A HREF="perlvar.html#perlvar__0">$_</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_ioctl_0">
ioctl FILEHANDLE,FUNCTION,SCALAR</A>

</STRONG>
<DD>

Implements the ioctl(2) function.  You'll probably have to say
<p>
<XMP>
    require "ioctl.ph"; # probably /usr/local/lib/perl/ioctl.ph

</XMP>
<p>first to get the correct function definitions.  If ioctl.ph doesn't
exist or doesn't have the correct definitions you'll have to roll your
own, based on your C header files such as &lt;sys/ioctl.h&gt;.  (There is a
Perl script called <STRONG>h2ph</STRONG> that comes with the Perl kit which may help you
in this.)  SCALAR will be read and/or written depending on the
FUNCTION--a pointer to the string value of SCALAR will be passed as the
third argument of the actual ioctl call.  (If SCALAR has no string
value but does have a numeric value, that value will be passed rather
than a pointer to the string value.  To guarantee this to be TRUE, add
a 0 to the scalar before using it.)  The 
<A HREF="perlfunc.html#perlfunc_pack_0">pack()</A>
 and 
<A HREF="perlfunc.html#perlfunc_unpack_0">unpack()</A>
 functions
are useful for manipulating the values of structures used by 
<A HREF="perlfunc.html#perlfunc_ioctl_0">ioctl()</A>
.
The following example sets the erase character to DEL.
<p>
<XMP>
    require 'ioctl.ph';
    $sgttyb_t = "ccccs";                # 4 chars and a short
    if (ioctl(STDIN,$TIOCGETP,$sgttyb)) {
        @ary = unpack($sgttyb_t,$sgttyb);
        $ary[2] = 127;
        $sgttyb = pack($sgttyb_t,@ary);
        ioctl(STDIN,$TIOCSETP,$sgttyb)
            || die "Can't ioctl: $!";
    }

</XMP>
<p>The return value of ioctl (and fcntl) is as follows:
<p>
<XMP>
        if OS returns:          then Perl returns:
            -1                    undefined value
             0                  string "0 but true"
        anything else               that number

</XMP>
<p>Thus Perl returns TRUE on success and FALSE on failure, yet you can
still easily determine the actual value returned by the operating
system:
<p>
<XMP>
    ($retval = ioctl(...)) || ($retval = -1);
    printf "System returned %d\n", $retval;

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_join_0">
join EXPR,LIST</A>

</STRONG>
<DD>

Joins the separate strings of LIST or ARRAY into a single string with
fields separated by the value of EXPR, and returns the string.
Example:
<p>
<XMP>
    $_ = join(':', $login,$passwd,$uid,$gid,$gcos,$home,$shell);

</XMP>
<p>See 
<A HREF="perlfunc.html#perlfunc_split_2"><EM>split</EM></A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_keys_0">
keys ASSOC_ARRAY</A>

</STRONG>
<DD>

Returns a normal array consisting of all the keys of the named
associative array.  (In a scalar context, returns the number of keys.)
The keys are returned in an apparently random order, but it is the same
order as either the 
<A HREF="perlfunc.html#perlfunc_values_0">values()</A>
 or 
<A HREF="perlfunc.html#perlfunc_each_0">each()</A>
 function produces (given that
the associative array has not been modified).  Here is yet another way
to print your environment:
<p>
<XMP>
    @keys = keys %ENV;
    @values = values %ENV;
    while ($#keys >= 0) {
        print pop(@keys), '=', pop(@values), "\n";
    }

</XMP>
<p>or how about sorted by key:
<p>
<XMP>
    foreach $key (sort(keys %ENV)) {
        print $key, '=', $ENV{$key}, "\n";
    }

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_kill_0">
kill LIST</A>

</STRONG>
<DD>

Sends a signal to a list of processes.  The first element of the list
must be the signal to send.  Returns the number of processes
successfully signaled.
<p>
<XMP>
    $cnt = kill 1, $child1, $child2;
    kill 9, @goners;

</XMP>
<p>Unlike in the shell, in Perl
if the <EM>SIGNAL</EM> is negative, it kills process groups instead of processes.
(On System V, a negative <EM>PROCESS</EM> number will also kill process
groups, but that's not portable.)  That means you usually want to use
positive not negative signals.  You may also use a signal name in quotes.
<p>
<DT><STRONG>

<A NAME="perlfunc_last_0">
last LABEL</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_last_0">
last</A>

</STRONG>
<DD>

The 
<A HREF="perlfunc.html#perlfunc_last_0">last</A>
 command is like the <CODE>break</CODE> statement in C (as used in
loops); it immediately exits the loop in question.  If the LABEL is
omitted, the command refers to the innermost enclosing loop.  The
<CODE>continue</CODE> block, if any, is not executed:
<p>
<XMP>
    line: while (<STDIN>) {
        last line if /^$/;      # exit when done with header
        ...
    }

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_lc_0">
lc EXPR</A>

</STRONG>
<DD>

Returns an lowercased version of EXPR.  This is the internal function
implementing the \L escape in double-quoted strings.
<p>
<DT><STRONG>

<A NAME="perlfunc_lcfirst_0">
lcfirst EXPR</A>

</STRONG>
<DD>

Returns the value of EXPR with the first character lowercased.  This is
the internal function implementing the \l escape in double-quoted strings.
<p>
<DT><STRONG>

<A NAME="perlfunc_length_0">
length EXPR</A>

</STRONG>
<DD>

Returns the length in characters of the value of EXPR.  If EXPR is
omitted, returns length of 
<A HREF="perlvar.html#perlvar__0">$_</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_link_0">
link OLDFILE,NEWFILE</A>

</STRONG>
<DD>

Creates a new filename linked to the old filename.  Returns 1 for
success, 0 otherwise.
<p>
<DT><STRONG>

<A NAME="perlfunc_listen_0">
listen SOCKET,QUEUESIZE</A>

</STRONG>
<DD>

Does the same thing that the listen system call does.  Returns TRUE if
it succeeded, FALSE otherwise.  See example in 
<A HREF="perlipc.html">
the <EM>perlipc</EM> manpage</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_local_0">
local EXPR</A>

</STRONG>
<DD>

In general, you should be using ``my'' instead of ``local'', because it's
faster and safer.  Format variables often use ``local'' though, as
do other variables whose current value must be visible to called
subroutines.  This is known as dynamic scoping.  Lexical scoping is
done with ``my'', which works more like C's auto declarations.
<p>A local modifies the listed variables to be local to the enclosing block,
subroutine, eval or ``do''.  If more than one value is listed, the list
must be placed in parens.  All the listed elements must be legal
lvalues.  This operator works by saving the current values of those
variables in LIST on a hidden stack and restoring them upon exiting the
block, subroutine or eval.  This means that called subroutines can also
reference the local variable, but not the global one.  The LIST may be
assigned to if desired, which allows you to initialize your local
variables.  (If no initializer is given for a particular variable, it
is created with an undefined value.)  Commonly this is used to name the
parameters to a subroutine.  Examples:
<p>
<XMP>
    sub RANGEVAL {
        local($min, $max, $thunk) = @_;
        local $result = '';
        local $i;
        # Presumably $thunk makes reference to $i
        for ($i = $min; $i < $max; $i++) {
            $result .= eval $thunk;
        }
        $result;
    }
    if ($sw eq '-v') {
        # init local array with global array
        local @ARGV = @ARGV;
        unshift(@ARGV,'echo');
        system @ARGV;
    }
    # @ARGV restored
    # temporarily add to digits associative array
    if ($base12) {
        # (NOTE: not claiming this is efficient!)
        local(%digits) = (%digits,'t',10,'e',11);
        parse_num();
    }

</XMP>
<p>Note that 
<A HREF="perlfunc.html#perlfunc_local_0">local()</A>
 is a run-time command, and so gets executed every
time through a loop.  In Perl 4 it used more stack storage each
time until the loop was exited.  Perl 5 reclaims the space each time
through, but it's still more efficient to declare your variables
outside the loop.
<p>A local is simply a modifier on an lvalue expression.
When you assign to a localized EXPR, the local doesn't change whether
EXPR is viewed as a scalar or an array.  So
<p>
<XMP>
    local($foo) = <STDIN>;
    local @FOO = <STDIN>;

</XMP>
<p>both supply a list context to the righthand side, while
<p>
<XMP>
    local $foo = <STDIN>;

</XMP>
<p>supplies a scalar context.
<p>
<DT><STRONG>

<A NAME="perlfunc_localtime_0">
localtime EXPR</A>

</STRONG>
<DD>

Converts a time as returned by the time function to a 9-element array
with the time analyzed for the local timezone.  Typically used as
follows:
<p>
<XMP>
    ($sec,$min,$hour,$mday,$mon,$year,$wday,$yday,$isdst) =
                                                localtime(time);

</XMP>
<p>All array elements are numeric, and come straight out of a struct tm.
In particular this means that <STRONG>$mon</STRONG> has the range 0..11 and <STRONG>$wday</STRONG> has
the range 0..6.  If EXPR is omitted, does localtime(time).
<p>In a scalar context, prints out the ctime(3) value:
<p>
<XMP>
    $now_string = localtime;  # e.g. "Thu Oct 13 04:54:34 1994"

</XMP>
<p>See also <EM>timelocal</EM> and the strftime(3) function available
via the POSIX modulie.
<p>
<DT><STRONG>

<A NAME="perlfunc_log_0">
log EXPR</A>

</STRONG>
<DD>

Returns logarithm (base <EM>e</EM>) of EXPR.  If EXPR is omitted, returns log
of 
<A HREF="perlvar.html#perlvar__0">$_</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_lstat_0">
lstat FILEHANDLE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_lstat_1">
lstat EXPR</A>

</STRONG>
<DD>

Does the same thing as the 
<A HREF="perlfunc.html#perlfunc_stat_1">stat()</A>
 function, but stats a symbolic link
instead of the file the symbolic link points to.  If symbolic links are
unimplemented on your system, a normal 
<A HREF="perlfunc.html#perlfunc_stat_1">stat()</A>
 is done.
<p>
<DT><STRONG>

<A NAME="perlfunc_m_0">
m//</A>

</STRONG>
<DD>

The match operator.  See 
<A HREF="perlop.html">
the <EM>perlop</EM> manpage</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_map_0">
map BLOCK LIST</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_map_1">
map EXPR,LIST</A>

</STRONG>
<DD>

Evaluates the BLOCK or EXPR for each element of LIST (locally setting 
<A HREF="perlvar.html#perlvar__0">$_</A>
 to each
element) and returns the list value composed of the results of each such
evaluation.  Evaluates BLOCK or EXPR in a list context, so each element of LIST
may produce zero, one, or more elements in the returned value.
<p>
<XMP>
    @chars = map(chr, @nums);

</XMP>
<p>translates a list of numbers to the corresponding characters.  And
<p>
<XMP>
    %hash = map {&key($_), $_} @array;

</XMP>
<p>is just a funny way to write
<p>
<XMP>
    %hash = ();
    foreach $_ (@array) {
        $hash{&key($_)} = $_;
    }

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_mkdir_0">
mkdir FILENAME,MODE</A>

</STRONG>
<DD>

Creates the directory specified by FILENAME, with permissions specified
by MODE (as modified by umask).  If it succeeds it returns 1, otherwise
it returns 0 and sets $! (errno).
<p>
<DT><STRONG>

<A NAME="perlfunc_msgctl_0">
msgctl ID,CMD,ARG</A>

</STRONG>
<DD>

Calls the System V IPC function msgctl.  If CMD is &amp;IPC_STAT, then ARG
must be a variable which will hold the returned msqid_ds structure.
Returns like ioctl: the undefined value for error, ``0 but true'' for
zero, or the actual return value otherwise.
<p>
<DT><STRONG>

<A NAME="perlfunc_msgget_0">
msgget KEY,FLAGS</A>

</STRONG>
<DD>

Calls the System V IPC function msgget.  Returns the message queue id,
or the undefined value if there is an error.
<p>
<DT><STRONG>

<A NAME="perlfunc_msgsnd_0">
msgsnd ID,MSG,FLAGS</A>

</STRONG>
<DD>

Calls the System V IPC function msgsnd to send the message MSG to the
message queue ID.  MSG must begin with the long integer message type,
which may be created with 
<A HREF="perlfunc.html#perlfunc_pack_0">pack(``L'', <STRONG>$type</STRONG>)</A>
.  Returns TRUE if
successful, or FALSE if there is an error.
<p>
<DT><STRONG>

<A NAME="perlfunc_msgrcv_0">
msgrcv ID,VAR,SIZE,TYPE,FLAGS</A>

</STRONG>
<DD>

Calls the System V IPC function msgrcv to receive a message from
message queue ID into variable VAR with a maximum message size of
SIZE.  Note that if a message is received, the message type will be the
first thing in VAR, and the maximum length of VAR is SIZE plus the size
of the message type.  Returns TRUE if successful, or FALSE if there is
an error.
<p>
<DT><STRONG>

<A NAME="perlfunc_my_0">
my EXPR</A>

</STRONG>
<DD>

A ``my'' declares the listed variables to be local (lexically) to the
enclosing block, subroutine, eval or ``do''.  If more than one value is
listed, the list must be placed in parens.  All the listed elements
must be legal lvalues.  Only alphanumeric identifiers may be lexically
scoped--magical builtins like $/ must be localized with ``local''
instead.  In particular, you're not allowed to say
<p>
<XMP>
    my $_;      # Illegal.

</XMP>
<p>Unlike the ``local'' declaration, variables declared with ``my''
are totally hidden from the outside world, including any called
subroutines (even if it's the same subroutine--every call gets its own
copy).
<p>(An 
<A HREF="perlfunc.html#perlfunc_eval_1">eval()</A>
, however, can see the lexical variables of the scope it is
being evaluated in so long as the names aren't hidden by declarations within
the 
<A HREF="perlfunc.html#perlfunc_eval_1">eval()</A>
 itself.  See the <EM>perlref</EM>  manpage
.)
<p>The EXPR may be assigned to if desired, which allows you to initialize
your variables.  (If no initializer is given for a particular
variable, it is created with an undefined value.)  Commonly this is
used to name the parameters to a subroutine.  Examples:
<p>
<XMP>
    sub RANGEVAL {
        my($min, $max, $thunk) = @_;
        my $result = '';
        my $i;
        # Presumably $thunk makes reference to $i
        for ($i = $min; $i < $max; $i++) {
            $result .= eval $thunk;
        }
        $result;
    }
    if ($sw eq '-v') {
        # init my array with global array
        my @ARGV = @ARGV;
        unshift(@ARGV,'echo');
        system @ARGV;
    }
    # Outer @ARGV again visible

</XMP>
<p>The ``my'' is simply a modifier on something you might assign to.
So when you do assign to the EXPR, the ``my'' doesn't change whether
EXPR is viewed as a scalar or an array.  So
<p>
<XMP>
    my ($foo) = <STDIN>;
    my @FOO = <STDIN>;

</XMP>
<p>both supply a list context to the righthand side, while
<p>
<XMP>
    my $foo = <STDIN>;

</XMP>
<p>supplies a scalar context.  But the following only declares one variable:
<p>
<XMP>
    my $foo, $bar = 1;

</XMP>
<p>That has the same effect as
<p>
<XMP>
    my $foo;
    $bar = 1;

</XMP>
<p>The declared variable is not introduced (is not visible) until after
the current statement.  Thus,
<p>
<XMP>
    my $x = $x;

</XMP>
<p>can be used to initialize the new <STRONG>$x</STRONG> with the value of the old <STRONG>$x</STRONG>, and 
the expression
<p>
<XMP>
    my $x = 123 and $x == 123

</XMP>
<p>is false unless the old <STRONG>$x</STRONG> happened to have the value 123.
<p>Some users may wish to encourage the use of lexically scoped variables.
As an aid to catching implicit references to package variables,
if you say
<p>
<XMP>
    use strict 'vars';

</XMP>
<p>then any variable reference from there to the end of the enclosing
block must either refer to a lexical variable, or must be fully
qualified with the package name.  A compilation error results
otherwise.  An inner block may countermand this with <STRONG>``no strict 'vars'''</STRONG>.
<p>
<DT><STRONG>

<A NAME="perlfunc_next_0">
next LABEL</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_next_0">
next</A>

</STRONG>
<DD>

The 
<A HREF="perlfunc.html#perlfunc_next_0">next</A>
 command is like the <CODE>continue</CODE> statement in C; it starts
the next iteration of the loop:
<p>
<XMP>
    line: while (<STDIN>) {
        next line if /^#/;      # discard comments
        ...
    }

</XMP>
<p>Note that if there were a <CODE>continue</CODE> block on the above, it would get
executed even on discarded lines.  If the LABEL is omitted, the command
refers to the innermost enclosing loop.
<p>
<DT><STRONG>

<A NAME="perlfunc_no_0">
no Module LIST</A>

</STRONG>
<DD>

See the ``use'' function, which ``no'' is the opposite of.
<p>
<DT><STRONG>

<A NAME="perlfunc_oct_0">
oct EXPR</A>

</STRONG>
<DD>

Returns the decimal value of EXPR interpreted as an octal string.  (If
EXPR happens to start off with 0x, interprets it as a hex string
instead.)  The following will handle decimal, octal, and hex in the
standard Perl or C notation:
<p>
<XMP>
    $val = oct($val) if $val =~ /^0/;

</XMP>
<p>If EXPR is omitted, uses 
<A HREF="perlvar.html#perlvar__0">$_</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_open_0">
open FILEHANDLE,EXPR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_open_1">
open FILEHANDLE</A>

</STRONG>
<DD>

Opens the file whose filename is given by EXPR, and associates it with
FILEHANDLE.  If FILEHANDLE is an expression, its value is used as the
name of the real filehandle wanted.  If EXPR is omitted, the scalar
variable of the same name as the FILEHANDLE contains the filename.  If
the filename begins with ``&lt;'' or nothing, the file is opened for input.
If the filename begins with ``&gt;'', the file is opened for output.  If the
filename begins with ``&gt;&gt;'', the file is opened for appending.  (You can
put a '+' in front of the '&gt;' or '&lt;' to indicate that you want both
read and write access to the file.)  If the filename begins with ``|'',
the filename is interpreted as a command to which output is to be
piped, and if the filename ends with a ``|'', the filename is interpreted
as command which pipes input to us.  (You may not have a command that
pipes both in and out.)  Opening '-' opens STDIN and opening '&gt;-'
opens STDOUT.  Open returns non-zero upon success, the undefined
value otherwise.  If the open involved a pipe, the return value happens
to be the pid of the subprocess.  Examples:
<p>
<XMP>
    $ARTICLE = 100;
    open ARTICLE or die "Can't find article $ARTICLE: $!\n";
    while (<ARTICLE>) {...

</XMP>
<PRE>
    open(LOG, '&gt;&gt;/usr/spool/news/twitlog'); # (log is reserved)
    open(article, "caesar <$article |");    # decrypt article
    open(extract, "|sort >/tmp/Tmp$$");     # $$ is our process id
    # process argument list of files along with any includes
    foreach $file (@ARGV) {
        process($file, 'fh00');
    }
    sub process {
        local($filename, $input) = @_;
        $input++;               # this is a string increment
        unless (open($input, $filename)) {
            print STDERR "Can't open $filename: $!\n";
            return;
        }
        while (<$input>) {              # note use of indirection
            if (/^#include "(.*)"/) {
                process($1, $input);
                next;
            }
            ...         # whatever
        }
    }

</PRE>
<p>You may also, in the Bourne shell tradition, specify an EXPR beginning
with ``&gt;&amp;'', in which case the rest of the string is interpreted as the
name of a filehandle (or file descriptor, if numeric) which is to be
duped and opened.  You may use &amp; after &gt;, &gt;&gt;, &lt;, +&gt;, +&gt;&gt; and +&lt;.  The
mode you specify should match the mode of the original filehandle.
Here is a script that saves, redirects, and restores STDOUT and
STDERR:
<p>
<XMP>
    #!/usr/bin/perl
    open(SAVEOUT, ">&STDOUT");
    open(SAVEERR, ">&STDERR");
    open(STDOUT, ">foo.out") || die "Can't redirect stdout";
    open(STDERR, ">&STDOUT") || die "Can't dup stdout";
    select(STDERR); $| = 1;     # make unbuffered
    select(STDOUT); $| = 1;     # make unbuffered
    print STDOUT "stdout 1\n";  # this works for
    print STDERR "stderr 1\n";  # subprocesses too
    close(STDOUT);
    close(STDERR);
    open(STDOUT, ">&SAVEOUT");
    open(STDERR, ">&SAVEERR");
    print STDOUT "stdout 2\n";
    print STDERR "stderr 2\n";

</XMP>
<p>If you specify ``&lt;&amp;=N'', where N is a number, then Perl will do an
equivalent of C's <EM>fdopen()</EM> of that file descriptor.  For example:
<p>
<XMP>
    open(FILEHANDLE, "<&=$fd")

</XMP>
<p>If you open a pipe on the command ``-'', i.e. either ``|-'' or ``-|'', then
there is an implicit fork done, and the return value of open is the pid
of the child within the parent process, and 0 within the child
process.  (Use defined(<STRONG>$pid</STRONG>) to determine whether the open was successful.)
The filehandle behaves normally for the parent, but i/o to that
filehandle is piped from/to the STDOUT/STDIN of the child process.
In the child process the filehandle isn't opened--i/o happens from/to
the new STDOUT or STDIN.  Typically this is used like the normal
piped open when you want to exercise more control over just how the
pipe command gets executed, such as when you are running setuid, and
don't want to have to scan shell commands for metacharacters.  The
following pairs are more or less equivalent:
<p>
<XMP>
    open(FOO, "|tr '[a-z]' '[A-Z]'");
    open(FOO, "|-") || exec 'tr', '[a-z]', '[A-Z]';
    open(FOO, "cat -n '$file'|");
    open(FOO, "-|") || exec 'cat', '-n', $file;

</XMP>
<p>Explicitly closing any piped filehandle causes the parent process to
wait for the child to finish, and returns the status value in $?.
Note: on any operation which may do a fork, unflushed buffers remain
unflushed in both processes, which means you may need to set $| to
avoid duplicate output.
<p>The filename that is passed to open will have leading and trailing
whitespace deleted.  In order to open a file with arbitrary weird
characters in it, it's necessary to protect any leading and trailing
whitespace thusly:
<p>
<XMP>
        $file =~ s#^(\s)#./$1#;
        open(FOO, "< $file\0");

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_opendir_0">
opendir DIRHANDLE,EXPR</A>

</STRONG>
<DD>

Opens a directory named EXPR for processing by 
<A HREF="perlfunc.html#perlfunc_readdir_0">readdir()</A>
, 
<A HREF="perlfunc.html#perlfunc_telldir_0">telldir()</A>
,

<A HREF="perlfunc.html#perlfunc_seekdir_0">seekdir()</A>
, 
<A HREF="perlfunc.html#perlfunc_rewinddir_0">rewinddir()</A>
 and 
<A HREF="perlfunc.html#perlfunc_closedir_0">closedir()</A>
.  Returns TRUE if successful.
DIRHANDLEs have their own namespace separate from FILEHANDLEs.
<p>
<DT><STRONG>

<A NAME="perlfunc_ord_0">
ord EXPR</A>

</STRONG>
<DD>

Returns the numeric ascii value of the first character of EXPR.  If
EXPR is omitted, uses 
<A HREF="perlvar.html#perlvar__0">$_</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_pack_0">
pack TEMPLATE,LIST</A>

</STRONG>
<DD>

Takes an array or list of values and packs it into a binary structure,
returning the string containing the structure.  The TEMPLATE is a
sequence of characters that give the order and type of values, as
follows:
<p><UL><LI>    A	An ascii string, will be space padded.</LI>
<LI>    a	An ascii string, will be null padded.</LI>
<LI>    b	A bit string (ascending bit order, like vec()).</LI>
<LI>    B	A bit string (descending bit order).</LI>
<LI>    h	A hex string (low nybble first).</LI>
<LI>    H	A hex string (high nybble first).</LI>
</UL>
<p><UL><LI>    c	A signed char value.</LI>
<LI>    C	An unsigned char value.</LI>
<LI>    s	A signed short value.</LI>
<LI>    S	An unsigned short value.</LI>
<LI>    i	A signed integer value.</LI>
<LI>    I	An unsigned integer value.</LI>
<LI>    l	A signed long value.</LI>
<LI>    L	An unsigned long value.</LI>
</UL>
<p><UL><LI>    n	A short in "network" order.</LI>
<LI>    N	A long in "network" order.</LI>
<LI>    v	A short in "VAX" (little-endian) order.</LI>
<LI>    V	A long in "VAX" (little-endian) order.</LI>
</UL>
<p><UL><LI>    f	A single-precision float in the native format.</LI>
<LI>    d	A double-precision float in the native format.</LI>
</UL>
<p><UL><LI>    p	A pointer to a null-terminated string.</LI>
<LI>    P	A pointer to a structure (fixed-length string).</LI>
</UL>
<p><UL><LI>    u	A uuencoded string.</LI>
</UL>
<p><UL><LI>    x	A null byte.</LI>
<LI>    X	Back up a byte.</LI>
<LI>    @	Null fill to absolute position.</LI>
</UL>
<p>Each letter may optionally be followed by a number which gives a repeat
count.  With all types except ``a'', ``A'', ``b'', ``B'', ``h'' and ``H'', and ``P'' the
pack function will gobble up that many values from the LIST.  A * for the
repeat count means to use however many items are left.  The ``a'' and ``A''
types gobble just one value, but pack it as a string of length count,
padding with nulls or spaces as necessary.  (When unpacking, ``A'' strips
trailing spaces and nulls, but ``a'' does not.)  Likewise, the ``b'' and ``B''
fields pack a string that many bits long.  The ``h'' and ``H'' fields pack a
string that many nybbles long.  The ``P'' packs a pointer to a structure of
the size indicated by the length.  Real numbers (floats and doubles) are
in the native machine format only; due to the multiplicity of floating
formats around, and the lack of a standard ``network'' representation, no
facility for interchange has been made.  This means that packed floating
point data written on one machine may not be readable on another - even if
both use IEEE floating point arithmetic (as the endian-ness of the memory
representation is not part of the IEEE spec).  Note that Perl uses doubles
internally for all numeric calculation, and converting from double into
float and thence back to double again will lose precision (i.e.

<A HREF="perlfunc.html#perlfunc_unpack_0">unpack(``f'', pack(``f'', <STRONG>$foo</STRONG>)</A>
) will not in general equal <STRONG>$foo</STRONG>).
<p>Examples:
<p>
<XMP>
    $foo = pack("cccc",65,66,67,68);
    # foo eq "ABCD"
    $foo = pack("c4",65,66,67,68);
    # same thing
    $foo = pack("ccxxcc",65,66,67,68);
    # foo eq "AB\0\0CD"
    $foo = pack("s2",1,2);
    # "\1\0\2\0" on little-endian
    # "\0\1\0\2" on big-endian
    $foo = pack("a4","abcd","x","y","z");
    # "abcd"
    $foo = pack("aaaa","abcd","x","y","z");
    # "axyz"
    $foo = pack("a14","abcdefg");
    # "abcdefg\0\0\0\0\0\0\0"
    $foo = pack("i9pl", gmtime);
    # a real struct tm (on my system anyway)
    sub bintodec {
        unpack("N", pack("B32", substr("0" x 32 . shift, -32)));
    }

</XMP>
<p>The same template may generally also be used in the unpack function.
<p>
<DT><STRONG>

<A NAME="perlfunc_pipe_0">
pipe READHANDLE,WRITEHANDLE</A>

</STRONG>
<DD>

Opens a pair of connected pipes like the corresponding system call.
Note that if you set up a loop of piped processes, deadlock can occur
unless you are very careful.  In addition, note that Perl's pipes use
stdio buffering, so you may need to set $| to flush your WRITEHANDLE
after each command, depending on the application.
<p>
<DT><STRONG>

<A NAME="perlfunc_pop_0">
pop ARRAY</A>

</STRONG>
<DD>

Pops and returns the last value of the array, shortening the array by
1.  Has a similar effect to
<p>
<XMP>
    $tmp = $ARRAY[$#ARRAY--];

</XMP>
<p>If there are no elements in the array, returns the undefined value.
<p>
<DT><STRONG>

<A NAME="perlfunc_pos_0">
pos SCALAR</A>

</STRONG>
<DD>

Returns the offset of where the last m//g search left off for the variable
in question.  May be modified to change that offset.
<p>
<DT><STRONG>

<A NAME="perlfunc_print_0">
print FILEHANDLE LIST</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_print_1">
print LIST</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_print_1">
print</A>

</STRONG>
<DD>

Prints a string or a comma-separated list of strings.  Returns non-zero
if successful.  FILEHANDLE may be a scalar variable name, in which case
the variable contains the name of the filehandle, thus introducing one
level of indirection.  (NOTE: If FILEHANDLE is a variable and the next
token is a term, it may be misinterpreted as an operator unless you
interpose a + or put parens around the arguments.)  If FILEHANDLE is
omitted, prints by default to standard output (or to the last selected
output channel--see 
<A HREF="perlfunc.html#perlfunc_select_1">select()</A>
).  If LIST is also omitted, prints 
<A HREF="perlvar.html#perlvar__0">$_</A>
 to
STDOUT.  To set the default output channel to something other than
STDOUT use the select operation.  Note that, because print takes a
LIST, anything in the LIST is evaluated in a list context, and any
subroutine that you call will have one or more of its expressions
evaluated in a list context.  Also be careful not to follow the print
keyword with a left parenthesis unless you want the corresponding right
parenthesis to terminate the arguments to the print--interpose a + or
put parens around all the arguments.
<p>
<DT><STRONG>

<A NAME="perlfunc_printf_0">
printf FILEHANDLE LIST</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_printf_1">
printf LIST</A>

</STRONG>
<DD>

Equivalent to a ``print FILEHANDLE sprintf(LIST)''.  The first argument
of the list will be interpreted as the printf format.
<p>
<DT><STRONG>

<A NAME="perlfunc_push_0">
push ARRAY,LIST</A>

</STRONG>
<DD>

Treats ARRAY as a stack, and pushes the values of LIST
onto the end of ARRAY.  The length of ARRAY increases by the length of
LIST.  Has the same effect as
<p>
<XMP>
    for $value (LIST) {
        $ARRAY[++$#ARRAY] = $value;
    }

</XMP>
<p>but is more efficient.  Returns the new number of elements in the array.
<p>
<DT><STRONG>

<A NAME="perlfunc_q_string_0">
q/STRING/</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_qq_string_0">
qq/STRING/</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_qx_string_0">
qx/STRING/</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_qw_string_0">
qw/STRING/</A>

</STRONG>
<DD>

Generalized quotes.  See 
<A HREF="perlop.html">
the <EM>perlop</EM> manpage</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_quotemeta_0">
quotemeta EXPR</A>

</STRONG>
<DD>

Returns the value of EXPR with with all regular expression
metacharacters backslashed.  This is the internal function implementing
the \Q escape in double-quoted strings.
<p>
<DT><STRONG>

<A NAME="perlfunc_rand_0">
rand EXPR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_rand_0">
rand</A>

</STRONG>
<DD>

Returns a random fractional number between 0 and the value of EXPR.
(EXPR should be positive.)  If EXPR is omitted, returns a value between 
0 and 1.  This function produces repeatable sequences unless 
<A HREF="perlfunc.html#perlfunc_srand_0">srand()</A>
 
is invoked.  See also 
<A HREF="perlfunc.html#perlfunc_srand_0">srand()</A>
.
<p>(Note: if your rand function consistently returns numbers that are too
large or too small, then your version of Perl was probably compiled
with the wrong number of RANDBITS.  As a workaround, you can usually
multiply EXPR by the correct power of 2 to get the range you want.
This will make your script unportable, however.  It's better to recompile
if you can.)
<p>
<DT><STRONG>

<A NAME="perlfunc_read_0">
read FILEHANDLE,SCALAR,LENGTH,OFFSET</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_read_1">
read FILEHANDLE,SCALAR,LENGTH</A>

</STRONG>
<DD>

Attempts to read LENGTH bytes of data into variable SCALAR from the
specified FILEHANDLE.  Returns the number of bytes actually read, or
undef if there was an error.  SCALAR will be grown or shrunk to the
length actually read.  An OFFSET may be specified to place the read
data at some other place than the beginning of the string.  This call
is actually implemented in terms of stdio's fread call.  To get a true
read system call, see 
<A HREF="perlfunc.html#perlfunc_sysread_1">sysread()</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_readdir_0">
readdir DIRHANDLE</A>

</STRONG>
<DD>

Returns the next directory entry for a directory opened by 
<A HREF="perlfunc.html#perlfunc_opendir_0">opendir()</A>
.
If used in a list context, returns all the rest of the entries in the
directory.  If there are no more entries, returns an undefined value in
a scalar context or a null list in a list context.
<p>
<DT><STRONG>

<A NAME="perlfunc_readlink_0">
readlink EXPR</A>

</STRONG>
<DD>

Returns the value of a symbolic link, if symbolic links are
implemented.  If not, gives a fatal error.  If there is some system
error, returns the undefined value and sets $! (errno).  If EXPR is
omitted, uses 
<A HREF="perlvar.html#perlvar__0">$_</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_recv_0">
recv SOCKET,SCALAR,LEN,FLAGS</A>

</STRONG>
<DD>

Receives a message on a socket.  Attempts to receive LENGTH bytes of
data into variable SCALAR from the specified SOCKET filehandle.
Actually does a C <EM>recvfrom()</EM>, so that it can returns the address of the
sender.  Returns the undefined value if there's an error.  SCALAR will
be grown or shrunk to the length actually read.  Takes the same flags
as the system call of the same name.
<p>
<DT><STRONG>

<A NAME="perlfunc_redo_0">
redo LABEL</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_redo_0">
redo</A>

</STRONG>
<DD>

The 
<A HREF="perlfunc.html#perlfunc_redo_0">redo</A>
 command restarts the loop block without evaluating the
conditional again.  The <CODE>continue</CODE> block, if any, is not executed.  If
the LABEL is omitted, the command refers to the innermost enclosing
loop.  This command is normally used by programs that want to lie to
themselves about what was just input:
<p>
<XMP>
    # a simpleminded Pascal comment stripper
    # (warning: assumes no { or } in strings)
    line: while (<STDIN>) {
        while (s|({.*}.*){.*}|$1 |) {}
        s|{.*}| |;
        if (s|{.*| |) {
            $front = $_;
            while (<STDIN>) {
                if (/}/) {      # end of comment?
                    s|^|$front{|;
                    redo line;
                }
            }
        }
        print;
    }

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_ref_0">
ref EXPR</A>

</STRONG>
<DD>

Returns a TRUE value if EXPR is a reference, FALSE otherwise.  The value
returned depends on the type of thing the reference is a reference to.
Builtin types include:
<p>
<XMP>
    REF
    SCALAR
    ARRAY
    HASH
    CODE
    GLOB

</XMP>
<p>If the referenced object has been blessed into a package, then that package 
name is returned instead.  You can think of 
<A HREF="perlfunc.html#perlfunc_ref_0">ref()</A>
 as a <EM>typeof()</EM> operator.
<p>
<XMP>
    if (ref($r) eq "HASH") {
        print "r is a reference to an associative array.\n";
    } 
    if (!ref ($r) {
        print "r is not a reference at all.\n";
    } 

</XMP>
<p>See also the <EM>perlref</EM>  manpage
.
<p>
<DT><STRONG>

<A NAME="perlfunc_rename_0">
rename OLDNAME,NEWNAME</A>

</STRONG>
<DD>

Changes the name of a file.  Returns 1 for success, 0 otherwise.  Will
not work across filesystem boundaries.
<p>
<DT><STRONG>

<A NAME="perlfunc_require_0">
require EXPR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_require_0">
require</A>

</STRONG>
<DD>

Demands some semantics specified by EXPR, or by 
<A HREF="perlvar.html#perlvar__0">$_</A>
 if EXPR is not
supplied.  If EXPR is numeric, demands that the current version of Perl
($] or 
<A HREF="perlvar.html#perlvar_perl_version_0">$PERL_VERSION</A>
) be equal or greater than EXPR.
<p>Otherwise, demands that a library file be included if it hasn't already
been included.  The file is included via the do-FILE mechanism, which is
essentially just a variety of 
<A HREF="perlfunc.html#perlfunc_eval_1">eval()</A>
.  Has semantics similar to the following
subroutine:
<p>
<XMP>
    sub require {
        local($filename) = @_;
        return 1 if $INC{$filename};
        local($realfilename,$result);
        ITER: {
            foreach $prefix (@INC) {
                $realfilename = "$prefix/$filename";
                if (-f $realfilename) {
                    $result = do $realfilename;
                    last ITER;
                }
            }
            die "Can't find $filename in \@INC";
        }
        die $@ if $@;
        die "$filename did not return true value" unless $result;
        $INC{$filename} = $realfilename;
        $result;
    }

</XMP>
<p>Note that the file will not be included twice under the same specified
name.  The file must return TRUE as the last statement to indicate
successful execution of any initialization code, so it's customary to
end such a file with ``1;'' unless you're sure it'll return TRUE
otherwise.  But it's better just to put the ``<CODE>1;</CODE>'', in case you add more
statements.
<p>If EXPR is a bare word, the require assumes a ``<EM>.pm</EM>'' extension for you,
to make it easy to load standard modules.  This form of loading of 
modules does not risk altering your namespace.
<p>For a yet-more-powerful import facility, see the 
<A HREF="perlfunc.html#perlfunc_use_1"><EM>use</EM></A>
 and 
the <EM>perlmod</EM>  manpage
.
<p>
<DT><STRONG>

<A NAME="perlfunc_reset_0">
reset EXPR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_reset_0">
reset</A>

</STRONG>
<DD>

Generally used in a <CODE>continue</CODE> block at the end of a loop to clear
variables and reset ?? searches so that they work again.  The
expression is interpreted as a list of single characters (hyphens
allowed for ranges).  All variables and arrays beginning with one of
those letters are reset to their pristine state.  If the expression is
omitted, one-match searches (?pattern?) are reset to match again.  Only
resets variables or searches in the current package.  Always returns
1.  Examples:
<p>
<XMP>
    reset 'X';          # reset all X variables
    reset 'a-z';        # reset lower case variables
    reset;              # just reset ?? searches

</XMP>
<p>Resetting ``A-Z'' is not recommended since you'll wipe out your
ARGV and ENV arrays.  Only resets package variables--lexical variables
are unaffected, but they clean themselves up on scope exit anyway,
so anymore you probably want to use them instead.  See 
<A HREF="perlfunc.html#perlfunc_my_0"><EM>my</EM></A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_return_0">
return LIST</A>

</STRONG>
<DD>

Returns from a subroutine or eval with the value specified.  (Note that
in the absence of a return a subroutine or eval will automatically
return the value of the last expression evaluated.)
<p>
<DT><STRONG>

<A NAME="perlfunc_reverse_0">
reverse LIST</A>

</STRONG>
<DD>

In a list context, returns a list value consisting of the elements
of LIST in the opposite order.  In a scalar context, returns a string
value consisting of the bytes of the first element of LIST in the
opposite order.
<p>
<DT><STRONG>

<A NAME="perlfunc_rewinddir_0">
rewinddir DIRHANDLE</A>

</STRONG>
<DD>

Sets the current position to the beginning of the directory for the

<A HREF="perlfunc.html#perlfunc_readdir_0">readdir()</A>
 routine on DIRHANDLE.
<p>
<DT><STRONG>

<A NAME="perlfunc_rindex_0">
rindex STR,SUBSTR,POSITION</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_rindex_1">
rindex STR,SUBSTR</A>

</STRONG>
<DD>

Works just like index except that it returns the position of the LAST
occurrence of SUBSTR in STR.  If POSITION is specified, returns the
last occurrence at or before that position.
<p>
<DT><STRONG>

<A NAME="perlfunc_rmdir_0">
rmdir FILENAME</A>

</STRONG>
<DD>

Deletes the directory specified by FILENAME if it is empty.  If it
succeeds it returns 1, otherwise it returns 0 and sets $! (errno).  If
FILENAME is omitted, uses 
<A HREF="perlvar.html#perlvar__0">$_</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_s_0">
s///</A>

</STRONG>
<DD>

The substitution operator.  See 
<A HREF="perlop.html">
the <EM>perlop</EM> manpage</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_scalar_0">
scalar EXPR</A>

</STRONG>
<DD>

Forces EXPR to be interpreted in a scalar context and returns the value
of EXPR.
<p>
<DT><STRONG>

<A NAME="perlfunc_seek_0">
seek FILEHANDLE,POSITION,WHENCE</A>

</STRONG>
<DD>

Randomly positions the file pointer for FILEHANDLE, just like the <EM>fseek()</EM>
call of stdio.  FILEHANDLE may be an expression whose value gives the name
of the filehandle.  The values for WHENCE are 0 to set the file pointer to
POSITION, 1 to set the it to current plus POSITION, and 2 to set it to EOF
plus offset.  You may use the values SEEK_SET, SEEK_CUR, and SEEK_END for
this is using the POSIX module.  Returns 1 upon success, 0 otherwise.
<p>
<DT><STRONG>

<A NAME="perlfunc_seekdir_0">
seekdir DIRHANDLE,POS</A>

</STRONG>
<DD>

Sets the current position for the 
<A HREF="perlfunc.html#perlfunc_readdir_0">readdir()</A>
 routine on DIRHANDLE.  POS
must be a value returned by 
<A HREF="perlfunc.html#perlfunc_telldir_0">telldir()</A>
.  Has the same caveats about
possible directory compaction as the corresponding system library
routine.
<p>
<DT><STRONG>

<A NAME="perlfunc_select_0">
select FILEHANDLE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_select_1">
select</A>

</STRONG>
<DD>

Returns the currently selected filehandle.  Sets the current default
filehandle for output, if FILEHANDLE is supplied.  This has two
effects: first, a 
<A HREF="perlfunc.html#perlfunc_write_1">write</A>
 or a 
<A HREF="perlfunc.html#perlfunc_print_1">print</A>
 without a filehandle will
default to this FILEHANDLE.  Second, references to variables related to
output will refer to this output channel.  For example, if you have to
set the top of form format for more than one output channel, you might
do the following:
<p>
<XMP>
    select(REPORT1);
    $^ = 'report1_top';
    select(REPORT2);
    $^ = 'report2_top';

</XMP>
<p>FILEHANDLE may be an expression whose value gives the name of the
actual filehandle.  Thus:
<p>
<XMP>
    $oldfh = select(STDERR); $| = 1; select($oldfh);

</XMP>
<p>With Perl 5, filehandles are objects with methods, and the last example
is preferably written
<p>
<XMP>
    use FileHandle;
    STDERR->autoflush(1);

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_select_1">
select RBITS,WBITS,EBITS,TIMEOUT</A>

</STRONG>
<DD>

This calls the select system(2) call with the bitmasks specified, which
can be constructed using 
<A HREF="perlfunc.html#perlfunc_fileno_0">fileno()</A>
 and 
<A HREF="perlfunc.html#perlfunc_vec_0">vec()</A>
, along these lines:
<p>
<XMP>
    $rin = $win = $ein = '';
    vec($rin,fileno(STDIN),1) = 1;
    vec($win,fileno(STDOUT),1) = 1;
    $ein = $rin | $win;

</XMP>
<p>If you want to select on many filehandles you might wish to write a
subroutine:
<p>
<XMP>
    sub fhbits {
        local(@fhlist) = split(' ',$_[0]);
        local($bits);
        for (@fhlist) {
            vec($bits,fileno($_),1) = 1;
        }
        $bits;
    }
    $rin = &fhbits('STDIN TTY SOCK');

</XMP>
<p>The usual idiom is:
<p>
<XMP>
    ($nfound,$timeleft) =
      select($rout=$rin, $wout=$win, $eout=$ein, $timeout);

</XMP>
<p>or to block until something becomes ready:
<p>
<XMP>
    $nfound = select($rout=$rin, $wout=$win, $eout=$ein, undef);

</XMP>
<p>Any of the bitmasks can also be undef.  The timeout, if specified, is
in seconds, which may be fractional.  Note: not all implementations are
capable of returning the <STRONG>$timeleft</STRONG>.  If not, they always return
<STRONG>$timeleft</STRONG> equal to the supplied <STRONG>$timeout</STRONG>.
<p>You can effect a 250 microsecond sleep this way:
<p>
<XMP>
    select(undef, undef, undef, 0.25);

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_semctl_0">
semctl ID,SEMNUM,CMD,ARG</A>

</STRONG>
<DD>

Calls the System V IPC function semctl.  If CMD is &amp;IPC_STAT or
&amp;GETALL, then ARG must be a variable which will hold the returned
semid_ds structure or semaphore value array.  Returns like ioctl: the
undefined value for error, ``0 but true'' for zero, or the actual return
value otherwise.
<p>
<DT><STRONG>

<A NAME="perlfunc_semget_0">
semget KEY,NSEMS,FLAGS</A>

</STRONG>
<DD>

Calls the System V IPC function semget.  Returns the semaphore id, or
the undefined value if there is an error.
<p>
<DT><STRONG>

<A NAME="perlfunc_semop_0">
semop KEY,OPSTRING</A>

</STRONG>
<DD>

Calls the System V IPC function semop to perform semaphore operations
such as signaling and waiting.  OPSTRING must be a packed array of
semop structures.  Each semop structure can be generated with

<A HREF="perlfunc.html#perlfunc_pack_0">pack(``sss'', <STRONG>$semnum</STRONG>, <STRONG>$semop</STRONG>, <STRONG>$semflag</STRONG>)</A>
.  The number of semaphore
operations is implied by the length of OPSTRING.  Returns TRUE if
successful, or FALSE if there is an error.  As an example, the
following code waits on semaphore <STRONG>$semnum</STRONG> of semaphore id <STRONG>$semid:</STRONG>
<p>
<XMP>
    $semop = pack("sss", $semnum, -1, 0);
    die "Semaphore trouble: $!\n" unless semop($semid, $semop);

</XMP>
<p>To signal the semaphore, replace ``-1'' with ``1''.
<p>
<DT><STRONG>

<A NAME="perlfunc_send_0">
send SOCKET,MSG,FLAGS,TO</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_send_1">
send SOCKET,MSG,FLAGS</A>

</STRONG>
<DD>

Sends a message on a socket.  Takes the same flags as the system call
of the same name.  On unconnected sockets you must specify a
destination to send TO, in which case it does a C <EM>sendto()</EM>.  Returns
the number of characters sent, or the undefined value if there is an
error.
<p>
<DT><STRONG>

<A NAME="perlfunc_setpgrp_0">
setpgrp PID,PGRP</A>

</STRONG>
<DD>

Sets the current process group for the specified PID, 0 for the current
process.  Will produce a fatal error if used on a machine that doesn't
implement setpgrp(2).
<p>
<DT><STRONG>

<A NAME="perlfunc_setpriority_0">
setpriority WHICH,WHO,PRIORITY</A>

</STRONG>
<DD>

Sets the current priority for a process, a process group, or a user.
(See setpriority(2).)  Will produce a fatal error if used on a machine
that doesn't implement setpriority(2).
<p>
<DT><STRONG>

<A NAME="perlfunc_setsockopt_0">
setsockopt SOCKET,LEVEL,OPTNAME,OPTVAL</A>

</STRONG>
<DD>

Sets the socket option requested.  Returns undefined if there is an
error.  OPTVAL may be specified as undef if you don't want to pass an
argument.
<p>
<DT><STRONG>

<A NAME="perlfunc_shift_0">
shift ARRAY</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_shift_0">
shift</A>

</STRONG>
<DD>

Shifts the first value of the array off and returns it, shortening the
array by 1 and moving everything down.  If there are no elements in the
array, returns the undefined value.  If ARRAY is omitted, shifts the

<A HREF="perlvar.html#perlvar_argv_1">@ARGV</A>
 array in the main program, and the <STRONG>@_</STRONG> array in subroutines.
(This is determined lexically.)  See also 
<A HREF="perlfunc.html#perlfunc_unshift_0">unshift()</A>
, 
<A HREF="perlfunc.html#perlfunc_push_0">push()</A>
, and 
<A HREF="perlfunc.html#perlfunc_pop_0">pop()</A>
.
<EM>Shift()</EM> and 
<A HREF="perlfunc.html#perlfunc_unshift_0">unshift()</A>
 do the same thing to the left end of an array
that 
<A HREF="perlfunc.html#perlfunc_push_0">push()</A>
 and 
<A HREF="perlfunc.html#perlfunc_pop_0">pop()</A>
 do to the right end.
<p>
<DT><STRONG>

<A NAME="perlfunc_shmctl_0">
shmctl ID,CMD,ARG</A>

</STRONG>
<DD>

Calls the System V IPC function shmctl.  If CMD is &amp;IPC_STAT, then ARG
must be a variable which will hold the returned shmid_ds structure.
Returns like ioctl: the undefined value for error, ``0 but true'' for
zero, or the actual return value otherwise.
<p>
<DT><STRONG>

<A NAME="perlfunc_shmget_0">
shmget KEY,SIZE,FLAGS</A>

</STRONG>
<DD>

Calls the System V IPC function shmget.  Returns the shared memory
segment id, or the undefined value if there is an error.
<p>
<DT><STRONG>

<A NAME="perlfunc_shmread_0">
shmread ID,VAR,POS,SIZE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_shmwrite_0">
shmwrite ID,STRING,POS,SIZE</A>

</STRONG>
<DD>

Reads or writes the System V shared memory segment ID starting at
position POS for size SIZE by attaching to it, copying in/out, and
detaching from it.  When reading, VAR must be a variable which will
hold the data read.  When writing, if STRING is too long, only SIZE
bytes are used; if STRING is too short, nulls are written to fill out
SIZE bytes.  Return TRUE if successful, or FALSE if there is an error.
<p>
<DT><STRONG>

<A NAME="perlfunc_shutdown_0">
shutdown SOCKET,HOW</A>

</STRONG>
<DD>

Shuts down a socket connection in the manner indicated by HOW, which
has the same interpretation as in the system call of the same name.
<p>
<DT><STRONG>

<A NAME="perlfunc_sin_0">
sin EXPR</A>

</STRONG>
<DD>

Returns the sine of EXPR (expressed in radians).  If EXPR is omitted,
returns sine of 
<A HREF="perlvar.html#perlvar__0">$_</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_sleep_0">
sleep EXPR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_sleep_0">
sleep</A>

</STRONG>
<DD>

Causes the script to sleep for EXPR seconds, or forever if no EXPR.
May be interrupted by sending the process a SIGALRM.  Returns the
number of seconds actually slept.  You probably cannot mix 
<A HREF="perlfunc.html#perlfunc_alarm_0">alarm()</A>
 and

<A HREF="perlfunc.html#perlfunc_sleep_0">sleep()</A>
 calls, since 
<A HREF="perlfunc.html#perlfunc_sleep_0">sleep()</A>
 is often implemented using 
<A HREF="perlfunc.html#perlfunc_alarm_0">alarm()</A>
.
<p>On some older systems, it may sleep up to a full second less than what
you requested, depending on how it counts seconds.  Most modern systems
always sleep the full amount.
<p>
<DT><STRONG>

<A NAME="perlfunc_socket_0">
socket SOCKET,DOMAIN,TYPE,PROTOCOL</A>

</STRONG>
<DD>

Opens a socket of the specified kind and attaches it to filehandle
SOCKET.  DOMAIN, TYPE and PROTOCOL are specified the same as for the
system call of the same name.  You should ``use Socket;'' first to get
the proper definitions imported.  See the example in 
<A HREF="perlipc.html">
the <EM>perlipc</EM> manpage</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_socketpair_0">
socketpair SOCKET1,SOCKET2,DOMAIN,TYPE,PROTOCOL</A>

</STRONG>
<DD>

Creates an unnamed pair of sockets in the specified domain, of the
specified type.  DOMAIN, TYPE and PROTOCOL are specified the same as
for the system call of the same name.  If unimplemented, yields a fatal
error.  Returns TRUE if successful.
<p>
<DT><STRONG>

<A NAME="perlfunc_sort_0">
sort SUBNAME LIST</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_sort_1">
sort BLOCK LIST</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_sort_2">
sort LIST</A>

</STRONG>
<DD>

Sorts the LIST and returns the sorted list value.  Nonexistent values
of arrays are stripped out.  If SUBNAME or BLOCK is omitted, sorts
in standard string comparison order.  If SUBNAME is specified, it
gives the name of a subroutine that returns an integer less than, equal
to, or greater than 0, depending on how the elements of the array are
to be ordered.  (The &lt;=&gt; and cmp operators are extremely useful in such
routines.)  SUBNAME may be a scalar variable name, in which case the
value provides the name of the subroutine to use.  In place of a
SUBNAME, you can provide a BLOCK as an anonymous, in-line sort
subroutine.
<p>In the interests of efficiency the normal calling code for subroutines
is bypassed, with the following effects: the subroutine may not be a
recursive subroutine, and the two elements to be compared are passed
into the subroutine not via <STRONG>@_</STRONG> but as <STRONG>$a</STRONG> and <STRONG>$b</STRONG> (see example below).
They are passed by reference, so don't modify <STRONG>$a</STRONG> and <STRONG>$b</STRONG>.
<p>Examples:
<p>
<XMP>
    # sort lexically
    @articles = sort @files;
    # same thing, but with explicit sort routine
    @articles = sort {$a cmp $b} @files;
    # same thing in reversed order
    @articles = sort {$b cmp $a} @files;
    # sort numerically ascending
    @articles = sort {$a <=> $b} @files;
    # sort numerically descending
    @articles = sort {$b <=> $a} @files;
    # sort using explicit subroutine name
    sub byage {
        $age{$a} <=> $age{$b};  # presuming integers
    }
    @sortedclass = sort byage @class;
    sub backwards { $b cmp $a; }
    @harry = ('dog','cat','x','Cain','Abel');
    @george = ('gone','chased','yz','Punished','Axed');
    print sort @harry;
            # prints AbelCaincatdogx
    print sort backwards @harry;
            # prints xdogcatCainAbel
    print sort @george, 'to', @harry;
            # prints AbelAxedCainPunishedcatchaseddoggonetoxyz

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_splice_0">
splice ARRAY,OFFSET,LENGTH,LIST</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_splice_1">
splice ARRAY,OFFSET,LENGTH</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_splice_2">
splice ARRAY,OFFSET</A>

</STRONG>
<DD>

Removes the elements designated by OFFSET and LENGTH from an array, and
replaces them with the elements of LIST, if any.  Returns the elements
removed from the array.  The array grows or shrinks as necessary.  If
LENGTH is omitted, removes everything from OFFSET onward.  The
following equivalencies hold (assuming $[ == 0):
<p>
<XMP>
    push(@a,$x,$y)      splice(@a,$#a+1,0,$x,$y)
    pop(@a)             splice(@a,-1)
    shift(@a)           splice(@a,0,1)
    unshift(@a,$x,$y)   splice(@a,0,0,$x,$y)
    $a[$x] = $y         splice(@a,$x,1,$y);

</XMP>
<p>Example, assuming array lengths are passed before arrays:
<p>
<XMP>
    sub aeq {   # compare two list values
        local(@a) = splice(@_,0,shift);
        local(@b) = splice(@_,0,shift);
        return 0 unless @a == @b;       # same len?
        while (@a) {
            return 0 if pop(@a) ne pop(@b);
        }
        return 1;
    }
    if (&aeq($len,@foo[1..$len],0+@bar,@bar)) { ... }

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_split_0">
split /PATTERN/,EXPR,LIMIT</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_split_1">
split /PATTERN/,EXPR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_split_2">
split /PATTERN/</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_split_2">
split</A>

</STRONG>
<DD>

Splits a string into an array of strings, and returns it.
<p>If not in a list context, returns the number of fields found and splits into
the <STRONG>@_</STRONG> array.  (In a list context, you can force the split into <STRONG>@_</STRONG> by
using <CODE>??</CODE> as the pattern delimiters, but it still returns the array
value.)  The use of implicit split to <STRONG>@_</STRONG> is deprecated, however.
<p>If EXPR is omitted, splits the 
<A HREF="perlvar.html#perlvar__0">$_</A>
 string.  If PATTERN is also omitted,
splits on whitespace (after skipping any leading whitespace).
Anything matching PATTERN is taken
to be a delimiter separating the fields.  (Note that the delimiter may
be longer than one character.)  If LIMIT is specified and is not
negative, splits into no more than that many fields (though it may
split into fewer).  If LIMIT is unspecified, trailing null fields are
stripped (which potential users of 
<A HREF="perlfunc.html#perlfunc_pop_0">pop()</A>
 would do well to remember).
If LIMIT is negative, it is treated as if an arbitrarily large LIMIT
had been specified.
<p>A pattern matching the null string (not to be confused with
a null pattern <CODE>//</CODE>, which is just one member of the set of patterns
matching a null string) will split the value of EXPR into separate
characters at each point it matches that way.  For example:
<p>
<XMP>
    print join(':', split(/ */, 'hi there'));

</XMP>
<p>produces the output 'h:i:t:h:e:r:e'.
<p>The LIMIT parameter can be used to partially split a line
<p>
<XMP>
    ($login, $passwd, $remainder) = split(/:/, $_, 3);

</XMP>
<p>When assigning to a list, if LIMIT is omitted, Perl supplies a LIMIT
one larger than the number of variables in the list, to avoid
unnecessary work.  For the list above LIMIT would have been 4 by
default.  In time critical applications it behooves you not to split
into more fields than you really need.
<p>If the PATTERN contains parentheses, additional array elements are
created from each matching substring in the delimiter.
<p>
<XMP>
    split(/([,-])/, "1-10,20");

</XMP>
<p>produces the list value
<p>
<XMP>
    (1, '-', 10, ',', 20)

</XMP>
<p>The pattern <CODE>/PATTERN/</CODE> may be replaced with an expression to specify
patterns that vary at runtime.  (To do runtime compilation only once,
use <CODE>/<STRONG>$variable</STRONG>/o</CODE>.)
<p>As a special case, specifying a PATTERN of space (<CODE>' '</CODE>) will split on
white space just as split with no arguments does.  Thus, split(' ') can
be used to emulate <STRONG>awk</STRONG>'s default behavior, whereas 
<A HREF="perlfunc.html#perlfunc_split_2">split(/ /)</A>

will give you as many null initial fields as there are leading spaces.
A split on /\s+/ is like a split(' ') except that any leading
whitespace produces a null first field.  A split with no arguments
really does a 
<A HREF="perlfunc.html#perlfunc_split_2">split(' ', 
<A HREF="perlvar.html#perlvar__0">$_</A>
)</A>
 internally.
<p>Example:
<p>
<XMP>
    open(passwd, '/etc/passwd');
    while (<passwd>) {
        ($login, $passwd, $uid, $gid, $gcos, 
            $home, $shell) = split(/:/);
        ...
    }

</XMP>
<p>(Note that <STRONG>$shell</STRONG> above will still have a newline on it.  See 
<A HREF="perlfunc.html#perlfunc_chop_1"><EM>chop</EM></A>
, 

<A HREF="perlfunc.html#perlfunc_chomp_1"><EM>chomp</EM></A>
, and 
<A HREF="perlfunc.html#perlfunc_join_0"><EM>join</EM></A>
.)
<p>
<DT><STRONG>

<A NAME="perlfunc_sprintf_0">
sprintf FORMAT,LIST</A>

</STRONG>
<DD>

Returns a string formatted by the usual printf conventions of the C
language.  (The * character for an indirectly specified length is not
supported, but you can get the same effect by interpolating a variable
into the pattern.)
<p>
<DT><STRONG>

<A NAME="perlfunc_sqrt_0">
sqrt EXPR</A>

</STRONG>
<DD>

Return the square root of EXPR.  If EXPR is omitted, returns square
root of 
<A HREF="perlvar.html#perlvar__0">$_</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_srand_0">
srand EXPR</A>

</STRONG>
<DD>

Sets the random number seed for the 
<A HREF="perlfunc.html#perlfunc_rand_0">rand</A>
 operator.  If EXPR is
omitted, does 
<A HREF="perlfunc.html#perlfunc_srand_0">srand(time)</A>
.  Of course, you'd need something much more
random than that for cryptographic purposes, since it's easy to guess
the current time.  Checksumming the compressed output of rapidly
changing operating system status programs is the usual method.
Examples are posted regularly to comp.security.unix.
<p>
<DT><STRONG>

<A NAME="perlfunc_stat_0">
stat FILEHANDLE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_stat_1">
stat EXPR</A>

</STRONG>
<DD>

Returns a 13-element array giving the status info for a file, either the
file opened via FILEHANDLE, or named by EXPR.  Returns a null list if
the stat fails.  Typically used as follows:
<p>
<XMP>
    ($dev,$ino,$mode,$nlink,$uid,$gid,$rdev,$size,
       $atime,$mtime,$ctime,$blksize,$blocks)
           = stat($filename);

</XMP>
<p>If stat is passed the special filehandle consisting of an underline, no
stat is done, but the current contents of the stat structure from the
last stat or filetest are returned.  Example:
<p>
<XMP>
    if (-x $file && (($d) = stat(_)) && $d < 0) {
        print "$file is executable NFS file\n";
    }

</XMP>
<p>(This only works on machines for which the device number is negative under NFS.)
<p>
<DT><STRONG>

<A NAME="perlfunc_study_0">
study SCALAR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_study_0">
study</A>

</STRONG>
<DD>

Takes extra time to study SCALAR (
<A HREF="perlvar.html#perlvar__0">$_</A>
 if unspecified) in anticipation of
doing many pattern matches on the string before it is next modified.
This may or may not save time, depending on the nature and number of
patterns you are searching on, and on the distribution of character
frequencies in the string to be searched--you probably want to compare
runtimes with and without it to see which runs faster.  Those loops
which scan for many short constant strings (including the constant
parts of more complex patterns) will benefit most.  You may have only
one study active at a time--if you study a different scalar the first
is ``unstudied''.  (The way study works is this: a linked list of every
character in the string to be searched is made, so we know, for
example, where all the 'k' characters are.  From each search string,
the rarest character is selected, based on some static frequency tables
constructed from some C programs and English text.  Only those places
that contain this ``rarest'' character are examined.)
<p>For example, here is a loop which inserts index producing entries
before any line containing a certain pattern:
<p>
<XMP>
    while (<>) {
        study;
        print ".IX foo\n" if /\bfoo\b/;
        print ".IX bar\n" if /\bbar\b/;
        print ".IX blurfl\n" if /\bblurfl\b/;
        ...
        print;
    }

</XMP>
<p>In searching for /\bfoo\b/, only those locations in 
<A HREF="perlvar.html#perlvar__0">$_</A>
 that contain ``f''
will be looked at, because ``f'' is rarer than ``o''.  In general, this is
a big win except in pathological cases.  The only question is whether
it saves you more time than it took to build the linked list in the
first place.
<p>Note that if you have to look for strings that you don't know till
runtime, you can build an entire loop as a string and eval that to
avoid recompiling all your patterns all the time.  Together with
undefining $/ to input entire files as one record, this can be very
fast, often faster than specialized programs like fgrep(1).  The following
scans a list of files (<STRONG>@files</STRONG>) for a list of words (<STRONG>@words</STRONG>), and prints
out the names of those files that contain a match:
<p>
<XMP>
    $search = 'while (<>) { study;';
    foreach $word (@words) {
        $search .= "++\$seen{\$ARGV} if /\\b$word\\b/;\n";
    }
    $search .= "}";
    @ARGV = @files;
    undef $/;
    eval $search;               # this screams
    $/ = "\n";          # put back to normal input delim
    foreach $file (sort keys(%seen)) {
        print $file, "\n";
    }

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_substr_0">
substr EXPR,OFFSET,LEN</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_substr_1">
substr EXPR,OFFSET</A>

</STRONG>
<DD>

Extracts a substring out of EXPR and returns it.  First character is at
offset 0, or whatever you've set $[ to.  If OFFSET is negative, starts
that far from the end of the string.  If LEN is omitted, returns
everything to the end of the string.  If LEN is negative, leaves that
many characters off the end of the string.
<p>You can use the 
<A HREF="perlfunc.html#perlfunc_substr_1">substr()</A>
 function
as an lvalue, in which case EXPR must be an lvalue.  If you assign
something shorter than LEN, the string will shrink, and if you assign
something longer than LEN, the string will grow to accommodate it.  To
keep the string the same length you may need to pad or chop your value
using 
<A HREF="perlfunc.html#perlfunc_sprintf_0">sprintf()</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_symlink_0">
symlink OLDFILE,NEWFILE</A>

</STRONG>
<DD>

Creates a new filename symbolically linked to the old filename.
Returns 1 for success, 0 otherwise.  On systems that don't support
symbolic links, produces a fatal error at run time.  To check for that,
use eval:
<p>
<XMP>
    $symlink_exists = (eval 'symlink("","");', $@ eq '');

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_syscall_0">
syscall LIST</A>

</STRONG>
<DD>

Calls the system call specified as the first element of the list,
passing the remaining elements as arguments to the system call.  If
unimplemented, produces a fatal error.  The arguments are interpreted
as follows: if a given argument is numeric, the argument is passed as
an int.  If not, the pointer to the string value is passed.  You are
responsible to make sure a string is pre-extended long enough to
receive any result that might be written into a string.  If your
integer arguments are not literals and have never been interpreted in a
numeric context, you may need to add 0 to them to force them to look
like numbers.
<p>
<XMP>
    require 'syscall.ph';               # may need to run h2ph
    syscall(&SYS_write, fileno(STDOUT), "hi there\n", 9);

</XMP>
<p>Note that Perl only supports passing of up to 14 arguments to your system call,
which in practice should usually suffice.
<p>
<DT><STRONG>

<A NAME="perlfunc_sysread_0">
sysread FILEHANDLE,SCALAR,LENGTH,OFFSET</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_sysread_1">
sysread FILEHANDLE,SCALAR,LENGTH</A>

</STRONG>
<DD>

Attempts to read LENGTH bytes of data into variable SCALAR from the
specified FILEHANDLE, using the system call read(2).  It bypasses
stdio, so mixing this with other kinds of reads may cause confusion.
Returns the number of bytes actually read, or undef if there was an
error.  SCALAR will be grown or shrunk to the length actually read.  An
OFFSET may be specified to place the read data at some other place than
the beginning of the string.
<p>
<DT><STRONG>

<A NAME="perlfunc_system_0">
system LIST</A>

</STRONG>
<DD>

Does exactly the same thing as ``exec LIST'' except that a fork is done
first, and the parent process waits for the child process to complete.
Note that argument processing varies depending on the number of
arguments.  The return value is the exit status of the program as
returned by the 
<A HREF="perlfunc.html#perlfunc_wait_0">wait()</A>
 call.  To get the actual exit value divide by
256.  See also 
<A HREF="perlfunc.html#perlfunc_exec_0"><EM>exec</EM></A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_syswrite_0">
syswrite FILEHANDLE,SCALAR,LENGTH,OFFSET</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_syswrite_1">
syswrite FILEHANDLE,SCALAR,LENGTH</A>

</STRONG>
<DD>

Attempts to write LENGTH bytes of data from variable SCALAR to the
specified FILEHANDLE, using the system call write(2).  It bypasses
stdio, so mixing this with prints may cause confusion.  Returns the
number of bytes actually written, or undef if there was an error.  An
OFFSET may be specified to place the read data at some other place than
the beginning of the string.
<p>
<DT><STRONG>

<A NAME="perlfunc_tell_0">
tell FILEHANDLE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_tell_0">
tell</A>

</STRONG>
<DD>

Returns the current file position for FILEHANDLE.  FILEHANDLE may be an
expression whose value gives the name of the actual filehandle.  If
FILEHANDLE is omitted, assumes the file last read.
<p>
<DT><STRONG>

<A NAME="perlfunc_telldir_0">
telldir DIRHANDLE</A>

</STRONG>
<DD>

Returns the current position of the 
<A HREF="perlfunc.html#perlfunc_readdir_0">readdir()</A>
 routines on DIRHANDLE.
Value may be given to 
<A HREF="perlfunc.html#perlfunc_seekdir_0">seekdir()</A>
 to access a particular location in a
directory.  Has the same caveats about possible directory compaction as
the corresponding system library routine.
<p>
<DT><STRONG>

<A NAME="perlfunc_tie_0">
tie VARIABLE,PACKAGENAME,LIST</A>

</STRONG>
<DD>

This function binds a variable to a package that will provide the
implementation for the variable.  VARIABLE is the name of the variable to
be enchanted.  PACKAGENAME is the name of a package implementing objects
of correct type.  Any additional arguments are passed to the ``new'' method
of the package (meaning TIESCALAR, TIEARRAY, or TIEHASH).  Typically these
are arguments such as might be passed to the <EM>dbm_open()</EM> function of C.
<p>Note that functions such as 
<A HREF="perlfunc.html#perlfunc_keys_0">keys()</A>
 and 
<A HREF="perlfunc.html#perlfunc_values_0">values()</A>
 may return huge array
values when used on large objects, like DBM files.  You may prefer to
use the 
<A HREF="perlfunc.html#perlfunc_each_0">each()</A>
 function to iterate over such.  Example:
<p>
<XMP>
    # print out history file offsets
    tie(%HIST, NDBM_File, '/usr/lib/news/history', 1, 0);
    while (($key,$val) = each %HIST) {
        print $key, ' = ', unpack('L',$val), "\n";
    }
    untie(%HIST);

</XMP>
<p>A package implementing an associative array should have the following
methods:
<p>
<XMP>
    TIEHASH objectname, LIST
    DESTROY this
    FETCH this, key
    STORE this, key, value
    DELETE this, key
    EXISTS this, key
    FIRSTKEY this
    NEXTKEY this, lastkey

</XMP>
<p>A package implementing an ordinary array should have the following methods:
<p>
<XMP>
    TIEARRAY objectname, LIST
    DESTROY this
    FETCH this, key
    STORE this, key, value
    [others TBD]

</XMP>
<p>A package implementing a scalar should have the following methods:
<p>
<XMP>
    TIESCALAR objectname, LIST
    DESTROY this
    FETCH this, 
    STORE this, value

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_time_0">
time</A>

</STRONG>
<DD>

Returns the number of non-leap seconds since 00:00:00 UTC, January 1,
1970.  Suitable for feeding to 
<A HREF="perlfunc.html#perlfunc_gmtime_0">gmtime()</A>
 and 
<A HREF="perlfunc.html#perlfunc_localtime_0">localtime()</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_times_0">
times</A>

</STRONG>
<DD>

Returns a four-element array giving the user and system times, in
seconds, for this process and the children of this process.
<p>
<XMP>
    ($user,$system,$cuser,$csystem) = times;

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_tr_0">
tr///</A>

</STRONG>
<DD>

The translation operator.  See 
<A HREF="perlop.html">
the <EM>perlop</EM> manpage</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_truncate_0">
truncate FILEHANDLE,LENGTH</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_truncate_1">
truncate EXPR,LENGTH</A>

</STRONG>
<DD>

Truncates the file opened on FILEHANDLE, or named by EXPR, to the
specified length.  Produces a fatal error if truncate isn't implemented
on your system.
<p>
<DT><STRONG>

<A NAME="perlfunc_uc_0">
uc EXPR</A>

</STRONG>
<DD>

Returns an uppercased version of EXPR.  This is the internal function
implementing the \U escape in double-quoted strings.
<p>
<DT><STRONG>

<A NAME="perlfunc_ucfirst_0">
ucfirst EXPR</A>

</STRONG>
<DD>

Returns the value of EXPR with the first character uppercased.  This is
the internal function implementing the \u escape in double-quoted strings.
<p>
<DT><STRONG>

<A NAME="perlfunc_umask_0">
umask EXPR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_umask_0">
umask</A>

</STRONG>
<DD>

Sets the umask for the process and returns the old one.  If EXPR is
omitted, merely returns current umask.
<p>
<DT><STRONG>

<A NAME="perlfunc_undef_0">
undef EXPR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_undef_0">
undef</A>

</STRONG>
<DD>

Undefines the value of EXPR, which must be an lvalue.  Use only on a
scalar value, an entire array, or a subroutine name (using ``&amp;'').  (Using 
<A HREF="perlfunc.html#perlfunc_undef_0">undef()</A>

will probably not do what you expect on most predefined variables or
DBM list values, so don't do that.)  Always returns the undefined value.  You can omit
the EXPR, in which case nothing is undefined, but you still get an
undefined value that you could, for instance, return from a
subroutine.  Examples:
<p>
<XMP>
    undef $foo;
    undef $bar{'blurfl'};
    undef @ary;
    undef %assoc;
    undef &mysub;
    return (wantarray ? () : undef) if $they_blew_it;

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_unlink_0">
unlink LIST</A>

</STRONG>
<DD>

Deletes a list of files.  Returns the number of files successfully
deleted.
<p>
<XMP>
    $cnt = unlink 'a', 'b', 'c';
    unlink @goners;
    unlink <*.bak>;

</XMP>
<p>Note: unlink will not delete directories unless you are superuser and
the 
<A HREF="perlrun.html#perlrun_u_1">-U</A>
 flag is supplied to Perl.  Even if these conditions are
met, be warned that unlinking a directory can inflict damage on your
filesystem.  Use rmdir instead.
<p>
<DT><STRONG>

<A NAME="perlfunc_unpack_0">
unpack TEMPLATE,EXPR</A>

</STRONG>
<DD>

Unpack does the reverse of pack: it takes a string representing a
structure and expands it out into a list value, returning the array
value.  (In a scalar context, it merely returns the first value
produced.)  The TEMPLATE has the same format as in the pack function.
Here's a subroutine that does substring:
<p>
<XMP>
    sub substr {
        local($what,$where,$howmuch) = @_;
        unpack("x$where a$howmuch", $what);
    }

</XMP>
<p>and then there's
<p>
<XMP>
    sub ordinal { unpack("c",$_[0]); } # same as ord()

</XMP>
<p>In addition, you may prefix a field with a %&lt;number&gt; to indicate that
you want a &lt;number&gt;-bit checksum of the items instead of the items
themselves.  Default is a 16-bit checksum.  For example, the following
computes the same number as the System V sum program:
<p>
<XMP>
    while (<>) {
        $checksum += unpack("%16C*", $_);
    }
    $checksum %= 65536;

</XMP>
<p>The following efficiently counts the number of set bits in a bit vector:
<p>
<XMP>
    $setbits = unpack("%32b*", $selectmask);

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_untie_0">
untie VARIABLE</A>

</STRONG>
<DD>

Breaks the binding between a variable and a package.  (See 
<A HREF="perlfunc.html#perlfunc_tie_0">tie()</A>
.)
<p>
<DT><STRONG>

<A NAME="perlfunc_unshift_0">
unshift ARRAY,LIST</A>

</STRONG>
<DD>

Does the opposite of a 
<A HREF="perlfunc.html#perlfunc_shift_0">shift</A>
.  Or the opposite of a 
<A HREF="perlfunc.html#perlfunc_push_0">push</A>
,
depending on how you look at it.  Prepends list to the front of the
array, and returns the new number of elements in the array.
<p>
<XMP>
    unshift(ARGV, '-e') unless $ARGV[0] =~ /^-/;

</XMP>
<p>Note the LIST is prepended whole, not one element at a time, so the
prepended elements stay in the same order.  Use reverse to do the
reverse.
<p>
<DT><STRONG>

<A NAME="perlfunc_use_0">
use Module LIST</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_use_1">
use Module</A>

</STRONG>
<DD>

Imports some semantics into the current package from the named module,
generally by aliasing certain subroutine or variable names into your
package.  It is exactly equivalent to
<p>
<XMP>
    BEGIN { require Module; import Module LIST; }

</XMP>
<p>If you don't want your namespace altered, use require instead.
<p>The BEGIN forces the require and import to happen at compile time.  The
require makes sure the module is loaded into memory if it hasn't been
yet.  The import is not a builtin--it's just an ordinary static method
call into the ``Module'' package to tell the module to import the list of
features back into the current package.  The module can implement its
import method any way it likes, though most modules just choose to
derive their import method via inheritance from the Exporter class that
is defined in the Exporter module.
<p>Because this is a wide-open interface, pragmas (compiler directives)
are also implemented this way.  Currently implemented pragmas are:
<p>
<XMP>
    use integer;
    use sigtrap qw(SEGV BUS);
    use strict  qw(subs vars refs);
    use subs    qw(afunc blurfl);

</XMP>
<p>These pseudomodules import semantics into the current block scope, unlike
ordinary modules, which import symbols into the current package (which are
effective through the end of the file).
<p>There's a corresponding ``no'' command that unimports meanings imported
by use.
<p>
<XMP>
    no integer;
    no strict 'refs';

</XMP>
<p>See the <EM>perlmod</EM>  manpage
 for a list of standard modules and pragmas.
<p>
<DT><STRONG>

<A NAME="perlfunc_utime_0">
utime LIST</A>

</STRONG>
<DD>

Changes the access and modification times on each file of a list of
files.  The first two elements of the list must be the NUMERICAL access
and modification times, in that order.  Returns the number of files
successfully changed.  The inode modification time of each file is set
to the current time.  Example of a ``touch'' command:
<p>
<XMP>
    #!/usr/bin/perl
    $now = time;
    utime $now, $now, @ARGV;

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_values_0">
values ASSOC_ARRAY</A>

</STRONG>
<DD>

Returns a normal array consisting of all the values of the named
associative array.  (In a scalar context, returns the number of
values.)  The values are returned in an apparently random order, but it
is the same order as either the 
<A HREF="perlfunc.html#perlfunc_keys_0">keys()</A>
 or 
<A HREF="perlfunc.html#perlfunc_each_0">each()</A>
 function would produce
on the same array.  See also 
<A HREF="perlfunc.html#perlfunc_keys_0">keys()</A>
 and 
<A HREF="perlfunc.html#perlfunc_each_0">each()</A>
.
<p>
<DT><STRONG>

<A NAME="perlfunc_vec_0">
vec EXPR,OFFSET,BITS</A>

</STRONG>
<DD>

Treats a string as a vector of unsigned integers, and returns the value
of the bitfield specified.  May also be assigned to.  BITS must be a
power of two from 1 to 32.
<p>Vectors created with 
<A HREF="perlfunc.html#perlfunc_vec_0">vec()</A>
 can also be manipulated with the logical
operators |, &amp; and ^, which will assume a bit vector operation is
desired when both operands are strings.
<p>To transform a bit vector into a string or array of 0's and 1's, use these:
<p>
<XMP>
    $bits = unpack("b*", $vector);
    @bits = split(//, unpack("b*", $vector));

</XMP>
<p>If you know the exact length in bits, it can be used in place of the *.
<p>
<DT><STRONG>

<A NAME="perlfunc_wait_0">
wait</A>

</STRONG>
<DD>

Waits for a child process to terminate and returns the pid of the
deceased process, or -1 if there are no child processes.  The status is
returned in $?.
<p>
<DT><STRONG>

<A NAME="perlfunc_waitpid_0">
waitpid PID,FLAGS</A>

</STRONG>
<DD>

Waits for a particular child process to terminate and returns the pid
of the deceased process, or -1 if there is no such child process.  The
status is returned in $?.  If you say
<p>
<XMP>
    use POSIX "wait_h";
    ...
    waitpid(-1,&WNOHANG);

</XMP>
<p>then you can do a non-blocking wait for any process.  Non-blocking wait
is only available on machines supporting either the waitpid(2) or
wait4(2) system calls.  However, waiting for a particular pid with
FLAGS of 0 is implemented everywhere.  (Perl emulates the system call
by remembering the status values of processes that have exited but have
not been harvested by the Perl script yet.)
<p>
<DT><STRONG>

<A NAME="perlfunc_wantarray_0">
wantarray</A>

</STRONG>
<DD>

Returns TRUE if the context of the currently executing subroutine is
looking for a list value.  Returns FALSE if the context is looking
for a scalar.
<p>
<XMP>
    return wantarray ? () : undef;

</XMP>
<p>
<DT><STRONG>

<A NAME="perlfunc_warn_0">
warn LIST</A>

</STRONG>
<DD>

Produces a message on STDERR just like 
<A HREF="perlfunc.html#perlfunc_die_0">die()</A>
, but doesn't exit or
throw an exception.
<p>
<DT><STRONG>

<A NAME="perlfunc_write_0">
write FILEHANDLE</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_write_1">
write EXPR</A>

</STRONG>
<DD>
<p>
<DT><STRONG>

<A NAME="perlfunc_write_1">
write</A>

</STRONG>
<DD>

Writes a formatted record (possibly multi-line) to the specified file,
using the format associated with that file.  By default the format for
a file is the one having the same name is the filehandle, but the
format for the current output channel (see the 
<A HREF="perlfunc.html#perlfunc_select_1">select()</A>
 function) may be set
explicitly by assigning the name of the format to the $~ variable.
<p>Top of form processing is handled automatically:  if there is
insufficient room on the current page for the formatted record, the
page is advanced by writing a form feed, a special top-of-page format
is used to format the new page header, and then the record is written.
By default the top-of-page format is the name of the filehandle with
``_TOP'' appended, but it may be dynamically set to the format of your
choice by assigning the name to the $^ variable while the filehandle is
selected.  The number of lines remaining on the current page is in
variable $-, which can be set to 0 to force a new page.
<p>If FILEHANDLE is unspecified, output goes to the current default output
channel, which starts out as STDOUT but may be changed by the

<A HREF="perlfunc.html#perlfunc_select_1">select</A>
 operator.  If the FILEHANDLE is an EXPR, then the expression
is evaluated and the resulting string is used to look up the name of
the FILEHANDLE at run time.  For more on formats, see the <EM>perlform</EM>  manpage
.
<p>Note that write is <EM>NOT</EM> the opposite of read.  Unfortunately.
<p>
<DT><STRONG>

<A NAME="perlfunc_y_0">
y///</A>

</STRONG>
<DD>

The translation operator.  See 
<A HREF="perlfunc.html#perlfunc_tr_0"><EM>tr///</EM></A>
.
<p>
</DL>
.
<p>
</BODY>
</HTML>
<HR>
Return to:
<UL>
<LI>The <A HREF="index.html">FMTYEWTK index page</a>.
<LI>The <A HREF="/perl/index.html">Perl home page</a>.
</UL>
<HR>
Copyright 1996 <A HREF="mailto:tchrist@perl.com">Tom Christiansen</a>.
<BR>All rights reserved.
