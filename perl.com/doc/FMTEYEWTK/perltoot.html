    <HTML>
    <HEAD>
    <TITLE>perltoot</TITLE>
    </HEAD>
    <BODY>
<!-- INDEX BEGIN -->
<UL>
	<LI><A HREF="#name">NAME</A>
	<LI><A HREF="#description">DESCRIPTION</A>
	<LI><A HREF="#creating_a_class">Creating a Class</A>
	<UL>
		<LI><A HREF="#object_representation">Object Representation</A>
		<LI><A HREF="#class_interface">Class Interface</A>
		<LI><A HREF="#constructors_and_instance_method">Constructors and Instance Methods</A>
		<LI><A HREF="#planning_for_the_future_better_c">Planning for the Future: Better Constructors</A>
		<LI><A HREF="#destructors">Destructors</A>
		<LI><A HREF="#other_object_methods">Other Object Methods</A>
	</UL>
	<LI><A HREF="#class_data">Class Data</A>
	<UL>
		<LI><A HREF="#accessing_class_data">Accessing Class Data</A>
		<LI><A HREF="#debugging_methods">Debugging Methods</A>
		<LI><A HREF="#class_destructors">Class Destructors</A>
		<LI><A HREF="#documenting_the_interface">Documenting the Interface</A>
	</UL>
	<LI><A HREF="#aggregation">Aggregation</A>
	<LI><A HREF="#inheritance">Inheritance</A>
	<UL>
		<LI><A HREF="#overridden_methods">Overridden Methods</A>
		<LI><A HREF="#multiple_inheritance">Multiple Inheritance</A>
		<LI><A HREF="#universal_the_root_of_all_object">UNIVERSAL: The Root of All Objects</A>
	</UL>
	<LI><A HREF="#alternate_object_representations">Alternate Object Representations</A>
	<UL>
		<LI><A HREF="#arrays_as_objects">Arrays as Objects</A>
		<LI><A HREF="#closures_as_objects">Closures as Objects</A>
	</UL>
	<LI><A HREF="#autoload_proxy_methods">AUTOLOAD: Proxy Methods</A>
	<UL>
		<LI><A HREF="#autoloaded_data_methods">Autoloaded Data Methods</A>
		<LI><A HREF="#inherited_autoloaded_data_method">Inherited Autoloaded Data Methods</A>
	</UL>
	<LI><A HREF="#metaclassical_tools">Metaclassical Tools</A>
	<UL>
		<LI><A HREF="#classtemplate">Class::Template</A>
		<LI><A HREF="#data_members_as_variables">Data Members as Variables</A>
		<LI><A HREF="#notes">NOTES</A>
		<LI><A HREF="#object_terminology">Object Terminology</A>
	</UL>
	<LI><A HREF="#see_also">SEE ALSO</A>
	<LI><A HREF="#copyright">COPYRIGHT</A>
	<UL>
		<LI><A HREF="#acknowledgments">Acknowledgments</A>
	</UL>
</UL>
<!-- INDEX END -->
<HR>
<P>
<H1><A NAME="name">NAME</A></H1>
perltoot - Tom's object-oriented tutorial for perl
<P>
<HR>
<H1><A NAME="description">DESCRIPTION</A></H1>
Object-oriented programming is a big seller these days. Some managers would
rather have objects than sliced bread. Why is that? What's so special about
an object? Just what <EM>is</EM>
 an object anyway?
<P>
An object is nothing but a way of tucking away complex behaviours into a
neat little easy-to-use bundle. (This is what professors call abstraction.)
Smart people who have nothing to do but sit around for weeks on end
figuring out really hard problems make these nifty objects that even
regular people can use. (This is what professors call software reuse.)
Users (well, programmers) can play with this little bundle all they want,
but they aren't to open it up and mess with the insides. Just like an
expensive piece of hardware, the contract says that you void the warranty
if you muck with the cover. So don't do that.
<P>
The heart of objects is the class, a protected little private namespace
full of data and functions. A class is a set of related routines that
addresses some problem area. You can think of it as a user-defined type.
The Perl package mechanism, also used for more traditional modules, is used
for class modules as well. Objects ``live'' in a class, meaning that they
belong to some package.
<P>
More often than not, the class provides the user with little bundles. These
bundles are objects. They know whose class they belong to, and how to
behave. Users ask the class to do something, like ``give me an object.'' Or
they can ask one of these objects to do something. Asking a class to do
something for you is calling a <EM>class method</EM>. Asking an object to do something for you is calling an <EM>object method</EM>. Asking either a class (usually) or an object (sometimes) to give you back
an object is calling a <EM>constructor</EM>
, which is just a kind of method.
<P>
That's all well and good, but how is an object different from any other
Perl data type? Just what is an object <EM>really</EM>
; that is, what's its fundamental type? The answer to the first question is
easy. An object is different from any other data type in Perl in one and
only one way: you may dereference it using not merely string or numeric
subscripts as with simple arrays and hashes, but with named subroutine
calls. In a word, with <EM>methods</EM>.
<P>
The answer to the second question is that it's a reference, and not just
any reference, mind you, but one whose referent has been <EM>bless</EM>
()ed into a particular class (read: package). What kind of reference? Well,
the answer to that one is a bit less concrete. That's because in Perl the
designer of the class can employ any sort of reference they'd like as the
underlying intrinsic data type. It could be a scalar, an array, or a hash
reference. It could even be a code reference. But because of its inherent
flexibility, an object is usually a hash reference.
<P>
<HR>
<H1><A NAME="creating_a_class">Creating a Class</A></H1>
Before you create a class, you need to decide what to name it. That's
because the class (package) name governs the name of the file used to house
it, just as with regular modules. Then, that class (package) should provide
one or more ways to generate objects. Finally, it should provide mechanisms
to allow users of its objects to indirectly manipulate these objects from a
distance.
<P>
For example, let's make a simple Person class module. It gets stored in the
file Person.pm. If it were called a Happy::Person class, it would be stored
in the file Happy/Person.pm, and its package would become Happy::Person
instead of just Person. (On a personal computer not running Unix or Plan 9,
but something like MacOS or VMS, the directory separator may be different,
but the principle is the same.) Do not assume any formal relationship
between modules based on their directory names. This is merely a grouping
convenience, and has no effect on inheritance, variable accessibility, or
anything else.
<P>
For this module we aren't going to use Exporter, because we're a
well-behaved class module that doesn't export anything at all. In order to
manufacture objects, a class needs to have a <EM>constructor
method</EM>. A constructor gives you back not just a regular data type, but a
brand-new object in that class. This magic is taken care of by the
<CODE>bless()</CODE> function, whose sole purpose is to enable its referent
to be used as an object. Remember: being an object really means nothing
more than that methods may now be called against it.
<P>
While a constructor may be named anything you'd like, most Perl programmers
seem to like to call theirs <CODE>new().</CODE> However, <CODE>new()</CODE>
is not a reserved word, and a class is under no obligation to supply such.
Some programmers have also been known to use a function with the same name
as the class as the constructor.
<P>
<HR>
<H2><A NAME="object_representation">Object Representation</A></H2>
By far the most common mechanism used in Perl to represent a Pascal record,
a C struct, or a C++ class an anonymous hash. That's because a hash has an
arbitrary number of data fields, each conveniently accessed by an arbitrary
name of your own devising.
<P>
If you were just doing a simple struct-like emulation, you would likely go
about it something like this:
<P>
<PRE>
    $rec = {
        name  =&gt; &quot;Jason&quot;,
        age   =&gt; 23,
        peers =&gt; [ &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot;],
    };
</PRE>
<P>
If you felt like it, you could add a bit of visual distinction by up-casing
the hash keys:
<P>
<PRE>
    $rec = {
        NAME  =&gt; &quot;Jason&quot;,
        AGE   =&gt; 23,
        PEERS =&gt; [ &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot;],
    };
</PRE>
<P>
And so you could get at <CODE>$rec-&gt;{NAME}</CODE> to find ``Jason'', or
<CODE>@{ $rec-&gt;{PEERS} }</CODE> to get at ``Norbert'', ``Rhys'', and ``Phineas''. (Have you ever noticed
how many 23-year-old programmers seem to be named ``Jason'' these days? :-)
<P>
This same model is often used for classes, although it is not considered
the pinnacle of programming propriety for folks from outside the class to
come waltzing into an object, brazenly accessing its data members directly.
Generally speaking, an object should be considered an opaque cookie that
you use <EM>object methods</EM>
 to access. Visually, methods look like you're dereffing a reference using a
function name instead of brackets or braces.
<P>
<HR>
<H2><A NAME="class_interface">Class Interface</A></H2>
Some languages provide a formal syntactic interface to a class's methods,
but Perl does not. It relies on you to read the documentation of each
class. If you try to call an undefined method on an object, Perl won't
complain, but the program will trigger an exception while it's running.
Likewise, if you call a method expecting a prime number as its argument
with a non-prime one instead, you can't expect the compiler to catch this.
(Well, you can expect it all you like, but it's not going to happen.)
<P>
Let's suppose you have a well-educated user of your Person class, someone
who has read the docs that explain the prescribed interface. Here's how
they might use the Person class:
<P>
<PRE>
    use Person;
</PRE>
<P>
<PRE>
    $him = Person-&gt;new();
    $him-&gt;name(&quot;Jason&quot;);
    $him-&gt;age(23);
    $him-&gt;peers( &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot; );
</PRE>
<P>
<PRE>
    push @All_Recs, $him;  # save object in array for later
</PRE>
<P>
<PRE>
    printf &quot;%s is %d years old.\n&quot;, $him-&gt;name, $him-&gt;age;
    print &quot;His peers are: &quot;, join(&quot;, &quot;, $him-&gt;peers), &quot;\n&quot;;
</PRE>
<P>
<PRE>
    printf &quot;Last rec's name is %s\n&quot;, $All_Recs[-1]-&gt;name;
</PRE>
<P>
As you can see, the user of the class doesn't know (or at least, has no
business paying attention to the fact) that the object has one particular
implementation or another. The interface to the class and its objects is
exclusively via methods, and that's all the user of the class should ever
play with.
<P>
<HR>
<H2><A NAME="constructors_and_instance_method">Constructors and Instance Methods</A></H2>
Still, <EM>someone</EM>
 has to know what's in the object. And that someone is the class. It
implements methods that the programmer uses to access the object. Here's
how to implement the Person class using the standard hash-ref-as-an-object
idiom. We'll make a class method called <CODE>new()</CODE> to act as the
constructor, and three object methods called <CODE>name(),</CODE>
<CODE>age(),</CODE> and <CODE>peers()</CODE> to get at per-object data
hidden away in our anonymous hash.
<P>
<PRE>
    package Person;
    use strict;
</PRE>
<P>
<PRE>
    ##################################################
    ## the object constructor (simplistic version)  ##
    ##################################################
    sub new {
        my $self  = {};
        $self-&gt;{NAME}   = undef;
        $self-&gt;{AGE}    = undef;
        $self-&gt;{PEERS}  = [];
        bless($self);           # but see below
        return $self;
    }
</PRE>
<P>
<PRE>
    ##############################################
    ## methods to access per-object data        ##
    ##                                          ##
    ## With args, they set the value.  Without  ##
    ## any, they only retrieve it/them.         ##
    ##############################################
</PRE>
<P>
<PRE>
    sub name {
        my $self = shift;
        if (@_) { $self-&gt;{NAME} = shift }
        return $self-&gt;{NAME};
    }
</PRE>
<P>
<PRE>
    sub age {
        my $self = shift;
        if (@_) { $self-&gt;{AGE} = shift }
        return $self-&gt;{AGE};
    }
</PRE>
<P>
<PRE>
    sub peers {
        my $self = shift;
        if (@_) { @{ $self-&gt;{PEERS} } = @_ }
        return @{ $self-&gt;{PEERS} };
    }
</PRE>
<P>
<PRE>
    1;  # so the require or use succeeds
</PRE>
<P>
We've created three methods to access an object's data,
<CODE>name(),</CODE> <CODE>age(),</CODE> and <CODE>peers().</CODE> These
are all substantially similar. If called with an argument, they set the
appropriate field; otherwise they return the value held by that field,
meaning the value of that hash key.
<P>
<HR>
<H2><A NAME="planning_for_the_future_better_c">Planning for the Future: Better Constructors</A></H2>
Even though at this point you may not even know what it means, someday
you're going to worry about inheritance. (You can safely ignore this for
now and worry about it later if you'd like.) To ensure that this all works
out smoothly, you must use the double-argument form of
<CODE>bless().</CODE> The second argument is the class into which the
referent will be blessed. By not assuming our own class as the default
second argument and instead using the class passed into us, we make our
constructor inheritable.
<P>
While we're at it, let's make our constructor a bit more flexible. Rather
than being uniquely a class method, we'll set it up so that it can be
called as either a class method <EM>or</EM>
 an object method. That way you can say:
<P>
<PRE>
    $me  = Person-&gt;new();
    $him = $me-&gt;new();
</PRE>
<P>
To do this, all we have to do is check whether what was passed in was a
reference or not. If so, we were invoked as an object method, and we need
to extract the package (class) using the <CODE>ref()</CODE> function. If
not, we just use the string passed in as the package name for blessing our
referent.
<P>
<PRE>
    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self  = {};
        $self-&gt;{NAME}   = undef;
        $self-&gt;{AGE}    = undef;
        $self-&gt;{PEERS}  = [];
        bless ($self, $class);
        return $self;
    }
</PRE>
<P>
That's about all there is for constructors. These methods bring objects to
life, returning neat little opaque bundles to the user to be used in
subsequent method calls.
<P>
<HR>
<H2><A NAME="destructors">Destructors</A></H2>
Every story has a beginning and an end. The beginning of the object's story
is its constructor, explicitly called when the object comes into existence.
But the ending of its story is the <EM>destructor</EM>
, a method implicitly called when an object leaves this life. Any
per-object clean-up code is placed in the destructor, which must (in Perl)
be called DESTROY.
<P>
If constructors can have arbitrary names, then why not destructors? Because
while a constructor is explicitly called, a destructor is not. Destruction
happens automatically via Perl's garbage collection (GC) system, which is a
quick but somewhat lazy reference-based GC system. To know what to call,
Perl insists that the destructor be named DESTROY.
<P>
Why is DESTROY in all caps? Perl on occasion uses purely upper-case
function names as a convention to indicate that the function will be
automatically called by Perl in some way. Others that are called implicitly
include BEGIN, END, AUTOLOAD, plus all methods used by tied objects,
described in <EM>perltie</EM>.
<P>
In really good object-oriented programming languages, the user doesn't care
when the destructor is called. It just happens when it's supposed to. In
low-level languages without any GC at all, there's no way to depend on this
happening at the right time, so the programmer must explicitly call the
destructor to clean up memory and state, crossing their fingers that it's
the right time to do so. Unlike C++, an object destructor is nearly never
needed in Perl, and even when it is, explicit invocation is uncalled for.
In the case of our Person class, we don't need a destructor because Perl
takes care of simple matters like memory deallocation.
<P>
The only situation where Perl's reference-based GC won't work is when
there's a circularity in the data structure, such as:
<P>
<PRE>
    $this-&gt;{WHATEVER} = $this;
</PRE>
<P>
In that case, you must delete the self-reference manually if you expect
your program not to leak memory. While admittedly error-prone, this is the
best we can do right now. Nonetheless, rest assured that when your program
is finished, its objects' destructors are all duly called. So you are
guaranteed that an object <EM>eventually</EM>
 gets properly destroyed, except in the unique case of a program that never
exits. (If you're running Perl embedded in another application, this full
GC pass happens a bit more frequently--whenever a thread shuts down.)
<P>
<HR>
<H2><A NAME="other_object_methods">Other Object Methods</A></H2>
The methods we've talked about so far have either been constructors or else
simple ``data methods'', interfaces to data stored in the object. These are
a bit like an object's data members in the C++ world, except that strangers
don't access them as data. Instead, they should only access the object's
data indirectly via its methods. This is an important rule: in Perl, access
to an object's data should <EM>only</EM>
be made through methods.
<P>
Perl doesn't impose restrictions on who gets to use which methods. The
public-versus-private distinction is by convention, not syntax. (Well,
unless you use the Alias module described below in 
<A HREF="#data_members_as_variables">Data Members as Variables</A>.) Occasionally you'll see method names beginning or ending with an
underscore or two. This marking is a convention indicating that the methods
are private to that class alone and sometimes to its closest acquaintances,
its immediate subclasses. But this distinction is not enforced by Perl
itself. It's up to the programmer to behave.
<P>
There's no reason to limit methods to those that simply access data.
Methods can do anything at all. The key point is that they're invoked
against an object or a class. Let's say we'd like object methods that do
more than fetch or set one particular field.
<P>
<PRE>
    sub exclaim {
        my $self = shift;
        return sprintf &quot;Hi, I'm %s, age %d, working with %s&quot;,
            $self-&gt;{NAME}, $self-&gt;{AGE}, join(&quot;, &quot;, $self-&gt;{PEERS});
    }
</PRE>
<P>
Or maybe even one like this:
<P>
<PRE>
    sub happy_birthday {
        my $self = shift;
        return ++$self-&gt;{AGE};
    }
</PRE>
<P>
Some might argue that one should go at these this way:
<P>
<PRE>
    sub exclaim {
        my $self = shift;
        return sprintf &quot;Hi, I'm %s, age %d, working with %s&quot;,
            $self-&gt;name, $self-&gt;age, join(&quot;, &quot;, $self-&gt;peers);
    }
</PRE>
<P>
<PRE>
    sub happy_birthday {
        my $self = shift;
        return $self-&gt;age( $self-&gt;age() + 1 );
    }
</PRE>
<P>
But since these methods are all executing in the class itself, this may not
be critical. There are trade-offs to be made. Using direct hash access is
faster (about an order of magnitude faster, in fact), and it's more
convenient when you want to interpolate in strings. But using methods (the
external interface) internally shields not just the users of your class but
even you yourself from changes in your data representation.
<P>
<HR>
<H1><A NAME="class_data">Class Data</A></H1>
What about ``class data'', data items common to each object in a class?
What would you want that for? Well, in your Person class, you might like to
keep track of the total people alive. How do you implement that?
<P>
You <EM>could</EM>
 make it a global variable called $Person::Census. But about only reason
you'd do that would be if you <EM>wanted</EM>
 people to be able to get at your class data directly. They could just say
$Person::Census and play around with it. Maybe this is ok in your design
scheme. You might even conceivably want to make it an exported variable. To
be exportable, a variable must be a (package) global. If this were a
traditional module rather than an object-oriented one, you might do that.
<P>
While this approach is expected in most traditional modules, it's generally
considered rather poor form in most object modules. In an object module,
you should set up a protective veil to separate interface from
implementation. So provide a class method to access class data just as you
provide object methods to access object data.
<P>
So, you <EM>could</EM>
 still keep <CODE>$Census</CODE> as a package global and rely upon others to
honor the contract of the module and therefore not play around with its
implementation. You could even be supertricky and make <CODE>$Census</CODE>
a tied object as described in <EM>perltie</EM>
, thereby intercepting all accesses.
<P>
But more often than not, you just want to make your class data a
file-scoped lexical. To do so, simply put this at the top of the file:
<P>
<PRE>
    my $Census = 0;
</PRE>
<P>
Even though the scope of a <CODE>my()</CODE> normally expires when the
block in which it was declared is done (in this case the whole file being
required or used), Perl's deep binding of lexical variables guarantees that
the variable will not be deallocated, remaining accessible to functions
declared within that scope. This doesn't work with global variables given
temporary values via <CODE>local(),</CODE> though.
<P>
Irrespective of whether you leave <CODE>$Census</CODE> a package global or
make it instead a file-scoped lexical, you should make these changes to
your <CODE>Person::new()</CODE> constructor:
<P>
<PRE>
    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self  = {};
        $Census++;
        $self-&gt;{NAME}   = undef;
        $self-&gt;{AGE}    = undef;
        $self-&gt;{PEERS}  = [];
        bless ($self, $class);
        return $self;
    }
</PRE>
<P>
<PRE>
    sub population {
        return $Census;
    }
</PRE>
<P>
Now that we've done this, we certainly do need a destructor so that when
Person is destroyed, the <CODE>$Census</CODE> goes down. Here's how this
could be done:
<P>
<PRE>
    sub DESTROY { --$Census }
</PRE>
<P>
Notice how there's no memory to deallocate in the destructor? That's
something that Perl takes care of for you all by itself.
<P>
<HR>
<H2><A NAME="accessing_class_data">Accessing Class Data</A></H2>
It turns out that this is not really a good way to go about handling class
data. A good scalable rule is that <EM>you must never reference class
data directly from an object method</EM>. Otherwise you aren't building a scalable, inheritable class. The object
must be the rendezvous point for all operations, especially from an object
method. The globals (class data) would in some sense be in the ``wrong''
package in your derived classes. In Perl, methods execute in the context of
the class they were defined in, <EM>not</EM>
 that of the object that triggered them. Therefore, namespace visibility of
package globals in methods is unrelated to inheritance.
<P>
Got that? Maybe not. Ok, let's say that some other class ``borrowed''
(well, inherited) the DESTROY method as it was defined above. When those
objects are destroyed, the original <CODE>$Census</CODE> variable will be
altered, not the one in the new class's package namespace. Perhaps this is
what you want, but probably it isn't.
<P>
Here's how to fix this. We'll store a reference to the data in the value
accessed by the hash key ``_CENSUS''. Why the underscore? Well, mostly
because an initial underscore already conveys strong feelings of
magicalness to a C programmer. It's really just a mnemonic device to remind
ourselves that this field is special and not to be used as a public data
member in the same way that NAME, AGE, and PEERS are. (Because we've been
developing this code under the strict pragma, prior to perl version 5.004
we'll have to quote the field name.)
<P>
<PRE>
    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self  = {};
        $self-&gt;{NAME}     = undef;
        $self-&gt;{AGE}      = undef;
        $self-&gt;{PEERS}    = [];
        # &quot;private&quot; data
        $self-&gt;{&quot;_CENSUS&quot;} = \$Census;
        bless ($self, $class);
        ++ ${ $self-&gt;{&quot;_CENSUS&quot;} };
        return $self;
    }
</PRE>
<P>
<PRE>
    sub population {
        my $self = shift;
        if (ref $self) {
            return ${ $self-&gt;{&quot;_CENSUS&quot;} };
        } else {
            return $Census;
        }
    }
</PRE>
<P>
<PRE>
    sub DESTROY {
        my $self = shift;
        -- ${ $self-&gt;{&quot;_CENSUS&quot;} };
    }
</PRE>
<P>
<HR>
<H2><A NAME="debugging_methods">Debugging Methods</A></H2>
It's common for a class to have a debugging mechanism. For example, you
might want to see when objects are created or destroyed. To do that, add a
debugging variable as a file-scoped lexical. For this, we'll pull in the
standard Carp module to emit our warnings and fatal messages. That way
messages will come out with the caller's filename and line number instead
of our own; if we wanted them to be from our own perspective, we'd just use
<CODE>die()</CODE> and <CODE>warn()</CODE> directly instead of
<CODE>croak()</CODE> and <CODE>carp()</CODE> respectively.
<P>
<PRE>
    use Carp;
    my $Debugging = 0;
</PRE>
<P>
Now add a new class method to access the variable.
<P>
<PRE>
    sub debug {
        my $class = shift;
        if (ref $class)  { confess &quot;Class method called as object method&quot; }
        unless (@_ == 1) { confess &quot;usage: CLASSNAME-&gt;debug(level)&quot; }
        $Debugging = shift;
    }
</PRE>
<P>
Now fix up DESTROY to murmur a bit as the moribund object expires:
<P>
<PRE>
    sub DESTROY {
        my $self = shift;
        if ($Debugging) { carp &quot;Destroying $self &quot; . $self-&gt;name }
        -- ${ $self-&gt;{&quot;_CENSUS&quot;} };
    }
</PRE>
<P>
One could conceivably make a per-object debug state. That way you could
call both of these:
<P>
<PRE>
    Person-&gt;debug(1);   # entire class
    $him-&gt;debug(1);     # just this object
</PRE>
<P>
To do so, we need our debugging method to be a ``bimodal'' one, one that
works on both classes <EM>and</EM>
 objects. Therefore, adjust the <CODE>debug()</CODE> and DESTROY methods as
follows:
<P>
<PRE>
    sub debug {
        my $self = shift;
        confess &quot;usage: thing-&gt;debug(level)&quot;    unless @_ == 1;
        my $level = shift;
        if (ref($self))  {
            $self-&gt;{&quot;_DEBUG&quot;} = $level;		# just myself
        } else {
            $Debugging        = $level;         # whole class
        }
    }
</PRE>
<P>
<PRE>
    sub DESTROY {
        my $self = shift;
        if ($Debugging || $self-&gt;{&quot;_DEBUG&quot;}) {
            carp &quot;Destroying $self &quot; . $self-&gt;name;
        }
        -- ${ $self-&gt;{&quot;_CENSUS&quot;} };
    }
</PRE>
<P>
What happens if a derived class (which we'll call Employee) inherits
methods from this Person base class? Then <CODE>Employee-&gt;debug()</CODE>, when called as a class method, manipulates $Person::Debugging not
$Employee::Debugging.
<P>
<HR>
<H2><A NAME="class_destructors">Class Destructors</A></H2>
The object destructor handles the death of each distinct object. But
sometimes you want a bit of cleanup when the entire class is shut down,
which currently only happens when the program exits. To make such a
<EM>class destructor</EM>
, create a function in that class's package named END. This works just like
the END function in traditional modules, meaning that it gets called
whenever your program exits unless it execs or dies of an uncaught signal.
For example,
<P>
<PRE>
    sub END {
        if ($Debugging) {
            print &quot;All persons are going away now.\n&quot;;
        }
    }
</PRE>
<P>
When the program exits, all the class destructors (END functions) are be
called in the opposite order that they were loaded in (LIFO order).
<P>
<HR>
<H2><A NAME="documenting_the_interface">Documenting the Interface</A></H2>
And there you have it: we've just shown you the <EM>implementation</EM>
 of this Person class. Its <EM>interface</EM>
 would be its documentation. Usually this means putting it in pod (``plain
old documentation'') format right there in the same file. In our Person
example, we would place the following docs anywhere in the Person.pm file.
Even though it looks mostly like code, it's not. It's embedded
documentation such as would be used by the pod2man, pod2html, or pod2text
programs. The Perl compiler ignores pods entirely, just as the translators
ignore code. Here's an example of some pods describing the informal
interface:
<P>
<PRE>
=head1 NAME
    Person - class to implement people

=head1 SYNOPSIS

     use Person;

     #################
     # class methods #
     #################
     $ob    = Person-&gt;new;
     $count = Person-&gt;population;

     #######################
     # object data methods #
     #######################

     ### get versions ###
         $who   = $ob-&gt;name;
         $years = $ob-&gt;age;
         @pals  = $ob-&gt;peers;

     ### set versions ###
         $ob-&gt;name(&quot;Jason&quot;);
         $ob-&gt;age(23);
         $ob-&gt;peers( &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot; );

     ########################
     # other object methods #
     ########################

     $phrase = $ob-&gt;exclaim;
     $ob-&gt;happy_birthday;

=head1 DESCRIPTION

    The Person class implements dah dee dah dee dah....

</PRE>
<P>
That's all there is to the matter of interface versus implementation. A
programmer who opens up the module and plays around with all the private
little shiny bits that were safely locked up behind the interface contract
has voided the warranty, and you shouldn't worry about their fate.
<P>
<HR>
<H1><A NAME="aggregation">Aggregation</A></H1>
Suppose you later want to change the class to implement better names.
Perhaps you'd like to support both given names (called Christian names,
irrespective of one's religion) and family names (called surnames), plus
nicknames and titles. If users of your Person class have been properly
accessing it through its documented interface, then you can easily change
the underlying implementation. If they haven't, then they lose and it's
their fault for breaking the contract and voiding their warranty.
<P>
To do this, we'll make another class, this one called Fullname. What's the
Fullname class look like? To answer that question, you have to first figure
out how you want to use it. How about we use it this way:
<P>
<PRE>
    $him = Person-&gt;new();
    $him-&gt;fullname-&gt;title(&quot;St&quot;);
    $him-&gt;fullname-&gt;christian(&quot;Thomas&quot;);
    $him-&gt;fullname-&gt;surname(&quot;Aquinas&quot;);
    $him-&gt;fullname-&gt;nickname(&quot;Tommy&quot;);
    printf &quot;His normal name is %s\n&quot;, $him-&gt;name;
    printf &quot;But his real name is %s\n&quot;, $him-&gt;fullname-&gt;as_string;
</PRE>
<P>
Ok. To do this, we'll change <CODE>Person::new()</CODE> so that it supports a full name
field this way:
<P>
<PRE>
    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self  = {};
        $self-&gt;{FULLNAME} = Fullname-&gt;new();
        $self-&gt;{AGE}      = undef;
        $self-&gt;{PEERS}    = [];
        $self-&gt;{&quot;_CENSUS&quot;} = \$Census;
        bless ($self, $class);
        ++ ${ $self-&gt;{&quot;_CENSUS&quot;} };
        return $self;
    }
</PRE>
<P>
<PRE>
    sub fullname {
        my $self = shift;
        return $self-&gt;{FULLNAME};
    }
</PRE>
<P>
Then to support old code, define <CODE>Person::name()</CODE> this way:
<P>
<PRE>
    sub name {
        my $self = shift;
        return $self-&gt;{FULLNAME}-&gt;nickname(@_)
          ||   $self-&gt;{FULLNAME}-&gt;christian(@_);
    }
</PRE>
<P>
Here's the Fullname class. We'll use the same technique of using a hash
reference to hold data fields, and methods by the appropriate name to
access them:
<P>
<PRE>
    package Fullname;
    use strict;
</PRE>
<P>
<PRE>
    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self  = {
            TITLE       =&gt; undef,
            CHRISTIAN   =&gt; undef,
            SURNAME     =&gt; undef,
            NICK        =&gt; undef,
        };
        bless ($self, $class);
        return $self;
    }
</PRE>
<P>
<PRE>
    sub christian {
        my $self = shift;
        if (@_) { $self-&gt;{CHRISTIAN} = shift }
        return $self-&gt;{CHRISTIAN};
    }
</PRE>
<P>
<PRE>
    sub surname {
        my $self = shift;
        if (@_) { $self-&gt;{SURNAME} = shift }
        return $self-&gt;{SURNAME};
    }
</PRE>
<P>
<PRE>
    sub nickname {
        my $self = shift;
        if (@_) { $self-&gt;{NICK} = shift }
        return $self-&gt;{NICK};
    }
</PRE>
<P>
<PRE>
    sub title {
        my $self = shift;
        if (@_) { $self-&gt;{TITLE} = shift }
        return $self-&gt;{TITLE};
    }
</PRE>
<P>
<PRE>
    sub as_string {
        my $self = shift;
        my $name = join(&quot; &quot;, @$self{'CHRISTIAN', 'SURNAME'});
        if ($self-&gt;{TITLE}) {
            $name = $self-&gt;{TITLE} . &quot; &quot; . $name;
        }
        return $name;
    }
</PRE>
<P>
<PRE>
    1;
</PRE>
<P>
Finally, here's the test program:
<P>
<PRE>
    #!/usr/bin/perl -w
    use strict;
    use Person;
    sub END { show_census() }
</PRE>
<P>
<PRE>
    sub show_census ()  {
        printf &quot;Current population: %d\n&quot;, Person-&gt;population;
    }
</PRE>
<P>
<PRE>
    Person-&gt;debug(1);
</PRE>
<P>
<PRE>
    show_census();
</PRE>
<P>
<PRE>
    my $him = Person-&gt;new();
</PRE>
<P>
<PRE>
    $him-&gt;fullname-&gt;christian(&quot;Thomas&quot;);
    $him-&gt;fullname-&gt;surname(&quot;Aquinas&quot;);
    $him-&gt;fullname-&gt;nickname(&quot;Tommy&quot;);
    $him-&gt;fullname-&gt;title(&quot;St&quot;);
    $him-&gt;age(1);
</PRE>
<P>
<PRE>
    printf &quot;%s is really %s.\n&quot;, $him-&gt;name, $him-&gt;fullname;
    printf &quot;%s's age: %d.\n&quot;, $him-&gt;name, $him-&gt;age;
    $him-&gt;happy_birthday;
    printf &quot;%s's age: %d.\n&quot;, $him-&gt;name, $him-&gt;age;
</PRE>
<P>
<PRE>
    show_census();
</PRE>
<P>
<HR>
<H1><A NAME="inheritance">Inheritance</A></H1>
Object-oriented programming systems all support some notion of inheritance.
Inheritance means allowing one class to piggy-back on top of another one so
you don't have to write the same code again and again. It's about software
reuse, and therefore related to Laziness, the principal virtue of a
programmer. (The import/export mechanisms in traditional modules are also a
form of code reuse, but a simpler one than the true inheritance that you
find in object modules.)
<P>
Sometimes the syntax of inheritance is built into the core of the language,
and sometimes it's not. Perl has no special syntax for specifying the class
(or classes) to inherit from. Instead, it's all strictly in the semantics.
Each package can have a variable called <CODE>@ISA</CODE>, which governs (method)
inheritance. If you try to call a method on an object or class, and that
method is not found in that object's package, Perl then looks to
<CODE>@ISA</CODE> for other packages to go looking through in search of the
missing method.
<P>
Like the special per-package variables recognized by Exporter (such as
<CODE>@EXPORT</CODE>, <CODE>@EXPORT_OK</CODE>, <CODE>@EXPORT_FAIL</CODE>, <CODE>%EXPORT_TAGS</CODE>, and <CODE>$VERSION</CODE>), the
<CODE>@ISA</CODE> array <EM>must</EM>
 be a package-scoped global and not a file-scoped lexical created via
<CODE>my().</CODE> Most classes have just one item in their
<CODE>@ISA</CODE> array. In this case, we have what's called ``single
inheritance'', or SI for short.
<P>
Consider this class:
<P>
<PRE>
    package Employee;
    use Person;
    @ISA = (&quot;Person&quot;);
    1;
</PRE>
<P>
Not a lot to it, eh? All it's doing so far is loading in another class and
stating that this one will inherit methods from that other class if need
be. We have given it none of its own methods. We rely upon an Employee to
behave just like a Person.
<P>
Setting up an empty class like this is called the ``empty subclass test'';
that is, making a derived class that does nothing but inherit from a base
class. If the original base class has been designed properly, then the new
derived class can be used as a drop-in replacement for the old one. This
means you should be able to write a program like this:
<P>
<PRE>
    use Employee
    my $empl = Employee-&gt;new();
    $empl-&gt;name(&quot;Jason&quot;);
    $empl-&gt;age(23);
    printf &quot;%s is age %d.\n&quot;, $empl-&gt;name, $empl-&gt;age;
</PRE>
<P>
By proper design, we mean always using the two-argument form of
<CODE>bless(),</CODE> avoiding direct access of global data, and not
exporting anything. If you look back at the <CODE>Person::new()</CODE> function we
defined above, we were careful to do that. There's a bit of package data
used in the constructor, but the reference to this is stored on the object
itself and all other methods access package data via that reference, so we
should be ok.
<P>
What do we mean by the <CODE>Person::new()</CODE> function -- isn't that actually a
method? Well, in principle, yes. A method is just a function that expects
as its first argument a class name (package) or object (blessed reference).
<CODE>Person::new()</CODE> is the function that both the
<CODE>Person-&gt;new()</CODE> method and the <CODE>Employee-&gt;new()</CODE> method end up calling. Understand that while a method call looks a lot like
a function call, they aren't really quite the same, and if you treat them
as the same, you'll very soon be left with nothing but broken programs.
First, the actual underlying calling conventions are different: method
calls get an extra argument. Second, function calls don't do inheritance,
but methods do.
<P>
<PRE>
        Method Call             Resulting Function Call
        -----------             ------------------------
        Person-&gt;new()           Person::new(&quot;Person&quot;)
        Employee-&gt;new()         Person::new(&quot;Employee&quot;)
</PRE>
<P>
So don't use function calls when you mean to call a method.
<P>
If an employee is just a Person, that's not all too very interesting. So
let's add some other methods. We'll give our employee data fields to access
their salary, their employee ID, and their start date.
<P>
If you're getting a little tired of creating all these nearly identical
methods just to get at the object's data, do not despair. Later, we'll
describe several different convenience mechanisms for shortening this up.
Meanwhile, here's the straight-forward way:
<P>
<PRE>
    sub salary {
        my $self = shift;
        if (@_) { $self-&gt;{SALARY} = shift }
        return $self-&gt;{SALARY};
    }
</PRE>
<P>
<PRE>
    sub id_number {
        my $self = shift;
        if (@_) { $self-&gt;{ID} = shift }
        return $self-&gt;{ID};
    }
</PRE>
<P>
<PRE>
    sub start_date {
        my $self = shift;
        if (@_) { $self-&gt;{START_DATE} = shift }
        return $self-&gt;{START_DATE};
    }
</PRE>
<P>
<HR>
<H2><A NAME="overridden_methods">Overridden Methods</A></H2>
What happens when both a derived class and its base class have the same
method defined? Well, then you get the derived class's version of that
method. For example, let's say that we want the <CODE>peers()</CODE> method
called on an employee to act a bit differently. Instead of just returning
the list of peer names, let's return slightly different strings. So doing
this:
<P>
<PRE>
    $empl-&gt;peers(&quot;Peter&quot;, &quot;Paul&quot;, &quot;Mary&quot;);
    printf &quot;His peers are: %s\n&quot;, join(&quot;, &quot;, $empl-&gt;peers);
</PRE>
<P>
will produce:
<P>
<PRE>
    His peers are: PEON=PETER, PEON=PAUL, PEON=MARY
</PRE>
<P>
To do this, merely add this definition into the Employee.pm file:
<P>
<PRE>
    sub peers {
        my $self = shift;
        if (@_) { @{ $self-&gt;{PEERS} } = @_ }
        return map { &quot;PEON=\U$_&quot; } @{ $self-&gt;{PEERS} };
    }
</PRE>
<P>
There, we've just demonstrated the high-falutin' concept known in certain
circles as <EM>polymorphism</EM>. We've taken on the form and behaviour of an existing object, and then
we've altered it to suit our own purposes. This is a form of Laziness.
(Getting polymorphed is also what happens when the wizard decides you'd
look better as a frog.)
<P>
Every now and then you'll want to have a method call trigger both its
derived class (also know as ``subclass'') version as well as its base class
(also known as ``superclass'') version. In practice, constructors and
destructors are likely to want to do this, and it probably also makes sense
in the <CODE>debug()</CODE> method we showed previously.
<P>
To do this, add this to Employee.pm:
<P>
<PRE>
    use Carp;
    my $Debugging = 0;
</PRE>
<P>
<PRE>
    sub debug {
        my $self = shift;
        confess &quot;usage: thing-&gt;debug(level)&quot;    unless @_ == 1;
        my $level = shift;
        if (ref($self))  {
            $self-&gt;{&quot;_DEBUG&quot;} = $level;
        } else {
            $Debugging = $level;            # whole class
        }
        Person::debug($self, $Debugging);   # don't really do this
    }
</PRE>
<P>
As you see, we turn around and call the Person package's
<CODE>debug()</CODE> function. But this is far too fragile for good design.
What if Person doesn't have a <CODE>debug()</CODE> function, but is
inheriting <EM>its</EM>
 <CODE>debug()</CODE> method from elsewhere? It would have been slightly
better to say
<P>
<PRE>
    Person-&gt;debug($Debugging);
</PRE>
<P>
But even that's got too much hard-coded. It's somewhat better to say
<P>
<PRE>
    $self-&gt;Person::debug($Debugging);
</PRE>
<P>
Which is a funny way to say to start looking for a <CODE>debug()</CODE>
method up in Person. This strategy is more often seen on overridden object
methods than on overridden class methods.
<P>
There is still something a bit off here. We've hard-coded our superclass's
name. This in particular is bad if you change which classes you inherit
from, or add others. Fortunately, the pseudoclass SUPER comes to the rescue
here.
<P>
<PRE>
    $self-&gt;SUPER::debug($Debugging);
</PRE>
<P>
This way it starts looking in my class's @ISA. This only makes sense from <EM>within</EM>
 a method call, though. Don't try to access anything in SUPER:: from
anywhere else, because it doesn't exist outside an overridden method call.
<P>
Things are getting a bit complicated here. Have we done anything we
shouldn't? As before, one way to test whether we're designing a decent
class is via the empty subclass test. Since we already have an Employee
class that we're trying to check, we'd better get a new empty subclass that
can derive from Employee. Here's one:
<P>
<PRE>
    package Boss;
    use Employee;        # :-)
    @ISA = qw(Employee);
</PRE>
<P>
And here's the test program:
<P>
<PRE>
    #!/usr/bin/perl -w
    use strict;
    use Boss;
    Boss-&gt;debug(1);
</PRE>
<P>
<PRE>
    my $boss = Boss-&gt;new();
</PRE>
<P>
<PRE>
    $boss-&gt;fullname-&gt;title(&quot;Don&quot;);
    $boss-&gt;fullname-&gt;surname(&quot;Pichon Alvarez&quot;);
    $boss-&gt;fullname-&gt;christian(&quot;Federico Jesus&quot;);
    $boss-&gt;fullname-&gt;nickname(&quot;Fred&quot;);
</PRE>
<P>
<PRE>
    $boss-&gt;age(47);
    $boss-&gt;peers(&quot;Frank&quot;, &quot;Felipe&quot;, &quot;Faust&quot;);
</PRE>
<P>
<PRE>
    printf &quot;%s is age %d.\n&quot;, $boss-&gt;fullname, $boss-&gt;age;
    printf &quot;His peers are: %s\n&quot;, join(&quot;, &quot;, $boss-&gt;peers);
</PRE>
<P>
Running it, we see that we're still ok. If you'd like to dump out your
object in a nice format, somewhat like the way the 'x' command works in the
debugger, you could use the Data::Dumper module from CPAN this way:
<P>
<PRE>
    use Data::Dumper;
    print &quot;Here's the boss:\n&quot;;
    print Dumper($boss);
</PRE>
<P>
Which shows us something like this:
<P>
<PRE>
    Here's the boss:
    $VAR1 = bless( {
	 _CENSUS =&gt; \1,
	 FULLNAME =&gt; bless( {
			      TITLE =&gt; 'Don',
			      SURNAME =&gt; 'Pichon Alvarez',
			      NICK =&gt; 'Fred',
			      CHRISTIAN =&gt; 'Federico Jesus'
			    }, 'Fullname' ),
	 AGE =&gt; 47,
	 PEERS =&gt; [
		    'Frank',
		    'Felipe',
		    'Faust'
		  ]
       }, 'Boss' );
</PRE>
<P>
Hm.... something's missing there. What about the salary, start date, and ID
fields? Well, we never set them to anything, even undef, so they don't show
up in the hash's keys. The Employee class has no <CODE>new()</CODE> method
of its own, and the <CODE>new()</CODE> method in Person doesn't know about
Employees. (Nor should it: proper OO design dictates that a subclass be
allowed to know about its immediate superclass, but never vice-versa.) So
let's fix up <CODE>Employee::new()</CODE> this way:
<P>
<PRE>
    sub new {
        my $proto = shift;
        my $class = ref($proto) || $proto;
        my $self  = $class-&gt;SUPER::new();
        $self-&gt;{SALARY}        = undef;
        $self-&gt;{ID}            = undef;
        $self-&gt;{START_DATE}    = undef;
        bless ($self, $class);          # reconsecrate
        return $self;
    }
</PRE>
<P>
Now if you dump out an Employee or Boss object, you'll find that new fields
show up there now.
<P>
<HR>
<H2><A NAME="multiple_inheritance">Multiple Inheritance</A></H2>
Ok, at the risk of confusing beginners and annoying OO gurus, it's time to
confess that Perl's object system includes that controversial notion known
as multiple inheritance, or MI for short. All this means is that rather
than having just one parent class who in turn might itself have a parent
class, etc., that you can directly inherit from two or more parents. It's
true that some uses of MI can get you into trouble, although hopefully not
quite so much trouble with Perl as with dubiously-OO languages like C++.
<P>
The way it works is actually pretty simple: just put more than one package
name in your <CODE>@ISA</CODE> array. When it comes time for Perl to go
finding methods for your object, it looks at each of these packages in
order. Well, kinda. It's actually a fully recursive, depth-first order.
Consider a bunch of <CODE>@ISA</CODE> arrays like this:
<P>
<PRE>
    @First::ISA    = qw( Alpha );
    @Second::ISA   = qw( Beta );
    @Third::ISA    = qw( First Second );
</PRE>
<P>
If you have an object of class Third:
<P>
<PRE>
    my $ob = Third-&gt;new();
    $ob-&gt;spin();
</PRE>
<P>
How do we find a <CODE>spin()</CODE> method (or a <CODE>new()</CODE> method
for that matter)? Because the search is depth-first, classes will be looked
up in the following order: Third, First, Alpha, Second, and Beta.
<P>
In practice, few class modules have been seen that actually make use of MI.
One nearly always chooses simple containership of one class within another
over MI. That's why our Person object <EM>contained</EM>
 a Fullname object. That doesn't mean it <EM>was</EM>
 one.
<P>
However, there is one particular area where MI in Perl is rampant:
borrowing another class's class methods. This is rather common, especially
with some bundled ``objectless'' classes, like Exporter, DynaLoader,
AutoLoader, and SelfLoader. These classes do not provide constructors; they
exist only so you may inherit their class methods. (It's not entirely clear
why inheritance was done here rather than traditional module importation.)
<P>
For example, here is the POSIX module's @ISA:
<P>
<PRE>
    package POSIX;
    @ISA = qw(Exporter DynaLoader);
</PRE>
<P>
The POSIX module isn't really an object module, but then, neither are
Exporter or DynaLoader. They're just lending their classes' behaviours to
POSIX.
<P>
Why don't people use MI for object methods much? One reason is that it can
have complicated side-effects. For one thing, your inheritance graph (no
longer a tree) might converge back to the same base class. Although Perl
guards against recursive inheritance, merely having parents who are related
to each other via a common ancestor, incestuous though it sounds, is not
forbidden. What if in our Third class shown above we wanted its
<CODE>new()</CODE> method to also call both overridden constructors in its
two parent classes? The SUPER notation would only find the first one. Also,
what about if the Alpha and Beta classes both had a common ancestor, like
Nought? If you kept climbing up the inheritance tree calling overridden
methods, you'd end up calling <CODE>Nought::new()</CODE> twice, which might well be a
bad idea.
<P>
<HR>
<H2><A NAME="universal_the_root_of_all_object">UNIVERSAL: The Root of All Objects</A></H2>
Wouldn't it be convenient if all objects were rooted at some ultimate base
class? That way you could give every object common methods without having
to go and add it to each and every @ISA. Well, it turns out that you can.
You don't see it, but Perl tacitly and irrevocably assumes that there's an
extra element at the end of @ISA: the class UNIVERSAL. In version 5.003,
there were no predefined methods there, but you could put whatever you felt
like into it.
<P>
However, as of version 5.004 (or some subversive releases, like 5.003_08),
UNIVERSAL has some methods in it already. These are built-in to your Perl
binary, so they don't take any extra time to load. Predefined methods
include <CODE>isa(),</CODE> <CODE>can(),</CODE> and <CODE>VERSION().</CODE>
<CODE>isa()</CODE> tells you whether an object or class ``is'' another one
without having to traverse the hierarchy yourself:
<P>
<PRE>
   $has_io = $fd-&gt;isa(&quot;IO::Handle&quot;);
   $itza_handle = IO::Socket-&gt;isa(&quot;IO::Handle&quot;);
</PRE>
<P>
The <CODE>can()</CODE> method, called against that object or class, reports
back whether its string argument is a callable method name in that class.
In fact, it gives you back a function reference to that method:
<P>
<PRE>
   $his_print_method = $obj-&gt;can('as_string');
</PRE>
<P>
Finally, the VERSION method checks whether the class (or the object's
class) has a package global called <CODE>$VERSION</CODE> that's high
enough, as in:
<P>
<PRE>
    Some_Module-&gt;VERSION(3.0);
    $his_vers = $ob-&gt;VERSION();
</PRE>
<P>
However, we don't usually call VERSION ourselves. (Remember that an all
upper-case function name is a Perl convention that indicates that the
function will be automatically used by Perl in some way.) In this case, it
happens when you say
<P>
<PRE>
    use Some_Module 3.0;
</PRE>
<P>
If you wanted to add version checking to your Person class explained above,
just add this to Person.pm:
<P>
<PRE>
    use vars qw($VERSION);
    $VERSION = '1.1';
</PRE>
<P>
and then in Employee.pm could you can say
<P>
<PRE>
    use Employee 1.1;
</PRE>
<P>
And it would make sure that you have at least that version number or higher
available. This is not the same as loading in that exact version number. No
mechanism currently exists for concurrent installation of multiple versions
of a module. Lamentably.
<P>
<HR>
<H1><A NAME="alternate_object_representations">Alternate Object Representations</A></H1>
Nothing requires objects to be implemented as hash references. An object
can be any sort of reference so long as its referent has been suitably
blessed. That means scalar, array, and code references are also fair game.
<P>
A scalar would work if the object has only one datum to hold. An array
would work for most cases, but makes inheritance a bit dodgy because you
have to invent new indices for the derived classes.
<P>
<HR>
<H2><A NAME="arrays_as_objects">Arrays as Objects</A></H2>
If the user of your class honors the contract and sticks to the advertised
interface, then you can change its underlying interface if you feel like
it. Here's another implementation that conforms to the same interface
specification. This time we'll use an array reference instead of a hash
reference to represent the object.
<P>
<PRE>
    package Person;
    use strict;
</PRE>
<P>
<PRE>
    my($NAME, $AGE, $PEERS) = ( 0 .. 2 );
</PRE>
<P>
<PRE>
    ############################################
    ## the object constructor (array version) ##
    ############################################
    sub new {
        my $self = [];
        $self-&gt;[$NAME]   = undef;  # this is unnecessary
        $self-&gt;[$AGE]    = undef;  # as it this
        $self-&gt;[$PEERS]  = [];     # but this isn't, really
        bless($self);
        return $self;
    }
</PRE>
<P>
<PRE>
    sub name {
        my $self = shift;
        if (@_) { $self-&gt;[$NAME] = shift }
        return $self-&gt;[$NAME];
    }
</PRE>
<P>
<PRE>
    sub age {
        my $self = shift;
        if (@_) { $self-&gt;[$AGE] = shift }
        return $self-&gt;[$AGE];
    }
</PRE>
<P>
<PRE>
    sub peers {
        my $self = shift;
        if (@_) { @{ $self-&gt;[$PEERS] } = @_ }
        return @{ $self-&gt;[$PEERS] };
    }
</PRE>
<P>
<PRE>
    1;  # so the require or use succeeds
</PRE>
<P>
You might guess that the array access would be a lot faster than the hash
access, but they're actually comparable. The array is a <EM>little</EM>
bit faster, but not more than ten or fifteen percent, even when you replace
the variables above like <CODE>$AGE</CODE> with literal numbers, like 1. A
bigger difference between the two approaches can be found in memory use. A
hash representation takes up more memory than an array representation
because you have to allocate memory for the keys as well as for the values.
However, it really isn't that bad, especially since as of version 5.004,
memory is only allocated once for a given hash key, no matter how many
hashes have that key. It's expected that sometime in the future, even these
differences will fade into obscurity as more efficient underlying
representations are devised.
<P>
Still, the tiny edge in speed (and somewhat larger one in memory) is enough
to make some programmers choose an array representation for simple classes.
There's still a little problem with scalability, though, because later in
life when you feel like creating subclasses, you'll find that hashes just
work out better.
<P>
<HR>
<H2><A NAME="closures_as_objects">Closures as Objects</A></H2>
Using a code reference to represent an object offers some fascinating
possibilities. We can create a new anonymous function (closure) who alone
in all the world can see the object's data. This is because we put the data
into an anonymous hash that's lexically visible only to the closure we
create, bless, and return as the object. This object's methods turn around
and call the closure as a regular subroutine call, passing it the field we
want to affect. (Yes, the double-function call is slow, but if you wanted
fast, you wouldn't be using objects at all, eh? :-)
<P>
Use would be similar to before:
<P>
<PRE>
    use Person;
    $him = Person-&gt;new();
    $him-&gt;name(&quot;Jason&quot;);
    $him-&gt;age(23);
    $him-&gt;peers( [ &quot;Norbert&quot;, &quot;Rhys&quot;, &quot;Phineas&quot; ] );
    printf &quot;%s is %d years old.\n&quot;, $him-&gt;name, $him-&gt;age;
    print &quot;His peers are: &quot;, join(&quot;, &quot;, @{$him-&gt;peers}), &quot;\n&quot;;
</PRE>
<P>
but the implementation would be radically, perhaps even sublimely
different:
<P>
<PRE>
    package Person;
</PRE>
<P>
<PRE>
    sub new {
	 my $that  = shift;
	 my $class = ref($that) || $that;
	 my $self = {
	    NAME  =&gt; undef,
	    AGE   =&gt; undef,
	    PEERS =&gt; [],
	 };
	 my $closure = sub {
	    my $field = shift;
	    if (@_) { $self-&gt;{$field} = shift }
	    return    $self-&gt;{$field};
	};
	bless($closure, $class);
	return $closure;
    }
</PRE>
<P>
<PRE>
    sub name   { &amp;{ $_[0] }(&quot;NAME&quot;,  @_[ 1 .. $#_ ] ) }
    sub age    { &amp;{ $_[0] }(&quot;AGE&quot;,   @_[ 1 .. $#_ ] ) }
    sub peers  { &amp;{ $_[0] }(&quot;PEERS&quot;, @_[ 1 .. $#_ ] ) }
</PRE>
<P>
<PRE>
    1;
</PRE>
<P>
Because this object is hidden behind a code reference, it's probably a bit
mysterious to those whose background is more firmly rooted in standard
procedural or object-based programming languages than in functional
programming languages whence closures derive. The object created and
returned by the <CODE>new()</CODE> method is itself not a data reference as
we've seen before. It's an anonymous code reference that has within it
access to a specific version (lexical binding and instantiation) of the
object's data, which are stored in the private variable $self. Although
this is the same function each time, it contains a different version of
$self.
<P>
When a method like <CODE>$him-&gt;name("Jason")</CODE> is called, its implicit zeroth argument is the invoking object--just as it
is with all method calls. But in this case, it's our code reference
(something like a function pointer in C++, but with deep binding of lexical
variables). There's not a lot to be done with a code reference beyond
calling it, so that's just what we do when we say <CODE>&{$_[0]}</CODE>. This is just a regular function call, not a method call. The initial
argument is the string ``NAME'', and any remaining arguments are whatever
had been passed to the method itself.
<P>
Once we're executing inside the closure that had been created in
<CODE>new(),</CODE> the <CODE>$self</CODE> hash reference suddenly becomes
visible. The closure grabs its first argument (``NAME'' in this case
because that's what the <CODE>name()</CODE> method passed it), and uses
that string to subscript into the private hash hidden in its unique version
of $self.
<P>
Nothing under the sun will allow anyone outside the executing method to be
able to get at this hidden data. Well, nearly nothing. You <EM>could</EM>
single step through the program using the debugger and find out the pieces
while you're in the method, but everyone else is out of luck.
<P>
There, if that doesn't excite the Scheme folks, then I just don't know what
will. Translation of this technique into C++, Java, or any other
braindead-static language is left as a futile exercise for aficionados of
those camps.
<P>
You could even add a bit of nosiness via the <CODE>caller()</CODE> function
and make the closure refuse to operate unless called via its own package.
This would no doubt satisfy certain fastidious concerns of programming
police and related puritans.
<P>
If you were wondering when Hubris, the third principle virtue of a
programmer, would come into play, here you have it. (More seriously, Hubris
is just the pride in craftsmanship that comes from having written a sound
bit of well-designed code.)
<P>
<HR>
<H1><A NAME="autoload_proxy_methods">AUTOLOAD: Proxy Methods</A></H1>
Autoloading is a way to intercept calls to undefined methods. An autoload
routine may choose to create a new function on the fly, either loaded from
disk or perhaps just <CODE>eval()</CODE>ed right there. This
define-on-the-fly strategy is why it's called autoloading.
<P>
But that's only one possible approach. Another one is to just have the
autoloaded method itself directly provide the requested service. When used
in this way, you may think of autoloaded methods as ``proxy'' methods.
<P>
When Perl tries to call an undefined function in a particular package and
that function is not defined, it looks for a function in that same package
called AUTOLOAD. If one exists, it's called with the same arguments as the
original function would have had. The fully-qualified name of the function
is stored in that package's global variable $AUTOLOAD. Once called, the
function can do anything it would like, including defining a new function
by the right name, and then doing a really fancy kind of <CODE>goto</CODE> right to it, erasing itself from the call stack.
<P>
What does this have to do with objects? After all, we keep talking about
functions, not methods. Well, since a method is just a function with an
extra argument and some fancier semantics about where it's found, we can
use autoloading for methods, too. Perl doesn't start looking for an
AUTOLOAD method until it has exhausted the recursive hunt up through @ISA,
though. Some programmers have even been known to define a
UNIVERSAL::AUTOLOAD method to trap unresolved method calls to any kind of
object.
<P>
<HR>
<H2><A NAME="autoloaded_data_methods">Autoloaded Data Methods</A></H2>
You probably began to get a little suspicious about the duplicated code way
back earlier when we first showed you the Person class, and then later the
Employee class. Each method used to access the hash fields looked virtually
identical. This should have tickled that great programming virtue,
Impatience, but for the time, we let Laziness win out, and so did nothing.
Proxy methods can cure this.
<P>
Instead of writing a new function every time we want a new data field,
we'll use the autoload mechanism to generate (actually, mimic) methods on
the fly. To verify that we're accessing a valid member, we will check
against an <CODE>_permitted</CODE> (pronounced ``under-permitted'') field, which is a reference to a
file-scoped lexical (like a C file static) hash of permitted fields in this
record called %fields. Why the underscore? For the same reason as the
_CENSUS field we once used: as a marker that means ``for internal use
only''.
<P>
Here's what the module initialization code and class constructor will look
like when taking this approach:
<P>
<PRE>
    package Person;
    use Carp;
    use vars qw($AUTOLOAD);  # it's a package global
</PRE>
<P>
<PRE>
    my %fields = (
	name        =&gt; undef,
	age         =&gt; undef,
	peers       =&gt; undef,
    );
</PRE>
<P>
<PRE>
    sub new {
	my $that  = shift;
	my $class = ref($that) || $that;
	my $self  = {
	    _permitted =&gt; \%fields,
	    %fields,
	};
	bless $self, $class;
	return $self;
    }
</PRE>
<P>
If we wanted our record to have default values, we could fill those in
where current we have <CODE>undef</CODE> in the <CODE>%fields</CODE> hash.
<P>
Notice how we saved a reference to our class data on the object itself?
Remember that it's important to access class data through the object itself
instead of having any method reference <CODE>%fields</CODE> directly, or
else you won't have a decent inheritance.
<P>
The real magic, though, is going to reside in our proxy method, which will
handle all calls to undefined methods for objects of class Person (or
subclasses of Person). It has to be called AUTOLOAD. Again, it's all caps
because it's called for us implicitly by Perl itself, not by a user
directly.
<P>
<PRE>
    sub AUTOLOAD {
	my $self = shift;
	my $type = ref($self)
		    or croak &quot;$self is not an object&quot;;
</PRE>
<P>
<PRE>
	my $name = $AUTOLOAD;
	$name =~ s/.*://;   # strip fully-qualified portion
</PRE>
<P>
<PRE>
	unless (exists $self-&gt;{_permitted}-&gt;{$name} ) {
	    croak &quot;Can't access `$name' field in class $type&quot;;
	}
</PRE>
<P>
<PRE>
	if (@_) {
	    return $self-&gt;{$name} = shift;
	} else {
	    return $self-&gt;{$name};
	}
    }
</PRE>
<P>
Pretty nifty, eh? All we have to do to add new data fields is modify
%fields. No new functions need be written.
<P>
I could have avoided the <CODE>_permitted</CODE> field entirely, but I wanted to demonstrate how to store a reference to
class data on the object so you wouldn't have to access that class data
directly from an object method.
<P>
<HR>
<H2><A NAME="inherited_autoloaded_data_method">Inherited Autoloaded Data Methods</A></H2>
But what about inheritance? Can we define our Employee class similarly?
Yes, so long as we're careful enough.
<P>
Here's how to be careful:
<P>
<PRE>
    package Employee;
    use Person;
    use strict;
    use vars qw(@ISA);
    @ISA = qw(Person);
</PRE>
<P>
<PRE>
    my %fields = (
	id          =&gt; undef,
	salary      =&gt; undef,
    );
</PRE>
<P>
<PRE>
    sub new {
	my $that  = shift;
	my $class = ref($that) || $that;
	my $self = bless $that-&gt;SUPER::new(), $class;
	my($element);
	foreach $element (keys %fields) {
	    $self-&gt;{_permitted}-&gt;{$element} = $fields{$element};
	}
	@{$self}{keys %fields} = values %fields;
	return $self;
    }
</PRE>
<P>
Once we've done this, we don't even need to have an AUTOLOAD function in
the Employee package, because we'll grab Person's version of that via
inheritance, and it will all work out just fine.
<P>
<HR>
<H1><A NAME="metaclassical_tools">Metaclassical Tools</A></H1>
Even though proxy methods can provide a more convenient approach to making
more struct-like classes than tediously coding up data methods as
functions, it still leaves a bit to be desired. For one thing, it means you
have to handle bogus calls that you don't mean to trap via your proxy. It
also means you have to be quite careful when dealing with inheritance, as
detailed above.
<P>
Perl programmers have responded to this by creating several different class
construction classes. These metaclasses are classes that create other
classes. A couple worth looking at are Class::Template and Alias. These and
other related metaclasses can be found in the modules directory on CPAN.
<P>
<HR>
<H2><A NAME="classtemplate">Class::Template</A></H2>
One of the older ones is Class::Template. In fact, its syntax and interface
were sketched out long before perl5 even solidified into a real thing. What
it does is provide you a way to ``declare'' a class as having objects whose
fields are of a specific type. The function that does this is called, not
surprisingly enough, <CODE>struct().</CODE> Because structures or records
are not base types in Perl, each time you want to create a class to provide
a record-like data object, you yourself have to define a <CODE>new()</CODE>
method, plus separate data-access methods for each of that record's fields.
You'll quickly become bored with this process. The
<CODE>Class::Template::struct()</CODE> function alleviates this tedium.
<P>
Here's a simple example of using it:
<P>
<PRE>
    use Class::Template qw(struct);
    use Jobbie;  # user-defined; see below
</PRE>
<P>
<PRE>
    struct 'Fred' =&gt; {
        one        =&gt; '$',
        many       =&gt; '@',
        profession =&gt; Jobbie,  # calls Jobbie-&gt;new()
    };
</PRE>
<P>
<PRE>
    $ob = Fred-&gt;new;
    $ob-&gt;one(&quot;hmmmm&quot;);
</PRE>
<P>
<PRE>
    $ob-&gt;many(0, &quot;here&quot;);
    $ob-&gt;many(1, &quot;you&quot;);
    $ob-&gt;many(2, &quot;go&quot;);
    print &quot;Just set: &quot;, $ob-&gt;many(2), &quot;\n&quot;;
</PRE>
<P>
<PRE>
    $ob-&gt;profession-&gt;salary(10_000);
</PRE>
<P>
You can declare types in the struct to be basic Perl types, or user-defined
types (classes). User types will be initialized by calling that class's
<CODE>new()</CODE> method.
<P>
Here's a real-world example of using struct generation. Let's say you
wanted to override Perl's idea of <CODE>gethostbyname()</CODE> and
<CODE>gethostbyaddr()</CODE> so that they would return objects that acted
like C structures. We don't care about high-falutin' OO gunk. All we want
is for these objects to act like structs in the C sense.
<P>
<PRE>
    use Socket;
    use Net::hostent;
    $h = gethostbyname(&quot;perl.com&quot;);  # object return
    printf &quot;perl.com's real name is %s, address %s\n&quot;,
	$h-&gt;name, inet_ntoa($h-&gt;addr);
</PRE>
<P>
Here's how to do this using the Class::Template module. The crux is going
to be this call:
<P>
<PRE>
    struct 'Net::hostent' =&gt; [  	# note bracket
	name       =&gt; '$',
	aliases    =&gt; '@',
	addrtype   =&gt; '$',
	'length'   =&gt; '$',
	addr_list  =&gt; '@',
     ];
</PRE>
<P>
Which creates object methods of those names and types. It even creates a
<CODE>new()</CODE> method for us.
<P>
We could also have implemented our object this way:
<P>
<PRE>
    struct 'Net::hostent' =&gt; {  	# note brace
	name       =&gt; '$',
	aliases    =&gt; '@',
	addrtype   =&gt; '$',
	'length'   =&gt; '$',
	addr_list  =&gt; '@',
     };
</PRE>
<P>
and then Class::Template would have used an anonymous hash as the object
type, instead of an anonymous array. The array is faster and smaller, but
the hash works out better if you eventually want to do inheritance. Since
for this struct-like object we aren't planning on inheritance, this time
we'll opt for better speed and size over better flexibility.
<P>
Here's the whole implementation:
<P>
<PRE>
    package Net::hostent;
    use strict;
</PRE>
<P>
<PRE>
    BEGIN {
	use Exporter   ();
	use vars       qw(@ISA @EXPORT @EXPORT_OK %EXPORT_TAGS);
	@ISA         = qw(Exporter);
	@EXPORT      = qw(gethostbyname gethostbyaddr gethost);
	@EXPORT_OK   = qw(
			   $h_name         @h_aliases
			   $h_addrtype     $h_length
			   @h_addr_list    $h_addr
		       );
	%EXPORT_TAGS = ( FIELDS =&gt; [ @EXPORT_OK, @EXPORT ] );
    }
    use vars      @EXPORT_OK;
</PRE>
<P>
<PRE>
    use Class::Template qw(struct);
    struct 'Net::hostent' =&gt; [
       name        =&gt; '$',
       aliases     =&gt; '@',
       addrtype    =&gt; '$',
       'length'    =&gt; '$',
       addr_list   =&gt; '@',
    ];
</PRE>
<P>
<PRE>
    sub addr { shift-&gt;addr_list-&gt;[0] }
</PRE>
<P>
<PRE>
    sub populate (@) {
	return unless @_;
	my $hob = new();  # Class::Template made this!
	$h_name     =    $hob-&gt;[0]              = $_[0];
	@h_aliases  = @{ $hob-&gt;[1] } = split ' ', $_[1];
	$h_addrtype =    $hob-&gt;[2]              = $_[2];
	$h_length   =    $hob-&gt;[3]              = $_[3];
	$h_addr     =                             $_[4];
	@h_addr_list = @{ $hob-&gt;[4] } =         @_[ (4 .. $#_) ];
	return $hob;
    }
</PRE>
<P>
<PRE>
    sub gethostbyname ($)  { populate(CORE::gethostbyname(shift)) }
</PRE>
<P>
<PRE>
    sub gethostbyaddr ($;$) {
	my ($addr, $addrtype);
	$addr = shift;
	require Socket unless @_;
	$addrtype = @_ ? shift : Socket::AF_INET();
	populate(CORE::gethostbyaddr($addr, $addrtype))
    }
</PRE>
<P>
<PRE>
    sub gethost($) {
	if ($_[0] =~ /^\d+(?:\.\d+(?:\.\d+(?:\.\d+)?)?)?$/) {
	   require Socket;
	   &amp;gethostbyaddr(Socket::inet_aton(shift));
	} else {
	   &amp;gethostbyname;
	}
    }
</PRE>
<P>
<PRE>
    1;
</PRE>
<P>
We've snuck in quite a fair bit of other concepts besides just dynamic
class creation, like overriding core functions, import/export bits,
function prototyping, and short-cut function call via <CODE>&whatever</CODE>. These all mostly make sense from the perspective of a traditional module,
but as you can see, we can also use them in an object module.
<P>
You can look at other object-based, struct-like overrides of core functions
in the 5.004 release of Perl in File::stat, Net::hostent, Net::netent,
Net::protoent, Net::servent, Time::gmtime, Time::localtime, User::grent,
and User::pwent. These modules have a final component that's all
lower-case, by convention reserved for compiler pragmas, because they
affect the compilation and change a built-in function. They also have the
type names that a C programmer would most expect.
<P>
<HR>
<H2><A NAME="data_members_as_variables">Data Members as Variables</A></H2>
If you're used to C++ objects, then you're accustomed to being able to get
at an object's data members as simple variables from within a method. The
Alias module provides for this, as well as a good bit more, such as the
possibility of private methods that the object can call but folks outside
the class cannot.
<P>
Here's an example of creating a Person using the Alias module. When you
update these magical instance variables, you automatically update value
fields in the hash. Convenient, eh?
<P>
<PRE>
    package Person;
</PRE>
<P>
<PRE>
    # this is the same as before...
    sub new {
	 my $that  = shift;
	 my $class = ref($that) || $that;
	 my $self = {
	    NAME  =&gt; undef,
	    AGE   =&gt; undef,
	    PEERS =&gt; [],
	};
	bless($self, $class);
	return $self;
    }
</PRE>
<P>
<PRE>
    use Alias qw(attr);
    use vars qw($NAME $AGE $PEERS);
</PRE>
<P>
<PRE>
    sub name {
	my $self = attr shift;
	if (@_) { $NAME = shift; }
	return    $NAME;
    }
</PRE>
<P>
<PRE>
    sub age {
	my $self = attr shift;
	if (@_) { $AGE = shift; }
	return    $AGE;
    }
</PRE>
<P>
<PRE>
    sub peers {
	my $self = attr shift;
	if (@_) { @PEERS = @_; }
	return    @PEERS;
    }
</PRE>
<P>
<PRE>
    sub exclaim {
        my $self = attr shift;
        return sprintf &quot;Hi, I'm %s, age %d, working with %s&quot;,
            $NAME, $AGE, join(&quot;, &quot;, @PEERS);
    }
</PRE>
<P>
<PRE>
    sub happy_birthday {
        my $self = attr shift;
        return ++$AGE;
    }
</PRE>
<P>
The need for the <CODE>use vars</CODE> declaration is because what Alias does is play with package globals with
the same name as the fields. To use globals while <CODE>use strict</CODE> is in effect, you have to pre-declare them. These package variables are
localized to the block enclosing the <CODE>attr()</CODE> call just as if
you'd used a <CODE>local()</CODE> on them. However, that means that they're
still considered global variables with temporary values, just as with any
other <CODE>local().</CODE>
<P>
It would be nice to combine Alias with something like Class::Template or
Class::MethodMaker.
<P>
<HR>
<H2><A NAME="notes">NOTES</A></H2>
<P>
<HR>
<H2><A NAME="object_terminology">Object Terminology</A></H2>
In the various OO literature, it seems that a lot of different words are
used to describe only a few different concepts. If you're not already an
object programmer, then you don't need to worry about all these fancy
words. But if you are, then you might like to know how to get at the same
concepts in Perl.
<P>
For example, it's common to call an object an <EM>instance</EM>
 of a class and to call those objects' methods <EM>instance methods</EM>. Data fields peculiar to each object are often called <EM>instance data</EM>
 or <EM>object
attributes</EM>
, and data fields common to all members of that class are
<EM>class data</EM>
, <EM>class attributes</EM>
, or <EM>static data members</EM>.
<P>
Also, <EM>base class</EM>
, <EM>generic class</EM>
, and <EM>superclass</EM>
 all describe the same notion, whereas <EM>derived class</EM>
, <EM>specific class</EM>
, and
<EM>subclass</EM>
 describe the other related one.
<P>
C++ programmers have <EM>static methods</EM>
 and <EM>virtual methods</EM>
, but Perl only has <EM>class methods</EM>
 and <EM>object methods</EM>. Actually, Perl only has methods. Whether a method gets used as a class or
object method is by usage only. You could accidentally call a class method
(one expecting a string argument) on an object (one expecting a reference),
or vice versa.
<P>
From the C++ perspective, all methods in Perl are virtual. This, by the
way, is why they are never checked for function prototypes in the argument
list as regular built-in and user-defined functions can be.
<P>
Because a class is itself something of an object, Perl's classes can be
taken as describing both a ``class as meta-object'' (also called <EM>object
factory</EM>
) philosophy and the ``class as type definition'' (<EM>declaring</EM>
behaviour, not <EM>defining</EM>
 emchanism) idea. C++ supports the latter notion, but not the former.
<P>
<HR>
<H1><A NAME="see_also">SEE ALSO</A></H1>
The following man pages will doubtless provide more background for this
one:
<EM>perlmod</EM>(1)
,
<EM>perlref</EM>(1)
,
<EM>perlobj</EM>(1)
,
<EM>perlbot</EM>(1)
,
<EM>perltie</EM>(1)
, and
<EM>overload</EM>(3).
<P>
<HR>
<H1><A NAME="copyright">COPYRIGHT</A></H1>
I <EM>really</EM>
 hate to have to say this, but recent unpleasant experiences have mandated
its inclusion:
<BLOCKQUOTE>
<PRE>
    Copyright 1996 Tom Christiansen.  All Rights Reserved.
</PRE>
<P>
This work derives in part from the second edition of <EM>Programming Perl</EM>. Although destined for release as a man page with the standard Perl
distribution, it is not public domain (nor is any of Perl and its docset:
publishers beware). It's expected to someday make its way into a revision
of the Camel Book. While it is copyright by me with all rights reserved,
permission is granted to freely distribute verbatim copies of this document
provided that no modifications outside of formatting be made, and that this
notice remain intact. You are permitted and encouraged to use its code and
derivatives thereof in your own source code for fun or for profit as you
see fit. But so help me, if in six months I find some book out there with a
hacked-up version of this material in it claiming to be written by someone
else, I'll tell all the world that you're a jerk. Furthermore, your lawyer
will meet my lawyer (or O'Reilly's) over lunch to arrange for you to
receive your just deserts. Count on it.
</BLOCKQUOTE>
<P>
<HR>
<H2><A NAME="acknowledgments">Acknowledgments</A></H2>
Thanks to Larry Wall, Roderick Schertler, Gurusamy Sarathy, Dean Roehrich,
Raphael Manfredi, Brent Halsey, Greg Bacon, Brad Appleton, and many others
for their helpful comments.
<P>
    </BODY>
    </HTML>
