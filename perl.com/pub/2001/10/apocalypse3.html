<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN"
    "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" id="sixapart-standard">
<head>
    <meta http-equiv="Content-Type" content="text/html; charset=UTF-8" />
<meta name="generator" content="Movable Type Pro 5.02" />
<link rel="stylesheet" href="/pub/styles.css" type="text/css" />
<link rel="start" href="/pub/" title="Home" />
<link rel="alternate" type="application/atom+xml" title="Recent Entries" href="/pub/atom.xml" />
<script type="text/javascript" src="/pub/mt.js"></script>

<script type="text/javascript">

 var _gaq = _gaq || [];
 _gaq.push(['_setAccount', 'UA-50555-22']);
 _gaq.push(['_trackPageview']);

 (function() {
   var ga = document.createElement('script'); ga.type =
   'text/javascript'; ga.async = true;
   ga.src = ('https:' == document.location.protocol ? 'https://ssl' :
   'http://www') + '.google-analytics.com/ga.js';
   var s = document.getElementsByTagName('script')[0];
   s.parentNode.insertBefore(ga, s);
 })();

</script>
    
    <link rel="prev bookmark" href="/pub/2001/09/crypto1.html" title="Asymmetric Cryptography in Perl" />
    <link rel="next bookmark" href="/pub/2001/10/exegesis3.html" title="Exegesis 3" />
    
    
    <title>Apocalypse 3 - Perl.com</title>
</head>
<body id="perl-com" class="mt-entry-archive layout-wt">
    <div id="container">
        <div id="container-inner">


            <div id="header">
    <div id="header-inner">
        <div id="header-content">
        <div id="top_advert"> 
<!-- Put any landscape advert in here -->
<a href="http://www.perlfoundation.org/" target="_new">
<img src="/i/tpf_banner.png" width="468" height="60" /></a>
        </div> 



            <div id="header-name"><a href="/pub/" accesskey="1">Perl.com</a></div>
            <div id="header-description"></div>




        </div>
    </div>
</div>



            <div id="content">
                <div id="content-inner">


                    <div id="alpha">
                        <div id="alpha-inner">


                            <div id="entry-1608" class="entry-asset asset hentry">
                                <div class="asset-header">
                                    <h1 id="page-title" class="asset-name entry-title">Apocalypse 3</h1>
                                    <div class="asset-meta">
                                        <span class="byline">

                                            By <span class="vcard author">Larry Wall</span> on <abbr class="published" title="2001-10-02T00:00:00-08:00">October  2, 2001 12:00 AM</abbr>

                                        </span>


                                    </div>
                                </div>
                                <div class="asset-content entry-content">

                                    <div class="asset-body">
                                        

<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S03.html">Synopsis 03</a> for the latest information.</em></p>

<!-- INDEX BEGIN -->
<table width="150" border="0" cellspacing="0" cellpadding="4" align="right">
<tr> 
<td width="150" valign="top" height="4" bgcolor="#6699cc"></td></tr> 
<tr>
<td bgcolor="#efefef">
<p class="headline" align="center">Table of Contents
</p>
<p class="smalltext">

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=2#rfc 025: operators: multiway comparisons">RFC 025: Operators: Multiway comparisons</a><br /><br />
&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=2#rfc 320: allow grouping of x file tests and add filetest builtin">RFC 320: Allow grouping of -X file tests and add <code>filetest</code> builtin</a><br /><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=2#rfc 290: better english names for x">RFC 290: Better english names for -X</a><br /><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=3#rfc 283: tr/// in array context should return a histogram">RFC 283: <code>tr///</code> in array context should return a histogram</a><br /><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=3#rfc 084: replace => (stringifying comma) with => (pair constructor)">RFC 084: Replace <code>=&gt;</code> (stringifying comma) with <code>=&gt;</code> (pair constructor)</a><br /><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=3#rfc 081: lazily evaluated list generation functions">RFC 081: Lazily evaluated list generation functions</a><br /><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=4#rfc 285: lazy input / contextsensitive input">RFC 285: Lazy Input / Context-sensitive Input</a><br /><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=4#rfc 082: arrays: apply operators elementwise in a list context">RFC 082: Arrays: Apply operators element-wise in a list context</a><br /><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=4#rfc 045: || and && should propagate result context to both sides">RFC 045: <code>||</code> and <code>&amp;&amp;</code> should propagate result context to both sides</a><br /><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=5#rfc 054: operators: polymorphic comparisons">RFC 054: Operators: Polymorphic comparisons</a><br /><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=5#rfc 104: backtracking">RFC 104: Backtracking</a><br /><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=5#rfc 143: case ignoring eq and cmp operators">RFC 143: Case ignoring <code>eq</code> and <code>cmp</code> operators</a><br /><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=5#rfc 170: generalize =~ to a special applyto assignment operator">RFC 170: Generalize <code>=~</code> to a special ``apply-to'' assignment operator</a><br /><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#nonrfc considerations">Non-RFC considerations</a>
</p>
<table border="0" width="100%" cellpadding="0" cellspacing="0">
<tr><td valign="top" bgcolor="#efefef" width="15">&nbsp;</td>
<td valign="top" bgcolor="#efefef">
<span class="tiny">
&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#binary . (dot)">Binary <code>.</code> (dot)</a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#unary . (dot)">Unary <code>.</code> (dot)</a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#binary _">Binary <code>_</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#unary _">Unary <code>_</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#unary + X">Unary <code>+</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#binary := Y">Binary <code>:=</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#unary * XX">Unary <code>*</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#list context">List context</a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#binary : YY">Binary <code>:</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#trinary ::">Trinary <code>??::</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#binary // YYY">Binary <code>//</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#binary ; YYYY">Binary <code>;</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#unary ^ XXX">Unary <code>^</code></a>
<br />
&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#unary ">Unary <code>?</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#binary ">Binary <code>?</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#binary ~ YYYYY">Binary <code>~</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#binary ~~ YYYYYY">Binary <code>~~</code></a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#user defined operators">User defined operators</a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#unicode operators">Unicode operators</a><br />

&#149; <a href="/pub/a/2001/10/02/apocalypse3.html?page=6#precedence">Precedence</a><br /></span>
</td></tr></table>

</td></tr> <tr><td width="150" valign="top" height="4" bgcolor="#6699cc"> </td></tr></table>
<!-- INDEX END -->

<p>To me, one of the most agonizing aspects of language design is coming
up with a useful system of operators.  To other language designers,
this may seem like a silly thing to agonize over.  After all, you can
view all operators as mere syntactic sugar -- operators are just funny
looking function calls.  Some languages make a feature of leveling all
function calls into one syntax.  As a result, the so-called functional
languages tend to wear out your parenthesis keys, while OO languages
tend to wear out your dot key.</p>

<p>But while your computer really likes it when everything looks the same,
most people don't think like computers.  People prefer different things to
look different.  They also prefer to have shortcuts for common tasks.
(Even the mathematicians don't go for complete orthogonality.  Many of
the shortcuts we typically use for operators were, in fact, invented
by mathematicians in the first place.)</p>

<p>So let me enumerate some of the principles that I weigh against each
other when designing a system of operators.</p>
<ul>
<li>
Different classes of operators should look different.  That's why
filetest operators look different from string or numeric operators.
</li>
<li>
Similar classes of operators should look similar.  That's why
the filetest operators look like each other.
</li>
<li>
Common operations should be ``Huffman coded.''  That is, frequently used
operators should be shorter than infrequently used ones.  For how
often it's used, the <code>scalar</code> operator of Perl 5 is too long, in
my estimation.
</li>
<li>
Preserving your culture is important.  So Perl borrowed many of its
operators from other familiar languages.  For instance, we used Fortran's
<code>**</code> operator for exponentiation.  As we go on to Perl 6, most of
the operators will be ``borrowed'' directly from Perl 5.
</li>
<li>
Breaking out of your culture is also important, because that is
how we understand other cultures.  As an explicitly multicultural
language, Perl has generally done OK in this area, though we can
always do better.  Examples of cross-cultural exchange among computer
cultures include XML and Unicode.  (Not surprisingly, these features
also enable better cross-cultural exchange among human cultures -- we
sincerely hope.)
</li>
<li>
Sometimes operators should respond to their context.  Perl has
many operators that do different but related things in scalar versus
list context.
</li>
<li>
Sometimes operators should propagate context to their arguments.  The
<code>x</code> operator currently does this for its left argument, while the
short-circuit operators do this for their right argument.
</li>
<li>
Sometimes operators should force context on their arguments.  Historically,
the scalar mathematical operators of Perl have forced scalar context on
their arguments.  One of the RFCs discussed below proposes to revise this.
</li>
<li>
Sometimes operators should respond polymorphically to the types of
their arguments.  Method calls and overloading work this way.
</li>
<li>
Operator precedence should be designed to minimize the need for
parentheses.  You can think of the precedence of operators as a
partial ordering of the operators such that it minimizes the number of
``unnatural'' pairings that require parentheses in typical code.
</li>
<li>
Operator precedence should be as simple as possible.  Perl's precedence
table currently has 24 levels in it.  This might or might not be too many.
We could probably reduce it to about 18 levels, if we abandon strict
C compatibility of the C-like operators.
</li>
<li>
People don't actually want to think about precedence much, so
precedence should be designed to match expectations.  Unfortunately,
the expectations of someone who knows the precedence table won't
match the expectations of someone who doesn't.  And Perl has always
catered to the expectations of C programmers, at least up till now.
There's not much one can do up front about differing cultural expectations.
</li></ul>
<p>It would be easy to drive any one of these principles into the ground,
at the expense of other principles.  In fact, various languages
have done precisely that.</p>

<p>My overriding design principle has always been that the complexity of
the solution space should map well onto the complexity of the problem
space.  Simplification good!  Oversimplification bad!  Placing
artificial constraints on the solution space produces an impedence
mismatch with the problem space, with the result that using a language
that is artificially simple induces artificial complexity in all
solutions written in that language.</p>

<p>One artificial constraint that all computer languages must deal with is
the number of symbols available on the keyboard, corresponding roughly
to the number of symbols in ASCII.  Most computer languages have
compensated by defining systems of operators that include digraphs,
trigraphs, and worse.  This works pretty well, up to a point.  But
it means that certain common unary operators cannot be used as the
end of a digraph operator.  Early versions of C had assignment operators
in the wrong order.  For instance, there used to be a <code>=-</code> operator.
Nowadays that's spelled <code>-=</code>, to avoid conflict with unary minus.</p>

<p>By the same token (no pun intended), you can't easily define a
unary <code>=</code> operator without requiring a space before it most of the time,
since so many binary operators end with the <code>=</code> character.</p>
<p>Perl gets around some of these problems by keeping track of whether
it is expecting an operator or a term.  As it happens, a unary operator
is simply one that occurs when Perl is expecting a term.  So Perl could
keep track of a unary <code>=</code> operator, even if the human programmer might
be confused.  So I'd place a unary <code>=</code> operator in the category
of ``OK, but don't use it for anything that will cause widespread
confusion.''  Mind you, I'm not proposing a specific use for a unary
<code>=</code> at this point.  I'm just telling you how I think.  If we ever do
get a unary <code>=</code> operator, we will hopefully have taken these issues
into account.</p>
<p>While we can disambiguate operators based on whether an operator or a
term is expected, this implies some syntactic constraints as well.  For
instance, you can't use the same symbol for both a postfix operator and
a binary operator.  So you'll never see a binary <code>++</code> operator in
Perl, because Perl wouldn't know whether to expect a term or operator
after that.  It also implies that we can't use the ``juxtaposition''
operator.  That is, you can't just put two terms next to each other,
and expect something to happen (such as string concatenation, as in
<em>awk</em>).  What if the second term started with something looked like an
operator?  It would be misconstrued as a binary operator.</p>

<p>Well, enough of these vague generalities.  On to the vague specifics.</p>


<p>The RFCs for this apocalypse are (as usual) all over the map, but
don't cover the map.  I'll talk first about what the RFCs do cover,
and then about what they don't.  Here are the RFCs that happened to get
themselves classified into chapter 3:</p>
<pre>
    RFC   PSA    Title
    ---   ---    -----
    024   rr     Data types: Semi-finite (lazy) lists
    025   dba    Operators: Multiway comparisons
    039   rr     Perl should have a print operator 
    045   bbb    C&lt;||&gt; and C&lt;&amp;&amp;&gt; should propagate result context to both sides
    054   cdr    Operators: Polymorphic comparisons
    081   abc    Lazily evaluated list generation functions
    082   abc    Arrays: Apply operators element-wise in a list context
    084   abb    Replace =&gt; (stringifying comma) with =&gt; (pair constructor)
    104   ccr    Backtracking
    138   rr     Eliminate =~ operator.
    143   dcr    Case ignoring eq and cmp operators
    170   ccr    Generalize =~ to a special &quot;apply-to&quot; assignment operator
    283   ccc    C&lt;tr///&gt; in array context should return a histogram
    285   acb    Lazy Input / Context-sensitive Input
    290   bbc    Better english names for -X
    320   ccc    Allow grouping of -X file tests and add C&lt;filetest&gt; builtin</pre>
<p>
Note that you can click on the following RFC titles to view a copy of the
RFC in question.  The discussion sometimes assumes that you've read the RFC.













<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S03.html">Synopsis 03</a> for the latest information.</em></p>

<h3><a href="http://dev.perl.org/rfc/25.html" name="rfc 025: operators: multiway comparisons">RFC 025: Operators: Multiway comparisons</a></h3>

<table width="150" border="0" cellspacing="0" cellpadding="4" align="right">
<tr> 
<td width="150" valign="top" height="4" bgcolor="#6699cc"></td></tr> 
<tr>
<td bgcolor="#efefef">
<p class="headline" align="center">Previous Apocalypses
</p>
<p class="smalltext">
&#149; <a href="/pub/a/2001/04/02/wall.html">Apocalypse 1</a><br /><br />
&#149; <a href="/pub/a/2001/05/03/wall.html">Apocalypse 2</a><br /><br />
</td></tr> <tr><td width="150" valign="top" height="4" bgcolor="#6699cc"> </td></tr></table>
<p>This RFC proposes that expressions involving multiple chained comparisons
should act like mathematician would expect.  That is, if you say this:</p>
<pre>
    0 &lt;= $x &lt; 10</pre>
<p>it really means something like:</p>
<pre>
    0 &lt;= $x &amp;&amp; $x &lt; 10</pre>
<p>The <code>$x</code> would only be evaluated once, however.  (This is very much like
the rewrite rule we use to explain assignment operators such as <code>$x += 3</code>.)</p>
<p>I started with this RFC simply because it's not of any earthshaking
importance whether I accept it or not.  The tradeoff is whether to
put some slight complexity into the grammar in order to save some
slight complexity in some Perl programs.  The complexity in the grammar
is not much of a problem here, since it's amortized over all possible
uses of it, and it already matches the known psychology of a great
number of people.</p>
<p>There is a potential interaction with precedence levels, however.  If
we choose to allow an expression like:</p>
<pre>
    0 &lt;= $x == $y &lt; 20</pre>
<p>then we'll have to unify the precedence levels of the comparison
operators with the equality operators.  I don't see a great problem
with this, since the main reason for having them different was (I
believe) so that you could write an exclusive of two comparisons,
like this:</p>
<pre>
    $x &lt; 10 != $y &lt; 10</pre>
<p>However, Perl has a built-in <code>xor</code> operator, so this isn't
really much of an issue.  And there's a lot to be said for forcing
parentheses in that last expression anyway, just for clarity.  So
unless anyone comes up with a large objection that I'm not seeing, this
RFC is accepted.</p>

<h3><a href="http://dev.perl.org/rfc/320.html" name="rfc 320: allow grouping of x file tests and add filetest builtin">RFC 320: Allow grouping of -X file tests and add <code>filetest</code> builtin</a></h3>

<p>This RFC proposes to allow clustering of file test operators much like
some Unix utilities allow bundling of single character switches.  That
is, if you say:</p>
<pre>
    -drwx $file</pre>
<p>it really means something like:</p>
<pre>
    -d $file &amp;&amp; -r $file &amp;&amp; -w $file &amp;&amp; -x $file</pre>
<p>Unfortunately, as proposed, this syntax will simply be too confusing.
We have to be able to negate named operators and subroutines.  The
proposed workaround of putting a space after a unary minus is much too
onerous and counterintuitive, or at least countercultural.</p>



<p>The only way to rescue the proposal would be to say that such operators
are autoloaded in some fashion; any negated but <em>unrecognized</em>
operator would then be assumed to be a clustered filetest.  This would be
risky in that it would prevent Perl from catching misspelled
subroutine names at compile time when negated, and the error might
well not get caught at run time either, if all the characters in the
name are valid filetests, and if the argument can be interpreted
as a filename or filehandle (which is usually).  Perhaps it would
be naturally disallowed under <code>use strict</code>, since we'd basically
be treating <code>-xyz</code> as a bareword.  On the other hand, in Perl 5, <em>all</em>
method names are essentially in the unrecognized category until run
time, so it would be impossible to tell whether to parse the minus
sign as a real negation.  Optional type declarations in Perl 6 would
only help the compiler with variables that are actually declared to
have a type.  Fortunately, a negated 1 is still true, so even if we
parsed the negation as a real negation, it might still end up doing
the right thing.  But it's all very tacky.</p>
<p>So I'm thinking of a different tack.  Instead of bundling the letters:</p>
<pre>
    -drwx $file</pre>
<p>let's think about the trick of returning the value of <code>$file</code> for a true
value.  Then we'd write nested unary operators like this:</p>
<pre>
    -d -r -w -x $file</pre>
<p>One tricky thing about that is that the operators are applied right
to left.  And they don't really short circuit the way stacked <code>&amp;&amp;</code> would
(though the optimizer could probably fix that).  So I expect we could
do this for the default, and if you want the <code>-drwx</code> as an autoloaded
backstop, you can explicitly declare that.</p>
<p>In any event, the proposed <code>filetest</code> built-in need not be built in.
It can just be a universal method.  (Or maybe just common to strings
and filehandles?)</p>
<p>My one hesitation in making cascading operators work like that is that
people might be tempted to get cute with the returned filename:</p>
<pre>
    $handle = open -r -w -x $file or die;</pre>
<p>That might be terribly confusing to a lot of people.  The solution to
this conundrum is presented at the end of the next section.</p>

<h3><a href="http://dev.perl.org/rfc/290.html" name="rfc 290: better english names for x">RFC 290: Better english names for -X</a></h3>
<p>This RFC proposes long names as aliases for the various filetest operators,
so that instead of saying:</p>
<pre>
    -r $file</pre>
<p>you might say something like:</p>
<pre>
    use english;
    freadable($file)</pre>
<p>Actually, there's no need for the <code>use english</code>, I expect.  These names
could merely universal (or nearly universal) methods.  In any case, we
should start getting used to the idea that <code>mumble($foo)</code> is
equivalent to <code>$foo.mumble()</code>, at least in the absence of a local
subroutine definition to the contrary.  So I expect that we'll see
both:</p>
<pre>
    is_readable($file)</pre>
<p>and:</p>
<pre>
    $file.is_readable</pre>
<p>Similar to the cascaded filetest ops in the previous section,
one approach might be that the boolean methods return the object in
question for success so that method calls could be stacked without
repeating the object:</p>
<pre>
    if ($file.is_dir
             .is_readable
             .is_writable
             .is_executable) {</pre>
<p>But <code>-drwx $file</code> could still be construed as more readable,
for some definition of readability.  And cascading methods aren't
really short-circuited.  Plus, the value returned would have to be
something like ``$file is true,'' to prevent confusion over filename ``0.''</p>
<p>There is also the question of whether this really saves us anything
other than a little notational convenience.  If each of those methods
has to do a <em>stat</em> on the filename, it will be rather slow.  To fix
that, what we'd actually have to return would be not the filename,
but some object containing the stat buffer (represented in Perl 5 by
the <code>_</code> character).  If we did that, we wouldn't have to play
<code>$file is true</code> games, because a valid stat buffer object would
(presumably) always be true (at least until it's false).</p>
<p>The same argument would apply to cascaded filetest operators we talked
about earlier.  An autoloaded <code>-drwx</code> handler would presumably be
smart enough to do a single stat.  But we'd likely lose the speed gain
by invoking the autoload mechanism.  So cascaded operators
(either <code>-X</code> style or <code>.is_XXX</code> style) are the way to go.
They just return objects that know how to be either boolean or stat
buffer objects in context.  This implies you could even say</p>
<pre>
    $statbuf = -f $file or die &quot;Not a regular file: $file&quot;;
    if (-r -w $statbuf) { ... }</pre>
<p>This allows us to simplify the special case in Perl 5 represented by
the <code>_</code> token, which was always rather difficult to explain.   And
returning a stat buffer instead of <code>$file</code> prevents the confusing:</p>
<pre>
    $handle = open -r -w -x $file or die;</pre>
<p>Unless, of course, we decide to make a stat buffer object return the filename
in a string context.  <code>:-)</code></p>













<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S03.html">Synopsis 03</a> for the latest information.</em></p>

<h3><a href="http://dev.perl.org/rfc/283.html" name="rfc 283: tr/// in array context should return a histogram">RFC 283: <code>tr///</code> in array context should return a histogram</a></h3>
<p>Yes, but ...</p>
<p>While it's true that I put that item into the Todo list ages ago, I
think that histograms should probably have their own interface, since
the histogram should probably be returned as a complete hash in scalar
context, but we can't guess that they'll want a histogram for an
ordinary scalar <code>tr///</code>.  On the other hand, it could just be a <code>/h</code>
modifier.  But we've already done violence to <code>tr///</code> to make it do
character counting without transliterating, so maybe this isn't so far
fetched.</p>
<p>One problem with this RFC is that it does the histogram over the input
rather than the output string.  The original Todo entry did not specify
this, but it was what I had intended.  But it's more useful to do it on
the resulting characters because then you can use the <code>tr///</code> itself to
categorize characters into, say, vowels and consonants, and then count
the resulting V's and C's.</p>



<p>On the other hand, I'm thinking that the <code>tr///</code> interface is really
rather lousy, and getting lousier every day.  The whole <code>tr///</code>
interface is kind of sucky for any sort of dynamically generated data.
But even without dynamic data, there are serious problems.  It was bad
enough when the character set was just ASCII.  The basic problem is
that the notation is inside out from what it should be, in the sense
that it doesn't actually show which characters correspond, so you have
to count characters.  We made some progress on that in Perl 5 when,
instead of:</p>
<pre>
    tr/abcdefghijklmnopqrstuvwxyz/VCCCVCCCVCCCCCVCCCCCVCCCCC/</pre>
<p>we allowed you to say:</p>
<pre>
    tr[abcdefghijklmnopqrstuvwxyz]
      [VCCCVCCCVCCCCCVCCCCCVCCCCC]</pre>
<p>There are also shenanigans you can play if you know that duplicates
on the left side prefer the first mention to subsequent mentions:</p>
<pre>
    tr/aeioua-z/VVVVVC/</pre>
<p>But you're still working against the notation. We need a more
explicit way to put character classes into correspondence.</p>
<p>More problems show up when we extend the character set beyond ASCII.
The use of <code>tr///</code> for case translations has long been semi-deprecated,
because a range like <code>tr/a-z/A-Z/</code> leaves out characters with
diacritics.  And now with Unicode, the whole notion of what is a
character is becoming more susceptible to interpretation, and the <code>tr///</code>
interface doesn't tell Perl whether to treat character modifiers as
part of the base character.  For some of the double-wide characters
it's even hard to just <em>look</em> at the character and tell if it's
one character or two.  Counted character lists are about as modern as
hollerith strings in Fortran.</p>
<p>So I suspect the <code>tr///</code> syntax will be relegated to being just one
quote-like interface to the actual transliteration module, whose main
interface will be specified in terms of translation pairs, the left
side of which will give a pattern to match (typically a character
class), and the right side will say what to translation anything
matching to.  Think of it as a series of coordinated parallel <code>s///</code>
operations.  Syntax is still open for negotiation till apocalypse 5.</p>
<p>But there can certainly be a histogram option in there somewhere.</p>


<h3><a href="http://dev.perl.org/rfc/84.html" name="rfc 084: replace => (stringifying comma) with => (pair constructor)">RFC 084: Replace <code>=&gt;</code> (stringifying comma) with <code>=&gt;</code> (pair constructor)</a></h3>
<p>I like the basic idea of pairs because it generalizes to more than just
hash values.  Named parameters will almost certainly be implemented using
pairs as well.</p>
<p>I do have some quibbles with the RFC.  The proposed <code>key</code> and <code>value</code>
built-ins should simply be lvalue methods on pair objects.  And if we
use pair objects to implement entries in hashes, the key must be
immutable, or there must be some way of re-hashing the key if it
changes.</p>
<p>The stuff about using pairs for mumble-but-false is bogus.  We'll use
properties for that sort of chicanery.  (And multiway comparisons
won't rely on such chicanery in any event.  See above.)</p>


<h3><a href="http://dev.perl.org/rfc/81.html" name="rfc 081: lazily evaluated list generation functions">RFC 081: Lazily evaluated list generation functions</a></h3>
<p>Sorry, you can't have the colon--at least, not without sharing it.
Colon will be a kind of ``supercomma'' that supplies an adverbial list to
some previous operator, which in this case would be the prior colon or
dotdot.</p>
<p>(We can't quite implement <code>?:</code> as a <code>:</code> modifier on <code>?</code>, because
the precedence would be screwey, unless we limit <code>:</code> to a single
argument, which would preclude its being used to disambiguate indirect
objects.  More on that later.)</p>
<p>The RFCs proposal concerning <code>attributes::get(@a)</code> stuff is superseded by
value properties.  So, <code>@a.method()</code> should just pull out the
variable's properties directly, if the variable is of a type that
supports the methods in question.  A lazy list object should certainly
have such methods.</p>
<p>Assignment of a lazy list to a tied array is a problem unless the tie
implementation handles laziness.  By default a tied array is likely to
enforce immediate list evaluation.  Immediate list evaluation doesn't
work on infinite lists.  That means it's gonna fill up your disk drive
if you try to say something like:</p>
<pre>
    @my_tied_file = 1..Inf;</pre>
<p>Laziness should be possible, but not necessarily the norm.  It's all very
well to delay the evaluation of ``pure'' functions in the realm of math, since
presumably you get the same result no matter when you evaluate.  But a
lot of Perl programming is done with real world data that changes over time.
Saying <code>somefunc($a .. $b)</code> can get terribly fouled up if <code>$b</code> can change, and
the lazy function still refers to the variable rather than its instantaneous
value.  On the other hand, there is overhead in taking snapshots of the
current state.</p>
<p>On the gripping hand, the lazy list object <em>is</em> the snapshot of the values,
that's not a problem in this case.  Forget I mentioned it.</p>
<p>The tricky thing about lazy lists is not the lazy lists themselves, but
how they interact with the rest of the language.  For instance, what
happens if you say:</p>
<pre>
    @lazy = 1..Inf;
    @lazy[5] = 42;</pre>
<p>Is <code>@lazy</code> still lazy after it is modified?  Do we remember the
<code>@lazy[5]</code> is an ``exception'', and continue to generate the rest of
the values by the original rule?  What if <code>@lazy</code> is going to be
generated by a recursive function?  Does it matter whether we've
already generated <code>@lazy[5]</code>?</p>
<p>And how do we explain this simply to people so that they can
understand?  We will have to be very clear about the distinction
between the abstraction and the concrete value.  I'm of the opinion
that a lazy list is a definition of the <em>default</em> values of an array,
and that the actual values of the array override any default values.
Assigning to a previously memoized element overrides the memoized value.</p>
<p>It would help the optimizer to have a way to declare ``pure'' array
definitions that can't be overridden.</p>
<p>Also consider this:</p>
<pre>
    @array = (1..100, 100..10000:100);</pre>
<p>A single flat array can have multiple lazy lists as part of it's
default definition.  We'll have to keep track of that, which could get
especially tricky if the definitions start overlapping via slice
definitions.</p>
<p>In practice, people will treat the default values as real values.  If
you pass a lazy list into a function as an array argument, the function
will probably not know or care whether the values it's getting from the
array are being generated on the fly or were there in the first place.</p>
<p>I can think of other cans of worms this opens, and I'm quite certain
I'm too stupid to think of them all.  Nevertheless, my gut feeling is
that we can make things work more like people expect rather than less.
And I was always a little bit jealous that REXX could have arrays
with default values.  <code>:-)</code></p>













<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S03.html">Synopsis 03</a> for the latest information.</em></p>

<h3><a href="http://dev.perl.org/rfc/285.html" name="rfc 285: lazy input / contextsensitive input">RFC 285: Lazy Input / Context-sensitive Input</a></h3>
<p>Solving this with <code>want()</code> is the wrong approach, but I think the
basic idea is sound because it's what people expect.  And the <code>want()</code>
should in fact be unnecessary.  Essentially, if the right side of a
list assignment produces a lazy list, and the left side requests a
finite number of elements, the list generator will only produce enough
to satisy the demand.  It doesn't need to know how many in advance.
It just produces another scalar value when requested.  The generator
doesn't have to be smart about its context.  The motto of a lazy list
generator should be, ``Ours is not to question why, ours is but to do
(the next one) or die.''</p>
<p>It will be tricky to make this one work right:</p>
<pre>
    ($first, @rest) = 1 .. Inf;</pre>


<h3><a href="http://dev.perl.org/rfc/82.html" name="rfc 082: arrays: apply operators elementwise in a list context">RFC 082: Arrays: Apply operators element-wise in a list context</a></h3>
<p>APL, here we come...  :-)</p>
<p>This is by far the most difficult of these RFCs to decide, so I'm going
to be doing a lot of thinking out loud here.  This is research--or at
least, a search.  Please bear with me.</p>



<p>I expect that there are two classes of Perl programmers--those that
would find these ``hyper'' operators natural, and those that wouldn't.
Turning this feature on by default would cause a lot of heartburn for
people who (from Perl 5 experience) expect arrays to always return
their length under scalar operators even in list context.  It can
reasonably be argued that we need to make the scalar operators
default, but make it easy to turn on hyper operators within a
lexical scope.  In any event, both sets of operators need to be
visible from anywhere--we're just arguing over who gets the short,
traditional names.  All operators will presumably have longer names
for use as function calls anyway.  Instead of just naming an operator
with long names like:</p>
<pre>
    operator:+
    operator:/</pre>
<p>the longer names could distinguish ``hyperness'' like this:</p>
<pre>
    @a scalar:+ @b
    @a list:/ @b</pre>
<p>That implies they could also be called like this:</p>
<pre>
    scalar:+(@a, @b)
    list:/(@a, @b)</pre>
<p>We might find some short prefix character stands in for
``list'' or ``scalar''.  The obvious candidates are <code>@</code> and <code>$</code>:</p>
<pre>
    @a $+ @b
    @a @/ @b</pre>
<p>Unfortunately, in this case, ``obvious'' is synonymous with ``wrong''.
These operators would be completely confusing from a visual point
of view.  If the main psychological point of putting noun markers on
the nouns is so that they stand out from the verbs, then you don't
want to put the same markers on the verbs.  It would be like the
Germans starting to capitalize all their words instead of just their
nouns.</p>
<p>Instead, we could borrow a singular/plural memelet from shell
globbing, where <code>*</code> means multiple characters, and <code>?</code> means one
character:</p>
<pre>
    @a ?+ @b
    @a */ @b</pre>
<p>But that has a bad ambiguity.  How do you tell whether <code>**</code>
is an exponentiation or a list multiplication?  So if we went that
route, we'd probably have to say:</p>
<pre>
    @a ?:+ @b
    @a *:/ @b</pre>
<p>Or some such.  But if we're going that far in the direction of
gobbledygook, perhaps there are prefix characters that wouldn't be
so ambiguous.  The colon and the dot also have a visual singular/plural
value:</p>
<pre>
    @a .+ @b
    @a :/ @b</pre>
<p>We're already changing the old meaning of dot (and I'm planning to
rescue colon from the <code>?:</code> operator), so perhaps that could be made
to work.  You could almost think of dot and colon as complementary
method calls, where you could say:</p>
<pre>
    $len = @a.length;   # length as a scalar operator
    @len = @a:length;   # length as a list operator</pre>
<p>But that would interfere with other desirable uses of colon.  Plus,
it's actually going to be confusing to think of these as singular
and plural operators because, while we're specifying that we want a
``plural'' operator, we're not specifying how to treat the plurality.
Consider this:</p>
<pre>
    @len = list:length(@a);</pre>
<p>Anyone would naively think that returns the length of the list, not the
length of each element of the list.  To make it work in English, we'd
actually have to say something like this:</p>
<pre>
    @len = each:length(@a);
    $len = the:length(@a);</pre>
<p>That would be equivalent to the method calls:</p>
<pre>
    @len = @a.each:length;
    $len = @a.the:length;</pre>
<p>But does this really mean that there are two array methods with those
weird names?  I don't think so.  We've reached a result here that is
spectacularly close to a <em>reductio ad absurdum</em>.  It seems to me that
the whole point of this RFC is that the ``eachness'' is most simply
specified by the list context, together with the knowledge that
<code>length()</code> is a function/method that maps one scalar value to
another.  The distribution of that function over an array value is not
something the scalar function should be concerned with, except insofar
as it must make sure its type signature is correct.</p>
<p>And there's the rub.  We're really talking about enforced strong
typing for this to work right.  When we say:</p>
<pre>
    @foo = @bar.mumble</pre>
<p>How do we know whether <code>mumble</code> has the type signature that magically
enables iteration over <code>@bar</code>?  That definition is off in some other
file that we may not have memorized quite yet.  We need some
more explicit syntax that says that auto-interation is expected, regardless
of whether the definition of the operator is well specified.  Magical
auto-iteration is not going to work well in a language with optional
typing.</p>
<p>So the resolution of this is that the unmarked forms of operators will
force scalar context as they do in Perl 5, and we'll need a special
marker that says an operator is to be auto-iterated.  That special
marker turns out to be an uparrow, with a tip o' the hat to
higher-order functions.  That is, the hyper-operator:</p>
<pre>
    @a ^* @b</pre>
<p>is equivalent to this:</p>
<pre>
    parallel { $^a * $^b } @a, @b</pre>
<p>(where <code>parallel</code> is a hypothetical function that iterates through
multiple arrays in parallel.)</p>
<p>Hyper operators will also intuit where a dimension is missing from one
of its arguments, and replicate a scalar value to a list value in that
dimension.  That means you can say:</p>
<pre>
    @a ^+ 1</pre>
<p>to get a value with one added to each element of <code>@a</code>.  (<code>@a</code> is unchanged.)</p>
<p>I don't believe there are any insurmountable ambiguities with the uparrow
notation.  There is currently an uparrow operator meaning exclusive-or,
but that is rarely used in practice, and is not typically followed by
other operators when it is used.  We can represent
exclusive-or with <code>~</code> instead.  (I like that idea anyway, because
the unary <code>~</code> is a 1's complement, and the binary <code>~</code> would simply
be doing a 1's complement on the second argument of the set bits in
the first argument.  On the other hand, there's destructive interference
with other cultural meanings of tilde, so it's not completely obvious that
it's the right thing to do.  Nevertheless, that's what we're doing.)</p>
<p>Anyway, in essence, I'm rejecting the underlying premise of this RFC,
that we'll have strong enough typing to intuit the right behavior
without confusing people.  Nevertheless, we'll still have easy-to-use
(and more importantly, easy-to-recognize) hyper-operators.</p>
<p>This RFC also asks about how return values for functions like <code>abs()</code> might
be specified.  I expect sub declarations to (optionally) include a
return type, so this would be sufficient to figure out which functions
would know how to map a scalar to a scalar.  And we should point out again
that even though the base language will not try to intuit which operators
should be hyperoperators, there's no reason in principle that someone
couldn't invent a dialect that does.  All is fair if you predeclare.</p>


<h3><a href="http://dev.perl.org/rfc/45.html" name="rfc 045: || and && should propagate result context to both sides">RFC 045: <code>||</code> and <code>&amp;&amp;</code> should propagate result context to both sides</a></h3>
<p>Yes.  The thing that makes this work in Perl 6, where it was almost
impossible in Perl 5, is that in Perl 6, list context doesn't imply
immediate list flattening.  More precisely, it specifies immediate list
flattening in a notional sense, but the implementation is free to delay
that flattening until it's actually required.  Internally, a flattened
list is still an object.  So when <code>@a || @b</code> evaluates the arrays,
they're evaluated as objects that can return either a boolean value or
a list, depending on the context.  And it will be possible to apply
both contexts to the first argument simultaneously.  (Of course, the
computer actually looks at it in the boolean context first.)</p>
<p>There is no conflict with RFC 81 because the hyper versions of
these operators will be spelled:</p>
<pre>
    @a ^|| @b
    @a ^&amp;&amp; @b</pre>












<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S03.html">Synopsis 03</a> for the latest information.</em></p>

<h3><a href="http://dev.perl.org/rfc/54.html" name="rfc 054: operators: polymorphic comparisons">RFC 054: Operators: Polymorphic comparisons</a></h3>
<p>I'm not sure of the performance hit of backstopping numeric equality
with string equality.  Maybe vtables help with this.  But I think this
RFC is proposing something that is too specific.  The more general
problem is how you allow variants of built-ins, not just for <code>==</code>,
but for other operators like <code>&lt;=&gt;</code> and <code>cmp</code>, not to mention
all the other operators that have scalar and list variants.</p>
<p>A generic equality operator could potentially be supplied by operator
definition.  I expect that a similar mechanism would allow us to define
how abstract a comparison <code>cmp</code> would do, so we could sort and collate
according to the various defined levels of Unicode.</p>
<p>The argument that you can't do generic programming is somewhat
specious. The problem in Perl 5 is that you can't name operators,
so you couldn't pass in a generic operator in place of a specific one
even if you wanted to.  I think it's more important to make sure all
operators have real function names in Perl 6:</p>
<pre>
    operator:+($a, $b);     # $a + $b
    operator:^+(@a, @b);    # @a ^+ @b</pre>
<pre>
    my sub operator:&lt;?&gt; ($a, $b) { ... }
    if ($a &lt;?&gt; $b) { ... }
    @sorted = collate \&amp;operator:&lt;?&gt;, @unicode;</pre>


<h3><a href="http://dev.perl.org/rfc/104.html" name="rfc 104: backtracking">RFC 104: Backtracking</a></h3>



<p>As proposed, this can easily be done with an operator definition to call
a sequence of closures.  I wonder whether the proposal is complete,
however.  There should probably be more make-it-didn't-happen semantics
to a backtracking engine.  If Prolog unification is emulated with an
assignment, how do you later unassign a variable if you backtrack past it?</p>
<p>Ordinarily, temporary values are scoped to a block, but we're using
blocks differently here, much like parens are used in a regex.  Later
parens don't undo the ``unifications'' of earlier parens.</p>
<p>In normal imperative programming these temporary determinations are
remembered in ordinary scoped variables and the current hypothesis is
extended via recursion.  An <code>andthen</code> operator would need to have a
way of keeping BLOCK1's scope around until BLOCK2 succeeds or fails.
That is, in terms of lexical scoping:</p>
<pre>
    {BLOCK1} andthen {BLOCK2}</pre>
<p>needs to work more like</p>
<pre>
    {BLOCK1 andthen {BLOCK2}}</pre>
<p>This might be difficult to arrange as a mere module.  However, with
rewriting rules it might be possible to install the requisite scoping
semantics within BLOCK1 to make it work like that.  So I don't think
this is a primitive in the same sense that continuations would be.  For
now let's assume we can build backtracking operators from continuations.
Those will be covered in a future apocalypse.</p>


<h3><a href="http://dev.perl.org/rfc/143.html" name="rfc 143: case ignoring eq and cmp operators">RFC 143: Case ignoring <code>eq</code> and <code>cmp</code> operators</a></h3>
<p>This is another RFC that proposes a specific feature that can
be handled by a more generic feature, in this case, an operator
definition:</p>
<pre>
    my sub operator:EQ { lc($^a) eq lc($^b) }</pre>
<p>Incidentally, I notice that the RFC normalizes to uppercase.  I suspect
it's better these days to normalize to lowercase, because Unicode
distinguishes titlecase from uppercase, and provides mappings for
both to lowercase.</p>


<h3><a href="http://dev.perl.org/rfc/170.html" name="rfc 170: generalize =~ to a special applyto assignment operator">RFC 170: Generalize <code>=~</code> to a special ``apply-to'' assignment operator</a></h3>
<p>I don't think the argument should come in on the right.  I think it would
be more natural to treat it as an object, since all Perl variables will
essentially be objects anyway, if you scratch them right.  Er, left.</p>
<p>I do wonder whether we could generalize <code>=~</code> to a list operator that
calls a given method on multiple objects, so that</p>
<pre>
    ($a, $b) =~ s/foo/bar/;</pre>
<p>would be equivalent to</p>
<pre>
    for ($a, $b) { s/foo/bar/ }</pre>
<p>But then maybe it's redundant, except that you could say</p>
<pre>
    @foo =~ s/foo/bar/</pre>
<p>in the middle of an expression.  But by and large, I think I'd rather see:</p>
<pre>
    @foo.grep {!m/\s/}</pre>
<p>instead of using <code>=~</code> for what is essentially a method call.  In line with
what we discussed before, the list version could be a hyperoperator:</p>
<pre>
    @foo . ^s/foo/bar/;</pre>
<p>or possibly:</p>
<pre>
    @foo ^. s/foo/bar/;</pre>
<p>Note that in the general case this all implies that there is some
interplay between how you declare method calls and how you declare
quote-like operators.  It seems as though it would be dangerous to
let a quote-like declaration out of a lexical scope, but then it's
also not clear how a method call declaration could be lexically
scoped.  So we probably can't do away with <code>=~</code> as an explicit marker
that the thing on the left is a string, and the thing on the right
is a quoted construct.  That means that a hypersubstitution
is really spelled:</p>
<pre>
    @foo ^=~ s/foo/bar/;</pre>
<p>Admittedly, that's not the prettiest thing in the world.</p>













<p><em>Editor's Note: this Apocalypse is out of date and remains here for historic reasons.  See <a href="http://dev.perl.org/perl6/doc/design/syn/S03.html">Synopsis 03</a> for the latest information.</em></p>

<h3><a name="nonrfc considerations">Non-RFC considerations</a></h3>
<p>The RFCs propose various specific features, but don't give a systematic
view of the operators as a whole.  In this section I'll try to give a
more cohesive picture of where I see things going.</p>
<p>
<h4><a name="binary . (dot)">Binary <code>.</code> (dot)</a></h4>
<p>This is now the method call operator, in line with industry-wide practice.
It also has ramifications for how we declare object attribute variables.
I'm anticipating that, within a class module, saying</p>
<pre>
    my int $.counter;</pre>
<p>would declare both a <code>$.counter</code> instance variable and a <code>counter</code>
accessor method for use within the class.  (If marked as public, it
would also declare a <code>counter</code> accessor method for use outside the
class.)</p>
<p>
<h4><a name="unary . (dot)">Unary <code>.</code> (dot)</a></h4>
<p>It's possible that a unary <code>.</code> would call a method on the current object
within a class.  That is, it would be the same as a binary <code>.</code> with
<code>$self</code> (or equivalent) on the left:</p>
<pre>
    method foowrapper ($a, $b) {
        .reallyfoo($a, $b, $c)
    }</pre>
<p>On the other hand, it might be considered better style to be explicit:</p>
<pre>
    method foowrapper ($self: $a, $b) {
        $self.reallyfoo($a, $b, $c)
    }</pre>
<p>(Don't take that declaration syntax as final just yet, however.)</p>
<p>
<h4><a name="binary _">Binary <code>_</code></a></h4>
<p>Since <code>.</code> is taken for method calls, we need a new way to concatenate
strings.  We'll use a solitary underscore for that.  So, instead of:</p>
<pre>
    $a . $b . $c</pre>
<p>you'll say:</p>
<pre>
    $a _ $b _ $c</pre>
<p>The only downside to that is the space between a variable name and the
operator is required.  This is to be construed as a feature.</p>
<p>
<h4><a name="unary _">Unary <code>_</code></a></h4>
<p>Since the <code>_</code> token indicating stat buffer is going away, a unary
underscore operator will force stringification, just
as interpolation does, only without the quotes.</p>
<p>
<h4><a name="unary + X">Unary <code>+</code></a></h4>
<p>Similarly, a unary <code>+</code> will force numification in Perl 6, unlike
in Perl 5.  If that fails, NaN (not a number) is returned.</p>
<p>
<h4><a name="binary := Y">Binary <code>:=</code></a></h4>
<p>We need to distinguish two different forms of assignment.  The standard
assignment operator, <code>=</code>, works just as it does Perl 5, as much as
possible.  That is, it tries to make it look like a value assignment.
This is our cultural heritage.</p>



<p>But we also need an operator that works like assignment but is more
definitional.  If you're familiar with Prolog, you can think of it as a
sort of unification operator (though without the implicit backtracking
semantics).  In human terms, it treats the left side as a set of formal
arguments exactly as if they were in the declaration of a function, and
binds a set of arguments on the right hand side as though they were
being passed to a function.  This is what the new <code>:=</code> operator does.
More below.</p>
<p>
<h4><a name="unary * XX">Unary <code>*</code></a></h4>
<p>Unary <code>*</code> is the list flattening operator.  (See Ruby
for prior art.) When used on an rvalue, it turns off function signature
matching for the rest of the arguments, so that, for instance:</p>
<pre>
    @args = (\@foo, @bar);
    push *@args;</pre>
<p>would be equivalent to:</p>
<pre>
    push @foo, @bar;</pre>
<p>In this respect, it serves as a replacement for the prototype-disabling
<code>&amp;foo(@bar)</code> syntax of Perl 5.  That would be translated to:</p>
<pre>
    foo(*@bar)</pre>
<p>In an lvalue, the unary <code>*</code> indicates that subsequent array names
slurp all the rest of the values.  So this would swap two arrays:</p>
<pre>
    (@a, @b) := (@b, @a);</pre>
<p>whereas this would assign all the array elements of <code>@c</code> and <code>@d</code> to <code>@a</code>.</p>
<pre>
    (*@a, @b) := (@c, @d);</pre>
<p>An ordinary flattening list assignment:</p>
<pre>
    @a = (@b, @c);</pre>
<p>is equivalent to:</p>
<pre>
    *@a := (@b, @c);</pre>
<p>That's not the same as</p>
<pre>
    @a := *(@b, @c);</pre>
<p>which would take the first element of <code>@b</code> as the new definition of
<code>@a</code>, and throw away the rest, exactly as if you passed too many
arguments to a function.  It could optionally be made to blow up
at run time.  (It can't be made to blow up at compile time, since we
don't know how many elements are in <code>@b</code> and <code>@c</code> combined.  There
could be exactly one element, which is what the left side wants.)</p>
<p>
<h4><a name="list context">List context</a></h4>
<p>The whole notion of list context is somewhat modified in Perl 6.
Since lists can be lazy, the interpretation of list flattening is
also by necessity lazy.  This means that, in the absence of the <code>*</code> list
flattening operator (or an equivalent old-fashioned list assignment),
lists in Perl 6 are object lists.  That is to say, they are parsed
as if they were a list of objects in scalar context.  When you see
a function call like:</p>
<pre>
    foo @a, @b, @c;</pre>
<p>you should generally assume that three discrete arrays are being passed
to the function, unless you happen to know that the signature of <code>foo</code>
includes a list flattening <code>*</code>.  (If a subroutine doesn't have a
signature, it is assumed to have a signature of <code>(*@_)</code> for old
times' sake.)  Note that this is really nothing new to Perl, which has always
made this distinction for builtins, and extended it to user-defined
functions in Perl 5 via prototypes like <code>\@</code> and <code>\%</code>.  We're just changing
the syntax in Perl 6 so that the unmarked form of formal argument expects
a scalar value, and you optionally declare the final formal argument
to expect a list.  It's a matter of Huffman coding again, not to mention
saving wear and tear on the backslash key.</p>
<p>
<h4><a name="binary : YY">Binary <code>:</code></a></h4>
<p>As I pointed out in an earlier apocalypse, the first rule of computer
language design is that everybody wants the colon.  I think that
means that we should do our best to give the colon to as many features
as possible.</p>
<p>Hence, this operator modifies a preceding operator adverbially.
That is, it can turn any operator into a trinary operator (provided a
suitable definition is declared).  It can be used to supply a ``step''
to a range operator, for instance.  It can also be used as a kind
of super-comma separating an indirect object from the subsequent
argument list:</p>
<pre>
    print $handle[2]: @args;</pre>
<p>Of course, this conflicts with the old definition of the <code>?:</code> operator.  See
below.</p>
<p>In a method type signature, this operator indicates that a previous
argument (or arguments) is to be considered the ``self'' of a method call.
(Putting it after multiple arguments could indicate a desire for multimethod
dispatch!)</p>
<p>
<h4><a name="trinary ::">Trinary <code>??::</code></a></h4>
<p>The old <code>?:</code> operator is now spelled <code>??::</code>.  That is to say, since it's
really a kind of short-circuit operator, we just double both characters
like the <code>&amp;&amp;</code> and <code>||</code> operator.  This makes it easy to remember for
C programmers.  Just change:</p>
<pre>
    $a ? $b : $c</pre>
<p>to</p>
<pre>
    $a ?? $b :: $c</pre>
<p>The basic problem is that the old <code>?:</code> operator wastes two very useful
single characters for an operator that is not used often enough to
justify the waste of two characters.  It's bad Huffman coding, in
other words.   Every proposed use of colon in the RFCs conflicted with
the <code>?:</code> operator.  I think that says something.</p>
<p>I can't list here all the possible spellings of <code>?:</code> that I considered.
I just think <code>??::</code> is the most visually appealing and mnemonic of the
lot of them.</p>
<p>
<h4><a name="binary // YYY">Binary <code>//</code></a></h4>
<p>A binary <code>//</code> operator is the defaulting operator.  That is:</p>
<pre>
    $a // $b</pre>
<p>is short for:</p>
<pre>
    defined($a) ?? $a :: $b</pre>
<p>except that the left side is evaluated only once.  It will work on
arrays and hashes as well as scalars.  It also has a corresponding
assignment operator, which only does the assignment if the left side
is undefined:</p>
<pre>
    $pi //= 3;</pre>
<p>
<h4><a name="binary ; YYYY">Binary <code>;</code></a></h4>
<p>The binary <code>;</code> operator separates two expressions in a list, much like
the expressions within a C-style <code>for</code> loop.  Obviously the
expressions need to be in some kind of bracketing structure to avoid
ambiguity with the end of the statement.  Depending on the context,
these expressions may be interpreted as arguments to a <code>for</code> loop, or
slices of a multi-dimensional array, or whatever.  In the absence of
other context, the default is simply to make a list of lists.  That is,</p>
<pre>
    [1,2,3;4,5,6]</pre>
<p>is a shorthand for:</p>
<pre>
    [[1,2,3],[4,5,6]]</pre>
<p>But usually there will be other context, such as a multidimension array
that wants to be sliced, or a syntactic construct that wants to emulate
some kind of control structure.  A construct emulating a 3-argument
<code>for</code> loop might force all the expressions to be closures, for
instance, so that they can be evaluated each time through the loop.
User-defined syntax will discussed in apocalypse 18, if not sooner.</p>
<p>
<h4><a name="unary ^ XXX">Unary <code>^</code></a></h4>
<p>Unary ^ is now reserved for hyper operators.  Note that it works on
assignment operators as well:</p>
<pre>
    @a ^+= 1;    # increment all elements of @a</pre>
<p>
<h4><a name="unary ">Unary <code>?</code></a></h4>
<p>Reserved for future use.</p>
<p>
<h4><a name="binary ">Binary <code>?</code></a></h4>
<p>Reserved for future use.</p>
<p>
<h4><a name="binary ~ YYYYY">Binary <code>~</code></a></h4>
<p>This is now the bitwise XOR operator.  Recall that unary
<code>~</code> (1's complement) is simply an XOR with a value containing all 1
bits.</p>
<p>
<h4><a name="binary ~~ YYYYYY">Binary <code>~~</code></a></h4>
<p>This is a logical XOR operator.  It's a high precedence version of the
low precedence <code>xor</code> operator.</p>
<p>
<h4><a name="user defined operators">User defined operators</a></h4>
<p>The declaration syntax of user-defined operators is still up for grabs,
but we can say a few things about it.  First, we can differentiate
unary from binary declarations simply by the number of arguments.
(Declaration of a return type may also be useful for disambiguating
subsequent parsing.  One place it won't be needed is for operators wanting
to know whether they should behave as hyperoperators.  The pressure to
do that is relieved by the explicit <code>^</code> hypermarker.)</p>
<p>We also need to think how these operator definitions relate to overloading.
We can treat an operator as a method on the first object, but sometimes
it's the second object that should control the action.  (Or with multimethod
dispatch, both objects.)  These will have to be thrashed out under
ordinary method dispatch policy.  The important thing is to realize
that an operator is just a funny looking method call.
When you say:</p>
<pre>
    $man bites $dog</pre>
<p>The infrastruture will need to untangle whether the man is biting the
dog or the dog is getting bitten by the man.  The actual biting could
be implement in either the <code>Man</code> class or the <code>Dog</code> class, or even
somewhere else, in the case of multimethods.</p>
<p>
<h4><a name="unicode operators">Unicode operators</a></h4>
<p>Rather than using longer and longer strings of ASCII characters to
represent user-defined operators, it will be much more readable to
allow the (judicious) use of Unicode operators.</p>
<p>In the short term, we won't see much of this.  As screen resolutions
increase over the next 20 years, we'll all become much more comfortable
with the richer symbol set.  I see no reason (other than fear of
obfuscation (and fear of fear of obfuscation))) why Unicode operators
should not be allowed.</p>
<p>Note that, unlike APL, we won't be hardware dependent, in the sense
that any Perl implementation will always be able to parse Unicode, even
if you can't display it very well.  (But note that Vim 6.0 just came
out with Unicode support.)</p>
<p>
<h4><a name="precedence">Precedence</a></h4>
<p>We will at least unify the precedence levels of the equality and
relational operators.  Other unifications are possible.  For instance,
the <code>not</code> logical operator could be combined with list operators in
precedence.  There's only so much simplification that you can do,
however, since you can't mix right association with left association.
By and large, the precedence table will be what you expect, if you
expect it to remain largely the same.</p>
<p>And that still goes for Perl 6 in general.  We talk a lot here about
what we're changing, but there's a lot more that we're not changing.
Perl 5 does a lot of things right, and we're not terribly interested in
``fixing'' that.</p>

</body>

</html>

                                    </div>


                                </div>
                                <div class="asset-footer">

    
                                    <div class="entry-categories">
                                        <h4>Categories<span class="delimiter">:</span></h4>
                                        <ul>
                                            <li><a href="/pub/perl-6/" rel="tag">Perl 6</a></li>
                                        </ul>
                                    </div>
    


                                </div>
                            </div>


                    
                    


                        </div>
                    </div>


                    <div id="beta">
    <div id="beta-inner">


    
    <div class="widget-what-is-perl widget">
    <div class="widget-content widget-content-what-is-perl">
       Visit the home of the  Perl programming language: <a href="http://www.perl.org/">Perl.org</a
    </div>
</div>
<div class="widget-find-out-more widget-archives widget">
    <div class="widget-content">
        <ul>
            <li><a href="http://www.perl.org/get.html">Download</a></li>
            <li><a href="http://perldoc.perl.org/">Documentation</a></li>
            <li><a href="http://blogs.perl.org/">Perl Bloggers</a></li>
            <li><a href="http://news.perlfoundation.org/">Foundation News</a></li>
        </ul>
    </div>
</div><div class="widget-tcpc widget">
<h3 class="widget-header">Sponsored by</h3>
    <div class="widget-content">
        <a href="http://training.perl.com/" alt="Perl Training" target="_blank"><img src="/i/tcpc.png" width="150" height="50"></a>
    </div>
</div>

<div class="widget-syndication widget">
    <div class="widget-content">
        <ul>
            <li><img src="/mt-static/images/status_icons/feed.gif" alt="Subscribe to feed" width="9" height="9" /> <a href="/pub/atom.xml">Subscribe to this website's feed</a></li>

        </ul>
    </div>
</div>
<div class="widget-archive-monthly widget-archive widget">
    <h3 class="widget-header">Monthly <a href="/pub/archives.html">Archives</a></h3>
    <div class="widget-content">
        <ul>
        
            <li><a href="/pub/2010/07/">July 2010 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/05/">May 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/04/">April 2008 (2)</a></li>
        
    
        
            <li><a href="/pub/2008/03/">March 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/02/">February 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2008/01/">January 2008 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/12/">December 2007 (2)</a></li>
        
    
        
            <li><a href="/pub/2007/09/">September 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/08/">August 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/07/">July 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/06/">June 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/05/">May 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/04/">April 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/03/">March 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/02/">February 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2007/01/">January 2007 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/12/">December 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/11/">November 2006 (2)</a></li>
        
    
        
            <li><a href="/pub/2006/10/">October 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/09/">September 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/08/">August 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/07/">July 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/06/">June 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/05/">May 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/04/">April 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/03/">March 2006 (1)</a></li>
        
    
        
            <li><a href="/pub/2006/02/">February 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2006/01/">January 2006 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/12/">December 2005 (4)</a></li>
        
    
        
            <li><a href="/pub/2005/11/">November 2005 (3)</a></li>
        
    
        
            <li><a href="/pub/2005/10/">October 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/09/">September 2005 (2)</a></li>
        
    
        
            <li><a href="/pub/2005/08/">August 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/07/">July 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/06/">June 2005 (9)</a></li>
        
    
        
            <li><a href="/pub/2005/05/">May 2005 (8)</a></li>
        
    
        
            <li><a href="/pub/2005/04/">April 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/03/">March 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2005/02/">February 2005 (7)</a></li>
        
    
        
            <li><a href="/pub/2005/01/">January 2005 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/12/">December 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/11/">November 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/10/">October 2004 (5)</a></li>
        
    
        
            <li><a href="/pub/2004/09/">September 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/08/">August 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/07/">July 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/06/">June 2004 (6)</a></li>
        
    
        
            <li><a href="/pub/2004/05/">May 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2004/04/">April 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/03/">March 2004 (8)</a></li>
        
    
        
            <li><a href="/pub/2004/02/">February 2004 (9)</a></li>
        
    
        
            <li><a href="/pub/2004/01/">January 2004 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/12/">December 2003 (4)</a></li>
        
    
        
            <li><a href="/pub/2003/11/">November 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/10/">October 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/09/">September 2003 (6)</a></li>
        
    
        
            <li><a href="/pub/2003/08/">August 2003 (7)</a></li>
        
    
        
            <li><a href="/pub/2003/07/">July 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/06/">June 2003 (9)</a></li>
        
    
        
            <li><a href="/pub/2003/05/">May 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/04/">April 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/03/">March 2003 (10)</a></li>
        
    
        
            <li><a href="/pub/2003/02/">February 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2003/01/">January 2003 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/12/">December 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/11/">November 2002 (9)</a></li>
        
    
        
            <li><a href="/pub/2002/10/">October 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/09/">September 2002 (11)</a></li>
        
    
        
            <li><a href="/pub/2002/08/">August 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/07/">July 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2002/06/">June 2002 (4)</a></li>
        
    
        
            <li><a href="/pub/2002/05/">May 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/04/">April 2002 (6)</a></li>
        
    
        
            <li><a href="/pub/2002/03/">March 2002 (7)</a></li>
        
    
        
            <li><a href="/pub/2002/02/">February 2002 (5)</a></li>
        
    
        
            <li><a href="/pub/2002/01/">January 2002 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/12/">December 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/11/">November 2001 (5)</a></li>
        
    
        
            <li><a href="/pub/2001/10/">October 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/09/">September 2001 (7)</a></li>
        
    
        
            <li><a href="/pub/2001/08/">August 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/07/">July 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/06/">June 2001 (13)</a></li>
        
    
        
            <li><a href="/pub/2001/05/">May 2001 (11)</a></li>
        
    
        
            <li><a href="/pub/2001/04/">April 2001 (9)</a></li>
        
    
        
            <li><a href="/pub/2001/03/">March 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/02/">February 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2001/01/">January 2001 (8)</a></li>
        
    
        
            <li><a href="/pub/2000/12/">December 2000 (6)</a></li>
        
    
        
            <li><a href="/pub/2000/11/">November 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/10/">October 2000 (10)</a></li>
        
    
        
            <li><a href="/pub/2000/09/">September 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/08/">August 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/07/">July 2000 (5)</a></li>
        
    
        
            <li><a href="/pub/2000/06/">June 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/05/">May 2000 (7)</a></li>
        
    
        
            <li><a href="/pub/2000/04/">April 2000 (3)</a></li>
        
    
        
            <li><a href="/pub/2000/03/">March 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/02/">February 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/2000/01/">January 2000 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/12/">December 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/11/">November 1999 (6)</a></li>
        
    
        
            <li><a href="/pub/1999/10/">October 1999 (5)</a></li>
        
    
        
            <li><a href="/pub/1999/09/">September 1999 (4)</a></li>
        
    
        
            <li><a href="/pub/1999/08/">August 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/07/">July 1999 (2)</a></li>
        
    
        
            <li><a href="/pub/1999/06/">June 1999 (3)</a></li>
        
    
        
            <li><a href="/pub/1999/04/">April 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/03/">March 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1999/01/">January 1999 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/12/">December 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/11/">November 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/07/">July 1998 (2)</a></li>
        
    
        
            <li><a href="/pub/1998/06/">June 1998 (1)</a></li>
        
    
        
            <li><a href="/pub/1998/03/">March 1998 (1)</a></li>
        
        </ul>
    </div>
</div>
        
    

<div class="widget-powered widget">
    <div class="widget-content">
        <a href="http://www.movabletype.com/"><img src="/mt-static/images/bug-pbmt-white.png" alt="Powered by Movable Type 5.02" width="120" height="75" /></a>
    </div>
</div>



    </div>
</div>






                </div>
            </div>


            <div id="footer">
    <div id="footer-inner">
        <div id="footer-content">
            <div class="widget-powered widget">
                <div class="widget-content">
                    Powered by <a href="http://www.movabletype.com/" rel="generator">Movable Type Pro</a>
                </div>
            </div>

        </div>
    </div>
</div>



        </div>
    </div>
</body>
</html>
